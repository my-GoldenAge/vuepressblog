(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,o,s=e[0],l=e[1],c=e[2],d=0,p=[];d<s.length;d++)o=s[d],Object.prototype.hasOwnProperty.call(a,o)&&a[o]&&p.push(a[o][0]),a[o]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(u&&u(e);p.length;)p.shift()();return i.push.apply(i,c||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==a[l]&&(r=!1)}r&&(i.splice(e--,1),n=o(o.s=t[0]))}return n}var r={},a={2:0},i=[];function o(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=a[n]=[e,r]}));e.push(t[2]=r);var i,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({3:"vendors~flowchart"}[n]||n)+"."+{1:"e3a634da",3:"83bdf470",4:"87cca1e2",5:"5f552971",6:"1c9f3509",7:"e627bf76",8:"4a7ea6d0",9:"3f961077",10:"33f4d679",11:"633d59fc",12:"6566debe",13:"813b91b9",14:"0508579e",15:"bea71415",16:"d5a87820",17:"a3ea973d",18:"cdcd3e86",19:"f57142c1",20:"9ff399c5",21:"bab6863c",22:"551758a7",23:"18ff150a",24:"97cc5fe7",25:"ef5f5151",26:"d8424825",27:"fe42ac28",28:"306a195b",29:"15b3a25f",30:"f58e0ff8",31:"189d9dfa",32:"904cde6d",33:"b7ad2e8e",34:"f59e295f",35:"d200411a",36:"b94f3fd5",37:"ddc71590",38:"a788387b",39:"162e9808",40:"f0c34f21",41:"9579425d",42:"2a8be507",43:"9bee127f",44:"6afdaaec",45:"ecc58971"}[n]+".js"}(n);var l=new Error;i=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+i+")",l.name="ChunkLoadError",l.type=r,l.request=i,t[1](l)}a[n]=void 0}};var c=setTimeout((function(){i({type:"timeout",target:s})}),12e4);s.onerror=s.onload=i,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=r,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)o.d(t,r,function(e){return n[e]}.bind(null,r));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/vuepress/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var u=l;i.push([283,0]),t()}([function(n,e,t){"use strict";t.d(e,"e",(function(){return x})),t.d(e,"d",(function(){return E})),t.d(e,"c",(function(){return A})),t.d(e,"f",(function(){return _})),t.d(e,"a",(function(){return S})),t.d(e,"g",(function(){return C})),t.d(e,"b",(function(){return T})),t.d(e,"h",(function(){return O})),t.d(e,"i",(function(){return j}));var r=t(49),a=t(48),i=t(72),o=t(115),s=(t(146),t(19),t(50),t(41),t(276),t(277),t(7),t(25),t(26),t(55),t(34),t(47),t(44),t(2)),l={NotFound:function(){return Promise.all([t.e(0),t.e(17)]).then(t.bind(null,736))},Category:function(){return Promise.all([t.e(0),t.e(1),t.e(7)]).then(t.bind(null,737))},Layout:function(){return Promise.all([t.e(0),t.e(1),t.e(4)]).then(t.bind(null,734))},Tag:function(){return Promise.all([t.e(0),t.e(1),t.e(5)]).then(t.bind(null,738))},Tags:function(){return Promise.all([t.e(0),t.e(1),t.e(6)]).then(t.bind(null,739))},TimeLines:function(){return Promise.all([t.e(0),t.e(1),t.e(18)]).then(t.bind(null,740))}},c={"v-073380e6":function(){return t.e(32).then(t.bind(null,741))},"v-1be91c9a":function(){return t.e(34).then(t.bind(null,742))},"v-f7f26542":function(){return t.e(33).then(t.bind(null,743))},"v-a67c1470":function(){return t.e(35).then(t.bind(null,744))},"v-3dc3c778":function(){return t.e(25).then(t.bind(null,745))},"v-bdcf9946":function(){return t.e(37).then(t.bind(null,746))},"v-e8410f2c":function(){return t.e(36).then(t.bind(null,747))},"v-d0b6117a":function(){return t.e(19).then(t.bind(null,748))},"v-0f4f0be8":function(){return t.e(9).then(t.bind(null,749))},"v-312a14d9":function(){return t.e(11).then(t.bind(null,750))},"v-383aa104":function(){return t.e(13).then(t.bind(null,751))},"v-05a7ba0f":function(){return t.e(12).then(t.bind(null,752))},"v-5f3f8622":function(){return t.e(38).then(t.bind(null,753))},"v-22a22e56":function(){return t.e(28).then(t.bind(null,754))},"v-5ae78972":function(){return t.e(14).then(t.bind(null,755))},"v-6266d266":function(){return t.e(29).then(t.bind(null,756))},"v-f65945d6":function(){return t.e(10).then(t.bind(null,757))},"v-e1ec06b4":function(){return t.e(15).then(t.bind(null,758))},"v-58e095d5":function(){return t.e(39).then(t.bind(null,759))},"v-66485df2":function(){return t.e(30).then(t.bind(null,760))},"v-7771c16d":function(){return t.e(8).then(t.bind(null,761))},"v-5c491b59":function(){return t.e(20).then(t.bind(null,762))},"v-64a9c608":function(){return t.e(22).then(t.bind(null,763))},"v-5af16972":function(){return t.e(26).then(t.bind(null,764))},"v-a9c98eb6":function(){return t.e(21).then(t.bind(null,765))},"v-54d6b646":function(){return t.e(16).then(t.bind(null,766))},"v-0de9a35d":function(){return t.e(40).then(t.bind(null,767))},"v-464f68c4":function(){return t.e(31).then(t.bind(null,768))},"v-6edd8a2c":function(){return t.e(41).then(t.bind(null,769))},"v-36962f7c":function(){return t.e(43).then(t.bind(null,770))},"v-008512f6":function(){return t.e(42).then(t.bind(null,771))},"v-1252c4e0":function(){return t.e(27).then(t.bind(null,772))},"v-399c8f76":function(){return t.e(44).then(t.bind(null,773))},"v-30eb6750":function(){return t.e(45).then(t.bind(null,774))}};function u(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var d=/-(\w)/g,p=u((function(n){return n.replace(d,(function(n,e){return e?e.toUpperCase():""}))})),h=/\B([A-Z])/g,f=u((function(n){return n.replace(h,"-$1").toLowerCase()})),v=u((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function m(n,e){if(e)return n(e)?n(e):e.includes("-")?n(v(p(e))):n(v(e))||n(f(e))}var g=Object.assign({},l,c),y=function(n){return g[n]},b=function(n){return c[n]},w=function(n){return l[n]},k=function(n){return s.default.component(n)};function x(n){return m(b,n)}function E(n){return m(w,n)}function A(n){return m(y,n)}function _(n){return m(k,n)}function S(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return Promise.all(e.filter((function(n){return n})).map(function(){var n=Object(o.a)(Object(i.a)().mark((function n(e){var t;return Object(i.a)().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(_(e)||!A(e)){n.next=5;break}return n.next=3,A(e)();case 3:t=n.sent,s.default.component(e,t.default);case 5:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()))}function C(n,e,t){var r;switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),(r=n[e]).push.apply(r,Object(a.a)(t));break;default:throw new Error("Unknown option name.")}}function T(n,e){for(var t=0;t<n.length;t++){var r=n[t];if(r.key===e)return r}return{path:"",frontmatter:{}}}function O(n,e){var t=n.$localePath;return"object"===Object(r.a)(e)&&e[t]?e[t]:e}function j(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.6.14
 * (c) 2014-2021 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({});function a(n){return null==n}function i(n){return null!=n}function o(n){return!0===n}function s(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function l(n){return null!==n&&"object"==typeof n}var c=Object.prototype.toString;function u(n){return"[object Object]"===c.call(n)}function d(n){return"[object RegExp]"===c.call(n)}function p(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function h(n){return i(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function f(n){return null==n?"":Array.isArray(n)||u(n)&&n.toString===c?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function m(n,e){for(var t=Object.create(null),r=n.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}m("slot,component",!0);var g=m("key,ref,slot,slot-scope,is");function y(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var b=Object.prototype.hasOwnProperty;function w(n,e){return b.call(n,e)}function k(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var x=/-(\w)/g,E=k((function(n){return n.replace(x,(function(n,e){return e?e.toUpperCase():""}))})),A=k((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),_=/\B([A-Z])/g,S=k((function(n){return n.replace(_,"-$1").toLowerCase()}));var C=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function T(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function O(n,e){for(var t in e)n[t]=e[t];return n}function j(n){for(var e={},t=0;t<n.length;t++)n[t]&&O(e,n[t]);return e}function B(n,e,t){}var I=function(n,e,t){return!1},L=function(n){return n};function N(n,e){if(n===e)return!0;var t=l(n),r=l(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Array.isArray(n),i=Array.isArray(e);if(a&&i)return n.length===e.length&&n.every((function(n,t){return N(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||i)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return N(n[t],e[t])}))}catch(n){return!1}}function P(n,e){for(var t=0;t<n.length;t++)if(N(n[t],e))return t;return-1}function q(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var R=["component","directive","filter"],F=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],M={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:I,isReservedAttr:I,isUnknownElement:I,getTagNamespace:B,parsePlatformTagName:L,mustUseProp:I,async:!0,_lifecycleHooks:F},z=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function D(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var U=new RegExp("[^"+z.source+".$_\\d]");var $,J="__proto__"in{},W="undefined"!=typeof window,Q="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,V=Q&&WXEnvironment.platform.toLowerCase(),H=W&&window.navigator.userAgent.toLowerCase(),G=H&&/msie|trident/.test(H),K=H&&H.indexOf("msie 9.0")>0,Y=H&&H.indexOf("edge/")>0,X=(H&&H.indexOf("android"),H&&/iphone|ipad|ipod|ios/.test(H)||"ios"===V),Z=(H&&/chrome\/\d+/.test(H),H&&/phantomjs/.test(H),H&&H.match(/firefox\/(\d+)/)),nn={}.watch,en=!1;if(W)try{var tn={};Object.defineProperty(tn,"passive",{get:function(){en=!0}}),window.addEventListener("test-passive",null,tn)}catch(n){}var rn=function(){return void 0===$&&($=!W&&!Q&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),$},an=W&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function on(n){return"function"==typeof n&&/native code/.test(n.toString())}var sn,ln="undefined"!=typeof Symbol&&on(Symbol)&&"undefined"!=typeof Reflect&&on(Reflect.ownKeys);sn="undefined"!=typeof Set&&on(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var cn=B,un=0,dn=function(){this.id=un++,this.subs=[]};dn.prototype.addSub=function(n){this.subs.push(n)},dn.prototype.removeSub=function(n){y(this.subs,n)},dn.prototype.depend=function(){dn.target&&dn.target.addDep(this)},dn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},dn.target=null;var pn=[];function hn(n){pn.push(n),dn.target=n}function fn(){pn.pop(),dn.target=pn[pn.length-1]}var vn=function(n,e,t,r,a,i,o,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=a,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},mn={child:{configurable:!0}};mn.child.get=function(){return this.componentInstance},Object.defineProperties(vn.prototype,mn);var gn=function(n){void 0===n&&(n="");var e=new vn;return e.text=n,e.isComment=!0,e};function yn(n){return new vn(void 0,void 0,void 0,String(n))}function bn(n){var e=new vn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var wn=Array.prototype,kn=Object.create(wn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=wn[n];D(kn,n,(function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];var a,i=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&o.observeArray(a),o.dep.notify(),i}))}));var xn=Object.getOwnPropertyNames(kn),En=!0;function An(n){En=n}var _n=function(n){this.value=n,this.dep=new dn,this.vmCount=0,D(n,"__ob__",this),Array.isArray(n)?(J?function(n,e){n.__proto__=e}(n,kn):function(n,e,t){for(var r=0,a=t.length;r<a;r++){var i=t[r];D(n,i,e[i])}}(n,kn,xn),this.observeArray(n)):this.walk(n)};function Sn(n,e){var t;if(l(n)&&!(n instanceof vn))return w(n,"__ob__")&&n.__ob__ instanceof _n?t=n.__ob__:En&&!rn()&&(Array.isArray(n)||u(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new _n(n)),e&&t&&t.vmCount++,t}function Cn(n,e,t,r,a){var i=new dn,o=Object.getOwnPropertyDescriptor(n,e);if(!o||!1!==o.configurable){var s=o&&o.get,l=o&&o.set;s&&!l||2!==arguments.length||(t=n[e]);var c=!a&&Sn(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=s?s.call(n):t;return dn.target&&(i.depend(),c&&(c.dep.depend(),Array.isArray(e)&&jn(e))),e},set:function(e){var r=s?s.call(n):t;e===r||e!=e&&r!=r||s&&!l||(l?l.call(n,e):t=e,c=!a&&Sn(e),i.notify())}})}}function Tn(n,e,t){if(Array.isArray(n)&&p(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var r=n.__ob__;return n._isVue||r&&r.vmCount?t:r?(Cn(r.value,e,t),r.dep.notify(),t):(n[e]=t,t)}function On(n,e){if(Array.isArray(n)&&p(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function jn(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&jn(e)}_n.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)Cn(n,e[t])},_n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Sn(n[e])};var Bn=M.optionMergeStrategies;function In(n,e){if(!e)return n;for(var t,r,a,i=ln?Reflect.ownKeys(e):Object.keys(e),o=0;o<i.length;o++)"__ob__"!==(t=i[o])&&(r=n[t],a=e[t],w(n,t)?r!==a&&u(r)&&u(a)&&In(r,a):Tn(n,t,a));return n}function Ln(n,e,t){return t?function(){var r="function"==typeof e?e.call(t,t):e,a="function"==typeof n?n.call(t,t):n;return r?In(r,a):a}:e?n?function(){return In("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function Nn(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Pn(n,e,t,r){var a=Object.create(n||null);return e?O(a,e):a}Bn.data=function(n,e,t){return t?Ln(n,e,t):e&&"function"!=typeof e?n:Ln(n,e)},F.forEach((function(n){Bn[n]=Nn})),R.forEach((function(n){Bn[n+"s"]=Pn})),Bn.watch=function(n,e,t,r){if(n===nn&&(n=void 0),e===nn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var i in O(a,n),e){var o=a[i],s=e[i];o&&!Array.isArray(o)&&(o=[o]),a[i]=o?o.concat(s):Array.isArray(s)?s:[s]}return a},Bn.props=Bn.methods=Bn.inject=Bn.computed=function(n,e,t,r){if(!n)return e;var a=Object.create(null);return O(a,n),e&&O(a,e),a},Bn.provide=Ln;var qn=function(n,e){return void 0===e?n:e};function Rn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,i={};if(Array.isArray(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(i[E(a)]={type:null});else if(u(t))for(var o in t)a=t[o],i[E(o)]=u(a)?a:{type:a};else 0;n.props=i}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(Array.isArray(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(u(t))for(var i in t){var o=t[i];r[i]=u(o)?O({from:i},o):{from:o}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];"function"==typeof r&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=Rn(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=Rn(n,e.mixins[r],t);var i,o={};for(i in n)s(i);for(i in e)w(n,i)||s(i);function s(r){var a=Bn[r]||qn;o[r]=a(n[r],e[r],t,r)}return o}function Fn(n,e,t,r){if("string"==typeof t){var a=n[e];if(w(a,t))return a[t];var i=E(t);if(w(a,i))return a[i];var o=A(i);return w(a,o)?a[o]:a[t]||a[i]||a[o]}}function Mn(n,e,t,r){var a=e[n],i=!w(t,n),o=t[n],s=$n(Boolean,a.type);if(s>-1)if(i&&!w(a,"default"))o=!1;else if(""===o||o===S(n)){var l=$n(String,a.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!w(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof r&&"Function"!==Dn(e.type)?r.call(n):r}(r,a,n);var c=En;An(!0),Sn(o),An(c)}return o}var zn=/^\s*function (\w+)/;function Dn(n){var e=n&&n.toString().match(zn);return e?e[1]:""}function Un(n,e){return Dn(n)===Dn(e)}function $n(n,e){if(!Array.isArray(e))return Un(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Un(e[t],n))return t;return-1}function Jn(n,e,t){hn();try{if(e)for(var r=e;r=r.$parent;){var a=r.$options.errorCaptured;if(a)for(var i=0;i<a.length;i++)try{if(!1===a[i].call(r,n,e,t))return}catch(n){Qn(n,r,"errorCaptured hook")}}Qn(n,e,t)}finally{fn()}}function Wn(n,e,t,r,a){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&h(i)&&!i._handled&&(i.catch((function(n){return Jn(n,r,a+" (Promise/async)")})),i._handled=!0)}catch(n){Jn(n,r,a)}return i}function Qn(n,e,t){if(M.errorHandler)try{return M.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Vn(e,null,"config.errorHandler")}Vn(n,e,t)}function Vn(n,e,t){if(!W&&!Q||"undefined"==typeof console)throw n;console.error(n)}var Hn,Gn=!1,Kn=[],Yn=!1;function Xn(){Yn=!1;var n=Kn.slice(0);Kn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&on(Promise)){var Zn=Promise.resolve();Hn=function(){Zn.then(Xn),X&&setTimeout(B)},Gn=!0}else if(G||"undefined"==typeof MutationObserver||!on(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Hn="undefined"!=typeof setImmediate&&on(setImmediate)?function(){setImmediate(Xn)}:function(){setTimeout(Xn,0)};else{var ne=1,ee=new MutationObserver(Xn),te=document.createTextNode(String(ne));ee.observe(te,{characterData:!0}),Hn=function(){ne=(ne+1)%2,te.data=String(ne)},Gn=!0}function re(n,e){var t;if(Kn.push((function(){if(n)try{n.call(e)}catch(n){Jn(n,e,"nextTick")}else t&&t(e)})),Yn||(Yn=!0,Hn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var ae=new sn;function ie(n){!function n(e,t){var r,a,i=Array.isArray(e);if(!i&&!l(e)||Object.isFrozen(e)||e instanceof vn)return;if(e.__ob__){var o=e.__ob__.dep.id;if(t.has(o))return;t.add(o)}if(i)for(r=e.length;r--;)n(e[r],t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,ae),ae.clear()}var oe=k((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function se(n,e){function t(){var n=arguments,r=t.fns;if(!Array.isArray(r))return Wn(r,null,arguments,e,"v-on handler");for(var a=r.slice(),i=0;i<a.length;i++)Wn(a[i],null,n,e,"v-on handler")}return t.fns=n,t}function le(n,e,t,r,i,s){var l,c,u,d;for(l in n)c=n[l],u=e[l],d=oe(l),a(c)||(a(u)?(a(c.fns)&&(c=n[l]=se(c,s)),o(d.once)&&(c=n[l]=i(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==u&&(u.fns=c,n[l]=u));for(l in e)a(n[l])&&r((d=oe(l)).name,e[l],d.capture)}function ce(n,e,t){var r;n instanceof vn&&(n=n.data.hook||(n.data.hook={}));var s=n[e];function l(){t.apply(this,arguments),y(r.fns,l)}a(s)?r=se([l]):i(s.fns)&&o(s.merged)?(r=s).fns.push(l):r=se([s,l]),r.merged=!0,n[e]=r}function ue(n,e,t,r,a){if(i(e)){if(w(e,t))return n[t]=e[t],a||delete e[t],!0;if(w(e,r))return n[t]=e[r],a||delete e[r],!0}return!1}function de(n){return s(n)?[yn(n)]:Array.isArray(n)?function n(e,t){var r,l,c,u,d=[];for(r=0;r<e.length;r++)a(l=e[r])||"boolean"==typeof l||(c=d.length-1,u=d[c],Array.isArray(l)?l.length>0&&(pe((l=n(l,(t||"")+"_"+r))[0])&&pe(u)&&(d[c]=yn(u.text+l[0].text),l.shift()),d.push.apply(d,l)):s(l)?pe(u)?d[c]=yn(u.text+l):""!==l&&d.push(yn(l)):pe(l)&&pe(u)?d[c]=yn(u.text+l.text):(o(e._isVList)&&i(l.tag)&&a(l.key)&&i(t)&&(l.key="__vlist"+t+"_"+r+"__"),d.push(l)));return d}(n):void 0}function pe(n){return i(n)&&i(n.text)&&!1===n.isComment}function he(n,e){if(n){for(var t=Object.create(null),r=ln?Reflect.ownKeys(n):Object.keys(n),a=0;a<r.length;a++){var i=r[a];if("__ob__"!==i){for(var o=n[i].from,s=e;s;){if(s._provided&&w(s._provided,o)){t[i]=s._provided[o];break}s=s.$parent}if(!s)if("default"in n[i]){var l=n[i].default;t[i]="function"==typeof l?l.call(e):l}else 0}}return t}}function fe(n,e){if(!n||!n.length)return{};for(var t={},r=0,a=n.length;r<a;r++){var i=n[r],o=i.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,i.context!==e&&i.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(i);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===i.tag?l.push.apply(l,i.children||[]):l.push(i)}}for(var c in t)t[c].every(ve)&&delete t[c];return t}function ve(n){return n.isComment&&!n.asyncFactory||" "===n.text}function me(n){return n.isComment&&n.asyncFactory}function ge(n,e,t){var a,i=Object.keys(e).length>0,o=n?!!n.$stable:!i,s=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&t&&t!==r&&s===t.$key&&!i&&!t.$hasNormal)return t;for(var l in a={},n)n[l]&&"$"!==l[0]&&(a[l]=ye(e,l,n[l]))}else a={};for(var c in e)c in a||(a[c]=be(e,c));return n&&Object.isExtensible(n)&&(n._normalized=a),D(a,"$stable",o),D(a,"$key",s),D(a,"$hasNormal",i),a}function ye(n,e,t){var r=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:de(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!me(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:r,enumerable:!0,configurable:!0}),r}function be(n,e){return function(){return n[e]}}function we(n,e){var t,r,a,o,s;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),r=0,a=n.length;r<a;r++)t[r]=e(n[r],r);else if("number"==typeof n)for(t=new Array(n),r=0;r<n;r++)t[r]=e(r+1,r);else if(l(n))if(ln&&n[Symbol.iterator]){t=[];for(var c=n[Symbol.iterator](),u=c.next();!u.done;)t.push(e(u.value,t.length)),u=c.next()}else for(o=Object.keys(n),t=new Array(o.length),r=0,a=o.length;r<a;r++)s=o[r],t[r]=e(n[s],s,r);return i(t)||(t=[]),t._isVList=!0,t}function ke(n,e,t,r){var a,i=this.$scopedSlots[n];i?(t=t||{},r&&(t=O(O({},r),t)),a=i(t)||("function"==typeof e?e():e)):a=this.$slots[n]||("function"==typeof e?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},a):a}function xe(n){return Fn(this.$options,"filters",n)||L}function Ee(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function Ae(n,e,t,r,a){var i=M.keyCodes[e]||t;return a&&r&&!M.keyCodes[e]?Ee(a,r):i?Ee(i,n):r?S(r)!==e:void 0===n}function _e(n,e,t,r,a){if(t)if(l(t)){var i;Array.isArray(t)&&(t=j(t));var o=function(o){if("class"===o||"style"===o||g(o))i=n;else{var s=n.attrs&&n.attrs.type;i=r||M.mustUseProp(e,s,o)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=E(o),c=S(o);l in i||c in i||(i[o]=t[o],a&&((n.on||(n.on={}))["update:"+o]=function(n){t[o]=n}))};for(var s in t)o(s)}else;return n}function Se(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||Te(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),r}function Ce(n,e,t){return Te(n,"__once__"+e+(t?"_"+t:""),!0),n}function Te(n,e,t){if(Array.isArray(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&Oe(n[r],e+"_"+r,t);else Oe(n,e,t)}function Oe(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function je(n,e){if(e)if(u(e)){var t=n.on=n.on?O({},n.on):{};for(var r in e){var a=t[r],i=e[r];t[r]=a?[].concat(a,i):i}}else;return n}function Be(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var i=n[a];Array.isArray(i)?Be(i,e,t):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return r&&(e.$key=r),e}function Ie(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function Le(n,e){return"string"==typeof n?e+n:n}function Ne(n){n._o=Ce,n._n=v,n._s=f,n._l=we,n._t=ke,n._q=N,n._i=P,n._m=Se,n._f=xe,n._k=Ae,n._b=_e,n._v=yn,n._e=gn,n._u=Be,n._g=je,n._d=Ie,n._p=Le}function Pe(n,e,t,a,i){var s,l=this,c=i.options;w(a,"_uid")?(s=Object.create(a))._original=a:(s=a,a=a._original);var u=o(c._compiled),d=!u;this.data=n,this.props=e,this.children=t,this.parent=a,this.listeners=n.on||r,this.injections=he(c.inject,a),this.slots=function(){return l.$slots||ge(n.scopedSlots,l.$slots=fe(t,a)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ge(n.scopedSlots,this.slots())}}),u&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=ge(n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,r){var i=Ue(s,n,e,t,r,d);return i&&!Array.isArray(i)&&(i.fnScopeId=c._scopeId,i.fnContext=a),i}:this._c=function(n,e,t,r){return Ue(s,n,e,t,r,d)}}function qe(n,e,t,r,a){var i=bn(n);return i.fnContext=t,i.fnOptions=r,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function Re(n,e){for(var t in e)n[E(t)]=e[t]}Ne(Pe.prototype);var Fe={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Fe.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;i(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ye)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,a,i){0;var o=a.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==r&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(i||n.$options._renderChildren||l);n.$options._parentVnode=a,n.$vnode=a,n._vnode&&(n._vnode.parent=a);if(n.$options._renderChildren=i,n.$attrs=a.data.attrs||r,n.$listeners=t||r,e&&n.$options.props){An(!1);for(var u=n._props,d=n.$options._propKeys||[],p=0;p<d.length;p++){var h=d[p],f=n.$options.props;u[h]=Mn(h,f,e,n)}An(!0),n.$options.propsData=e}t=t||r;var v=n.$options._parentListeners;n.$options._parentListeners=t,Ke(n,t,v),c&&(n.$slots=fe(i,a.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,et(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,rt.push(e)):nt(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,Ze(e)))return;if(!e._inactive){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);et(e,"deactivated")}}(e,!0):e.$destroy())}},Me=Object.keys(Fe);function ze(n,e,t,s,c){if(!a(n)){var u=t.$options._base;if(l(n)&&(n=u.extend(n)),"function"==typeof n){var d;if(a(n.cid)&&void 0===(n=function(n,e){if(o(n.error)&&i(n.errorComp))return n.errorComp;if(i(n.resolved))return n.resolved;var t=Je;t&&i(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(o(n.loading)&&i(n.loadingComp))return n.loadingComp;if(t&&!i(n.owners)){var r=n.owners=[t],s=!0,c=null,u=null;t.$on("hook:destroyed",(function(){return y(r,t)}));var d=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==c&&(clearTimeout(c),c=null),null!==u&&(clearTimeout(u),u=null))},p=q((function(t){n.resolved=We(t,e),s?r.length=0:d(!0)})),f=q((function(e){i(n.errorComp)&&(n.error=!0,d(!0))})),v=n(p,f);return l(v)&&(h(v)?a(n.resolved)&&v.then(p,f):h(v.component)&&(v.component.then(p,f),i(v.error)&&(n.errorComp=We(v.error,e)),i(v.loading)&&(n.loadingComp=We(v.loading,e),0===v.delay?n.loading=!0:c=setTimeout((function(){c=null,a(n.resolved)&&a(n.error)&&(n.loading=!0,d(!1))}),v.delay||200)),i(v.timeout)&&(u=setTimeout((function(){u=null,a(n.resolved)&&f(null)}),v.timeout)))),s=!1,n.loading?n.loadingComp:n.resolved}}(d=n,u)))return function(n,e,t,r,a){var i=gn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:r,tag:a},i}(d,e,t,s,c);e=e||{},Et(n),i(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),o=a[r],s=e.model.callback;i(o)?(Array.isArray(o)?-1===o.indexOf(s):o!==s)&&(a[r]=[s].concat(o)):a[r]=s}(n.options,e);var p=function(n,e,t){var r=e.options.props;if(!a(r)){var o={},s=n.attrs,l=n.props;if(i(s)||i(l))for(var c in r){var u=S(c);ue(o,l,c,u,!0)||ue(o,s,c,u,!1)}return o}}(e,n);if(o(n.options.functional))return function(n,e,t,a,o){var s=n.options,l={},c=s.props;if(i(c))for(var u in c)l[u]=Mn(u,c,e||r);else i(t.attrs)&&Re(l,t.attrs),i(t.props)&&Re(l,t.props);var d=new Pe(t,l,o,a,n),p=s.render.call(null,d._c,d);if(p instanceof vn)return qe(p,t,d.parent,s,d);if(Array.isArray(p)){for(var h=de(p)||[],f=new Array(h.length),v=0;v<h.length;v++)f[v]=qe(h[v],t,d.parent,s,d);return f}}(n,p,e,t,s);var f=e.on;if(e.on=e.nativeOn,o(n.options.abstract)){var v=e.slot;e={},v&&(e.slot=v)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Me.length;t++){var r=Me[t],a=e[r],i=Fe[r];a===i||a&&a._merged||(e[r]=a?De(i,a):i)}}(e);var m=n.options.name||c;return new vn("vue-component-"+n.cid+(m?"-"+m:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:p,listeners:f,tag:c,children:s},d)}}}function De(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}function Ue(n,e,t,r,c,u){return(Array.isArray(t)||s(t))&&(c=r,r=t,t=void 0),o(u)&&(c=2),function(n,e,t,r,s){if(i(t)&&i(t.__ob__))return gn();i(t)&&i(t.is)&&(e=t.is);if(!e)return gn();0;Array.isArray(r)&&"function"==typeof r[0]&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===s?r=de(r):1===s&&(r=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var c,u;if("string"==typeof e){var d;u=n.$vnode&&n.$vnode.ns||M.getTagNamespace(e),c=M.isReservedTag(e)?new vn(M.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!i(d=Fn(n.$options,"components",e))?new vn(e,t,r,void 0,void 0,n):ze(d,t,n,r,e)}else c=ze(e,t,n,r);return Array.isArray(c)?c:i(c)?(i(u)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(i(e.children))for(var s=0,l=e.children.length;s<l;s++){var c=e.children[s];i(c.tag)&&(a(c.ns)||o(r)&&"svg"!==c.tag)&&n(c,t,r)}}(c,u),i(t)&&function(n){l(n.style)&&ie(n.style);l(n.class)&&ie(n.class)}(t),c):gn()}(n,e,t,r,c)}var $e,Je=null;function We(n,e){return(n.__esModule||ln&&"Module"===n[Symbol.toStringTag])&&(n=n.default),l(n)?e.extend(n):n}function Qe(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(i(t)&&(i(t.componentOptions)||me(t)))return t}}function Ve(n,e){$e.$on(n,e)}function He(n,e){$e.$off(n,e)}function Ge(n,e){var t=$e;return function r(){var a=e.apply(null,arguments);null!==a&&t.$off(n,r)}}function Ke(n,e,t){$e=n,le(e,t||{},Ve,He,Ge,n),$e=void 0}var Ye=null;function Xe(n){var e=Ye;return Ye=n,function(){Ye=e}}function Ze(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function nt(n,e){if(e){if(n._directInactive=!1,Ze(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)nt(n.$children[t]);et(n,"activated")}}function et(n,e){hn();var t=n.$options[e],r=e+" hook";if(t)for(var a=0,i=t.length;a<i;a++)Wn(t[a],n,null,n,r);n._hasHookEvent&&n.$emit("hook:"+e),fn()}var tt=[],rt=[],at={},it=!1,ot=!1,st=0;var lt=0,ct=Date.now;if(W&&!G){var ut=window.performance;ut&&"function"==typeof ut.now&&ct()>document.createEvent("Event").timeStamp&&(ct=function(){return ut.now()})}function dt(){var n,e;for(lt=ct(),ot=!0,tt.sort((function(n,e){return n.id-e.id})),st=0;st<tt.length;st++)(n=tt[st]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=rt.slice(),r=tt.slice();st=tt.length=rt.length=0,at={},it=ot=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,nt(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r._watcher===t&&r._isMounted&&!r._isDestroyed&&et(r,"updated")}}(r),an&&M.devtools&&an.emit("flush")}var pt=0,ht=function(n,e,t,r,a){this.vm=n,a&&(n._watcher=this),n._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++pt,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new sn,this.newDepIds=new sn,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!U.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=B)),this.value=this.lazy?void 0:this.get()};ht.prototype.get=function(){var n;hn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Jn(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&ie(n),fn(),this.cleanupDeps()}return n},ht.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},ht.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},ht.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==at[e]){if(at[e]=!0,ot){for(var t=tt.length-1;t>st&&tt[t].id>n.id;)t--;tt.splice(t+1,0,n)}else tt.push(n);it||(it=!0,re(dt))}}(this)},ht.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||l(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';Wn(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},ht.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},ht.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},ht.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||y(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var ft={enumerable:!0,configurable:!0,get:B,set:B};function vt(n,e,t){ft.get=function(){return this[e][t]},ft.set=function(n){this[e][t]=n},Object.defineProperty(n,t,ft)}function mt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props={},a=n.$options._propKeys=[];n.$parent&&An(!1);var i=function(i){a.push(i);var o=Mn(i,e,t,n);Cn(r,i,o),i in n||vt(n,"_props",i)};for(var o in e)i(o);An(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?B:C(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;u(e=n._data="function"==typeof e?function(n,e){hn();try{return n.call(e,e)}catch(n){return Jn(n,e,"data()"),{}}finally{fn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var i=t[a];0,r&&w(r,i)||(o=void 0,36!==(o=(i+"").charCodeAt(0))&&95!==o&&vt(n,"_data",i))}var o;Sn(e,!0)}(n):Sn(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=rn();for(var a in e){var i=e[a],o="function"==typeof i?i:i.get;0,r||(t[a]=new ht(n,o||B,B,gt)),a in n||yt(n,a,i)}}(n,e.computed),e.watch&&e.watch!==nn&&function(n,e){for(var t in e){var r=e[t];if(Array.isArray(r))for(var a=0;a<r.length;a++)kt(n,t,r[a]);else kt(n,t,r)}}(n,e.watch)}var gt={lazy:!0};function yt(n,e,t){var r=!rn();"function"==typeof t?(ft.get=r?bt(e):wt(t),ft.set=B):(ft.get=t.get?r&&!1!==t.cache?bt(e):wt(t.get):B,ft.set=t.set||B),Object.defineProperty(n,e,ft)}function bt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),dn.target&&e.depend(),e.value}}function wt(n){return function(){return n.call(this,this)}}function kt(n,e,t,r){return u(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var xt=0;function Et(n){var e=n.options;if(n.super){var t=Et(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var a in t)t[a]!==r[a]&&(e||(e={}),e[a]=t[a]);return e}(n);r&&O(n.extendOptions,r),(e=n.options=Rn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function At(n){this._init(n)}function _t(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,a=n._Ctor||(n._Ctor={});if(a[r])return a[r];var i=n.name||t.options.name;var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=Rn(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)vt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)yt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,R.forEach((function(n){o[n]=t[n]})),i&&(o.options.components[i]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=O({},o.options),a[r]=o,o}}function St(n){return n&&(n.Ctor.options.name||n.tag)}function Ct(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!d(n)&&n.test(e)}function Tt(n,e){var t=n.cache,r=n.keys,a=n._vnode;for(var i in t){var o=t[i];if(o){var s=o.name;s&&!e(s)&&Ot(t,i,r,a)}}}function Ot(n,e,t,r){var a=n[e];!a||r&&a.tag===r.tag||a.componentInstance.$destroy(),n[e]=null,y(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=xt++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var a=r.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Rn(Et(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ke(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,a=t&&t.context;n.$slots=fe(e._renderChildren,a),n.$scopedSlots=r,n._c=function(e,t,r,a){return Ue(n,e,t,r,a,!1)},n.$createElement=function(e,t,r,a){return Ue(n,e,t,r,a,!0)};var i=t&&t.data;Cn(n,"$attrs",i&&i.attrs||r,null,!0),Cn(n,"$listeners",e._parentListeners||r,null,!0)}(e),et(e,"beforeCreate"),function(n){var e=he(n.$options.inject,n);e&&(An(!1),Object.keys(e).forEach((function(t){Cn(n,t,e[t])})),An(!0))}(e),mt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),et(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(At),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Tn,n.prototype.$delete=On,n.prototype.$watch=function(n,e,t){if(u(e))return kt(this,n,e,t);(t=t||{}).user=!0;var r=new ht(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'+r.expression+'"';hn(),Wn(e,this,[r.value],this,a),fn()}return function(){r.teardown()}}}(At),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(Array.isArray(n))for(var a=0,i=n.length;a<i;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var i,o=t._events[n];if(!o)return t;if(!e)return t._events[n]=null,t;for(var s=o.length;s--;)if((i=o[s])===e||i.fn===e){o.splice(s,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?T(t):t;for(var r=T(arguments,1),a='event handler for "'+n+'"',i=0,o=t.length;i<o;i++)Wn(t[i],e,r,e,a)}return e}}(At),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,a=t._vnode,i=Xe(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),i(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){et(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||y(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),et(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(At),function(n){Ne(n.prototype),n.prototype.$nextTick=function(n){return re(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,a=t._parentVnode;a&&(e.$scopedSlots=ge(a.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=a;try{Je=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){Jn(t,e,"render"),n=e._vnode}finally{Je=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof vn||(n=gn()),n.parent=a,n}}(At);var jt=[String,RegExp,Array],Bt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:jt,exclude:jt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var a=t.tag,i=t.componentInstance,o=t.componentOptions;n[r]={name:St(o),tag:a,componentInstance:i},e.push(r),this.max&&e.length>parseInt(this.max)&&Ot(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Ot(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Tt(n,(function(n){return Ct(e,n)}))})),this.$watch("exclude",(function(e){Tt(n,(function(n){return!Ct(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Qe(n),t=e&&e.componentOptions;if(t){var r=St(t),a=this.include,i=this.exclude;if(a&&(!r||!Ct(a,r))||i&&r&&Ct(i,r))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,y(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return M}};Object.defineProperty(n,"config",e),n.util={warn:cn,extend:O,mergeOptions:Rn,defineReactive:Cn},n.set=Tn,n.delete=On,n.nextTick=re,n.observable=function(n){return Sn(n),n},n.options=Object.create(null),R.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,O(n.options.components,Bt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=T(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Rn(this.options,n),this}}(n),_t(n),function(n){R.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&u(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(At),Object.defineProperty(At.prototype,"$isServer",{get:rn}),Object.defineProperty(At.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(At,"FunctionalRenderContext",{value:Pe}),At.version="2.6.14";var It=m("style,class"),Lt=m("input,textarea,option,select,progress"),Nt=m("contenteditable,draggable,spellcheck"),Pt=m("events,caret,typing,plaintext-only"),qt=m("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Rt="http://www.w3.org/1999/xlink",Ft=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Mt=function(n){return Ft(n)?n.slice(6,n.length):""},zt=function(n){return null==n||!1===n};function Dt(n){for(var e=n.data,t=n,r=n;i(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=Ut(r.data,e));for(;i(t=t.parent);)t&&t.data&&(e=Ut(e,t.data));return function(n,e){if(i(n)||i(e))return $t(n,Jt(e));return""}(e.staticClass,e.class)}function Ut(n,e){return{staticClass:$t(n.staticClass,e.staticClass),class:i(n.class)?[n.class,e.class]:e.class}}function $t(n,e){return n?e?n+" "+e:n:e||""}function Jt(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,a=n.length;r<a;r++)i(e=Jt(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):l(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Wt={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Qt=m("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Vt=m("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Ht=function(n){return Qt(n)||Vt(n)};var Gt=Object.create(null);var Kt=m("text,number,password,search,email,tel,url");var Yt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Wt[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Xt={create:function(n,e){Zt(e)},update:function(n,e){n.data.ref!==e.data.ref&&(Zt(n,!0),Zt(e))},destroy:function(n){Zt(n,!0)}};function Zt(n,e){var t=n.data.ref;if(i(t)){var r=n.context,a=n.componentInstance||n.elm,o=r.$refs;e?Array.isArray(o[t])?y(o[t],a):o[t]===a&&(o[t]=void 0):n.data.refInFor?Array.isArray(o[t])?o[t].indexOf(a)<0&&o[t].push(a):o[t]=[a]:o[t]=a}}var nr=new vn("",{},[]),er=["create","activate","update","remove","destroy"];function tr(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&i(n.data)===i(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=i(t=n.data)&&i(t=t.attrs)&&t.type,a=i(t=e.data)&&i(t=t.attrs)&&t.type;return r===a||Kt(r)&&Kt(a)}(n,e)||o(n.isAsyncPlaceholder)&&a(e.asyncFactory.error))}function rr(n,e,t){var r,a,o={};for(r=e;r<=t;++r)i(a=n[r].key)&&(o[a]=r);return o}var ar={create:ir,update:ir,destroy:function(n){ir(n,nr)}};function ir(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,a,i=n===nr,o=e===nr,s=sr(n.data.directives,n.context),l=sr(e.data.directives,e.context),c=[],u=[];for(t in l)r=s[t],a=l[t],r?(a.oldValue=r.value,a.oldArg=r.arg,cr(a,"update",e,n),a.def&&a.def.componentUpdated&&u.push(a)):(cr(a,"bind",e,n),a.def&&a.def.inserted&&c.push(a));if(c.length){var d=function(){for(var t=0;t<c.length;t++)cr(c[t],"inserted",e,n)};i?ce(e,"insert",d):d()}u.length&&ce(e,"postpatch",(function(){for(var t=0;t<u.length;t++)cr(u[t],"componentUpdated",e,n)}));if(!i)for(t in s)l[t]||cr(s[t],"unbind",n,n,o)}(n,e)}var or=Object.create(null);function sr(n,e){var t,r,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=or),a[lr(r)]=r,r.def=Fn(e.$options,"directives",r.name);return a}function lr(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function cr(n,e,t,r,a){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,r,a)}catch(r){Jn(r,t.context,"directive "+n.name+" "+e+" hook")}}var ur=[Xt,ar];function dr(n,e){var t=e.componentOptions;if(!(i(t)&&!1===t.Ctor.options.inheritAttrs||a(n.data.attrs)&&a(e.data.attrs))){var r,o,s=e.elm,l=n.data.attrs||{},c=e.data.attrs||{};for(r in i(c.__ob__)&&(c=e.data.attrs=O({},c)),c)o=c[r],l[r]!==o&&pr(s,r,o,e.data.pre);for(r in(G||Y)&&c.value!==l.value&&pr(s,"value",c.value),l)a(c[r])&&(Ft(r)?s.removeAttributeNS(Rt,Mt(r)):Nt(r)||s.removeAttribute(r))}}function pr(n,e,t,r){r||n.tagName.indexOf("-")>-1?hr(n,e,t):qt(e)?zt(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Nt(e)?n.setAttribute(e,function(n,e){return zt(e)||"false"===e?"false":"contenteditable"===n&&Pt(e)?e:"true"}(e,t)):Ft(e)?zt(t)?n.removeAttributeNS(Rt,Mt(e)):n.setAttributeNS(Rt,e,t):hr(n,e,t)}function hr(n,e,t){if(zt(t))n.removeAttribute(e);else{if(G&&!K&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var r=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",r)};n.addEventListener("input",r),n.__ieph=!0}n.setAttribute(e,t)}}var fr={create:dr,update:dr};function vr(n,e){var t=e.elm,r=e.data,o=n.data;if(!(a(r.staticClass)&&a(r.class)&&(a(o)||a(o.staticClass)&&a(o.class)))){var s=Dt(e),l=t._transitionClasses;i(l)&&(s=$t(s,Jt(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var mr,gr={create:vr,update:vr};function yr(n,e,t){var r=mr;return function a(){var i=e.apply(null,arguments);null!==i&&kr(n,a,t,r)}}var br=Gn&&!(Z&&Number(Z[1])<=53);function wr(n,e,t,r){if(br){var a=lt,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}mr.addEventListener(n,e,en?{capture:t,passive:r}:t)}function kr(n,e,t,r){(r||mr).removeEventListener(n,e._wrapper||e,t)}function xr(n,e){if(!a(n.data.on)||!a(e.data.on)){var t=e.data.on||{},r=n.data.on||{};mr=e.elm,function(n){if(i(n.__r)){var e=G?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}i(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),le(t,r,wr,kr,yr,e.context),mr=void 0}}var Er,Ar={create:xr,update:xr};function _r(n,e){if(!a(n.data.domProps)||!a(e.data.domProps)){var t,r,o=e.elm,s=n.data.domProps||{},l=e.data.domProps||{};for(t in i(l.__ob__)&&(l=e.data.domProps=O({},l)),s)t in l||(o[t]="");for(t in l){if(r=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===s[t])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===t&&"PROGRESS"!==o.tagName){o._value=r;var c=a(r)?"":String(r);Sr(o,c)&&(o.value=c)}else if("innerHTML"===t&&Vt(o.tagName)&&a(o.innerHTML)){(Er=Er||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var u=Er.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;u.firstChild;)o.appendChild(u.firstChild)}else if(r!==s[t])try{o[t]=r}catch(n){}}}}function Sr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(i(r)){if(r.number)return v(t)!==v(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Cr={create:_r,update:_r},Tr=k((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Or(n){var e=jr(n.style);return n.staticStyle?O(n.staticStyle,e):e}function jr(n){return Array.isArray(n)?j(n):"string"==typeof n?Tr(n):n}var Br,Ir=/^--/,Lr=/\s*!important$/,Nr=function(n,e,t){if(Ir.test(e))n.style.setProperty(e,t);else if(Lr.test(t))n.style.setProperty(S(e),t.replace(Lr,""),"important");else{var r=qr(e);if(Array.isArray(t))for(var a=0,i=t.length;a<i;a++)n.style[r]=t[a];else n.style[r]=t}},Pr=["Webkit","Moz","ms"],qr=k((function(n){if(Br=Br||document.createElement("div").style,"filter"!==(n=E(n))&&n in Br)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<Pr.length;t++){var r=Pr[t]+e;if(r in Br)return r}}));function Rr(n,e){var t=e.data,r=n.data;if(!(a(t.staticStyle)&&a(t.style)&&a(r.staticStyle)&&a(r.style))){var o,s,l=e.elm,c=r.staticStyle,u=r.normalizedStyle||r.style||{},d=c||u,p=jr(e.data.style)||{};e.data.normalizedStyle=i(p.__ob__)?O({},p):p;var h=function(n,e){var t,r={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Or(a.data))&&O(r,t);(t=Or(n.data))&&O(r,t);for(var i=n;i=i.parent;)i.data&&(t=Or(i.data))&&O(r,t);return r}(e,!0);for(s in d)a(h[s])&&Nr(l,s,"");for(s in h)(o=h[s])!==d[s]&&Nr(l,s,null==o?"":o)}}var Fr={create:Rr,update:Rr},Mr=/\s+/;function zr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Mr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Dr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Mr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Ur(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&O(e,$r(n.name||"v")),O(e,n),e}return"string"==typeof n?$r(n):void 0}}var $r=k((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Jr=W&&!K,Wr="transition",Qr="transitionend",Vr="animation",Hr="animationend";Jr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Wr="WebkitTransition",Qr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Vr="WebkitAnimation",Hr="webkitAnimationEnd"));var Gr=W?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Kr(n){Gr((function(){Gr(n)}))}function Yr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),zr(n,e))}function Xr(n,e){n._transitionClasses&&y(n._transitionClasses,e),Dr(n,e)}function Zr(n,e,t){var r=ea(n,e),a=r.type,i=r.timeout,o=r.propCount;if(!a)return t();var s="transition"===a?Qr:Hr,l=0,c=function(){n.removeEventListener(s,u),t()},u=function(e){e.target===n&&++l>=o&&c()};setTimeout((function(){l<o&&c()}),i+1),n.addEventListener(s,u)}var na=/\b(transform|all)(,|$)/;function ea(n,e){var t,r=window.getComputedStyle(n),a=(r[Wr+"Delay"]||"").split(", "),i=(r[Wr+"Duration"]||"").split(", "),o=ta(a,i),s=(r[Vr+"Delay"]||"").split(", "),l=(r[Vr+"Duration"]||"").split(", "),c=ta(s,l),u=0,d=0;return"transition"===e?o>0&&(t="transition",u=o,d=i.length):"animation"===e?c>0&&(t="animation",u=c,d=l.length):d=(t=(u=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?i.length:l.length:0,{type:t,timeout:u,propCount:d,hasTransform:"transition"===t&&na.test(r[Wr+"Property"])}}function ta(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ra(e)+ra(n[t])})))}function ra(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function aa(n,e){var t=n.elm;i(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=Ur(n.data.transition);if(!a(r)&&!i(t._enterCb)&&1===t.nodeType){for(var o=r.css,s=r.type,c=r.enterClass,u=r.enterToClass,d=r.enterActiveClass,p=r.appearClass,h=r.appearToClass,f=r.appearActiveClass,m=r.beforeEnter,g=r.enter,y=r.afterEnter,b=r.enterCancelled,w=r.beforeAppear,k=r.appear,x=r.afterAppear,E=r.appearCancelled,A=r.duration,_=Ye,S=Ye.$vnode;S&&S.parent;)_=S.context,S=S.parent;var C=!_._isMounted||!n.isRootInsert;if(!C||k||""===k){var T=C&&p?p:c,O=C&&f?f:d,j=C&&h?h:u,B=C&&w||m,I=C&&"function"==typeof k?k:g,L=C&&x||y,N=C&&E||b,P=v(l(A)?A.enter:A);0;var R=!1!==o&&!K,F=sa(I),M=t._enterCb=q((function(){R&&(Xr(t,j),Xr(t,O)),M.cancelled?(R&&Xr(t,T),N&&N(t)):L&&L(t),t._enterCb=null}));n.data.show||ce(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),I&&I(t,M)})),B&&B(t),R&&(Yr(t,T),Yr(t,O),Kr((function(){Xr(t,T),M.cancelled||(Yr(t,j),F||(oa(P)?setTimeout(M,P):Zr(t,s,M)))}))),n.data.show&&(e&&e(),I&&I(t,M)),R||F||M()}}}function ia(n,e){var t=n.elm;i(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=Ur(n.data.transition);if(a(r)||1!==t.nodeType)return e();if(!i(t._leaveCb)){var o=r.css,s=r.type,c=r.leaveClass,u=r.leaveToClass,d=r.leaveActiveClass,p=r.beforeLeave,h=r.leave,f=r.afterLeave,m=r.leaveCancelled,g=r.delayLeave,y=r.duration,b=!1!==o&&!K,w=sa(h),k=v(l(y)?y.leave:y);0;var x=t._leaveCb=q((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),b&&(Xr(t,u),Xr(t,d)),x.cancelled?(b&&Xr(t,c),m&&m(t)):(e(),f&&f(t)),t._leaveCb=null}));g?g(E):E()}function E(){x.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),p&&p(t),b&&(Yr(t,c),Yr(t,d),Kr((function(){Xr(t,c),x.cancelled||(Yr(t,u),w||(oa(k)?setTimeout(x,k):Zr(t,s,x)))}))),h&&h(t,x),b||w||x())}}function oa(n){return"number"==typeof n&&!isNaN(n)}function sa(n){if(a(n))return!1;var e=n.fns;return i(e)?sa(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function la(n,e){!0!==e.data.show&&aa(e)}var ca=function(n){var e,t,r={},l=n.modules,c=n.nodeOps;for(e=0;e<er.length;++e)for(r[er[e]]=[],t=0;t<l.length;++t)i(l[t][er[e]])&&r[er[e]].push(l[t][er[e]]);function u(n){var e=c.parentNode(n);i(e)&&c.removeChild(e,n)}function d(n,e,t,a,s,l,u){if(i(n.elm)&&i(l)&&(n=l[u]=bn(n)),n.isRootInsert=!s,!function(n,e,t,a){var s=n.data;if(i(s)){var l=i(n.componentInstance)&&s.keepAlive;if(i(s=s.hook)&&i(s=s.init)&&s(n,!1),i(n.componentInstance))return p(n,e),h(t,n.elm,a),o(l)&&function(n,e,t,a){var o,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,i(o=s.data)&&i(o=o.transition)){for(o=0;o<r.activate.length;++o)r.activate[o](nr,s);e.push(s);break}h(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var d=n.data,v=n.children,m=n.tag;i(m)?(n.elm=n.ns?c.createElementNS(n.ns,m):c.createElement(m,n),y(n),f(n,v,e),i(d)&&g(n,e),h(t,n.elm,a)):o(n.isComment)?(n.elm=c.createComment(n.text),h(t,n.elm,a)):(n.elm=c.createTextNode(n.text),h(t,n.elm,a))}}function p(n,e){i(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,v(n)?(g(n,e),y(n)):(Zt(n),e.push(n))}function h(n,e,t){i(n)&&(i(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function f(n,e,t){if(Array.isArray(e)){0;for(var r=0;r<e.length;++r)d(e[r],t,n.elm,null,!0,e,r)}else s(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function v(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return i(n.tag)}function g(n,t){for(var a=0;a<r.create.length;++a)r.create[a](nr,n);i(e=n.data.hook)&&(i(e.create)&&e.create(nr,n),i(e.insert)&&t.push(n))}function y(n){var e;if(i(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)i(e=t.context)&&i(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;i(e=Ye)&&e!==n.context&&e!==n.fnContext&&i(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function b(n,e,t,r,a,i){for(;r<=a;++r)d(t[r],i,n,e,!1,t,r)}function w(n){var e,t,a=n.data;if(i(a))for(i(e=a.hook)&&i(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(i(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function k(n,e,t){for(;e<=t;++e){var r=n[e];i(r)&&(i(r.tag)?(x(r),w(r)):u(r.elm))}}function x(n,e){if(i(e)||i(n.data)){var t,a=r.remove.length+1;for(i(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&u(n)}return t.listeners=e,t}(n.elm,a),i(t=n.componentInstance)&&i(t=t._vnode)&&i(t.data)&&x(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);i(t=n.data.hook)&&i(t=t.remove)?t(n,e):e()}else u(n.elm)}function E(n,e,t,r){for(var a=t;a<r;a++){var o=e[a];if(i(o)&&tr(n,o))return a}}function A(n,e,t,s,l,u){if(n!==e){i(e.elm)&&i(s)&&(e=s[l]=bn(e));var p=e.elm=n.elm;if(o(n.isAsyncPlaceholder))i(e.asyncFactory.resolved)?C(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(o(e.isStatic)&&o(n.isStatic)&&e.key===n.key&&(o(e.isCloned)||o(e.isOnce)))e.componentInstance=n.componentInstance;else{var h,f=e.data;i(f)&&i(h=f.hook)&&i(h=h.prepatch)&&h(n,e);var m=n.children,g=e.children;if(i(f)&&v(e)){for(h=0;h<r.update.length;++h)r.update[h](n,e);i(h=f.hook)&&i(h=h.update)&&h(n,e)}a(e.text)?i(m)&&i(g)?m!==g&&function(n,e,t,r,o){var s,l,u,p=0,h=0,f=e.length-1,v=e[0],m=e[f],g=t.length-1,y=t[0],w=t[g],x=!o;for(0;p<=f&&h<=g;)a(v)?v=e[++p]:a(m)?m=e[--f]:tr(v,y)?(A(v,y,r,t,h),v=e[++p],y=t[++h]):tr(m,w)?(A(m,w,r,t,g),m=e[--f],w=t[--g]):tr(v,w)?(A(v,w,r,t,g),x&&c.insertBefore(n,v.elm,c.nextSibling(m.elm)),v=e[++p],w=t[--g]):tr(m,y)?(A(m,y,r,t,h),x&&c.insertBefore(n,m.elm,v.elm),m=e[--f],y=t[++h]):(a(s)&&(s=rr(e,p,f)),a(l=i(y.key)?s[y.key]:E(y,e,p,f))?d(y,r,n,v.elm,!1,t,h):tr(u=e[l],y)?(A(u,y,r,t,h),e[l]=void 0,x&&c.insertBefore(n,u.elm,v.elm)):d(y,r,n,v.elm,!1,t,h),y=t[++h]);p>f?b(n,a(t[g+1])?null:t[g+1].elm,t,h,g,r):h>g&&k(e,p,f)}(p,m,g,t,u):i(g)?(i(n.text)&&c.setTextContent(p,""),b(p,null,g,0,g.length-1,t)):i(m)?k(m,0,m.length-1):i(n.text)&&c.setTextContent(p,""):n.text!==e.text&&c.setTextContent(p,e.text),i(f)&&i(h=f.hook)&&i(h=h.postpatch)&&h(n,e)}}}function _(n,e,t){if(o(t)&&i(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var S=m("attrs,class,staticClass,staticStyle,key");function C(n,e,t,r){var a,s=e.tag,l=e.data,c=e.children;if(r=r||l&&l.pre,e.elm=n,o(e.isComment)&&i(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(i(l)&&(i(a=l.hook)&&i(a=a.init)&&a(e,!0),i(a=e.componentInstance)))return p(e,t),!0;if(i(s)){if(i(c))if(n.hasChildNodes())if(i(a=l)&&i(a=a.domProps)&&i(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var u=!0,d=n.firstChild,h=0;h<c.length;h++){if(!d||!C(d,c[h],t,r)){u=!1;break}d=d.nextSibling}if(!u||d)return!1}else f(e,c,t);if(i(l)){var v=!1;for(var m in l)if(!S(m)){v=!0,g(e,t);break}!v&&l.class&&ie(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,s){if(!a(e)){var l,u=!1,p=[];if(a(n))u=!0,d(e,p);else{var h=i(n.nodeType);if(!h&&tr(n,e))A(n,e,p,null,null,s);else{if(h){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),o(t)&&C(n,e,p))return _(e,p,!0),n;l=n,n=new vn(c.tagName(l).toLowerCase(),{},[],void 0,l)}var f=n.elm,m=c.parentNode(f);if(d(e,p,f._leaveCb?null:m,c.nextSibling(f)),i(e.parent))for(var g=e.parent,y=v(e);g;){for(var b=0;b<r.destroy.length;++b)r.destroy[b](g);if(g.elm=e.elm,y){for(var x=0;x<r.create.length;++x)r.create[x](nr,g);var E=g.data.hook.insert;if(E.merged)for(var S=1;S<E.fns.length;S++)E.fns[S]()}else Zt(g);g=g.parent}i(m)?k([n],0,0):i(n.tag)&&w(n)}}return _(e,p,u),e.elm}i(n)&&w(n)}}({nodeOps:Yt,modules:[fr,gr,Ar,Cr,Fr,W?{create:la,activate:la,remove:function(n,e){!0!==n.data.show?ia(n,e):e()}}:{}].concat(ur)});K&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&ga(n,"input")}));var ua={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?ce(t,"postpatch",(function(){ua.componentUpdated(n,e,t)})):da(n,e,t.context),n._vOptions=[].map.call(n.options,fa)):("textarea"===t.tag||Kt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",va),n.addEventListener("compositionend",ma),n.addEventListener("change",ma),K&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){da(n,e,t.context);var r=n._vOptions,a=n._vOptions=[].map.call(n.options,fa);if(a.some((function(n,e){return!N(n,r[e])})))(n.multiple?e.value.some((function(n){return ha(n,a)})):e.value!==e.oldValue&&ha(e.value,a))&&ga(n,"change")}}};function da(n,e,t){pa(n,e,t),(G||Y)&&setTimeout((function(){pa(n,e,t)}),0)}function pa(n,e,t){var r=e.value,a=n.multiple;if(!a||Array.isArray(r)){for(var i,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],a)i=P(r,fa(o))>-1,o.selected!==i&&(o.selected=i);else if(N(fa(o),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));a||(n.selectedIndex=-1)}}function ha(n,e){return e.every((function(e){return!N(e,n)}))}function fa(n){return"_value"in n?n._value:n.value}function va(n){n.target.composing=!0}function ma(n){n.target.composing&&(n.target.composing=!1,ga(n.target,"input"))}function ga(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function ya(n){return!n.componentInstance||n.data&&n.data.transition?n:ya(n.componentInstance._vnode)}var ba={model:ua,show:{bind:function(n,e,t){var r=e.value,a=(t=ya(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&a?(t.data.show=!0,aa(t,(function(){n.style.display=i}))):n.style.display=r?i:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=ya(t)).data&&t.data.transition?(t.data.show=!0,r?aa(t,(function(){n.style.display=n.__vOriginalDisplay})):ia(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,a){a||(n.style.display=n.__vOriginalDisplay)}}},wa={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function ka(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?ka(Qe(e.children)):n}function xa(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var a=t._parentListeners;for(var i in a)e[E(i)]=a[i];return e}function Ea(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Aa=function(n){return n.tag||me(n)},_a=function(n){return"show"===n.name},Sa={name:"transition",props:wa,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Aa)).length){0;var r=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var i=ka(a);if(!i)return a;if(this._leaving)return Ea(n,a);var o="__transition-"+this._uid+"-";i.key=null==i.key?i.isComment?o+"comment":o+i.tag:s(i.key)?0===String(i.key).indexOf(o)?i.key:o+i.key:i.key;var l=(i.data||(i.data={})).transition=xa(this),c=this._vnode,u=ka(c);if(i.data.directives&&i.data.directives.some(_a)&&(i.data.show=!0),u&&u.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,u)&&!me(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var d=u.data.transition=O({},l);if("out-in"===r)return this._leaving=!0,ce(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Ea(n,a);if("in-out"===r){if(me(i))return c;var p,h=function(){p()};ce(l,"afterEnter",h),ce(l,"enterCancelled",h),ce(d,"delayLeave",(function(n){p=n}))}}return a}}},Ca=O({tag:String,moveClass:String},wa);function Ta(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Oa(n){n.data.newPos=n.elm.getBoundingClientRect()}function ja(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,a=e.top-t.top;if(r||a){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate("+r+"px,"+a+"px)",i.transitionDuration="0s"}}delete Ca.mode;var Ba={Transition:Sa,TransitionGroup:{props:Ca,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var a=Xe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,a=this.$slots.default||[],i=this.children=[],o=xa(this),s=0;s<a.length;s++){var l=a[s];if(l.tag)if(null!=l.key&&0!==String(l.key).indexOf("__vlist"))i.push(l),t[l.key]=l,(l.data||(l.data={})).transition=o;else;}if(r){for(var c=[],u=[],d=0;d<r.length;d++){var p=r[d];p.data.transition=o,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?c.push(p):u.push(p)}this.kept=n(e,null,c),this.removed=u}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Ta),n.forEach(Oa),n.forEach(ja),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;Yr(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(Qr,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(Qr,n),t._moveCb=null,Xr(t,e))})}})))},methods:{hasMove:function(n,e){if(!Jr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Dr(t,n)})),zr(t,e),t.style.display="none",this.$el.appendChild(t);var r=ea(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};At.config.mustUseProp=function(n,e,t){return"value"===t&&Lt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},At.config.isReservedTag=Ht,At.config.isReservedAttr=It,At.config.getTagNamespace=function(n){return Vt(n)?"svg":"math"===n?"math":void 0},At.config.isUnknownElement=function(n){if(!W)return!0;if(Ht(n))return!1;if(n=n.toLowerCase(),null!=Gt[n])return Gt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Gt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Gt[n]=/HTMLUnknownElement/.test(e.toString())},O(At.options.directives,ba),O(At.options.components,Ba),At.prototype.__patch__=W?ca:B,At.prototype.$mount=function(n,e){return function(n,e,t){var r;return n.$el=e,n.$options.render||(n.$options.render=gn),et(n,"beforeMount"),r=function(){n._update(n._render(),t)},new ht(n,r,B,{before:function(){n._isMounted&&!n._isDestroyed&&et(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,et(n,"mounted")),n}(this,n=n&&W?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},W&&setTimeout((function(){M.devtools&&an&&an.emit("init",At)}),0),e.default=At},function(n,e,t){var r=t(1),a=t(46).f,i=t(30),o=t(17),s=t(134),l=t(140),c=t(110);n.exports=function(n,e){var t,u,d,p,h,f=n.target,v=n.global,m=n.stat;if(t=v?r:m?r[f]||s(f,{}):(r[f]||{}).prototype)for(u in e){if(p=e[u],d=n.noTargetGet?(h=a(t,u))&&h.value:t[u],!c(v?u:f+(m?".":"#")+u,n.forced)&&void 0!==d){if(typeof p==typeof d)continue;l(p,d)}(n.sham||d&&d.sham)&&i(p,"sham",!0),o(t,u,p,n)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var r=t(80),a=Function.prototype,i=a.bind,o=a.call,s=r&&i.bind(o,o);n.exports=r?function(n){return n&&s(n)}:function(n){return n&&function(){return o.apply(n,arguments)}}},function(n,e,t){"use strict";function r(n,e,t,r,a,i,o,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),i&&(c._scopeId="data-v-"+i),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=l):a&&(l=s?function(){a.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:a),l)if(c.functional){c._injectStyles=l;var u=c.render;c.render=function(n,e){return l.call(e),u(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e,t){var r=t(143),a=t(17),i=t(310);r||a(Object.prototype,"toString",i,{unsafe:!0})},function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var r=t(1),a=t(63),i=t(12),o=t(103),s=t(64),l=t(181),c=a("wks"),u=r.Symbol,d=u&&u.for,p=l?u:u&&u.withoutSetter||o;n.exports=function(n){if(!i(c,n)||!s&&"string"!=typeof c[n]){var e="Symbol."+n;s&&i(u,n)?c[n]=u[n]:c[n]=l&&d?d(e):p(e)}return c[n]}},function(n,e,t){var r=t(4);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(80),a=Function.prototype.call;n.exports=r?a.bind(a):function(){return a.apply(a,arguments)}},function(n,e,t){var r=t(5),a=t(20),i=r({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(a(n),e)}},function(n,e,t){var r=t(1),a=t(100),i=r.String;n.exports=function(n){if("Symbol"===a(n))throw TypeError("Cannot convert a Symbol value to a string");return i(n)}},function(n,e,t){var r=t(1),a=t(15),i=r.String,o=r.TypeError;n.exports=function(n){if(a(n))return n;throw o(i(n)+" is not an object")}},function(n,e,t){var r=t(8);n.exports=function(n){return"object"==typeof n?null!==n:r(n)}},function(n,e,t){var r=t(1),a=t(10),i=t(183),o=t(182),s=t(14),l=t(105),c=r.TypeError,u=Object.defineProperty,d=Object.getOwnPropertyDescriptor;e.f=a?o?function(n,e,t){if(s(n),e=l(e),s(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var r=d(n,e);r&&r.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return u(n,e,t)}:u:function(n,e,t){if(s(n),e=l(e),s(t),i)try{return u(n,e,t)}catch(n){}if("get"in t||"set"in t)throw c("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var r=t(1),a=t(8),i=t(30),o=t(187),s=t(134);n.exports=function(n,e,t,l){var c=!!l&&!!l.unsafe,u=!!l&&!!l.enumerable,d=!!l&&!!l.noTargetGet,p=l&&void 0!==l.name?l.name:e;return a(t)&&o(t,p,l),n===r?(u?n[e]=t:s(e,t),n):(c?!d&&n[e]&&(u=!0):delete n[e],u?n[e]=t:i(n,e,t),n)}},function(n,e,t){var r=t(1),a=t(8),i=function(n){return a(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(r[n]):r[n]&&r[n][e]}},function(n,e,t){"use strict";var r=t(3),a=t(116);r({target:"RegExp",proto:!0,forced:/./.exec!==a},{exec:a})},function(n,e,t){var r=t(1),a=t(23),i=r.Object;n.exports=function(n){return i(a(n))}},function(n,e,t){"use strict";var r=t(250),a=Object.prototype.toString;function i(n){return"[object Array]"===a.call(n)}function o(n){return void 0===n}function s(n){return null!==n&&"object"==typeof n}function l(n){return"[object Function]"===a.call(n)}function c(n,e){if(null!=n)if("object"!=typeof n&&(n=[n]),i(n))for(var t=0,r=n.length;t<r;t++)e.call(null,n[t],t,n);else for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&e.call(null,n[a],a,n)}n.exports={isArray:i,isArrayBuffer:function(n){return"[object ArrayBuffer]"===a.call(n)},isBuffer:function(n){return null!==n&&!o(n)&&null!==n.constructor&&!o(n.constructor)&&"function"==typeof n.constructor.isBuffer&&n.constructor.isBuffer(n)},isFormData:function(n){return"undefined"!=typeof FormData&&n instanceof FormData},isArrayBufferView:function(n){return"undefined"!=typeof ArrayBuffer&&ArrayBuffer.isView?ArrayBuffer.isView(n):n&&n.buffer&&n.buffer instanceof ArrayBuffer},isString:function(n){return"string"==typeof n},isNumber:function(n){return"number"==typeof n},isObject:s,isUndefined:o,isDate:function(n){return"[object Date]"===a.call(n)},isFile:function(n){return"[object File]"===a.call(n)},isBlob:function(n){return"[object Blob]"===a.call(n)},isFunction:l,isStream:function(n){return s(n)&&l(n.pipe)},isURLSearchParams:function(n){return"undefined"!=typeof URLSearchParams&&n instanceof URLSearchParams},isStandardBrowserEnv:function(){return("undefined"==typeof navigator||"ReactNative"!==navigator.product&&"NativeScript"!==navigator.product&&"NS"!==navigator.product)&&("undefined"!=typeof window&&"undefined"!=typeof document)},forEach:c,merge:function n(){var e={};function t(t,r){"object"==typeof e[r]&&"object"==typeof t?e[r]=n(e[r],t):e[r]=t}for(var r=0,a=arguments.length;r<a;r++)c(arguments[r],t);return e},deepMerge:function n(){var e={};function t(t,r){"object"==typeof e[r]&&"object"==typeof t?e[r]=n(e[r],t):e[r]="object"==typeof t?n({},t):t}for(var r=0,a=arguments.length;r<a;r++)c(arguments[r],t);return e},extend:function(n,e,t){return c(e,(function(e,a){n[a]=t&&"function"==typeof e?r(e,t):e})),n},trim:function(n){return n.replace(/^\s*/,"").replace(/\s*$/,"")}}},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(77),t(69),t(34),t(7),t(429),t(37),t(38),t(210),t(430),t(70);var r=t(94);function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function i(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){Object(r.a)(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}},function(n,e,t){var r=t(1).TypeError;n.exports=function(n){if(null==n)throw r("Can't call method on "+n);return n}},function(n,e){n.exports=!1},function(n,e,t){"use strict";var r=t(204).charAt,a=t(13),i=t(35),o=t(186),s=i.set,l=i.getterFor("String Iterator");o(String,"String",(function(n){s(this,{type:"String Iterator",string:a(n),index:0})}),(function(){var n,e=l(this),t=e.string,a=e.index;return a>=t.length?{value:void 0,done:!0}:(n=r(t,a),e.index+=n.length,{value:n,done:!1})}))},function(n,e,t){var r=t(1),a=t(205),i=t(206),o=t(173),s=t(30),l=t(9),c=l("iterator"),u=l("toStringTag"),d=o.values,p=function(n,e){if(n){if(n[c]!==d)try{s(n,c,d)}catch(e){n[c]=d}if(n[u]||s(n,u,e),a[e])for(var t in o)if(n[t]!==o[t])try{s(n,t,o[t])}catch(e){n[t]=o[t]}}};for(var h in a)p(r[h]&&r[h].prototype,h);p(i,"DOMTokenList")},function(n,e,t){var r=t(79),a=t(23);n.exports=function(n){return r(a(n))}},function(n,e,t){var r=t(5),a=r({}.toString),i=r("".slice);n.exports=function(n){return i(a(n),8,-1)}},function(n,e,t){var r=t(1),a=t(8),i=t(82),o=r.TypeError;n.exports=function(n){if(a(n))return n;throw o(i(n)+" is not a function")}},function(n,e,t){var r=t(10),a=t(16),i=t(59);n.exports=r?function(n,e,t){return a.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){n.exports=t(473)},function(n,e,t){t(425),t(426)},function(n,e,t){var r=t(66);n.exports=function(n){return r(n.length)}},function(n,e,t){"use strict";var r=t(3),a=t(60).filter;r({target:"Array",proto:!0,forced:!t(101)("filter")},{filter:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r,a,i,o=t(285),s=t(1),l=t(5),c=t(15),u=t(30),d=t(12),p=t(133),h=t(107),f=t(83),v=s.TypeError,m=s.WeakMap;if(o||p.state){var g=p.state||(p.state=new m),y=l(g.get),b=l(g.has),w=l(g.set);r=function(n,e){if(b(g,n))throw new v("Object already initialized");return e.facade=n,w(g,n,e),e},a=function(n){return y(g,n)||{}},i=function(n){return b(g,n)}}else{var k=h("state");f[k]=!0,r=function(n,e){if(d(n,k))throw new v("Object already initialized");return e.facade=n,u(n,k,e),e},a=function(n){return d(n,k)?n[k]:{}},i=function(n){return d(n,k)}}n.exports={set:r,get:a,has:i,enforce:function(n){return i(n)?a(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=a(e)).type!==n)throw v("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(5);n.exports=r({}.isPrototypeOf)},function(n,e,t){"use strict";var r=t(3),a=t(209);r({target:"Array",proto:!0,forced:[].forEach!=a},{forEach:a})},function(n,e,t){var r=t(1),a=t(205),i=t(206),o=t(209),s=t(30),l=function(n){if(n&&n.forEach!==o)try{s(n,"forEach",o)}catch(e){n.forEach=o}};for(var c in a)a[c]&&l(r[c]&&r[c].prototype);l(i)},function(n,e,t){var r=t(218),a="object"==typeof self&&self&&self.Object===Object&&self,i=r||a||Function("return this")();n.exports=i},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){"use strict";var r=t(3),a=t(1),i=t(61),o=t(112),s=t(15),l=t(127),c=t(33),u=t(27),d=t(78),p=t(9),h=t(101),f=t(86),v=h("slice"),m=p("species"),g=a.Array,y=Math.max;r({target:"Array",proto:!0,forced:!v},{slice:function(n,e){var t,r,a,p=u(this),h=c(p),v=l(n,h),b=l(void 0===e?h:e,h);if(i(p)&&(t=p.constructor,(o(t)&&(t===g||i(t.prototype))||s(t)&&null===(t=t[m]))&&(t=void 0),t===g||void 0===t))return f(p,v,b);for(r=new(void 0===t?g:t)(y(b-v,0)),a=0;v<b;v++,a++)v in p&&d(r,a,p[v]);return r.length=a,r}})},function(n,e,t){var r,a=t(14),i=t(135),o=t(138),s=t(83),l=t(185),c=t(104),u=t(107),d=u("IE_PROTO"),p=function(){},h=function(n){return"<script>"+n+"<\/script>"},f=function(n){n.write(h("")),n.close();var e=n.parentWindow.Object;return n=null,e},v=function(){try{r=new ActiveXObject("htmlfile")}catch(n){}var n,e;v="undefined"!=typeof document?document.domain&&r?f(r):((e=c("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(h("document.F=Object")),n.close(),n.F):f(r);for(var t=o.length;t--;)delete v.prototype[o[t]];return v()};s[d]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(p.prototype=a(n),t=new p,p.prototype=null,t[d]=n):t=v(),void 0===e?t:i.f(t,e)}},function(n,e,t){var r=t(16).f,a=t(12),i=t(9)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!a(n,i)&&r(n,i,{configurable:!0,value:e})}},function(n,e,t){var r=t(17),a=t(319),i=Error.prototype;i.toString!==a&&r(i,"toString",a)},function(n,e,t){var r=t(18);n.exports=r("navigator","userAgent")||""},function(n,e,t){var r=t(10),a=t(11),i=t(139),o=t(59),s=t(27),l=t(105),c=t(12),u=t(183),d=Object.getOwnPropertyDescriptor;e.f=r?d:function(n,e){if(n=s(n),e=l(e),u)try{return d(n,e)}catch(n){}if(c(n,e))return o(!a(i.f,n,e),n[e])}},function(n,e,t){var r=t(3),a=t(1),i=t(51),o=t(315),s=a.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,l),r({global:!0,constructor:!0,arity:1,forced:l},t)},u=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return i(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),c("URIError",(function(n){return function(e){return i(n,this,arguments)}})),u("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),u("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),u("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(102);var r=t(93);t(69),t(89),t(7),t(114),t(25),t(26),t(214);var a=t(123);t(47),t(44);function i(n){return function(n){if(Array.isArray(n))return Object(r.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||Object(a.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";t.d(e,"a",(function(){return r}));t(69),t(89),t(7),t(114),t(25),t(26);function r(n){return(r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}},function(n,e,t){"use strict";var r=t(51),a=t(11),i=t(5),o=t(129),s=t(4),l=t(14),c=t(8),u=t(56),d=t(66),p=t(13),h=t(23),f=t(153),v=t(58),m=t(329),g=t(130),y=t(9)("replace"),b=Math.max,w=Math.min,k=i([].concat),x=i([].push),E=i("".indexOf),A=i("".slice),_="$0"==="a".replace(/./,"$0"),S=!!/./[y]&&""===/./[y]("a","$0");o("replace",(function(n,e,t){var i=S?"$":"$0";return[function(n,t){var r=h(this),i=null==n?void 0:v(n,y);return i?a(i,n,r,t):a(e,p(r),n,t)},function(n,a){var o=l(this),s=p(n);if("string"==typeof a&&-1===E(a,i)&&-1===E(a,"$<")){var h=t(e,o,s,a);if(h.done)return h.value}var v=c(a);v||(a=p(a));var y=o.global;if(y){var _=o.unicode;o.lastIndex=0}for(var S=[];;){var C=g(o,s);if(null===C)break;if(x(S,C),!y)break;""===p(C[0])&&(o.lastIndex=f(s,d(o.lastIndex),_))}for(var T,O="",j=0,B=0;B<S.length;B++){for(var I=p((C=S[B])[0]),L=b(w(u(C.index),s.length),0),N=[],P=1;P<C.length;P++)x(N,void 0===(T=C[P])?T:String(T));var q=C.groups;if(v){var R=k([I],N,L,s);void 0!==q&&x(R,q);var F=p(r(a,void 0,R))}else F=m(I,s,L,N,q,a);L>=j&&(O+=A(s,j,L)+F,j=L+I.length)}return O+A(s,j)}]}),!!s((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")}))||!_||S)},function(n,e,t){var r=t(80),a=Function.prototype,i=a.apply,o=a.call;n.exports="object"==typeof Reflect&&Reflect.apply||(r?o.bind(i):function(){return o.apply(i,arguments)})},function(n,e,t){var r=t(348),a=t(351);n.exports=function(n,e){var t=a(n,e);return r(t)?t:void 0}},function(n,e,t){var r=t(461),a=t(248),i=/[T ]/,o=/:/,s=/^(\d{2})$/,l=[/^([+-]\d{2})$/,/^([+-]\d{3})$/,/^([+-]\d{4})$/],c=/^(\d{4})/,u=[/^([+-]\d{4})/,/^([+-]\d{5})/,/^([+-]\d{6})/],d=/^-(\d{2})$/,p=/^-?(\d{3})$/,h=/^-?(\d{2})-?(\d{2})$/,f=/^-?W(\d{2})$/,v=/^-?W(\d{2})-?(\d{1})$/,m=/^(\d{2}([.,]\d*)?)$/,g=/^(\d{2}):?(\d{2}([.,]\d*)?)$/,y=/^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,b=/([Z+-].*)$/,w=/^(Z)$/,k=/^([+-])(\d{2})$/,x=/^([+-])(\d{2}):?(\d{2})$/;function E(n,e,t){e=e||0,t=t||0;var r=new Date(0);r.setUTCFullYear(n,0,4);var a=7*e+t+1-(r.getUTCDay()||7);return r.setUTCDate(r.getUTCDate()+a),r}n.exports=function(n,e){if(a(n))return new Date(n.getTime());if("string"!=typeof n)return new Date(n);var t=(e||{}).additionalDigits;t=null==t?2:Number(t);var A=function(n){var e,t={},r=n.split(i);o.test(r[0])?(t.date=null,e=r[0]):(t.date=r[0],e=r[1]);if(e){var a=b.exec(e);a?(t.time=e.replace(a[1],""),t.timezone=a[1]):t.time=e}return t}(n),_=function(n,e){var t,r=l[e],a=u[e];if(t=c.exec(n)||a.exec(n)){var i=t[1];return{year:parseInt(i,10),restDateString:n.slice(i.length)}}if(t=s.exec(n)||r.exec(n)){var o=t[1];return{year:100*parseInt(o,10),restDateString:n.slice(o.length)}}return{year:null}}(A.date,t),S=_.year,C=function(n,e){if(null===e)return null;var t,r,a,i;if(0===n.length)return(r=new Date(0)).setUTCFullYear(e),r;if(t=d.exec(n))return r=new Date(0),a=parseInt(t[1],10)-1,r.setUTCFullYear(e,a),r;if(t=p.exec(n)){r=new Date(0);var o=parseInt(t[1],10);return r.setUTCFullYear(e,0,o),r}if(t=h.exec(n)){r=new Date(0),a=parseInt(t[1],10)-1;var s=parseInt(t[2],10);return r.setUTCFullYear(e,a,s),r}if(t=f.exec(n))return i=parseInt(t[1],10)-1,E(e,i);if(t=v.exec(n)){i=parseInt(t[1],10)-1;var l=parseInt(t[2],10)-1;return E(e,i,l)}return null}(_.restDateString,S);if(C){var T,O=C.getTime(),j=0;if(A.time&&(j=function(n){var e,t,r;if(e=m.exec(n))return(t=parseFloat(e[1].replace(",",".")))%24*36e5;if(e=g.exec(n))return t=parseInt(e[1],10),r=parseFloat(e[2].replace(",",".")),t%24*36e5+6e4*r;if(e=y.exec(n)){t=parseInt(e[1],10),r=parseInt(e[2],10);var a=parseFloat(e[3].replace(",","."));return t%24*36e5+6e4*r+1e3*a}return null}(A.time)),A.timezone)T=6e4*function(n){var e,t;if(e=w.exec(n))return 0;if(e=k.exec(n))return t=60*parseInt(e[2],10),"+"===e[1]?-t:t;if(e=x.exec(n))return t=60*parseInt(e[2],10)+parseInt(e[3],10),"+"===e[1]?-t:t;return 0}(A.timezone);else{var B=O+j,I=new Date(B);T=r(I);var L=new Date(B);L.setDate(I.getDate()+1);var N=r(L)-r(I);N>0&&(T+=N)}return new Date(O+j+T)}return new Date(n)}},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(102);t(69),t(89),t(7),t(114),t(25),t(26);var r=t(123);t(47),t(44);function a(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var r,a,i=[],o=!0,s=!1;try{for(t=t.call(n);!(o=(r=t.next()).done)&&(i.push(r.value),!e||i.length!==e);o=!0);}catch(n){s=!0,a=n}finally{try{o||null==t.return||t.return()}finally{if(s)throw a}}return i}}(n,e)||Object(r.a)(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";var r=t(3),a=t(60).map;r({target:"Array",proto:!0,forced:!t(101)("map")},{map:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=function(n){var e=+n;return e!=e||0===e?0:(e>0?r:t)(e)}},function(n,e,t){"use strict";var r=t(4);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var r=t(29);n.exports=function(n,e){var t=n[e];return null==t?void 0:r(t)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(76),a=t(5),i=t(79),o=t(20),s=t(33),l=t(170),c=a([].push),u=function(n){var e=1==n,t=2==n,a=3==n,u=4==n,d=6==n,p=7==n,h=5==n||d;return function(f,v,m,g){for(var y,b,w=o(f),k=i(w),x=r(v,m),E=s(k),A=0,_=g||l,S=e?_(f,E):t||p?_(f,0):void 0;E>A;A++)if((h||A in k)&&(b=x(y=k[A],A,w),n))if(e)S[A]=b;else if(b)switch(n){case 3:return!0;case 5:return y;case 6:return A;case 2:c(S,y)}else switch(n){case 4:return!1;case 7:c(S,y)}return d?-1:a||u?u:S}};n.exports={forEach:u(0),map:u(1),filter:u(2),some:u(3),every:u(4),find:u(5),findIndex:u(6),filterReject:u(7)}},function(n,e,t){var r=t(28);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e,t){var r=t(10),a=t(99).EXISTS,i=t(5),o=t(16).f,s=Function.prototype,l=i(s.toString),c=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,u=i(c.exec);r&&!a&&o(s,"name",{configurable:!0,get:function(){try{return u(c,l(this))[1]}catch(n){return""}}})},function(n,e,t){var r=t(24),a=t(133);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.22.5",mode:r?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.22.5/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){var r=t(65),a=t(4);n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(n,e,t){var r,a,i=t(1),o=t(45),s=i.process,l=i.Deno,c=s&&s.versions||l&&l.version,u=c&&c.v8;u&&(a=(r=u.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!a&&o&&(!(r=o.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=o.match(/Chrome\/(\d+)/))&&(a=+r[1]),n.exports=a},function(n,e,t){var r=t(56),a=Math.min;n.exports=function(n){return n>0?a(r(n),9007199254740991):0}},function(n,e,t){var r=t(184),a=t(138).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},function(n,e,t){var r=t(1);n.exports=r.Promise},function(n,e,t){t(303),t(307),t(308),t(168),t(309)},function(n,e,t){var r=t(3),a=t(10),i=t(16).f;r({target:"Object",stat:!0,forced:Object.defineProperty!==i,sham:!a},{defineProperty:i})},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(69),t(89),t(7),t(114),t(25),t(26),t(311),t(312),t(313),t(314),t(70),t(146),t(47),t(44),t(148),t(37),t(38),t(62),t(149),t(320),t(41);var r=t(49);function a(){
/*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
a=function(){return n};var n={},e=Object.prototype,t=e.hasOwnProperty,i="function"==typeof Symbol?Symbol:{},o=i.iterator||"@@iterator",s=i.asyncIterator||"@@asyncIterator",l=i.toStringTag||"@@toStringTag";function c(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{c({},"")}catch(n){c=function(n,e,t){return n[e]=t}}function u(n,e,t,r){var a=e&&e.prototype instanceof h?e:h,i=Object.create(a.prototype),o=new _(r||[]);return i._invoke=function(n,e,t){var r="suspendedStart";return function(a,i){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===a)throw i;return C()}for(t.method=a,t.arg=i;;){var o=t.delegate;if(o){var s=x(o,t);if(s){if(s===p)continue;return s}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===r)throw r="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);r="executing";var l=d(n,e,t);if("normal"===l.type){if(r=t.done?"completed":"suspendedYield",l.arg===p)continue;return{value:l.arg,done:t.done}}"throw"===l.type&&(r="completed",t.method="throw",t.arg=l.arg)}}}(n,t,o),i}function d(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=u;var p={};function h(){}function f(){}function v(){}var m={};c(m,o,(function(){return this}));var g=Object.getPrototypeOf,y=g&&g(g(S([])));y&&y!==e&&t.call(y,o)&&(m=y);var b=v.prototype=h.prototype=Object.create(m);function w(n){["next","throw","return"].forEach((function(e){c(n,e,(function(n){return this._invoke(e,n)}))}))}function k(n,e){var a;this._invoke=function(i,o){function s(){return new e((function(a,s){!function a(i,o,s,l){var c=d(n[i],n,o);if("throw"!==c.type){var u=c.arg,p=u.value;return p&&"object"==Object(r.a)(p)&&t.call(p,"__await")?e.resolve(p.__await).then((function(n){a("next",n,s,l)}),(function(n){a("throw",n,s,l)})):e.resolve(p).then((function(n){u.value=n,s(u)}),(function(n){return a("throw",n,s,l)}))}l(c.arg)}(i,o,a,s)}))}return a=a?a.then(s,s):s()}}function x(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,x(n,e),"throw"===e.method))return p;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return p}var r=d(t,n.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,p;var a=r.arg;return a?a.done?(e[n.resultName]=a.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,p):a:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,p)}function E(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function A(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function _(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(E,this),this.reset(!0)}function S(n){if(n){var e=n[o];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var r=-1,a=function e(){for(;++r<n.length;)if(t.call(n,r))return e.value=n[r],e.done=!1,e;return e.value=void 0,e.done=!0,e};return a.next=a}}return{next:C}}function C(){return{value:void 0,done:!0}}return f.prototype=v,c(b,"constructor",v),c(v,"constructor",f),f.displayName=c(v,l,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===f||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,v):(n.__proto__=v,c(n,l,"GeneratorFunction")),n.prototype=Object.create(b),n},n.awrap=function(n){return{__await:n}},w(k.prototype),c(k.prototype,s,(function(){return this})),n.AsyncIterator=k,n.async=function(e,t,r,a,i){void 0===i&&(i=Promise);var o=new k(u(e,t,r,a),i);return n.isGeneratorFunction(t)?o:o.next().then((function(n){return n.done?n.value:o.next()}))},w(b),c(b,l,"Generator"),c(b,o,(function(){return this})),c(b,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var r=e.pop();if(r in n)return t.value=r,t.done=!1,t}return t.done=!0,t}},n.values=S,_.prototype={constructor:_,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(A),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function r(t,r){return o.type="throw",o.arg=n,e.next=t,r&&(e.method="next",e.arg=void 0),!!r}for(var a=this.tryEntries.length-1;a>=0;--a){var i=this.tryEntries[a],o=i.completion;if("root"===i.tryLoc)return r("end");if(i.tryLoc<=this.prev){var s=t.call(i,"catchLoc"),l=t.call(i,"finallyLoc");if(s&&l){if(this.prev<i.catchLoc)return r(i.catchLoc,!0);if(this.prev<i.finallyLoc)return r(i.finallyLoc)}else if(s){if(this.prev<i.catchLoc)return r(i.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return r(i.finallyLoc)}}}},abrupt:function(n,e){for(var r=this.tryEntries.length-1;r>=0;--r){var a=this.tryEntries[r];if(a.tryLoc<=this.prev&&t.call(a,"finallyLoc")&&this.prev<a.finallyLoc){var i=a;break}}i&&("break"===n||"continue"===n)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=n,o.arg=e,i?(this.method="next",this.next=i.finallyLoc,p):this.complete(o)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),p},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),A(t),p}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var r=t.completion;if("throw"===r.type){var a=r.arg;A(t)}return a}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:S(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),p}},n}},function(n,e,t){"use strict";var r=t(449),a=t(459),i=t(165);n.exports={formats:i,parse:a,stringify:r}},function(n,e,t){"use strict";var r=t(2);e.a=new r.default},function(n,e,t){"use strict";var r=t(3),a=t(1),i=t(4),o=t(61),s=t(15),l=t(20),c=t(33),u=t(78),d=t(170),p=t(101),h=t(9),f=t(65),v=h("isConcatSpreadable"),m=a.TypeError,g=f>=51||!i((function(){var n=[];return n[v]=!1,n.concat()[0]!==n})),y=p("concat"),b=function(n){if(!s(n))return!1;var e=n[v];return void 0!==e?!!e:o(n)};r({target:"Array",proto:!0,arity:1,forced:!g||!y},{concat:function(n){var e,t,r,a,i,o=l(this),s=d(o,0),p=0;for(e=-1,r=arguments.length;e<r;e++)if(b(i=-1===e?o:arguments[e])){if(p+(a=c(i))>9007199254740991)throw m("Maximum allowed index exceeded");for(t=0;t<a;t++,p++)t in i&&u(s,p,i[t])}else{if(p>=9007199254740991)throw m("Maximum allowed index exceeded");u(s,p++,i)}return s.length=p,s}})},function(n,e,t){var r=t(5),a=t(29),i=t(80),o=r(r.bind);n.exports=function(n,e){return a(n),void 0===e?n:i?o(n,e):function(){return n.apply(e,arguments)}}},function(n,e,t){var r=t(3),a=t(20),i=t(106);r({target:"Object",stat:!0,forced:t(4)((function(){i(1)}))},{keys:function(n){return i(a(n))}})},function(n,e,t){"use strict";var r=t(105),a=t(16),i=t(59);n.exports=function(n,e,t){var o=r(e);o in n?a.f(n,o,i(0,t)):n[o]=t}},function(n,e,t){var r=t(1),a=t(5),i=t(4),o=t(28),s=r.Object,l=a("".split);n.exports=i((function(){return!s("z").propertyIsEnumerable(0)}))?function(n){return"String"==o(n)?l(n,""):s(n)}:s},function(n,e,t){var r=t(4);n.exports=!r((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var r=t(1),a=t(18),i=t(8),o=t(36),s=t(181),l=r.Object;n.exports=s?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return i(e)&&o(e.prototype,l(n))}},function(n,e,t){var r=t(1).String;n.exports=function(n){try{return r(n)}catch(n){return"Object"}}},function(n,e){n.exports={}},function(n,e){n.exports={}},function(n,e,t){var r=t(5),a=t(14),i=t(286);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=r(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,r){return a(t),i(r),e?n(t,r):t.__proto__=r,t}}():void 0)},function(n,e,t){var r=t(5);n.exports=r([].slice)},function(n,e,t){var r=t(1),a=t(68),i=t(8),o=t(110),s=t(108),l=t(9),c=t(294),u=t(24),d=t(65),p=a&&a.prototype,h=l("species"),f=!1,v=i(r.PromiseRejectionEvent),m=o("Promise",(function(){var n=s(a),e=n!==String(a);if(!e&&66===d)return!0;if(u&&(!p.catch||!p.finally))return!0;if(d>=51&&/native code/.test(n))return!1;var t=new a((function(n){n(1)})),r=function(n){n((function(){}),(function(){}))};return(t.constructor={})[h]=r,!(f=t.then((function(){}))instanceof r)||!e&&c&&!v}));n.exports={CONSTRUCTOR:m,REJECTION_EVENT:v,SUBCLASSING:f}},function(n,e,t){"use strict";var r=t(29),a=function(n){var e,t;this.promise=new n((function(n,r){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=r})),this.resolve=r(e),this.reject=r(t)};n.exports.f=function(n){return new a(n)}},function(n,e,t){"use strict";var r=t(3),a=t(10),i=t(1),o=t(5),s=t(12),l=t(8),c=t(36),u=t(13),d=t(16).f,p=t(140),h=i.Symbol,f=h&&h.prototype;if(a&&l(h)&&(!("description"in f)||void 0!==h().description)){var v={},m=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:u(arguments[0]),e=c(f,this)?new h(n):void 0===n?h():h(n);return""===n&&(v[e]=!0),e};p(m,h),m.prototype=f,f.constructor=m;var g="Symbol(test)"==String(h("test")),y=o(f.toString),b=o(f.valueOf),w=/^Symbol\((.*)\)[^)]+$/,k=o("".replace),x=o("".slice);d(f,"description",{configurable:!0,get:function(){var n=b(this),e=y(n);if(s(v,n))return"";var t=g?x(e,7,-1):k(e,w,"$1");return""===t?void 0:t}}),r({global:!0,constructor:!0,forced:!0},{Symbol:m})}},function(n,e,t){var r=t(39).Symbol;n.exports=r},function(n,e,t){var r=t(90),a=t(333),i=t(334),o=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?a(n):i(n)}},function(n,e,t){"use strict";t.d(e,"a",(function(){return a})),t.d(e,"c",(function(){return i})),t.d(e,"b",(function(){return o}));t(34),t(7),t(98),t(239),t(132);var r=t(95);function a(n,e){return n=n.filter((function(t,r){var a=t.title,i=t.frontmatter,o=i.home,s=i.date,l=i.publish;return n.indexOf(t)===r&&(!0===e?!(1==o||null==a||void 0===s||!1===l):!(1==o||null==a||!1===l))}))}function i(n){n.sort((function(n,e){var t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(r.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(r.a)(n,e)}))}function o(n){n.sort((function(n,e){return Object(r.a)(n,e)}))}},function(n,e,t){"use strict";function r(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";t.d(e,"a",(function(){return r}));t(70);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}},function(n,e,t){"use strict";t.d(e,"f",(function(){return r})),t.d(e,"b",(function(){return i})),t.d(e,"k",(function(){return o})),t.d(e,"h",(function(){return l})),t.d(e,"i",(function(){return c})),t.d(e,"j",(function(){return u})),t.d(e,"c",(function(){return d})),t.d(e,"g",(function(){return p})),t.d(e,"m",(function(){return h})),t.d(e,"n",(function(){return f})),t.d(e,"e",(function(){return v})),t.d(e,"l",(function(){return m})),t.d(e,"d",(function(){return g})),t.d(e,"a",(function(){return b}));t(19),t(50),t(273),t(97),t(171),t(131),t(55),t(37),t(7),t(38),t(34),t(102),t(98),t(96),t(272),t(179),t(180),t(132),t(172);var r=/#.*$/,a=/\.(md|html)$/,i=/\/$/,o=/^(https?:|mailto:|tel:)/;function s(n){return decodeURI(n).replace(r,"").replace(a,"")}function l(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function u(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;var e=n.match(r),t=e?e[0]:"",a=s(n);return i.test(a)?n:a+".html"+t}function p(n,e){var t=n.hash,a=function(n){var e=n.match(r);if(e)return e[0]}(e);return(!a||t===a)&&s(n.path)===s(e)}function h(n,e,t){t&&(e=function(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var s=i[o];".."===s?a.pop():"."!==s&&a.push(s)}""!==a[0]&&a.unshift("");return a.join("/")}(e,t));for(var r=s(e),a=0;a<n.length;a++)if(s(n[a].regularPath)===r)return Object.assign({},n[a],{type:"page",path:d(n[a].path)});return console.error('[vuepress] No matching page found for sidebar item "'.concat(e,'"')),{}}function f(n,e,t,r){var a=t.pages,i=t.themeConfig,o=r&&i.locales&&i.locales[r]||i;if("auto"===(n.frontmatter.sidebar||o.sidebar||i.sidebar))return function(n){var e=v(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map((function(e){return{type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}}))}]}(n);var s=o.sidebar||i.sidebar;if(s){var l=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(var t in e)if(0===(r=n,/(\.html|\/)$/.test(r)?r:r+"/").indexOf(encodeURI(t)))return{base:t,config:e[t]};var r;return{}}(e,s),c=l.base,u=l.config;return u?u.map((function(n){return function n(e,t,r){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;if("string"==typeof e)return h(t,e,r);if(Array.isArray(e))return Object.assign(h(t,e[0],r),{title:e[1]});a>3&&console.error("[vuepress] detected a too deep nested sidebar group.");var i=e.children||[];return 0===i.length&&e.path?Object.assign(h(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,children:i.map((function(e){return n(e,t,r,a+1)})),collapsable:!1!==e.collapsable}}(n,a,c)})):[]}return[]}function v(n){var e;return(n=n.map((function(n){return Object.assign({},n)}))).forEach((function(n){2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)})),n.filter((function(n){return 2===n.level}))}function m(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function g(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"yyyy-MM-dd hh:mm:ss";n=n.replace(/-/g,"/");var t=new Date(n);/(y+)/.test(e)&&(e=e.replace(RegExp.$1,t.getFullYear()+"").substr(4-RegExp.$1.length));var r={"M+":t.getMonth()+1,"d+":t.getDate(),"h+":t.getHours(),"m+":t.getMinutes(),"s+":t.getSeconds()};for(var a in r)if(RegExp("(".concat(a,")")).test(e)){var i=r[a]+"";e=e.replace(RegExp.$1,2===i.length?i:"0"+i)}return e}function y(n){return new Date(n.frontmatter.date).getTime()}function b(n,e){return y(e)-y(n)}},function(n,e,t){var r=t(5),a=t(17),i=Date.prototype,o=r(i.toString),s=r(i.getTime);"Invalid Date"!=String(new Date(NaN))&&a(i,"toString",(function(){var n=s(this);return n==n?o(this):"Invalid Date"}))},function(n,e,t){"use strict";t(19);var r,a,i=t(3),o=t(1),s=t(11),l=t(5),c=t(8),u=t(15),d=(r=!1,(a=/[ac]/).exec=function(){return r=!0,/./.exec.apply(this,arguments)},!0===a.test("abc")&&r),p=o.Error,h=l(/./.test);i({target:"RegExp",proto:!0,forced:!d},{test:function(n){var e=this.exec;if(!c(e))return h(this,n);var t=s(e,this,n);if(null!==t&&!u(t))throw new p("RegExp exec method returned something other than an Object or null");return!!t}})},function(n,e,t){"use strict";var r=t(3),a=t(5),i=t(137).indexOf,o=t(57),s=a([].indexOf),l=!!s&&1/s([1],1,-0)<0,c=o("indexOf");r({target:"Array",proto:!0,forced:l||!c},{indexOf:function(n){var e=arguments.length>1?arguments[1]:void 0;return l?s(this,n,e)||0:i(this,n,e)}})},function(n,e,t){var r=t(10),a=t(12),i=Function.prototype,o=r&&Object.getOwnPropertyDescriptor,s=a(i,"name"),l=s&&"something"===function(){}.name,c=s&&(!r||r&&o(i,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var r=t(1),a=t(143),i=t(8),o=t(28),s=t(9)("toStringTag"),l=r.Object,c="Arguments"==o(function(){return arguments}());n.exports=a?o:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=l(n),s))?t:c?o(e):"Object"==(r=o(e))&&i(e.callee)?"Arguments":r}},function(n,e,t){var r=t(4),a=t(9),i=t(65),o=a("species");n.exports=function(n){return i>=51||!r((function(){var e=[];return(e.constructor={})[o]=function(){return{foo:1}},1!==e[n](Boolean).foo}))}},function(n,e,t){t(3)({target:"Array",stat:!0},{isArray:t(61)})},function(n,e,t){var r=t(5),a=0,i=Math.random(),o=r(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++a+i,36)}},function(n,e,t){var r=t(1),a=t(15),i=r.document,o=a(i)&&a(i.createElement);n.exports=function(n){return o?i.createElement(n):{}}},function(n,e,t){var r=t(136),a=t(81);n.exports=function(n){var e=r(n,"string");return a(e)?e:e+""}},function(n,e,t){var r=t(184),a=t(138);n.exports=Object.keys||function(n){return r(n,a)}},function(n,e,t){var r=t(63),a=t(103),i=r("keys");n.exports=function(n){return i[n]||(i[n]=a(n))}},function(n,e,t){var r=t(5),a=t(8),i=t(133),o=r(Function.toString);a(i.inspectSource)||(i.inspectSource=function(n){return o(n)}),n.exports=i.inspectSource},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(4),a=t(8),i=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t==u||t!=c&&(a(e)?r(e):!!e)},s=o.normalize=function(n){return String(n).replace(i,".").toLowerCase()},l=o.data={},c=o.NATIVE="N",u=o.POLYFILL="P";n.exports=o},function(n,e,t){var r=t(28),a=t(1);n.exports="process"==r(a.process)},function(n,e,t){var r=t(5),a=t(4),i=t(8),o=t(100),s=t(18),l=t(108),c=function(){},u=[],d=s("Reflect","construct"),p=/^\s*(?:class|function)\b/,h=r(p.exec),f=!p.exec(c),v=function(n){if(!i(n))return!1;try{return d(c,u,n),!0}catch(n){return!1}},m=function(n){if(!i(n))return!1;switch(o(n)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return f||!!h(p,l(n))}catch(n){return!0}};m.sham=!0,n.exports=!d||a((function(){var n;return v(v.call)||!v(Object)||!v((function(){n=!0}))||n}))?m:v},function(n,e,t){var r=t(304),a=t(12),i=t(202),o=t(16).f;n.exports=function(n){var e=r.Symbol||(r.Symbol={});a(e,n)||o(e,n,{value:i.f(n)})}},function(n,e,t){t(113)("iterator")},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(7);function r(n,e,t,r,a,i,o){try{var s=n[i](o),l=s.value}catch(n){return void t(n)}s.done?e(l):Promise.resolve(l).then(r,a)}function a(n){return function(){var e=this,t=arguments;return new Promise((function(a,i){var o=n.apply(e,t);function s(n){r(o,a,i,s,l,"next",n)}function l(n){r(o,a,i,s,l,"throw",n)}s(void 0)}))}}},function(n,e,t){"use strict";var r,a,i=t(11),o=t(5),s=t(13),l=t(215),c=t(117),u=t(63),d=t(42),p=t(35).get,h=t(152),f=t(216),v=u("native-string-replace",String.prototype.replace),m=RegExp.prototype.exec,g=m,y=o("".charAt),b=o("".indexOf),w=o("".replace),k=o("".slice),x=(a=/b*/g,i(m,r=/a/,"a"),i(m,a,"a"),0!==r.lastIndex||0!==a.lastIndex),E=c.BROKEN_CARET,A=void 0!==/()??/.exec("")[1];(x||A||E||h||f)&&(g=function(n){var e,t,r,a,o,c,u,h=this,f=p(h),_=s(n),S=f.raw;if(S)return S.lastIndex=h.lastIndex,e=i(g,S,_),h.lastIndex=S.lastIndex,e;var C=f.groups,T=E&&h.sticky,O=i(l,h),j=h.source,B=0,I=_;if(T&&(O=w(O,"y",""),-1===b(O,"g")&&(O+="g"),I=k(_,h.lastIndex),h.lastIndex>0&&(!h.multiline||h.multiline&&"\n"!==y(_,h.lastIndex-1))&&(j="(?: "+j+")",I=" "+I,B++),t=new RegExp("^(?:"+j+")",O)),A&&(t=new RegExp("^"+j+"$(?!\\s)",O)),x&&(r=h.lastIndex),a=i(m,T?t:h,I),T?a?(a.input=k(a.input,B),a[0]=k(a[0],B),a.index=h.lastIndex,h.lastIndex+=a[0].length):h.lastIndex=0:x&&a&&(h.lastIndex=h.global?a.index+a[0].length:r),A&&a&&a.length>1&&i(v,a[0],t,(function(){for(o=1;o<arguments.length-2;o++)void 0===arguments[o]&&(a[o]=void 0)})),a&&C)for(a.groups=c=d(null),o=0;o<C.length;o++)c[(u=C[o])[0]]=a[u[1]];return a}),n.exports=g},function(n,e,t){var r=t(4),a=t(1).RegExp,i=r((function(){var n=a("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),o=i||r((function(){return!a("a","y").sticky})),s=i||r((function(){var n=a("^r","gy");return n.lastIndex=2,null!=n.exec("str")}));n.exports={BROKEN_CARET:s,MISSED_STICKY:o,UNSUPPORTED_Y:i}},function(n,e,t){var r=t(338),a=t(339),i=t(340),o=t(341),s=t(342);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(220);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(52)(Object,"create");n.exports=r},function(n,e,t){var r=t(360);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(161);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(41),t(7),t(62),t(214),t(25),t(19),t(97);var r=t(93);function a(n,e){if(n){if("string"==typeof n)return Object(r.a)(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(r.a)(n,e):void 0}}},function(n,e,t){var r,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),u=r.speed,d=r.easing;return l.offsetWidth,o((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var a;return(a="translate3d"===r.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,a}(n,u,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),u)}),u)):setTimeout(e,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)};return r.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var a,o=e.querySelector(r.barSelector),l=n?"-100":i(t.status||0),u=document.querySelector(r.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(a=e.querySelector(r.spinnerSelector))&&p(a),u!=document.body&&c(u,"nprogress-custom-parent"),u.appendChild(e),e},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&p(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,a=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((r=n[a]+i)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,a,i=arguments;if(2==i.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&r(n,t,a);else r(n,i[1],i[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function u(n,e){var t,r=d(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function p(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=a)},function(n,e,t){"use strict";var r=t(3),a=t(60).some;r({target:"Array",proto:!0,forced:!t(57)("some")},{some:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(9),a=t(42),i=t(16),o=r("unscopables"),s=Array.prototype;null==s[o]&&i.f(s,o,{configurable:!0,value:a(null)}),n.exports=function(n){s[o][n]=!0}},function(n,e,t){var r=t(56),a=Math.max,i=Math.min;n.exports=function(n,e){var t=r(n);return t<0?a(t+e,0):i(t,e)}},function(n,e,t){var r=t(100),a=t(58),i=t(84),o=t(9)("iterator");n.exports=function(n){if(null!=n)return a(n,o)||a(n,"@@iterator")||i[r(n)]}},function(n,e,t){"use strict";t(19);var r=t(5),a=t(17),i=t(116),o=t(4),s=t(9),l=t(30),c=s("species"),u=RegExp.prototype;n.exports=function(n,e,t,d){var p=s(n),h=!o((function(){var e={};return e[p]=function(){return 7},7!=""[n](e)})),f=h&&!o((function(){var e=!1,t=/a/;return"split"===n&&((t={}).constructor={},t.constructor[c]=function(){return t},t.flags="",t[p]=/./[p]),t.exec=function(){return e=!0,null},t[p](""),!e}));if(!h||!f||t){var v=r(/./[p]),m=e(p,""[n],(function(n,e,t,a,o){var s=r(n),l=e.exec;return l===i||l===u.exec?h&&!o?{done:!0,value:v(e,t,a)}:{done:!0,value:s(t,e,a)}:{done:!1}}));a(String.prototype,n,m[0]),a(u,p,m[1])}d&&l(u[p],"sham",!0)}},function(n,e,t){var r=t(1),a=t(11),i=t(14),o=t(8),s=t(28),l=t(116),c=r.TypeError;n.exports=function(n,e){var t=n.exec;if(o(t)){var r=a(t,n,e);return null!==r&&i(r),r}if("RegExp"===s(n))return a(l,n,e);throw c("RegExp#exec called on incompatible receiver")}},function(n,e,t){"use strict";var r=t(3),a=t(5),i=t(79),o=t(27),s=t(57),l=a([].join),c=i!=Object,u=s("join",",");r({target:"Array",proto:!0,forced:c||!u},{join:function(n){return l(o(this),void 0===n?",":n)}})},function(n,e,t){var r=t(1),a=t(10),i=t(117).MISSED_STICKY,o=t(28),s=t(240),l=t(35).get,c=RegExp.prototype,u=r.TypeError;a&&i&&s(c,"sticky",{configurable:!0,get:function(){if(this!==c){if("RegExp"===o(this))return!!l(this).sticky;throw u("Incompatible receiver, RegExp required")}}})},function(n,e,t){var r=t(1),a=t(134),i=r["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=i},function(n,e,t){var r=t(1),a=Object.defineProperty;n.exports=function(n,e){try{a(r,n,{value:e,configurable:!0,writable:!0})}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(10),a=t(182),i=t(16),o=t(14),s=t(27),l=t(106);e.f=r&&!a?Object.defineProperties:function(n,e){o(n);for(var t,r=s(e),a=l(e),c=a.length,u=0;c>u;)i.f(n,t=a[u++],r[t]);return n}},function(n,e,t){var r=t(1),a=t(11),i=t(15),o=t(81),s=t(58),l=t(284),c=t(9),u=r.TypeError,d=c("toPrimitive");n.exports=function(n,e){if(!i(n)||o(n))return n;var t,r=s(n,d);if(r){if(void 0===e&&(e="default"),t=a(r,n,e),!i(t)||o(t))return t;throw u("Can't convert object to primitive value")}return void 0===e&&(e="number"),l(n,e)}},function(n,e,t){var r=t(27),a=t(127),i=t(33),o=function(n){return function(e,t,o){var s,l=r(e),c=i(l),u=a(o,c);if(n&&t!=t){for(;c>u;)if((s=l[u++])!=s)return!0}else for(;c>u;u++)if((n||u in l)&&l[u]===t)return n||u||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,i=a&&!r.call({1:2},1);e.f=i?function(n){var e=a(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(12),a=t(188),i=t(46),o=t(16);n.exports=function(n,e,t){for(var s=a(e),l=o.f,c=i.f,u=0;u<s.length;u++){var d=s[u];r(n,d)||t&&r(t,d)||l(n,d,c(e,d))}}},function(n,e,t){var r=t(1),a=t(12),i=t(8),o=t(20),s=t(107),l=t(190),c=s("IE_PROTO"),u=r.Object,d=u.prototype;n.exports=l?u.getPrototypeOf:function(n){var e=o(n);if(a(e,c))return e[c];var t=e.constructor;return i(t)&&e instanceof t?t.prototype:e instanceof u?d:null}},function(n,e,t){var r=t(14),a=t(192),i=t(9)("species");n.exports=function(n,e){var t,o=r(n).constructor;return void 0===o||null==(t=r(o)[i])?e:a(t)}},function(n,e,t){var r={};r[t(9)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,e,t){var r=t(1),a=t(127),i=t(33),o=t(78),s=r.Array,l=Math.max;n.exports=function(n,e,t){for(var r=i(n),c=a(e,r),u=a(void 0===t?r:t,r),d=s(l(u-c,0)),p=0;c<u;c++,p++)o(d,p,n[c]);return d.length=p,d}},function(n,e,t){t(3)({target:"Object",stat:!0,sham:!t(10)},{create:t(42)})},function(n,e,t){var r=t(8),a=t(15),i=t(85);n.exports=function(n,e,t){var o,s;return i&&r(o=e.constructor)&&o!==t&&a(s=o.prototype)&&s!==t.prototype&&i(n,s),n}},function(n,e,t){var r=t(3),a=t(4),i=t(20),o=t(141),s=t(190);r({target:"Object",stat:!0,forced:a((function(){o(1)})),sham:!s},{getPrototypeOf:function(n){return o(i(n))}})},function(n,e,t){t(3)({target:"Object",stat:!0},{setPrototypeOf:t(85)})},function(n,e,t){"use strict";var r=t(3),a=t(321).left,i=t(57),o=t(65),s=t(111);r({target:"Array",proto:!0,forced:!i("reduce")||!s&&o>79&&o<83},{reduce:function(n){var e=arguments.length;return a(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(15),a=t(28),i=t(9)("match");n.exports=function(n){var e;return r(n)&&(void 0!==(e=n[i])?!!e:"RegExp"==a(n))}},function(n,e,t){var r=t(4),a=t(1).RegExp;n.exports=r((function(){var n=a(".","s");return!(n.dotAll&&n.exec("\n")&&"s"===n.flags)}))},function(n,e,t){"use strict";var r=t(204).charAt;n.exports=function(n,e,t){return e+(t?r(n,e).length:1)}},function(n,e,t){var r=t(332),a=t(71),i=Object.prototype,o=i.hasOwnProperty,s=i.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return a(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(52)(t(39),"Map");n.exports=r},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(352),a=t(359),i=t(361),o=t(362),s=t(363);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(40),a=t(161),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(r(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(o.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(91),a=t(71);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==r(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";var r=SyntaxError,a=Function,i=TypeError,o=function(n){try{return a('"use strict"; return ('+n+").constructor;")()}catch(n){}},s=Object.getOwnPropertyDescriptor;if(s)try{s({},"")}catch(n){s=null}var l=function(){throw new i},c=s?function(){try{return l}catch(n){try{return s(arguments,"callee").get}catch(n){return l}}}():l,u=t(451)(),d=Object.getPrototypeOf||function(n){return n.__proto__},p={},h="undefined"==typeof Uint8Array?void 0:d(Uint8Array),f={"%AggregateError%":"undefined"==typeof AggregateError?void 0:AggregateError,"%Array%":Array,"%ArrayBuffer%":"undefined"==typeof ArrayBuffer?void 0:ArrayBuffer,"%ArrayIteratorPrototype%":u?d([][Symbol.iterator]()):void 0,"%AsyncFromSyncIteratorPrototype%":void 0,"%AsyncFunction%":p,"%AsyncGenerator%":p,"%AsyncGeneratorFunction%":p,"%AsyncIteratorPrototype%":p,"%Atomics%":"undefined"==typeof Atomics?void 0:Atomics,"%BigInt%":"undefined"==typeof BigInt?void 0:BigInt,"%Boolean%":Boolean,"%DataView%":"undefined"==typeof DataView?void 0:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":Error,"%eval%":eval,"%EvalError%":EvalError,"%Float32Array%":"undefined"==typeof Float32Array?void 0:Float32Array,"%Float64Array%":"undefined"==typeof Float64Array?void 0:Float64Array,"%FinalizationRegistry%":"undefined"==typeof FinalizationRegistry?void 0:FinalizationRegistry,"%Function%":a,"%GeneratorFunction%":p,"%Int8Array%":"undefined"==typeof Int8Array?void 0:Int8Array,"%Int16Array%":"undefined"==typeof Int16Array?void 0:Int16Array,"%Int32Array%":"undefined"==typeof Int32Array?void 0:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":u?d(d([][Symbol.iterator]())):void 0,"%JSON%":"object"==typeof JSON?JSON:void 0,"%Map%":"undefined"==typeof Map?void 0:Map,"%MapIteratorPrototype%":"undefined"!=typeof Map&&u?d((new Map)[Symbol.iterator]()):void 0,"%Math%":Math,"%Number%":Number,"%Object%":Object,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":"undefined"==typeof Promise?void 0:Promise,"%Proxy%":"undefined"==typeof Proxy?void 0:Proxy,"%RangeError%":RangeError,"%ReferenceError%":ReferenceError,"%Reflect%":"undefined"==typeof Reflect?void 0:Reflect,"%RegExp%":RegExp,"%Set%":"undefined"==typeof Set?void 0:Set,"%SetIteratorPrototype%":"undefined"!=typeof Set&&u?d((new Set)[Symbol.iterator]()):void 0,"%SharedArrayBuffer%":"undefined"==typeof SharedArrayBuffer?void 0:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":u?d(""[Symbol.iterator]()):void 0,"%Symbol%":u?Symbol:void 0,"%SyntaxError%":r,"%ThrowTypeError%":c,"%TypedArray%":h,"%TypeError%":i,"%Uint8Array%":"undefined"==typeof Uint8Array?void 0:Uint8Array,"%Uint8ClampedArray%":"undefined"==typeof Uint8ClampedArray?void 0:Uint8ClampedArray,"%Uint16Array%":"undefined"==typeof Uint16Array?void 0:Uint16Array,"%Uint32Array%":"undefined"==typeof Uint32Array?void 0:Uint32Array,"%URIError%":URIError,"%WeakMap%":"undefined"==typeof WeakMap?void 0:WeakMap,"%WeakRef%":"undefined"==typeof WeakRef?void 0:WeakRef,"%WeakSet%":"undefined"==typeof WeakSet?void 0:WeakSet},v={"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},m=t(164),g=t(454),y=m.call(Function.call,Array.prototype.concat),b=m.call(Function.apply,Array.prototype.splice),w=m.call(Function.call,String.prototype.replace),k=m.call(Function.call,String.prototype.slice),x=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,E=/\\(\\)?/g,A=function(n){var e=k(n,0,1),t=k(n,-1);if("%"===e&&"%"!==t)throw new r("invalid intrinsic syntax, expected closing `%`");if("%"===t&&"%"!==e)throw new r("invalid intrinsic syntax, expected opening `%`");var a=[];return w(n,x,(function(n,e,t,r){a[a.length]=t?w(r,E,"$1"):e||n})),a},_=function(n,e){var t,a=n;if(g(v,a)&&(a="%"+(t=v[a])[0]+"%"),g(f,a)){var s=f[a];if(s===p&&(s=function n(e){var t;if("%AsyncFunction%"===e)t=o("async function () {}");else if("%GeneratorFunction%"===e)t=o("function* () {}");else if("%AsyncGeneratorFunction%"===e)t=o("async function* () {}");else if("%AsyncGenerator%"===e){var r=n("%AsyncGeneratorFunction%");r&&(t=r.prototype)}else if("%AsyncIteratorPrototype%"===e){var a=n("%AsyncGenerator%");a&&(t=d(a.prototype))}return f[e]=t,t}(a)),void 0===s&&!e)throw new i("intrinsic "+n+" exists, but is not available. Please file an issue!");return{alias:t,name:a,value:s}}throw new r("intrinsic "+n+" does not exist!")};n.exports=function(n,e){if("string"!=typeof n||0===n.length)throw new i("intrinsic name must be a non-empty string");if(arguments.length>1&&"boolean"!=typeof e)throw new i('"allowMissing" argument must be a boolean');var t=A(n),a=t.length>0?t[0]:"",o=_("%"+a+"%",e),l=o.name,c=o.value,u=!1,d=o.alias;d&&(a=d[0],b(t,y([0,1],d)));for(var p=1,h=!0;p<t.length;p+=1){var v=t[p],m=k(v,0,1),w=k(v,-1);if(('"'===m||"'"===m||"`"===m||'"'===w||"'"===w||"`"===w)&&m!==w)throw new r("property names with quotes must have matching quotes");if("constructor"!==v&&h||(u=!0),g(f,l="%"+(a+="."+v)+"%"))c=f[l];else if(null!=c){if(!(v in c)){if(!e)throw new i("base intrinsic for "+n+" exists, but the property is not available.");return}if(s&&p+1>=t.length){var x=s(c,v);c=(h=!!x)&&"get"in x&&!("originalValue"in x.get)?x.get:c[v]}else h=g(c,v),c=c[v];h&&!u&&(f[l]=c)}}return c}},function(n,e,t){"use strict";var r=t(453);n.exports=Function.prototype.bind||r},function(n,e,t){"use strict";var r=String.prototype.replace,a=/%20/g,i="RFC1738",o="RFC3986";n.exports={default:o,formatters:{RFC1738:function(n){return r.call(n,a,"+")},RFC3986:function(n){return String(n)}},RFC1738:i,RFC3986:o}},function(n,e,t){var r=t(466);n.exports=function(n){return r(n,{weekStartsOn:1})}},function(n,e,t){var r=t(3),a=t(431);r({global:!0,forced:parseInt!=a},{parseInt:a})},function(n,e,t){var r=t(3),a=t(18),i=t(51),o=t(11),s=t(5),l=t(4),c=t(61),u=t(8),d=t(15),p=t(81),h=t(86),f=t(64),v=a("JSON","stringify"),m=s(/./.exec),g=s("".charAt),y=s("".charCodeAt),b=s("".replace),w=s(1..toString),k=/[\uD800-\uDFFF]/g,x=/^[\uD800-\uDBFF]$/,E=/^[\uDC00-\uDFFF]$/,A=!f||l((function(){var n=a("Symbol")();return"[null]"!=v([n])||"{}"!=v({a:n})||"{}"!=v(Object(n))})),_=l((function(){return'"\\udf06\\ud834"'!==v("\udf06\ud834")||'"\\udead"'!==v("\udead")})),S=function(n,e){var t=h(arguments),r=e;if((d(e)||void 0!==n)&&!p(n))return c(e)||(e=function(n,e){if(u(r)&&(e=o(r,this,n,e)),!p(e))return e}),t[1]=e,i(v,null,t)},C=function(n,e,t){var r=g(t,e-1),a=g(t,e+1);return m(x,n)&&!m(E,a)||m(E,n)&&!m(x,r)?"\\u"+w(y(n,0),16):n};v&&r({target:"JSON",stat:!0,arity:3,forced:A||_},{stringify:function(n,e,t){var r=h(arguments),a=i(A?S:v,null,r);return _&&"string"==typeof a?b(a,k,C):a}})},function(n,e,t){"use strict";var r=t(10),a=t(1),i=t(5),o=t(110),s=t(17),l=t(12),c=t(147),u=t(36),d=t(81),p=t(136),h=t(4),f=t(67).f,v=t(46).f,m=t(16).f,g=t(444),y=t(177).trim,b=a.Number,w=b.prototype,k=a.TypeError,x=i("".slice),E=i("".charCodeAt),A=function(n){var e=p(n,"number");return"bigint"==typeof e?e:_(e)},_=function(n){var e,t,r,a,i,o,s,l,c=p(n,"number");if(d(c))throw k("Cannot convert a Symbol value to a number");if("string"==typeof c&&c.length>2)if(c=y(c),43===(e=E(c,0))||45===e){if(88===(t=E(c,2))||120===t)return NaN}else if(48===e){switch(E(c,1)){case 66:case 98:r=2,a=49;break;case 79:case 111:r=8,a=55;break;default:return+c}for(o=(i=x(c,2)).length,s=0;s<o;s++)if((l=E(i,s))<48||l>a)return NaN;return parseInt(i,r)}return+c};if(o("Number",!b(" 0o1")||!b("0b1")||b("+0x1"))){for(var S,C=function(n){var e=arguments.length<1?0:b(A(n)),t=this;return u(w,t)&&h((function(){g(t)}))?c(Object(e),t,C):e},T=r?f(b):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),O=0;T.length>O;O++)l(b,S=T[O])&&!l(C,S)&&m(C,S,v(b,S));C.prototype=w,w.constructor=C,s(a,"Number",C,{constructor:!0})}},function(n,e,t){var r=t(306);n.exports=function(n,e){return new(r(n))(0===e?0:e)}},function(n,e,t){"use strict";var r=t(51),a=t(11),i=t(5),o=t(129),s=t(151),l=t(14),c=t(23),u=t(142),d=t(153),p=t(66),h=t(13),f=t(58),v=t(145),m=t(130),g=t(116),y=t(117),b=t(4),w=y.UNSUPPORTED_Y,k=Math.min,x=[].push,E=i(/./.exec),A=i(x),_=i("".slice);o("split",(function(n,e,t){var i;return i="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(n,t){var i=h(c(this)),o=void 0===t?4294967295:t>>>0;if(0===o)return[];if(void 0===n)return[i];if(!s(n))return a(e,i,n,o);for(var l,u,d,p=[],f=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),m=0,y=new RegExp(n.source,f+"g");(l=a(g,y,i))&&!((u=y.lastIndex)>m&&(A(p,_(i,m,l.index)),l.length>1&&l.index<i.length&&r(x,p,v(l,1)),d=l[0].length,m=u,p.length>=o));)y.lastIndex===l.index&&y.lastIndex++;return m===i.length?!d&&E(y,"")||A(p,""):A(p,_(i,m)),p.length>o?v(p,0,o):p}:"0".split(void 0,0).length?function(n,t){return void 0===n&&0===t?[]:a(e,this,n,t)}:e,[function(e,t){var r=c(this),o=null==e?void 0:f(e,n);return o?a(o,e,r,t):a(i,h(r),e,t)},function(n,r){var a=l(this),o=h(n),s=t(i,a,o,r,i!==e);if(s.done)return s.value;var c=u(a,RegExp),f=a.unicode,v=(a.ignoreCase?"i":"")+(a.multiline?"m":"")+(a.unicode?"u":"")+(w?"g":"y"),g=new c(w?"^(?:"+a.source+")":a,v),y=void 0===r?4294967295:r>>>0;if(0===y)return[];if(0===o.length)return null===m(g,o)?[o]:[];for(var b=0,x=0,E=[];x<o.length;){g.lastIndex=w?0:x;var S,C=m(g,w?_(o,x):o);if(null===C||(S=k(p(g.lastIndex+(w?x:0)),o.length))===b)x=d(o,x,f);else{if(A(E,_(o,b,x)),E.length===y)return E;for(var T=1;T<=C.length-1;T++)if(A(E,C[T]),E.length===y)return E;x=b=S}}return A(E,_(o,b)),E}]}),!!b((function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2!==t.length||"a"!==t[0]||"b"!==t[1]})),w)},function(n,e,t){"use strict";var r=t(99).PROPER,a=t(17),i=t(14),o=t(13),s=t(4),l=t(241),c=RegExp.prototype.toString,u=s((function(){return"/a/b"!=c.call({source:"a",flags:"b"})})),d=r&&"toString"!=c.name;(u||d)&&a(RegExp.prototype,"toString",(function(){var n=i(this);return"/"+o(n.source)+"/"+o(l(n))}),{unsafe:!0})},function(n,e,t){"use strict";var r=t(27),a=t(126),i=t(84),o=t(35),s=t(16).f,l=t(186),c=t(24),u=t(10),d=o.set,p=o.getterFor("Array Iterator");n.exports=l(Array,"Array",(function(n,e){d(this,{type:"Array Iterator",target:r(n),index:0,kind:e})}),(function(){var n=p(this),e=n.target,t=n.kind,r=n.index++;return!e||r>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:r,done:!1}:"values"==t?{value:e[r],done:!1}:{value:[r,e[r]],done:!1}}),"values");var h=i.Arguments=i.Array;if(a("keys"),a("values"),a("entries"),!c&&u&&"values"!==h.name)try{s(h,"name",{value:"values"})}catch(n){}},function(n,e,t){var r=t(1).TypeError;n.exports=function(n,e){if(n<e)throw r("Not enough arguments");return n}},function(n,e,t){var r=t(1),a=t(11),i=t(29),o=t(14),s=t(82),l=t(128),c=r.TypeError;n.exports=function(n,e){var t=arguments.length<2?l(n):e;if(i(t))return o(a(t,n));throw c(s(n)+" is not iterable")}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){var r=t(5),a=t(23),i=t(13),o=t(178),s=r("".replace),l="["+o+"]",c=RegExp("^"+l+l+"*"),u=RegExp(l+l+"*$"),d=function(n){return function(e){var t=i(a(e));return 1&n&&(t=s(t,c,"")),2&n&&(t=s(t,u,"")),t}};n.exports={start:d(1),end:d(2),trim:d(3)}},function(n,e){n.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(n,e,t){var r=t(10),a=t(1),i=t(5),o=t(110),s=t(147),l=t(30),c=t(67).f,u=t(36),d=t(151),p=t(13),h=t(241),f=t(117),v=t(207),m=t(17),g=t(4),y=t(12),b=t(35).enforce,w=t(191),k=t(9),x=t(152),E=t(216),A=k("match"),_=a.RegExp,S=_.prototype,C=a.SyntaxError,T=i(S.exec),O=i("".charAt),j=i("".replace),B=i("".indexOf),I=i("".slice),L=/^\?<[^\s\d!#%&*+<=>@^][^\s!#%&*+<=>@^]*>/,N=/a/g,P=/a/g,q=new _(N)!==N,R=f.MISSED_STICKY,F=f.UNSUPPORTED_Y,M=r&&(!q||R||x||E||g((function(){return P[A]=!1,_(N)!=N||_(P)==P||"/a/i"!=_(N,"i")})));if(o("RegExp",M)){for(var z=function(n,e){var t,r,a,i,o,c,f=u(S,this),v=d(n),m=void 0===e,g=[],w=n;if(!f&&v&&m&&n.constructor===z)return n;if((v||u(S,n))&&(n=n.source,m&&(e=h(w))),n=void 0===n?"":p(n),e=void 0===e?"":p(e),w=n,x&&"dotAll"in N&&(r=!!e&&B(e,"s")>-1)&&(e=j(e,/s/g,"")),t=e,R&&"sticky"in N&&(a=!!e&&B(e,"y")>-1)&&F&&(e=j(e,/y/g,"")),E&&(n=(i=function(n){for(var e,t=n.length,r=0,a="",i=[],o={},s=!1,l=!1,c=0,u="";r<=t;r++){if("\\"===(e=O(n,r)))e+=O(n,++r);else if("]"===e)s=!1;else if(!s)switch(!0){case"["===e:s=!0;break;case"("===e:T(L,I(n,r+1))&&(r+=2,l=!0),a+=e,c++;continue;case">"===e&&l:if(""===u||y(o,u))throw new C("Invalid capture group name");o[u]=!0,i[i.length]=[u,c],l=!1,u="";continue}l?u+=e:a+=e}return[a,i]}(n))[0],g=i[1]),o=s(_(n,e),f?this:S,z),(r||a||g.length)&&(c=b(o),r&&(c.dotAll=!0,c.raw=z(function(n){for(var e,t=n.length,r=0,a="",i=!1;r<=t;r++)"\\"!==(e=O(n,r))?i||"."!==e?("["===e?i=!0:"]"===e&&(i=!1),a+=e):a+="[\\s\\S]":a+=e+O(n,++r);return a}(n),t)),a&&(c.sticky=!0),g.length&&(c.groups=g)),n!==w)try{l(o,"source",""===w?"(?:)":w)}catch(n){}return o},D=c(_),U=0;D.length>U;)v(z,_,D[U++]);S.constructor=z,z.prototype=S,m(a,"RegExp",z,{constructor:!0})}w("RegExp")},function(n,e,t){var r=t(1),a=t(10),i=t(152),o=t(28),s=t(240),l=t(35).get,c=RegExp.prototype,u=r.TypeError;a&&i&&s(c,"dotAll",{configurable:!0,get:function(){if(this!==c){if("RegExp"===o(this))return!!l(this).dotAll;throw u("Incompatible receiver, RegExp required")}}})},function(n,e,t){var r=t(64);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(10),a=t(4);n.exports=r&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var r=t(10),a=t(4),i=t(104);n.exports=!r&&!a((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(5),a=t(12),i=t(27),o=t(137).indexOf,s=t(83),l=r([].push);n.exports=function(n,e){var t,r=i(n),c=0,u=[];for(t in r)!a(s,t)&&a(r,t)&&l(u,t);for(;e.length>c;)a(r,t=e[c++])&&(~o(u,t)||l(u,t));return u}},function(n,e,t){var r=t(18);n.exports=r("document","documentElement")},function(n,e,t){"use strict";var r=t(3),a=t(11),i=t(24),o=t(99),s=t(8),l=t(274),c=t(141),u=t(85),d=t(43),p=t(30),h=t(17),f=t(9),v=t(84),m=t(189),g=o.PROPER,y=o.CONFIGURABLE,b=m.IteratorPrototype,w=m.BUGGY_SAFARI_ITERATORS,k=f("iterator"),x=function(){return this};n.exports=function(n,e,t,o,f,m,E){l(t,e,o);var A,_,S,C=function(n){if(n===f&&I)return I;if(!w&&n in j)return j[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},T=e+" Iterator",O=!1,j=n.prototype,B=j[k]||j["@@iterator"]||f&&j[f],I=!w&&B||C(f),L="Array"==e&&j.entries||B;if(L&&(A=c(L.call(new n)))!==Object.prototype&&A.next&&(i||c(A)===b||(u?u(A,b):s(A[k])||h(A,k,x)),d(A,T,!0,!0),i&&(v[T]=x)),g&&"values"==f&&B&&"values"!==B.name&&(!i&&y?p(j,"name","values"):(O=!0,I=function(){return a(B,this)})),f)if(_={values:C("values"),keys:m?I:C("keys"),entries:C("entries")},E)for(S in _)(w||O||!(S in j))&&h(j,S,_[S]);else r({target:e,proto:!0,forced:w||O},_);return i&&!E||j[k]===I||h(j,k,I,{name:f}),v[e]=I,_}},function(n,e,t){var r=t(4),a=t(8),i=t(12),o=t(10),s=t(99).CONFIGURABLE,l=t(108),c=t(35),u=c.enforce,d=c.get,p=Object.defineProperty,h=o&&!r((function(){return 8!==p((function(){}),"length",{value:8}).length})),f=String(String).split("String"),v=n.exports=function(n,e,t){if("Symbol("===String(e).slice(0,7)&&(e="["+String(e).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!i(n,"name")||s&&n.name!==e)&&p(n,"name",{value:e,configurable:!0}),h&&t&&i(t,"arity")&&n.length!==t.arity&&p(n,"length",{value:t.arity}),t&&i(t,"constructor")&&t.constructor){if(o)try{p(n,"prototype",{writable:!1})}catch(n){}}else n.prototype=void 0;var r=u(n);return i(r,"source")||(r.source=f.join("string"==typeof e?e:"")),n};Function.prototype.toString=v((function(){return a(this)&&d(this).source||l(this)}),"toString")},function(n,e,t){var r=t(18),a=t(5),i=t(67),o=t(109),s=t(14),l=a([].concat);n.exports=r("Reflect","ownKeys")||function(n){var e=i.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){"use strict";var r,a,i,o=t(4),s=t(8),l=t(42),c=t(141),u=t(17),d=t(9),p=t(24),h=d("iterator"),f=!1;[].keys&&("next"in(i=[].keys())?(a=c(c(i)))!==Object.prototype&&(r=a):f=!0),null==r||o((function(){var n={};return r[h].call(n)!==n}))?r={}:p&&(r=l(r)),s(r[h])||u(r,h,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:f}},function(n,e,t){var r=t(4);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){"use strict";var r=t(18),a=t(16),i=t(9),o=t(10),s=i("species");n.exports=function(n){var e=r(n),t=a.f;o&&e&&!e[s]&&t(e,s,{configurable:!0,get:function(){return this}})}},function(n,e,t){var r=t(1),a=t(112),i=t(82),o=r.TypeError;n.exports=function(n){if(a(n))return n;throw o(i(n)+" is not a constructor")}},function(n,e,t){var r,a,i,o,s=t(1),l=t(51),c=t(76),u=t(8),d=t(12),p=t(4),h=t(185),f=t(86),v=t(104),m=t(174),g=t(194),y=t(111),b=s.setImmediate,w=s.clearImmediate,k=s.process,x=s.Dispatch,E=s.Function,A=s.MessageChannel,_=s.String,S=0,C={};try{r=s.location}catch(n){}var T=function(n){if(d(C,n)){var e=C[n];delete C[n],e()}},O=function(n){return function(){T(n)}},j=function(n){T(n.data)},B=function(n){s.postMessage(_(n),r.protocol+"//"+r.host)};b&&w||(b=function(n){m(arguments.length,1);var e=u(n)?n:E(n),t=f(arguments,1);return C[++S]=function(){l(e,void 0,t)},a(S),S},w=function(n){delete C[n]},y?a=function(n){k.nextTick(O(n))}:x&&x.now?a=function(n){x.now(O(n))}:A&&!g?(o=(i=new A).port2,i.port1.onmessage=j,a=c(o.postMessage,o)):s.addEventListener&&u(s.postMessage)&&!s.importScripts&&r&&"file:"!==r.protocol&&!p(B)?(a=B,s.addEventListener("message",j,!1)):a="onreadystatechange"in v("script")?function(n){h.appendChild(v("script")).onreadystatechange=function(){h.removeChild(this),T(n)}}:function(n){setTimeout(O(n),0)}),n.exports={set:b,clear:w}},function(n,e,t){var r=t(45);n.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(r)},function(n,e,t){var r=t(1),a=t(76),i=t(11),o=t(14),s=t(82),l=t(196),c=t(33),u=t(36),d=t(175),p=t(128),h=t(197),f=r.TypeError,v=function(n,e){this.stopped=n,this.result=e},m=v.prototype;n.exports=function(n,e,t){var r,g,y,b,w,k,x,E=t&&t.that,A=!(!t||!t.AS_ENTRIES),_=!(!t||!t.IS_ITERATOR),S=!(!t||!t.INTERRUPTED),C=a(e,E),T=function(n){return r&&h(r,"normal",n),new v(!0,n)},O=function(n){return A?(o(n),S?C(n[0],n[1],T):C(n[0],n[1])):S?C(n,T):C(n)};if(_)r=n;else{if(!(g=p(n)))throw f(s(n)+" is not iterable");if(l(g)){for(y=0,b=c(n);b>y;y++)if((w=O(n[y]))&&u(m,w))return w;return new v(!1)}r=d(n,g)}for(k=r.next;!(x=i(k,r)).done;){try{w=O(x.value)}catch(n){h(r,"throw",n)}if("object"==typeof w&&w&&u(m,w))return w}return new v(!1)}},function(n,e,t){var r=t(9),a=t(84),i=r("iterator"),o=Array.prototype;n.exports=function(n){return void 0!==n&&(a.Array===n||o[i]===n)}},function(n,e,t){var r=t(11),a=t(14),i=t(58);n.exports=function(n,e,t){var o,s;a(n);try{if(!(o=i(n,"return"))){if("throw"===e)throw t;return t}o=r(o,n)}catch(n){s=!0,o=n}if("throw"===e)throw t;if(s)throw o;return a(o),t}},function(n,e,t){var r=t(68),a=t(199),i=t(87).CONSTRUCTOR;n.exports=i||!a((function(n){r.all(n).then(void 0,(function(){}))}))},function(n,e,t){var r=t(9)("iterator"),a=!1;try{var i=0,o={next:function(){return{done:!!i++}},return:function(){a=!0}};o[r]=function(){return this},Array.from(o,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!a)return!1;var t=!1;try{var i={};i[r]=function(){return{next:function(){return{done:t=!0}}}},n(i)}catch(n){}return t}},function(n,e,t){var r=t(14),a=t(15),i=t(88);n.exports=function(n,e){if(r(n),a(e)&&e.constructor===n)return e;var t=i.f(n);return(0,t.resolve)(e),t.promise}},function(n,e,t){var r=t(28),a=t(27),i=t(67).f,o=t(145),s="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return s&&"Window"==r(n)?function(n){try{return i(n)}catch(n){return o(s)}}(n):i(a(n))}},function(n,e,t){var r=t(9);e.f=r},function(n,e,t){var r=t(64);n.exports=r&&!!Symbol.for&&!!Symbol.keyFor},function(n,e,t){var r=t(5),a=t(56),i=t(13),o=t(23),s=r("".charAt),l=r("".charCodeAt),c=r("".slice),u=function(n){return function(e,t){var r,u,d=i(o(e)),p=a(t),h=d.length;return p<0||p>=h?n?"":void 0:(r=l(d,p))<55296||r>56319||p+1===h||(u=l(d,p+1))<56320||u>57343?n?s(d,p):r:n?c(d,p,p+2):u-56320+(r-55296<<10)+65536}};n.exports={codeAt:u(!1),charAt:u(!0)}},function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,e,t){var r=t(104)("span").classList,a=r&&r.constructor&&r.constructor.prototype;n.exports=a===Object.prototype?void 0:a},function(n,e,t){var r=t(16).f;n.exports=function(n,e,t){t in n||r(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var r=t(13);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:r(n)}},function(n,e,t){"use strict";var r=t(60).forEach,a=t(57)("forEach");n.exports=a?[].forEach:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,e,t){var r=t(3),a=t(10),i=t(188),o=t(27),s=t(46),l=t(78);r({target:"Object",stat:!0,sham:!a},{getOwnPropertyDescriptors:function(n){for(var e,t,r=o(n),a=s.f,c=i(r),u={},d=0;c.length>d;)void 0!==(t=a(r,e=c[d++]))&&l(u,e,t);return u}})},function(n,e,t){var r=t(1),a=t(151),i=r.TypeError;n.exports=function(n){if(a(n))throw i("The method doesn't accept regular expressions");return n}},function(n,e,t){var r=t(9)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[r]=!1,"/./"[n](e)}catch(n){}}return!1}},function(n,e,t){var r=t(4);n.exports=!r((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,e,t){var r=t(3),a=t(327);r({target:"Array",stat:!0,forced:!t(199)((function(n){Array.from(n)}))},{from:a})},function(n,e,t){"use strict";var r=t(14);n.exports=function(){var n=r(this),e="";return n.hasIndices&&(e+="d"),n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){var r=t(4),a=t(1).RegExp;n.exports=r((function(){var n=a("(?<a>b)","g");return"b"!==n.exec("b").groups.a||"bc"!=="b".replace(n,"$<a>c")}))},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,a=n.length;++t<r;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var r=t(118),a=t(343),i=t(344),o=t(345),s=t(346),l=t(347);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=a,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(91),a=t(156);n.exports=function(n){if(!a(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(364),a=t(71);n.exports=function n(e,t,i,o,s){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:r(e,t,i,o,n,s))}},function(n,e,t){var r=t(225),a=t(367),i=t(226);n.exports=function(n,e,t,o,s,l){var c=1&t,u=n.length,d=e.length;if(u!=d&&!(c&&d>u))return!1;var p=l.get(n),h=l.get(e);if(p&&h)return p==e&&h==n;var f=-1,v=!0,m=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++f<u;){var g=n[f],y=e[f];if(o)var b=c?o(y,g,f,e,n,l):o(g,y,f,n,e,l);if(void 0!==b){if(b)continue;v=!1;break}if(m){if(!a(e,(function(n,e){if(!i(m,e)&&(g===n||s(g,n,t,o,l)))return m.push(e)}))){v=!1;break}}else if(g!==y&&!s(g,y,t,o,l)){v=!1;break}}return l.delete(n),l.delete(e),v}},function(n,e,t){var r=t(157),a=t(365),i=t(366);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=a,o.prototype.has=i,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(377),a=t(383),i=t(231);n.exports=function(n){return i(n)?r(n):a(n)}},function(n,e,t){(function(n){var r=t(39),a=t(379),i=e&&!e.nodeType&&e,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===i?r.Buffer:void 0,l=(s?s.isBuffer:void 0)||a;n.exports=l}).call(this,t(176)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var r=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==r||"symbol"!=r&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(380),a=t(381),i=t(382),o=i&&i.isTypedArray,s=o?a(o):r;n.exports=s},function(n,e,t){var r=t(221),a=t(159);n.exports=function(n){return null!=n&&a(n.length)&&!r(n)}},function(n,e,t){var r=t(52)(t(39),"Set");n.exports=r},function(n,e,t){var r=t(156);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(236),a=t(122);n.exports=function(n,e){for(var t=0,i=(e=r(e,n)).length;null!=n&&t<i;)n=n[a(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var r=t(40),a=t(160),i=t(394),o=t(397);n.exports=function(n,e){return r(n)?n:a(n,e)?[n]:i(o(n))}},function(n,e,t){var r=t(1),a=t(51),i=t(8),o=t(45),s=t(86),l=t(174),c=/MSIE .\./.test(o),u=r.Function,d=function(n){return c?function(e,t){var r=l(arguments.length,1)>2,o=i(e)?e:u(e),c=r?s(arguments,2):void 0;return n(r?function(){a(o,this,c)}:o,t)}:n};n.exports={setTimeout:d(r.setTimeout),setInterval:d(r.setInterval)}},function(n,e,t){},function(n,e,t){"use strict";var r=t(3),a=t(5),i=t(29),o=t(20),s=t(33),l=t(13),c=t(4),u=t(281),d=t(57),p=t(437),h=t(438),f=t(65),v=t(439),m=[],g=a(m.sort),y=a(m.push),b=c((function(){m.sort(void 0)})),w=c((function(){m.sort(null)})),k=d("sort"),x=!c((function(){if(f)return f<70;if(!(p&&p>3)){if(h)return!0;if(v)return v<603;var n,e,t,r,a="";for(n=65;n<76;n++){switch(e=String.fromCharCode(n),n){case 66:case 69:case 70:case 72:t=3;break;case 68:case 71:t=4;break;default:t=2}for(r=0;r<47;r++)m.push({k:e+r,v:t})}for(m.sort((function(n,e){return e.v-n.v})),r=0;r<m.length;r++)e=m[r].k.charAt(0),a.charAt(a.length-1)!==e&&(a+=e);return"DGBEFHACIJK"!==a}}));r({target:"Array",proto:!0,forced:b||!w||!k||!x},{sort:function(n){void 0!==n&&i(n);var e=o(this);if(x)return void 0===n?g(e):g(e,n);var t,r,a=[],c=s(e);for(r=0;r<c;r++)r in e&&y(a,e[r]);for(u(a,function(n){return function(e,t){return void 0===t?-1:void 0===e?1:void 0!==n?+n(e,t)||0:l(e)>l(t)?1:-1}}(n)),t=a.length,r=0;r<t;)e[r]=a[r++];for(;r<c;)delete e[r++];return e}})},function(n,e,t){var r=t(187),a=t(16);n.exports=function(n,e,t){return t.get&&r(t.get,e,{getter:!0}),t.set&&r(t.set,e,{setter:!0}),a.f(n,e,t)}},function(n,e,t){var r=t(11),a=t(12),i=t(36),o=t(215),s=RegExp.prototype;n.exports=function(n){var e=n.flags;return void 0!==e||"flags"in s||a(n,"flags")||!i(s,n)?e:r(o,n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";var r=t(165),a=Object.prototype.hasOwnProperty,i=Array.isArray,o=function(){for(var n=[],e=0;e<256;++e)n.push("%"+((e<16?"0":"")+e.toString(16)).toUpperCase());return n}(),s=function(n,e){for(var t=e&&e.plainObjects?Object.create(null):{},r=0;r<n.length;++r)void 0!==n[r]&&(t[r]=n[r]);return t};n.exports={arrayToObject:s,assign:function(n,e){return Object.keys(e).reduce((function(n,t){return n[t]=e[t],n}),n)},combine:function(n,e){return[].concat(n,e)},compact:function(n){for(var e=[{obj:{o:n},prop:"o"}],t=[],r=0;r<e.length;++r)for(var a=e[r],o=a.obj[a.prop],s=Object.keys(o),l=0;l<s.length;++l){var c=s[l],u=o[c];"object"==typeof u&&null!==u&&-1===t.indexOf(u)&&(e.push({obj:o,prop:c}),t.push(u))}return function(n){for(;n.length>1;){var e=n.pop(),t=e.obj[e.prop];if(i(t)){for(var r=[],a=0;a<t.length;++a)void 0!==t[a]&&r.push(t[a]);e.obj[e.prop]=r}}}(e),n},decode:function(n,e,t){var r=n.replace(/\+/g," ");if("iso-8859-1"===t)return r.replace(/%[0-9a-f]{2}/gi,unescape);try{return decodeURIComponent(r)}catch(n){return r}},encode:function(n,e,t,a,i){if(0===n.length)return n;var s=n;if("symbol"==typeof n?s=Symbol.prototype.toString.call(n):"string"!=typeof n&&(s=String(n)),"iso-8859-1"===t)return escape(s).replace(/%u[0-9a-f]{4}/gi,(function(n){return"%26%23"+parseInt(n.slice(2),16)+"%3B"}));for(var l="",c=0;c<s.length;++c){var u=s.charCodeAt(c);45===u||46===u||95===u||126===u||u>=48&&u<=57||u>=65&&u<=90||u>=97&&u<=122||i===r.RFC1738&&(40===u||41===u)?l+=s.charAt(c):u<128?l+=o[u]:u<2048?l+=o[192|u>>6]+o[128|63&u]:u<55296||u>=57344?l+=o[224|u>>12]+o[128|u>>6&63]+o[128|63&u]:(c+=1,u=65536+((1023&u)<<10|1023&s.charCodeAt(c)),l+=o[240|u>>18]+o[128|u>>12&63]+o[128|u>>6&63]+o[128|63&u])}return l},isBuffer:function(n){return!(!n||"object"!=typeof n)&&!!(n.constructor&&n.constructor.isBuffer&&n.constructor.isBuffer(n))},isRegExp:function(n){return"[object RegExp]"===Object.prototype.toString.call(n)},maybeMap:function(n,e){if(i(n)){for(var t=[],r=0;r<n.length;r+=1)t.push(e(n[r]));return t}return e(n)},merge:function n(e,t,r){if(!t)return e;if("object"!=typeof t){if(i(e))e.push(t);else{if(!e||"object"!=typeof e)return[e,t];(r&&(r.plainObjects||r.allowPrototypes)||!a.call(Object.prototype,t))&&(e[t]=!0)}return e}if(!e||"object"!=typeof e)return[e].concat(t);var o=e;return i(e)&&!i(t)&&(o=s(e,r)),i(e)&&i(t)?(t.forEach((function(t,i){if(a.call(e,i)){var o=e[i];o&&"object"==typeof o&&t&&"object"==typeof t?e[i]=n(o,t,r):e.push(t)}else e[i]=t})),e):Object.keys(t).reduce((function(e,i){var o=t[i];return a.call(e,i)?e[i]=n(e[i],o,r):e[i]=o,e}),o)}}},function(n,e){n.exports=function(n){return n instanceof Date}},function(n,e,t){var r=t(53),a=t(166);n.exports=function(n){var e=r(n),t=e.getFullYear(),i=new Date(0);i.setFullYear(t+1,0,4),i.setHours(0,0,0,0);var o=a(i),s=new Date(0);s.setFullYear(t,0,4),s.setHours(0,0,0,0);var l=a(s);return e.getTime()>=o.getTime()?t+1:e.getTime()>=l.getTime()?t:t-1}},function(n,e,t){"use strict";n.exports=function(n,e){return function(){for(var t=new Array(arguments.length),r=0;r<t.length;r++)t[r]=arguments[r];return n.apply(e,t)}}},function(n,e,t){"use strict";var r=t(21);function a(n){return encodeURIComponent(n).replace(/%40/gi,"@").replace(/%3A/gi,":").replace(/%24/g,"$").replace(/%2C/gi,",").replace(/%20/g,"+").replace(/%5B/gi,"[").replace(/%5D/gi,"]")}n.exports=function(n,e,t){if(!e)return n;var i;if(t)i=t(e);else if(r.isURLSearchParams(e))i=e.toString();else{var o=[];r.forEach(e,(function(n,e){null!=n&&(r.isArray(n)?e+="[]":n=[n],r.forEach(n,(function(n){r.isDate(n)?n=n.toISOString():r.isObject(n)&&(n=JSON.stringify(n)),o.push(a(e)+"="+a(n))})))})),i=o.join("&")}if(i){var s=n.indexOf("#");-1!==s&&(n=n.slice(0,s)),n+=(-1===n.indexOf("?")?"?":"&")+i}return n}},function(n,e,t){"use strict";n.exports=function(n){return!(!n||!n.__CANCEL__)}},function(n,e,t){"use strict";var r=t(21),a=t(478),i={"Content-Type":"application/x-www-form-urlencoded"};function o(n,e){!r.isUndefined(n)&&r.isUndefined(n["Content-Type"])&&(n["Content-Type"]=e)}var s,l={adapter:(("undefined"!=typeof XMLHttpRequest||"undefined"!=typeof process&&"[object process]"===Object.prototype.toString.call(process))&&(s=t(254)),s),transformRequest:[function(n,e){return a(e,"Accept"),a(e,"Content-Type"),r.isFormData(n)||r.isArrayBuffer(n)||r.isBuffer(n)||r.isStream(n)||r.isFile(n)||r.isBlob(n)?n:r.isArrayBufferView(n)?n.buffer:r.isURLSearchParams(n)?(o(e,"application/x-www-form-urlencoded;charset=utf-8"),n.toString()):r.isObject(n)?(o(e,"application/json;charset=utf-8"),JSON.stringify(n)):n}],transformResponse:[function(n){if("string"==typeof n)try{n=JSON.parse(n)}catch(n){}return n}],timeout:0,xsrfCookieName:"XSRF-TOKEN",xsrfHeaderName:"X-XSRF-TOKEN",maxContentLength:-1,validateStatus:function(n){return n>=200&&n<300}};l.headers={common:{Accept:"application/json, text/plain, */*"}},r.forEach(["delete","get","head"],(function(n){l.headers[n]={}})),r.forEach(["post","put","patch"],(function(n){l.headers[n]=r.merge(i)})),n.exports=l},function(n,e,t){"use strict";var r=t(21),a=t(479),i=t(251),o=t(481),s=t(484),l=t(485),c=t(255);n.exports=function(n){return new Promise((function(e,u){var d=n.data,p=n.headers;r.isFormData(d)&&delete p["Content-Type"];var h=new XMLHttpRequest;if(n.auth){var f=n.auth.username||"",v=n.auth.password||"";p.Authorization="Basic "+btoa(f+":"+v)}var m=o(n.baseURL,n.url);if(h.open(n.method.toUpperCase(),i(m,n.params,n.paramsSerializer),!0),h.timeout=n.timeout,h.onreadystatechange=function(){if(h&&4===h.readyState&&(0!==h.status||h.responseURL&&0===h.responseURL.indexOf("file:"))){var t="getAllResponseHeaders"in h?s(h.getAllResponseHeaders()):null,r={data:n.responseType&&"text"!==n.responseType?h.response:h.responseText,status:h.status,statusText:h.statusText,headers:t,config:n,request:h};a(e,u,r),h=null}},h.onabort=function(){h&&(u(c("Request aborted",n,"ECONNABORTED",h)),h=null)},h.onerror=function(){u(c("Network Error",n,null,h)),h=null},h.ontimeout=function(){var e="timeout of "+n.timeout+"ms exceeded";n.timeoutErrorMessage&&(e=n.timeoutErrorMessage),u(c(e,n,"ECONNABORTED",h)),h=null},r.isStandardBrowserEnv()){var g=t(486),y=(n.withCredentials||l(m))&&n.xsrfCookieName?g.read(n.xsrfCookieName):void 0;y&&(p[n.xsrfHeaderName]=y)}if("setRequestHeader"in h&&r.forEach(p,(function(n,e){void 0===d&&"content-type"===e.toLowerCase()?delete p[e]:h.setRequestHeader(e,n)})),r.isUndefined(n.withCredentials)||(h.withCredentials=!!n.withCredentials),n.responseType)try{h.responseType=n.responseType}catch(e){if("json"!==n.responseType)throw e}"function"==typeof n.onDownloadProgress&&h.addEventListener("progress",n.onDownloadProgress),"function"==typeof n.onUploadProgress&&h.upload&&h.upload.addEventListener("progress",n.onUploadProgress),n.cancelToken&&n.cancelToken.promise.then((function(n){h&&(h.abort(),u(n),h=null)})),void 0===d&&(d=null),h.send(d)}))}},function(n,e,t){"use strict";var r=t(480);n.exports=function(n,e,t,a,i){var o=new Error(n);return r(o,e,t,a,i)}},function(n,e,t){"use strict";var r=t(21);n.exports=function(n,e){e=e||{};var t={},a=["url","method","params","data"],i=["headers","auth","proxy"],o=["baseURL","url","transformRequest","transformResponse","paramsSerializer","timeout","withCredentials","adapter","responseType","xsrfCookieName","xsrfHeaderName","onUploadProgress","onDownloadProgress","maxContentLength","validateStatus","maxRedirects","httpAgent","httpsAgent","cancelToken","socketPath"];r.forEach(a,(function(n){void 0!==e[n]&&(t[n]=e[n])})),r.forEach(i,(function(a){r.isObject(e[a])?t[a]=r.deepMerge(n[a],e[a]):void 0!==e[a]?t[a]=e[a]:r.isObject(n[a])?t[a]=r.deepMerge(n[a]):void 0!==n[a]&&(t[a]=n[a])})),r.forEach(o,(function(r){void 0!==e[r]?t[r]=e[r]:void 0!==n[r]&&(t[r]=n[r])}));var s=a.concat(i).concat(o),l=Object.keys(e).filter((function(n){return-1===s.indexOf(n)}));return r.forEach(l,(function(r){void 0!==e[r]?t[r]=e[r]:void 0!==n[r]&&(t[r]=n[r])})),t}},function(n,e,t){"use strict";function r(n){this.message=n}r.prototype.toString=function(){return"Cancel"+(this.message?": "+this.message:"")},r.prototype.__CANCEL__=!0,n.exports=r},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(3),a=t(18),i=t(51),o=t(497),s=t(192),l=t(14),c=t(15),u=t(42),d=t(4),p=a("Reflect","construct"),h=Object.prototype,f=[].push,v=d((function(){function n(){}return!(p((function(){}),[],n)instanceof n)})),m=!d((function(){p((function(){}))})),g=v||m;r({target:"Reflect",stat:!0,forced:g,sham:g},{construct:function(n,e){s(n),l(e);var t=arguments.length<3?n:s(arguments[2]);if(m&&!v)return p(n,e,t);if(n==t){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var r=[null];return i(f,r,e),new(i(o,n,r))}var a=t.prototype,d=u(c(a)?a:h),g=i(n,d,e);return c(g)?g:d}})},function(n,e,t){var r=t(3),a=t(1),i=t(43);r({global:!0},{Reflect:{}}),i(a.Reflect,"Reflect",!0)},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(330),a=t(335),i=t(406),o=t(414),s=t(423),l=t(424),c=i((function(n){var e=l(n);return s(e)&&(e=void 0),o(r(n,1,s,!0),a(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;n.exports=function(n){var e,t=""+n,a=r.exec(t);if(!a)return t;var i="",o=0,s=0;for(o=a.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(i+=t.substring(s,o)),s=o+1,i+=e}return s!==o?i+t.substring(s,o):i}},function(n,e){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,i=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),u=Object.prototype.toString,d=Math.max,p=Math.min,h=function(){return c.Date.now()};function f(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function v(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==u.call(n)}(n))return NaN;if(f(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=f(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=a.test(n);return s||i.test(n)?o(n.slice(2),s?2:8):r.test(n)?NaN:+n}n.exports=function(n,e,t){var r,a,i,o,s,l,c=0,u=!1,m=!1,g=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function y(e){var t=r,i=a;return r=a=void 0,c=e,o=n.apply(i,t)}function b(n){return c=n,s=setTimeout(k,e),u?y(n):o}function w(n){var t=n-l;return void 0===l||t>=e||t<0||m&&n-c>=i}function k(){var n=h();if(w(n))return x(n);s=setTimeout(k,function(n){var t=e-(n-l);return m?p(t,i-(n-c)):t}(n))}function x(n){return s=void 0,g&&r?y(n):(r=a=void 0,o)}function E(){var n=h(),t=w(n);if(r=arguments,a=this,l=n,t){if(void 0===s)return b(l);if(m)return s=setTimeout(k,e),y(l)}return void 0===s&&(s=setTimeout(k,e)),o}return e=v(e)||0,f(t)&&(u=!!t.leading,i=(m="maxWait"in t)?d(v(t.maxWait)||0,e):i,g="trailing"in t?!!t.trailing:g),E.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=a=s=void 0},E.flush=function(){return void 0===s?o:x(h())},E}},function(n){n.exports=JSON.parse('{"en-US":{"author":"author","beforeAuthor":"Copyright © ","afterAuthor":"\\nLink: "},"zh-CN":{"author":"作者","beforeAuthor":"著作权归","afterAuthor":"所有。\\n链接："}}')},function(n,e,t){!function(){"use strict";n.exports={polyfill:function(){var n=window,e=document;if(!("scrollBehavior"in e.documentElement.style)||!0===n.__forceSmoothScrollPolyfill__){var t,r=n.HTMLElement||n.Element,a={scroll:n.scroll||n.scrollTo,scrollBy:n.scrollBy,elementScroll:r.prototype.scroll||s,scrollIntoView:r.prototype.scrollIntoView},i=n.performance&&n.performance.now?n.performance.now.bind(n.performance):Date.now,o=(t=n.navigator.userAgent,new RegExp(["MSIE ","Trident/","Edge/"].join("|")).test(t)?1:0);n.scroll=n.scrollTo=function(){void 0!==arguments[0]&&(!0!==l(arguments[0])?f.call(n,e.body,void 0!==arguments[0].left?~~arguments[0].left:n.scrollX||n.pageXOffset,void 0!==arguments[0].top?~~arguments[0].top:n.scrollY||n.pageYOffset):a.scroll.call(n,void 0!==arguments[0].left?arguments[0].left:"object"!=typeof arguments[0]?arguments[0]:n.scrollX||n.pageXOffset,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:n.scrollY||n.pageYOffset))},n.scrollBy=function(){void 0!==arguments[0]&&(l(arguments[0])?a.scrollBy.call(n,void 0!==arguments[0].left?arguments[0].left:"object"!=typeof arguments[0]?arguments[0]:0,void 0!==arguments[0].top?arguments[0].top:void 0!==arguments[1]?arguments[1]:0):f.call(n,e.body,~~arguments[0].left+(n.scrollX||n.pageXOffset),~~arguments[0].top+(n.scrollY||n.pageYOffset)))},r.prototype.scroll=r.prototype.scrollTo=function(){if(void 0!==arguments[0])if(!0!==l(arguments[0])){var n=arguments[0].left,e=arguments[0].top;f.call(this,this,void 0===n?this.scrollLeft:~~n,void 0===e?this.scrollTop:~~e)}else{if("number"==typeof arguments[0]&&void 0===arguments[1])throw new SyntaxError("Value could not be converted");a.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left:"object"!=typeof arguments[0]?~~arguments[0]:this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top:void 0!==arguments[1]?~~arguments[1]:this.scrollTop)}},r.prototype.scrollBy=function(){void 0!==arguments[0]&&(!0!==l(arguments[0])?this.scroll({left:~~arguments[0].left+this.scrollLeft,top:~~arguments[0].top+this.scrollTop,behavior:arguments[0].behavior}):a.elementScroll.call(this,void 0!==arguments[0].left?~~arguments[0].left+this.scrollLeft:~~arguments[0]+this.scrollLeft,void 0!==arguments[0].top?~~arguments[0].top+this.scrollTop:~~arguments[1]+this.scrollTop))},r.prototype.scrollIntoView=function(){if(!0!==l(arguments[0])){var t=p(this),r=t.getBoundingClientRect(),i=this.getBoundingClientRect();t!==e.body?(f.call(this,t,t.scrollLeft+i.left-r.left,t.scrollTop+i.top-r.top),"fixed"!==n.getComputedStyle(t).position&&n.scrollBy({left:r.left,top:r.top,behavior:"smooth"})):n.scrollBy({left:i.left,top:i.top,behavior:"smooth"})}else a.scrollIntoView.call(this,void 0===arguments[0]||arguments[0])}}function s(n,e){this.scrollLeft=n,this.scrollTop=e}function l(n){if(null===n||"object"!=typeof n||void 0===n.behavior||"auto"===n.behavior||"instant"===n.behavior)return!0;if("object"==typeof n&&"smooth"===n.behavior)return!1;throw new TypeError("behavior member of ScrollOptions "+n.behavior+" is not a valid value for enumeration ScrollBehavior.")}function c(n,e){return"Y"===e?n.clientHeight+o<n.scrollHeight:"X"===e?n.clientWidth+o<n.scrollWidth:void 0}function u(e,t){var r=n.getComputedStyle(e,null)["overflow"+t];return"auto"===r||"scroll"===r}function d(n){var e=c(n,"Y")&&u(n,"Y"),t=c(n,"X")&&u(n,"X");return e||t}function p(n){for(;n!==e.body&&!1===d(n);)n=n.parentNode||n.host;return n}function h(e){var t,r,a,o,s=(i()-e.startTime)/468;o=s=s>1?1:s,t=.5*(1-Math.cos(Math.PI*o)),r=e.startX+(e.x-e.startX)*t,a=e.startY+(e.y-e.startY)*t,e.method.call(e.scrollable,r,a),r===e.x&&a===e.y||n.requestAnimationFrame(h.bind(n,e))}function f(t,r,o){var l,c,u,d,p=i();t===e.body?(l=n,c=n.scrollX||n.pageXOffset,u=n.scrollY||n.pageYOffset,d=a.scroll):(l=t,c=t.scrollLeft,u=t.scrollTop,d=s),h({scrollable:l,method:d,startTime:p,startX:c,startY:u,x:r,y:o})}}}}()},function(n,e,t){var r=t(460),a=t(465),i=t(249),o=t(53),s=t(468),l=t(469);var c={M:function(n){return n.getMonth()+1},MM:function(n){return p(n.getMonth()+1,2)},Q:function(n){return Math.ceil((n.getMonth()+1)/3)},D:function(n){return n.getDate()},DD:function(n){return p(n.getDate(),2)},DDD:function(n){return r(n)},DDDD:function(n){return p(r(n),3)},d:function(n){return n.getDay()},E:function(n){return n.getDay()||7},W:function(n){return a(n)},WW:function(n){return p(a(n),2)},YY:function(n){return p(n.getFullYear(),4).substr(2)},YYYY:function(n){return p(n.getFullYear(),4)},GG:function(n){return String(i(n)).substr(2)},GGGG:function(n){return i(n)},H:function(n){return n.getHours()},HH:function(n){return p(n.getHours(),2)},h:function(n){var e=n.getHours();return 0===e?12:e>12?e%12:e},hh:function(n){return p(c.h(n),2)},m:function(n){return n.getMinutes()},mm:function(n){return p(n.getMinutes(),2)},s:function(n){return n.getSeconds()},ss:function(n){return p(n.getSeconds(),2)},S:function(n){return Math.floor(n.getMilliseconds()/100)},SS:function(n){return p(Math.floor(n.getMilliseconds()/10),2)},SSS:function(n){return p(n.getMilliseconds(),3)},Z:function(n){return d(n.getTimezoneOffset(),":")},ZZ:function(n){return d(n.getTimezoneOffset())},X:function(n){return Math.floor(n.getTime()/1e3)},x:function(n){return n.getTime()}};function u(n){return n.match(/\[[\s\S]/)?n.replace(/^\[|]$/g,""):n.replace(/\\/g,"")}function d(n,e){e=e||"";var t=n>0?"-":"+",r=Math.abs(n),a=r%60;return t+p(Math.floor(r/60),2)+e+p(a,2)}function p(n,e){for(var t=Math.abs(n).toString();t.length<e;)t="0"+t;return t}n.exports=function(n,e,t){var r=e?String(e):"YYYY-MM-DDTHH:mm:ss.SSSZ",a=(t||{}).locale,i=l.format.formatters,d=l.format.formattingTokensRegExp;a&&a.format&&a.format.formatters&&(i=a.format.formatters,a.format.formattingTokensRegExp&&(d=a.format.formattingTokensRegExp));var p=o(n);return s(p)?function(n,e,t){var r,a,i=n.match(t),o=i.length;for(r=0;r<o;r++)a=e[i[r]]||c[i[r]],i[r]=a||u(i[r]);return function(n){for(var e="",t=0;t<o;t++)i[t]instanceof Function?e+=i[t](n,c):e+=i[t];return e}}(r,i,d)(p):"Invalid Date"}},function(n,e,t){function r(){var n;try{n=e.storage.debug}catch(n){}return!n&&"undefined"!=typeof process&&"env"in process&&(n=process.env.DEBUG),n}(e=n.exports=t(491)).log=function(){return"object"==typeof console&&console.log&&Function.prototype.apply.call(console.log,console,arguments)},e.formatArgs=function(n){var t=this.useColors;if(n[0]=(t?"%c":"")+this.namespace+(t?" %c":" ")+n[0]+(t?"%c ":" ")+"+"+e.humanize(this.diff),!t)return;var r="color: "+this.color;n.splice(1,0,r,"color: inherit");var a=0,i=0;n[0].replace(/%[a-zA-Z%]/g,(function(n){"%%"!==n&&(a++,"%c"===n&&(i=a))})),n.splice(i,0,r)},e.save=function(n){try{null==n?e.storage.removeItem("debug"):e.storage.debug=n}catch(n){}},e.load=r,e.useColors=function(){if("undefined"!=typeof window&&window.process&&"renderer"===window.process.type)return!0;return"undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},e.storage="undefined"!=typeof chrome&&void 0!==chrome.storage?chrome.storage.local:function(){try{return window.localStorage}catch(n){}}(),e.colors=["lightseagreen","forestgreen","goldenrod","dodgerblue","darkorchid","crimson"],e.formatters.j=function(n){try{return JSON.stringify(n)}catch(n){return"[UnexpectedJSONParseError]: "+n.message}},e.enable(r())},function(n,e,t){"use strict";var r=t(3),a=t(5),i=t(23),o=t(56),s=t(13),l=a("".slice),c=Math.max,u=Math.min;r({target:"String",proto:!0,forced:!"".substr||"b"!=="ab".substr(-1)},{substr:function(n,e){var t,r,a=s(i(this)),d=a.length,p=o(n);return p===1/0&&(p=0),p<0&&(p=c(d+p,0)),(t=void 0===e?d:o(e))<=0||t===1/0||p>=(r=u(p+t,d))?"":l(a,p,r)}})},function(n,e,t){"use strict";var r=t(11),a=t(129),i=t(14),o=t(66),s=t(13),l=t(23),c=t(58),u=t(153),d=t(130);a("match",(function(n,e,t){return[function(e){var t=l(this),a=null==e?void 0:c(e,n);return a?r(a,e,t):new RegExp(e)[n](s(t))},function(n){var r=i(this),a=s(n),l=t(e,r,a);if(l.done)return l.value;if(!r.global)return d(r,a);var c=r.unicode;r.lastIndex=0;for(var p,h=[],f=0;null!==(p=d(r,a));){var v=s(p[0]);h[f]=v,""===v&&(r.lastIndex=u(a,o(r.lastIndex),c)),f++}return 0===f?null:h}]}))},function(n,e,t){"use strict";var r=t(189).IteratorPrototype,a=t(42),i=t(59),o=t(43),s=t(84),l=function(){return this};n.exports=function(n,e,t,c){var u=e+" Iterator";return n.prototype=a(r,{next:i(+!c,t)}),o(n,u,!1,!0),s[u]=l,n}},function(n,e,t){var r=t(1),a=t(36),i=r.TypeError;n.exports=function(n,e){if(a(e,n))return n;throw i("Incorrect invocation")}},function(n,e,t){"use strict";var r=t(3),a=t(137).includes,i=t(4),o=t(126);r({target:"Array",proto:!0,forced:i((function(){return!Array(1).includes()}))},{includes:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}}),o("includes")},function(n,e,t){"use strict";var r=t(3),a=t(5),i=t(211),o=t(23),s=t(13),l=t(212),c=a("".indexOf);r({target:"String",proto:!0,forced:!l("includes")},{includes:function(n){return!!~c(s(o(this)),s(i(n)),arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(3),a=t(4),i=t(20),o=t(136);r({target:"Date",proto:!0,arity:1,forced:a((function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}))},{toJSON:function(n){var e=i(this),t=o(e,"number");return"number"!=typeof t||isFinite(t)?e.toISOString():null}})},function(n,e,t){"use strict";var r=t(3),a=t(11);r({target:"URL",proto:!0,enumerable:!0},{toJSON:function(){return a(URL.prototype.toString,this)}})},function(n,e,t){var r=t(3),a=t(434);r({target:"Date",proto:!0,forced:Date.prototype.toISOString!==a},{toISOString:a})},function(n,e,t){var r=t(145),a=Math.floor,i=function(n,e){var t=n.length,l=a(t/2);return t<8?o(n,e):s(n,i(r(n,0,l),e),i(r(n,l),e),e)},o=function(n,e){for(var t,r,a=n.length,i=1;i<a;){for(r=i,t=n[i];r&&e(n[r-1],t)>0;)n[r]=n[--r];r!==i++&&(n[r]=t)}return n},s=function(n,e,t,r){for(var a=e.length,i=t.length,o=0,s=0;o<a||s<i;)n[o+s]=o<a&&s<i?r(e[o],t[s])<=0?e[o++]:t[s++]:o<a?e[o++]:t[s++];return n};n.exports=i},function(n,e,t){"use strict";var r=t(3),a=t(60).find,i=t(126),o=!0;"find"in[]&&Array(1).find((function(){o=!1})),r({target:"Array",proto:!0,forced:o},{find:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}}),i("find")},function(n,e,t){n.exports=t(500)},function(n,e,t){var r=t(1),a=t(11),i=t(8),o=t(15),s=r.TypeError;n.exports=function(n,e){var t,r;if("string"===e&&i(t=n.toString)&&!o(r=a(t,n)))return r;if(i(t=n.valueOf)&&!o(r=a(t,n)))return r;if("string"!==e&&i(t=n.toString)&&!o(r=a(t,n)))return r;throw s("Can't convert object to primitive value")}},function(n,e,t){var r=t(1),a=t(8),i=t(108),o=r.WeakMap;n.exports=a(o)&&/native code/.test(i(o))},function(n,e,t){var r=t(1),a=t(8),i=r.String,o=r.TypeError;n.exports=function(n){if("object"==typeof n||a(n))return n;throw o("Can't set "+i(n)+" as a prototype")}},function(n,e,t){t(288),t(295),t(296),t(297),t(298),t(299)},function(n,e,t){"use strict";var r,a,i,o=t(3),s=t(24),l=t(111),c=t(1),u=t(11),d=t(17),p=t(85),h=t(43),f=t(191),v=t(29),m=t(8),g=t(15),y=t(275),b=t(142),w=t(193).set,k=t(289),x=t(292),E=t(144),A=t(293),_=t(35),S=t(68),C=t(87),T=t(88),O=C.CONSTRUCTOR,j=C.REJECTION_EVENT,B=C.SUBCLASSING,I=_.getterFor("Promise"),L=_.set,N=S&&S.prototype,P=S,q=N,R=c.TypeError,F=c.document,M=c.process,z=T.f,D=z,U=!!(F&&F.createEvent&&c.dispatchEvent),$=function(n){var e;return!(!g(n)||!m(e=n.then))&&e},J=function(n,e){var t,r,a,i=e.value,o=1==e.state,s=o?n.ok:n.fail,l=n.resolve,c=n.reject,d=n.domain;try{s?(o||(2===e.rejection&&G(e),e.rejection=1),!0===s?t=i:(d&&d.enter(),t=s(i),d&&(d.exit(),a=!0)),t===n.promise?c(R("Promise-chain cycle")):(r=$(t))?u(r,t,l,c):l(t)):c(i)}catch(n){d&&!a&&d.exit(),c(n)}},W=function(n,e){n.notified||(n.notified=!0,k((function(){for(var t,r=n.reactions;t=r.get();)J(t,n);n.notified=!1,e&&!n.rejection&&V(n)})))},Q=function(n,e,t){var r,a;U?((r=F.createEvent("Event")).promise=e,r.reason=t,r.initEvent(n,!1,!0),c.dispatchEvent(r)):r={promise:e,reason:t},!j&&(a=c["on"+n])?a(r):"unhandledrejection"===n&&x("Unhandled promise rejection",t)},V=function(n){u(w,c,(function(){var e,t=n.facade,r=n.value;if(H(n)&&(e=E((function(){l?M.emit("unhandledRejection",r,t):Q("unhandledrejection",t,r)})),n.rejection=l||H(n)?2:1,e.error))throw e.value}))},H=function(n){return 1!==n.rejection&&!n.parent},G=function(n){u(w,c,(function(){var e=n.facade;l?M.emit("rejectionHandled",e):Q("rejectionhandled",e,n.value)}))},K=function(n,e,t){return function(r){n(e,r,t)}},Y=function(n,e,t){n.done||(n.done=!0,t&&(n=t),n.value=e,n.state=2,W(n,!0))},X=function(n,e,t){if(!n.done){n.done=!0,t&&(n=t);try{if(n.facade===e)throw R("Promise can't be resolved itself");var r=$(e);r?k((function(){var t={done:!1};try{u(r,e,K(X,t,n),K(Y,t,n))}catch(e){Y(t,e,n)}})):(n.value=e,n.state=1,W(n,!1))}catch(e){Y({done:!1},e,n)}}};if(O&&(q=(P=function(n){y(this,q),v(n),u(r,this);var e=I(this);try{n(K(X,e),K(Y,e))}catch(n){Y(e,n)}}).prototype,(r=function(n){L(this,{type:"Promise",done:!1,notified:!1,parent:!1,reactions:new A,rejection:!1,state:0,value:void 0})}).prototype=d(q,"then",(function(n,e){var t=I(this),r=z(b(this,P));return t.parent=!0,r.ok=!m(n)||n,r.fail=m(e)&&e,r.domain=l?M.domain:void 0,0==t.state?t.reactions.add(r):k((function(){J(r,t)})),r.promise})),a=function(){var n=new r,e=I(n);this.promise=n,this.resolve=K(X,e),this.reject=K(Y,e)},T.f=z=function(n){return n===P||void 0===n?new a(n):D(n)},!s&&m(S)&&N!==Object.prototype)){i=N.then,B||d(N,"then",(function(n,e){var t=this;return new P((function(n,e){u(i,t,n,e)})).then(n,e)}),{unsafe:!0});try{delete N.constructor}catch(n){}p&&p(N,q)}o({global:!0,constructor:!0,wrap:!0,forced:O},{Promise:P}),h(P,"Promise",!1,!0),f("Promise")},function(n,e,t){var r,a,i,o,s,l,c,u,d=t(1),p=t(76),h=t(46).f,f=t(193).set,v=t(194),m=t(290),g=t(291),y=t(111),b=d.MutationObserver||d.WebKitMutationObserver,w=d.document,k=d.process,x=d.Promise,E=h(d,"queueMicrotask"),A=E&&E.value;A||(r=function(){var n,e;for(y&&(n=k.domain)&&n.exit();a;){e=a.fn,a=a.next;try{e()}catch(n){throw a?o():i=void 0,n}}i=void 0,n&&n.enter()},v||y||g||!b||!w?!m&&x&&x.resolve?((c=x.resolve(void 0)).constructor=x,u=p(c.then,c),o=function(){u(r)}):y?o=function(){k.nextTick(r)}:(f=p(f,d),o=function(){f(r)}):(s=!0,l=w.createTextNode(""),new b(r).observe(l,{characterData:!0}),o=function(){l.data=s=!s})),n.exports=A||function(n){var e={fn:n,next:void 0};i&&(i.next=e),a||(a=e,o()),i=e}},function(n,e,t){var r=t(45),a=t(1);n.exports=/ipad|iphone|ipod/i.test(r)&&void 0!==a.Pebble},function(n,e,t){var r=t(45);n.exports=/web0s(?!.*chrome)/i.test(r)},function(n,e,t){var r=t(1);n.exports=function(n,e){var t=r.console;t&&t.error&&(1==arguments.length?t.error(n):t.error(n,e))}},function(n,e){var t=function(){this.head=null,this.tail=null};t.prototype={add:function(n){var e={item:n,next:null};this.head?this.tail.next=e:this.head=e,this.tail=e},get:function(){var n=this.head;if(n)return this.head=n.next,this.tail===n&&(this.tail=null),n.item}},n.exports=t},function(n,e){n.exports="object"==typeof window&&"object"!=typeof Deno},function(n,e,t){"use strict";var r=t(3),a=t(11),i=t(29),o=t(88),s=t(144),l=t(195);r({target:"Promise",stat:!0,forced:t(198)},{all:function(n){var e=this,t=o.f(e),r=t.resolve,c=t.reject,u=s((function(){var t=i(e.resolve),o=[],s=0,u=1;l(n,(function(n){var i=s++,l=!1;u++,a(t,e,n).then((function(n){l||(l=!0,o[i]=n,--u||r(o))}),c)})),--u||r(o)}));return u.error&&c(u.value),t.promise}})},function(n,e,t){"use strict";var r=t(3),a=t(24),i=t(87).CONSTRUCTOR,o=t(68),s=t(18),l=t(8),c=t(17),u=o&&o.prototype;if(r({target:"Promise",proto:!0,forced:i,real:!0},{catch:function(n){return this.then(void 0,n)}}),!a&&l(o)){var d=s("Promise").prototype.catch;u.catch!==d&&c(u,"catch",d,{unsafe:!0})}},function(n,e,t){"use strict";var r=t(3),a=t(11),i=t(29),o=t(88),s=t(144),l=t(195);r({target:"Promise",stat:!0,forced:t(198)},{race:function(n){var e=this,t=o.f(e),r=t.reject,c=s((function(){var o=i(e.resolve);l(n,(function(n){a(o,e,n).then(t.resolve,r)}))}));return c.error&&r(c.value),t.promise}})},function(n,e,t){"use strict";var r=t(3),a=t(11),i=t(88);r({target:"Promise",stat:!0,forced:t(87).CONSTRUCTOR},{reject:function(n){var e=i.f(this);return a(e.reject,void 0,n),e.promise}})},function(n,e,t){"use strict";var r=t(3),a=t(18),i=t(24),o=t(68),s=t(87).CONSTRUCTOR,l=t(200),c=a("Promise"),u=i&&!s;r({target:"Promise",stat:!0,forced:i||s},{resolve:function(n){return l(u&&this===c?o:this,n)}})},function(n,e,t){var r=t(3),a=t(301);r({target:"Object",stat:!0,arity:2,forced:Object.assign!==a},{assign:a})},function(n,e,t){"use strict";var r=t(10),a=t(5),i=t(11),o=t(4),s=t(106),l=t(109),c=t(139),u=t(20),d=t(79),p=Object.assign,h=Object.defineProperty,f=a([].concat);n.exports=!p||o((function(){if(r&&1!==p({b:1},p(h({},"a",{enumerable:!0,get:function(){h(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},e={},t=Symbol();return n[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){e[n]=n})),7!=p({},n)[t]||"abcdefghijklmnopqrst"!=s(p({},e)).join("")}))?function(n,e){for(var t=u(n),a=arguments.length,o=1,p=l.f,h=c.f;a>o;)for(var v,m=d(arguments[o++]),g=p?f(s(m),p(m)):s(m),y=g.length,b=0;y>b;)v=g[b++],r&&!i(h,m,v)||(t[v]=m[v]);return t}:p},function(n,e,t){"use strict";var r=t(3),a=t(24),i=t(68),o=t(4),s=t(18),l=t(8),c=t(142),u=t(200),d=t(17),p=i&&i.prototype;if(r({target:"Promise",proto:!0,real:!0,forced:!!i&&o((function(){p.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var e=c(this,s("Promise")),t=l(n);return this.then(t?function(t){return u(e,n()).then((function(){return t}))}:n,t?function(t){return u(e,n()).then((function(){throw t}))}:n)}}),!a&&l(i)){var h=s("Promise").prototype.finally;p.finally!==h&&d(p,"finally",h,{unsafe:!0})}},function(n,e,t){"use strict";var r=t(3),a=t(1),i=t(11),o=t(5),s=t(24),l=t(10),c=t(64),u=t(4),d=t(12),p=t(36),h=t(14),f=t(27),v=t(105),m=t(13),g=t(59),y=t(42),b=t(106),w=t(67),k=t(201),x=t(109),E=t(46),A=t(16),_=t(135),S=t(139),C=t(17),T=t(63),O=t(107),j=t(83),B=t(103),I=t(9),L=t(202),N=t(113),P=t(305),q=t(43),R=t(35),F=t(60).forEach,M=O("hidden"),z=R.set,D=R.getterFor("Symbol"),U=Object.prototype,$=a.Symbol,J=$&&$.prototype,W=a.TypeError,Q=a.QObject,V=E.f,H=A.f,G=k.f,K=S.f,Y=o([].push),X=T("symbols"),Z=T("op-symbols"),nn=T("wks"),en=!Q||!Q.prototype||!Q.prototype.findChild,tn=l&&u((function(){return 7!=y(H({},"a",{get:function(){return H(this,"a",{value:7}).a}})).a}))?function(n,e,t){var r=V(U,e);r&&delete U[e],H(n,e,t),r&&n!==U&&H(U,e,r)}:H,rn=function(n,e){var t=X[n]=y(J);return z(t,{type:"Symbol",tag:n,description:e}),l||(t.description=e),t},an=function(n,e,t){n===U&&an(Z,e,t),h(n);var r=v(e);return h(t),d(X,r)?(t.enumerable?(d(n,M)&&n[M][r]&&(n[M][r]=!1),t=y(t,{enumerable:g(0,!1)})):(d(n,M)||H(n,M,g(1,{})),n[M][r]=!0),tn(n,r,t)):H(n,r,t)},on=function(n,e){h(n);var t=f(e),r=b(t).concat(un(t));return F(r,(function(e){l&&!i(sn,t,e)||an(n,e,t[e])})),n},sn=function(n){var e=v(n),t=i(K,this,e);return!(this===U&&d(X,e)&&!d(Z,e))&&(!(t||!d(this,e)||!d(X,e)||d(this,M)&&this[M][e])||t)},ln=function(n,e){var t=f(n),r=v(e);if(t!==U||!d(X,r)||d(Z,r)){var a=V(t,r);return!a||!d(X,r)||d(t,M)&&t[M][r]||(a.enumerable=!0),a}},cn=function(n){var e=G(f(n)),t=[];return F(e,(function(n){d(X,n)||d(j,n)||Y(t,n)})),t},un=function(n){var e=n===U,t=G(e?Z:f(n)),r=[];return F(t,(function(n){!d(X,n)||e&&!d(U,n)||Y(r,X[n])})),r};c||(C(J=($=function(){if(p(J,this))throw W("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?m(arguments[0]):void 0,e=B(n),t=function(n){this===U&&i(t,Z,n),d(this,M)&&d(this[M],e)&&(this[M][e]=!1),tn(this,e,g(1,n))};return l&&en&&tn(U,e,{configurable:!0,set:t}),rn(e,n)}).prototype,"toString",(function(){return D(this).tag})),C($,"withoutSetter",(function(n){return rn(B(n),n)})),S.f=sn,A.f=an,_.f=on,E.f=ln,w.f=k.f=cn,x.f=un,L.f=function(n){return rn(I(n),n)},l&&(H(J,"description",{configurable:!0,get:function(){return D(this).description}}),s||C(U,"propertyIsEnumerable",sn,{unsafe:!0}))),r({global:!0,constructor:!0,wrap:!0,forced:!c,sham:!c},{Symbol:$}),F(b(nn),(function(n){N(n)})),r({target:"Symbol",stat:!0,forced:!c},{useSetter:function(){en=!0},useSimple:function(){en=!1}}),r({target:"Object",stat:!0,forced:!c,sham:!l},{create:function(n,e){return void 0===e?y(n):on(y(n),e)},defineProperty:an,defineProperties:on,getOwnPropertyDescriptor:ln}),r({target:"Object",stat:!0,forced:!c},{getOwnPropertyNames:cn}),P(),q($,"Symbol"),j[M]=!0},function(n,e,t){var r=t(1);n.exports=r},function(n,e,t){var r=t(11),a=t(18),i=t(9),o=t(17);n.exports=function(){var n=a("Symbol"),e=n&&n.prototype,t=e&&e.valueOf,s=i("toPrimitive");e&&!e[s]&&o(e,s,(function(n){return r(t,this)}),{arity:1})}},function(n,e,t){var r=t(1),a=t(61),i=t(112),o=t(15),s=t(9)("species"),l=r.Array;n.exports=function(n){var e;return a(n)&&(e=n.constructor,(i(e)&&(e===l||a(e.prototype))||o(e)&&null===(e=e[s]))&&(e=void 0)),void 0===e?l:e}},function(n,e,t){var r=t(3),a=t(18),i=t(12),o=t(13),s=t(63),l=t(203),c=s("string-to-symbol-registry"),u=s("symbol-to-string-registry");r({target:"Symbol",stat:!0,forced:!l},{for:function(n){var e=o(n);if(i(c,e))return c[e];var t=a("Symbol")(e);return c[e]=t,u[t]=e,t}})},function(n,e,t){var r=t(3),a=t(12),i=t(81),o=t(82),s=t(63),l=t(203),c=s("symbol-to-string-registry");r({target:"Symbol",stat:!0,forced:!l},{keyFor:function(n){if(!i(n))throw TypeError(o(n)+" is not a symbol");if(a(c,n))return c[n]}})},function(n,e,t){var r=t(3),a=t(64),i=t(4),o=t(109),s=t(20);r({target:"Object",stat:!0,forced:!a||i((function(){o.f(1)}))},{getOwnPropertySymbols:function(n){var e=o.f;return e?e(s(n)):[]}})},function(n,e,t){"use strict";var r=t(143),a=t(100);n.exports=r?{}.toString:function(){return"[object "+a(this)+"]"}},function(n,e,t){t(113)("asyncIterator")},function(n,e,t){var r=t(18),a=t(113),i=t(43);a("toStringTag"),i(r("Symbol"),"Symbol")},function(n,e,t){var r=t(1);t(43)(r.JSON,"JSON",!0)},function(n,e,t){t(43)(Math,"Math",!0)},function(n,e,t){"use strict";var r=t(18),a=t(12),i=t(30),o=t(36),s=t(85),l=t(140),c=t(207),u=t(147),d=t(208),p=t(316),h=t(317),f=t(318),v=t(10),m=t(24);n.exports=function(n,e,t,g){var y=g?2:1,b=n.split("."),w=b[b.length-1],k=r.apply(null,b);if(k){var x=k.prototype;if(!m&&a(x,"cause")&&delete x.cause,!t)return k;var E=r("Error"),A=e((function(n,e){var t=d(g?e:n,void 0),r=g?new k(n):new k;return void 0!==t&&i(r,"message",t),f&&i(r,"stack",h(r.stack,2)),this&&o(x,this)&&u(r,this,A),arguments.length>y&&p(r,arguments[y]),r}));if(A.prototype=x,"Error"!==w?s?s(A,E):l(A,E,{name:!0}):v&&"stackTraceLimit"in k&&(c(A,k,"stackTraceLimit"),c(A,k,"prepareStackTrace")),l(A,k),!m)try{x.name!==w&&i(x,"name",w),x.constructor=A}catch(n){}return A}}},function(n,e,t){var r=t(15),a=t(30);n.exports=function(n,e){r(e)&&"cause"in e&&a(n,"cause",e.cause)}},function(n,e,t){var r=t(5),a=Error,i=r("".replace),o=String(a("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!a.prepareStackTrace)for(;e--;)n=i(n,s,"");return n}},function(n,e,t){var r=t(4),a=t(59);n.exports=!r((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",a(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var r=t(10),a=t(4),i=t(14),o=t(42),s=t(208),l=Error.prototype.toString,c=a((function(){if(r){var n=o(Object.defineProperty({},"name",{get:function(){return this===n}}));if("true"!==l.call(n))return!0}return"2: 1"!==l.call({message:1,name:2})||"Error"!==l.call({})}));n.exports=c?function(){var n=i(this),e=s(n.name,"Error"),t=s(n.message);return e?t?e+": "+t:e:t}:l},function(n,e,t){"use strict";var r=t(3),a=t(5),i=t(61),o=a([].reverse),s=[1,2];r({target:"Array",proto:!0,forced:String(s)===String(s.reverse())},{reverse:function(){return i(this)&&(this.length=this.length),o(this)}})},function(n,e,t){var r=t(1),a=t(29),i=t(20),o=t(79),s=t(33),l=r.TypeError,c=function(n){return function(e,t,r,c){a(t);var u=i(e),d=o(u),p=s(u),h=n?p-1:0,f=n?-1:1;if(r<2)for(;;){if(h in d){c=d[h],h+=f;break}if(h+=f,n?h<0:p<=h)throw l("Reduce of empty array with no initial value")}for(;n?h>=0:p>h;h+=f)h in d&&(c=t(c,d[h],h,u));return c}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){"use strict";var r,a=t(3),i=t(5),o=t(46).f,s=t(66),l=t(13),c=t(211),u=t(23),d=t(212),p=t(24),h=i("".startsWith),f=i("".slice),v=Math.min,m=d("startsWith");a({target:"String",proto:!0,forced:!!(p||m||(r=o(String.prototype,"startsWith"),!r||r.writable))&&!m},{startsWith:function(n){var e=l(u(this));c(n);var t=s(v(arguments.length>1?arguments[1]:void 0,e.length)),r=l(n);return h?h(e,r,t):f(e,t,t+r.length)===r}})},function(n,e,t){var r=t(3),a=t(213),i=t(4),o=t(15),s=t(324).onFreeze,l=Object.freeze;r({target:"Object",stat:!0,forced:i((function(){l(1)})),sham:!a},{freeze:function(n){return l&&o(n)?l(s(n)):n}})},function(n,e,t){var r=t(3),a=t(5),i=t(83),o=t(15),s=t(12),l=t(16).f,c=t(67),u=t(201),d=t(325),p=t(103),h=t(213),f=!1,v=p("meta"),m=0,g=function(n){l(n,v,{value:{objectID:"O"+m++,weakData:{}}})},y=n.exports={enable:function(){y.enable=function(){},f=!0;var n=c.f,e=a([].splice),t={};t[v]=1,n(t).length&&(c.f=function(t){for(var r=n(t),a=0,i=r.length;a<i;a++)if(r[a]===v){e(r,a,1);break}return r},r({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:u.f}))},fastKey:function(n,e){if(!o(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!s(n,v)){if(!d(n))return"F";if(!e)return"E";g(n)}return n[v].objectID},getWeakData:function(n,e){if(!s(n,v)){if(!d(n))return!0;if(!e)return!1;g(n)}return n[v].weakData},onFreeze:function(n){return h&&f&&d(n)&&!s(n,v)&&g(n),n}};i[v]=!0},function(n,e,t){var r=t(4),a=t(15),i=t(28),o=t(326),s=Object.isExtensible,l=r((function(){s(1)}));n.exports=l||o?function(n){return!!a(n)&&((!o||"ArrayBuffer"!=i(n))&&(!s||s(n)))}:s},function(n,e,t){var r=t(4);n.exports=r((function(){if("function"==typeof ArrayBuffer){var n=new ArrayBuffer(8);Object.isExtensible(n)&&Object.defineProperty(n,"a",{value:8})}}))},function(n,e,t){"use strict";var r=t(1),a=t(76),i=t(11),o=t(20),s=t(328),l=t(196),c=t(112),u=t(33),d=t(78),p=t(175),h=t(128),f=r.Array;n.exports=function(n){var e=o(n),t=c(this),r=arguments.length,v=r>1?arguments[1]:void 0,m=void 0!==v;m&&(v=a(v,r>2?arguments[2]:void 0));var g,y,b,w,k,x,E=h(e),A=0;if(!E||this==f&&l(E))for(g=u(e),y=t?new this(g):f(g);g>A;A++)x=m?v(e[A],A):e[A],d(y,A,x);else for(k=(w=p(e,E)).next,y=t?new this:[];!(b=i(k,w)).done;A++)x=m?s(w,v,[b.value,A],!0):b.value,d(y,A,x);return y.length=A,y}},function(n,e,t){var r=t(14),a=t(197);n.exports=function(n,e,t,i){try{return i?e(r(t)[0],t[1]):e(t)}catch(e){a(n,"throw",e)}}},function(n,e,t){var r=t(5),a=t(20),i=Math.floor,o=r("".charAt),s=r("".replace),l=r("".slice),c=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,u=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,e,t,r,d,p){var h=t+n.length,f=r.length,v=u;return void 0!==d&&(d=a(d),v=c),s(p,v,(function(a,s){var c;switch(o(s,0)){case"$":return"$";case"&":return n;case"`":return l(e,0,t);case"'":return l(e,h);case"<":c=d[l(s,1,-1)];break;default:var u=+s;if(0===u)return a;if(u>f){var p=i(u/10);return 0===p?a:p<=f?void 0===r[p-1]?o(s,1):r[p-1]+o(s,1):a}c=r[u-1]}return void 0===c?"":c}))}},function(n,e,t){var r=t(217),a=t(331);n.exports=function n(e,t,i,o,s){var l=-1,c=e.length;for(i||(i=a),s||(s=[]);++l<c;){var u=e[l];t>0&&i(u)?t>1?n(u,t-1,i,o,s):r(s,u):o||(s[s.length]=u)}return s}},function(n,e,t){var r=t(90),a=t(154),i=t(40),o=r?r.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||a(n)||!!(o&&n&&n[o])}},function(n,e,t){var r=t(91),a=t(71);n.exports=function(n){return a(n)&&"[object Arguments]"==r(n)}},function(n,e,t){var r=t(90),a=Object.prototype,i=a.hasOwnProperty,o=a.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=i.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var a=o.call(n);return r&&(e?n[s]=t:delete n[s]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var r=t(336),a=t(392),i=t(162),o=t(40),s=t(403);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?o(n)?a(n[0],n[1]):r(n):s(n)}},function(n,e,t){var r=t(337),a=t(391),i=t(234);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(219),a=t(223);n.exports=function(n,e,t,i){var o=t.length,s=o,l=!i;if(null==n)return!s;for(n=Object(n);o--;){var c=t[o];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<s;){var u=(c=t[o])[0],d=n[u],p=c[1];if(l&&c[2]){if(void 0===d&&!(u in n))return!1}else{var h=new r;if(i)var f=i(d,p,u,n,e,h);if(!(void 0===f?a(p,d,3,i,h):f))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var r=t(119),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(119);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(119);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(119);n.exports=function(n,e){var t=this.__data__,a=r(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var r=t(118);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(118),a=t(155),i=t(157);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var o=t.__data__;if(!a||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var r=t(221),a=t(349),i=t(156),o=t(222),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,u=l.toString,d=c.hasOwnProperty,p=RegExp("^"+u.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||a(n))&&(r(n)?p:s).test(o(n))}},function(n,e,t){var r,a=t(350),i=(r=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var r=t(39)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(353),a=t(118),i=t(155);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(i||a),string:new r}}},function(n,e,t){var r=t(354),a=t(355),i=t(356),o=t(357),s=t(358);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(120);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(120),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(120),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var r=t(120);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(121);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(121);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(121);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(121);n.exports=function(n,e){var t=r(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var r=t(219),a=t(224),i=t(368),o=t(371),s=t(387),l=t(40),c=t(228),u=t(230),d="[object Object]",p=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,h,f,v){var m=l(n),g=l(e),y=m?"[object Array]":s(n),b=g?"[object Array]":s(e),w=(y="[object Arguments]"==y?d:y)==d,k=(b="[object Arguments]"==b?d:b)==d,x=y==b;if(x&&c(n)){if(!c(e))return!1;m=!0,w=!1}if(x&&!w)return v||(v=new r),m||u(n)?a(n,e,t,h,f,v):i(n,e,y,t,h,f,v);if(!(1&t)){var E=w&&p.call(n,"__wrapped__"),A=k&&p.call(e,"__wrapped__");if(E||A){var _=E?n.value():n,S=A?e.value():e;return v||(v=new r),f(_,S,t,h,v)}}return!!x&&(v||(v=new r),o(n,e,t,h,f,v))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var r=t(90),a=t(369),i=t(220),o=t(224),s=t(370),l=t(158),c=r?r.prototype:void 0,u=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,d,p){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var h=s;case"[object Set]":var f=1&r;if(h||(h=l),n.size!=e.size&&!f)return!1;var v=p.get(n);if(v)return v==e;r|=2,p.set(n,e);var m=o(h(n),h(e),r,c,d,p);return p.delete(n),m;case"[object Symbol]":if(u)return u.call(n)==u.call(e)}return!1}},function(n,e,t){var r=t(39).Uint8Array;n.exports=r},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(372),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,o,s){var l=1&t,c=r(n),u=c.length;if(u!=r(e).length&&!l)return!1;for(var d=u;d--;){var p=c[d];if(!(l?p in e:a.call(e,p)))return!1}var h=s.get(n),f=s.get(e);if(h&&f)return h==e&&f==n;var v=!0;s.set(n,e),s.set(e,n);for(var m=l;++d<u;){var g=n[p=c[d]],y=e[p];if(i)var b=l?i(y,g,p,e,n,s):i(g,y,p,n,e,s);if(!(void 0===b?g===y||o(g,y,t,i,s):b)){v=!1;break}m||(m="constructor"==p)}if(v&&!m){var w=n.constructor,k=e.constructor;w==k||!("constructor"in n)||!("constructor"in e)||"function"==typeof w&&w instanceof w&&"function"==typeof k&&k instanceof k||(v=!1)}return s.delete(n),s.delete(e),v}},function(n,e,t){var r=t(373),a=t(374),i=t(227);n.exports=function(n){return r(n,i,a)}},function(n,e,t){var r=t(217),a=t(40);n.exports=function(n,e,t){var i=e(n);return a(n)?i:r(i,t(n))}},function(n,e,t){var r=t(375),a=t(376),i=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),r(o(n),(function(e){return i.call(n,e)})))}:a;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=0,i=[];++t<r;){var o=n[t];e(o,t,n)&&(i[a++]=o)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(378),a=t(154),i=t(40),o=t(228),s=t(229),l=t(230),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),u=!t&&a(n),d=!t&&!u&&o(n),p=!t&&!u&&!d&&l(n),h=t||u||d||p,f=h?r(n.length,String):[],v=f.length;for(var m in n)!e&&!c.call(n,m)||h&&("length"==m||d&&("offset"==m||"parent"==m)||p&&("buffer"==m||"byteLength"==m||"byteOffset"==m)||s(m,v))||f.push(m);return f}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(91),a=t(159),i=t(71),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&a(n.length)&&!!o[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(218),a=e&&!e.nodeType&&e,i=a&&"object"==typeof n&&n&&!n.nodeType&&n,o=i&&i.exports===a&&r.process,s=function(){try{var n=i&&i.require&&i.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(176)(n))},function(n,e,t){var r=t(384),a=t(385),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return a(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var r=t(386)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var r=t(388),a=t(155),i=t(389),o=t(232),s=t(390),l=t(91),c=t(222),u=c(r),d=c(a),p=c(i),h=c(o),f=c(s),v=l;(r&&"[object DataView]"!=v(new r(new ArrayBuffer(1)))||a&&"[object Map]"!=v(new a)||i&&"[object Promise]"!=v(i.resolve())||o&&"[object Set]"!=v(new o)||s&&"[object WeakMap]"!=v(new s))&&(v=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case u:return"[object DataView]";case d:return"[object Map]";case p:return"[object Promise]";case h:return"[object Set]";case f:return"[object WeakMap]"}return e}),n.exports=v},function(n,e,t){var r=t(52)(t(39),"DataView");n.exports=r},function(n,e,t){var r=t(52)(t(39),"Promise");n.exports=r},function(n,e,t){var r=t(52)(t(39),"WeakMap");n.exports=r},function(n,e,t){var r=t(233),a=t(227);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var i=e[t],o=n[i];e[t]=[i,o,r(o)]}return e}},function(n,e,t){var r=t(223),a=t(393),i=t(400),o=t(160),s=t(233),l=t(234),c=t(122);n.exports=function(n,e){return o(n)&&s(e)?l(c(n),e):function(t){var o=a(t,n);return void 0===o&&o===e?i(t,n):r(e,o,3)}}},function(n,e,t){var r=t(235);n.exports=function(n,e,t){var a=null==n?void 0:r(n,e);return void 0===a?t:a}},function(n,e,t){var r=t(395),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,o=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,r,a){e.push(r?a.replace(i,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var r=t(396);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(157);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var r=arguments,a=e?e.apply(this,r):r[0],i=t.cache;if(i.has(a))return i.get(a);var o=n.apply(this,r);return t.cache=i.set(a,o)||i,o};return t.cache=new(a.Cache||r),t}a.Cache=r,n.exports=a},function(n,e,t){var r=t(398);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){var r=t(90),a=t(399),i=t(40),o=t(161),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return a(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=Array(r);++t<r;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var r=t(401),a=t(402);n.exports=function(n,e){return null!=n&&a(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(236),a=t(154),i=t(40),o=t(229),s=t(159),l=t(122);n.exports=function(n,e,t){for(var c=-1,u=(e=r(e,n)).length,d=!1;++c<u;){var p=l(e[c]);if(!(d=null!=n&&t(n,p)))break;n=n[p]}return d||++c!=u?d:!!(u=null==n?0:n.length)&&s(u)&&o(p,u)&&(i(n)||a(n))}},function(n,e,t){var r=t(404),a=t(405),i=t(160),o=t(122);n.exports=function(n){return i(n)?r(o(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(235);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(162),a=t(407),i=t(409);n.exports=function(n,e){return i(a(n,e,r),n+"")}},function(n,e,t){var r=t(408),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var i=arguments,o=-1,s=a(i.length-e,0),l=Array(s);++o<s;)l[o]=i[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=i[o];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(410),a=t(413)(r);n.exports=a},function(n,e,t){var r=t(411),a=t(412),i=t(162),o=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:i;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(52),a=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,r=0;return function(){var a=t(),i=16-(a-r);if(r=a,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(225),a=t(415),i=t(420),o=t(226),s=t(421),l=t(158);n.exports=function(n,e,t){var c=-1,u=a,d=n.length,p=!0,h=[],f=h;if(t)p=!1,u=i;else if(d>=200){var v=e?null:s(n);if(v)return l(v);p=!1,u=o,f=new r}else f=e?[]:h;n:for(;++c<d;){var m=n[c],g=e?e(m):m;if(m=t||0!==m?m:0,p&&g==g){for(var y=f.length;y--;)if(f[y]===g)continue n;e&&f.push(g),h.push(m)}else u(f,g,t)||(f!==h&&f.push(g),h.push(m))}return h}},function(n,e,t){var r=t(416);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(417),a=t(418),i=t(419);n.exports=function(n,e,t){return e==e?i(n,e,t):r(n,a,t)}},function(n,e){n.exports=function(n,e,t,r){for(var a=n.length,i=t+(r?1:-1);r?i--:++i<a;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,a=n.length;++r<a;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,a=null==n?0:n.length;++r<a;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(232),a=t(422),i=t(158),o=r&&1/i(new r([,-0]))[1]==1/0?function(n){return new r(n)}:a;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(231),a=t(71);n.exports=function(n){return a(n)&&r(n)}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){var r=t(3),a=t(1),i=t(237).setInterval;r({global:!0,bind:!0,forced:a.setInterval!==i},{setInterval:i})},function(n,e,t){var r=t(3),a=t(1),i=t(237).setTimeout;r({global:!0,bind:!0,forced:a.setTimeout!==i},{setTimeout:i})},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(3),a=t(4),i=t(27),o=t(46).f,s=t(10),l=a((function(){o(1)}));r({target:"Object",stat:!0,forced:!s||l,sham:!s},{getOwnPropertyDescriptor:function(n,e){return o(i(n),e)}})},function(n,e,t){var r=t(3),a=t(10),i=t(135).f;r({target:"Object",stat:!0,forced:Object.defineProperties!==i,sham:!a},{defineProperties:i})},function(n,e,t){var r=t(1),a=t(4),i=t(5),o=t(13),s=t(177).trim,l=t(178),c=r.parseInt,u=r.Symbol,d=u&&u.iterator,p=/^[+-]?0x/i,h=i(p.exec),f=8!==c(l+"08")||22!==c(l+"0x16")||d&&!a((function(){c(Object(d))}));n.exports=f?function(n,e){var t=s(o(n));return c(t,e>>>0||(h(p,t)?16:10))}:c},function(n,e,t){"use strict";t(238)},function(n,e,t){},function(n,e,t){"use strict";var r=t(1),a=t(5),i=t(4),o=t(435).start,s=r.RangeError,l=Math.abs,c=Date.prototype,u=c.toISOString,d=a(c.getTime),p=a(c.getUTCDate),h=a(c.getUTCFullYear),f=a(c.getUTCHours),v=a(c.getUTCMilliseconds),m=a(c.getUTCMinutes),g=a(c.getUTCMonth),y=a(c.getUTCSeconds);n.exports=i((function(){return"0385-07-25T07:06:39.999Z"!=u.call(new Date(-50000000000001))}))||!i((function(){u.call(new Date(NaN))}))?function(){if(!isFinite(d(this)))throw s("Invalid time value");var n=h(this),e=v(this),t=n<0?"-":n>9999?"+":"";return t+o(l(n),t?6:4,0)+"-"+o(g(this)+1,2,0)+"-"+o(p(this),2,0)+"T"+o(f(this),2,0)+":"+o(m(this),2,0)+":"+o(y(this),2,0)+"."+o(e,3,0)+"Z"}:u},function(n,e,t){var r=t(5),a=t(66),i=t(13),o=t(436),s=t(23),l=r(o),c=r("".slice),u=Math.ceil,d=function(n){return function(e,t,r){var o,d,p=i(s(e)),h=a(t),f=p.length,v=void 0===r?" ":i(r);return h<=f||""==v?p:((d=l(v,u((o=h-f)/v.length))).length>o&&(d=c(d,0,o)),n?p+d:d+p)}};n.exports={start:d(!1),end:d(!0)}},function(n,e,t){"use strict";var r=t(1),a=t(56),i=t(13),o=t(23),s=r.RangeError;n.exports=function(n){var e=i(o(this)),t="",r=a(n);if(r<0||r==1/0)throw s("Wrong number of repetitions");for(;r>0;(r>>>=1)&&(e+=e))1&r&&(t+=e);return t}},function(n,e,t){var r=t(45).match(/firefox\/(\d+)/i);n.exports=!!r&&+r[1]},function(n,e,t){var r=t(45);n.exports=/MSIE|Trident/.test(r)},function(n,e,t){var r=t(45).match(/AppleWebKit\/(\d+)\./);n.exports=!!r&&+r[1]},function(n,e,t){},function(n,e,t){"use strict";t(242)},function(n,e,t){"use strict";t(243)},function(n,e,t){"use strict";t(244)},function(n,e,t){var r=t(5);n.exports=r(1..valueOf)},function(n,e,t){"use strict";t(245)},function(n,e,t){
/*!
 * Valine v1.3.6
 * (c) 2017-2019 xCss
 * Released under the GPL-2.0 License.
 * Last Update: 2019-04-01 14:26:14
 */
n.exports=function(n){function e(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return n[r].call(a.exports,a,a.exports,e),a.l=!0,a.exports}var t={};return e.m=n,e.c=t,e.i=function(n){return n},e.d=function(n,t,r){e.o(n,t)||Object.defineProperty(n,t,{configurable:!1,enumerable:!0,get:r})},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},e.p="",e(e.s=17)}([function(n,e,t){var r,a,i;
/*!
	autosize 4.0.2
	license: MIT
	http://www.jacklmoore.com/autosize
*/a=[n,e],r=function(n,e){"use strict";function t(n){function e(e){var t=n.style.width;n.style.width="0px",n.offsetWidth,n.style.width=t,n.style.overflowY=e}function t(){if(0!==n.scrollHeight){var e=function(n){for(var e=[];n&&n.parentNode&&n.parentNode instanceof Element;)n.parentNode.scrollTop&&e.push({node:n.parentNode,scrollTop:n.parentNode.scrollTop}),n=n.parentNode;return e}(n),t=document.documentElement&&document.documentElement.scrollTop;n.style.height="",n.style.height=n.scrollHeight+a+"px",s=n.clientWidth,e.forEach((function(n){n.node.scrollTop=n.scrollTop})),t&&(document.documentElement.scrollTop=t)}}function r(){t();var r=Math.round(parseFloat(n.style.height)),a=window.getComputedStyle(n,null),i="content-box"===a.boxSizing?Math.round(parseFloat(a.height)):n.offsetHeight;if(i<r?"hidden"===a.overflowY&&(e("scroll"),t(),i="content-box"===a.boxSizing?Math.round(parseFloat(window.getComputedStyle(n,null).height)):n.offsetHeight):"hidden"!==a.overflowY&&(e("hidden"),t(),i="content-box"===a.boxSizing?Math.round(parseFloat(window.getComputedStyle(n,null).height)):n.offsetHeight),l!==i){l=i;var s=o("autosize:resized");try{n.dispatchEvent(s)}catch(n){}}}if(n&&n.nodeName&&"TEXTAREA"===n.nodeName&&!i.has(n)){var a=null,s=null,l=null,c=function(){n.clientWidth!==s&&r()},u=function(e){window.removeEventListener("resize",c,!1),n.removeEventListener("input",r,!1),n.removeEventListener("keyup",r,!1),n.removeEventListener("autosize:destroy",u,!1),n.removeEventListener("autosize:update",r,!1),Object.keys(e).forEach((function(t){n.style[t]=e[t]})),i.delete(n)}.bind(n,{height:n.style.height,resize:n.style.resize,overflowY:n.style.overflowY,overflowX:n.style.overflowX,wordWrap:n.style.wordWrap});n.addEventListener("autosize:destroy",u,!1),"onpropertychange"in n&&"oninput"in n&&n.addEventListener("keyup",r,!1),window.addEventListener("resize",c,!1),n.addEventListener("input",r,!1),n.addEventListener("autosize:update",r,!1),n.style.overflowX="hidden",n.style.wordWrap="break-word",i.set(n,{destroy:u,update:r}),function(){var e=window.getComputedStyle(n,null);"vertical"===e.resize?n.style.resize="none":"both"===e.resize&&(n.style.resize="horizontal"),a="content-box"===e.boxSizing?-(parseFloat(e.paddingTop)+parseFloat(e.paddingBottom)):parseFloat(e.borderTopWidth)+parseFloat(e.borderBottomWidth),isNaN(a)&&(a=0),r()}()}}function r(n){var e=i.get(n);e&&e.destroy()}function a(n){var e=i.get(n);e&&e.update()}var i="function"==typeof Map?new Map:function(){var n=[],e=[];return{has:function(e){return n.indexOf(e)>-1},get:function(t){return e[n.indexOf(t)]},set:function(t,r){-1===n.indexOf(t)&&(n.push(t),e.push(r))},delete:function(t){var r=n.indexOf(t);r>-1&&(n.splice(r,1),e.splice(r,1))}}}(),o=function(n){return new Event(n,{bubbles:!0})};try{new Event("test")}catch(n){o=function(n){var e=document.createEvent("Event");return e.initEvent(n,!0,!1),e}}var s=null;"undefined"==typeof window||"function"!=typeof window.getComputedStyle?((s=function(n){return n}).destroy=function(n){return n},s.update=function(n){return n}):((s=function(n,e){return n&&Array.prototype.forEach.call(n.length?n:[n],(function(n){return t(n)})),n}).destroy=function(n){return n&&Array.prototype.forEach.call(n.length?n:[n],r),n},s.update=function(n){return n&&Array.prototype.forEach.call(n.length?n:[n],a),n}),e.default=s,n.exports=e.default},void 0!==(i="function"==typeof r?r.apply(e,a):r)&&(n.exports=i)},function(n,e,t){"use strict";function r(n){return!!n&&this.init(n),this}function a(n){return new r(n)}var i=t(9).version,o=t(6),s=t(8),l=t(0),c=t(5),u=t(3),d=t(4),p=t(2),h=t(7),f=/^https?\:\/\//,v={comment:"",nick:"Anonymous",mail:"",link:"",ua:navigator.userAgent,url:""},m={"zh-cn":{head:{nick:"昵称",mail:"邮箱",link:"网址(http://)"},tips:{comments:"评论",sofa:"快来做第一个评论的人吧~",busy:"还在提交中，请稍候...",again:"这么简单也能错，也是没谁了."},ctrl:{reply:"回复",ok:"好的",sure:"确认",cancel:"取消",confirm:"确认",continue:"继续",more:"查看更多...",try:"再试试?",preview:"预览",emoji:"表情"},error:{99:"初始化失败，请检查init中的`el`元素.",100:"初始化失败，请检查你的AppId和AppKey.",401:"未经授权的操作，请检查你的AppId和AppKey.",403:"访问被api域名白名单拒绝，请检查你的安全域名设置."},timeago:{seconds:"秒前",minutes:"分钟前",hours:"小时前",days:"天前",now:"刚刚"}},en:{head:{nick:"NickName",mail:"E-Mail",link:"Website(http://)"},tips:{comments:"Comments",sofa:"No comments yet.",busy:"Submit is busy, please wait...",again:"Sorry, this is a wrong calculation."},ctrl:{reply:"Reply",ok:"Ok",sure:"Sure",cancel:"Cancel",confirm:"Confirm",continue:"Continue",more:"Load More...",try:"Once More?",preview:"Preview",emoji:"Emoji"},error:{99:"Initialization failed, Please check the `el` element in the init method.",100:"Initialization failed, Please check your appId and appKey.",401:"Unauthorized operation, Please check your appId and appKey.",403:"Access denied by api domain white list, Please check your security domain."},timeago:{seconds:"seconds ago",minutes:"minutes ago",hours:"hours ago",days:"days ago",now:"just now"}}},g={cdn:"https://gravatar.loli.net/avatar/",ds:["mp","identicon","monsterid","wavatar","robohash","retro",""],params:"",hide:!1},y=["nick","mail","link"],b=Storage&&localStorage&&localStorage instanceof Storage&&localStorage,w=location.pathname.replace(/index\.html?$/,"");r.prototype.init=function(n){if("undefined"!=typeof document){var e=this;try{var t=n.lang,r=n.langMode,a=n.avatar,o=n.avatarForce,l=n.avatar_cdn,c=n.notify,u=n.verify,p=n.visitor,b=n.pageSize,k=n.recordIP,E=g.ds,A=o?"&q="+Math.random().toString(32).substring(2):"";if(t&&r&&e.installLocale(t,r),e.locale=e.locale||m[t||"zh-cn"],e.notify=c||!1,e.verify=u||!1,k){var _=d.create("script","src","//api.ip.sb/jsonip?callback=getIP"),S=document.getElementsByTagName("script")[0];S.parentNode.insertBefore(_,S),window.getIP=function(n){v.ip=n.ip}}g.params="?d="+(E.indexOf(a)>-1?a:"mp")+"&v="+i+A,g.hide="hide"===a,g.cdn=f.test(l)?l:g.cdn,w=n.path||w;var C=Number(b||10);if(n.pageSize=isNaN(C)||C<1?10:C,s.setOptions({renderer:new s.Renderer,highlight:!1===n.highlight?null:h,gfm:!0,tables:!0,breaks:!0,pedantic:!1,sanitize:!1,smartLists:!0,smartypants:!0}),!AV)return void setTimeout((function(){e.init(n)}),20);var T=n.app_id||n.appId,O=n.app_key||n.appKey;if(!T||!O)throw 99;AV.applicationId&&delete AV._config.applicationId||(AV.applicationId=null),AV.applicationKey&&delete AV._config.applicationKey||(AV.applicationKey=null),AV.init({appId:T,appKey:O});for(var j=d.findAll(document,".valine-comment-count"),B=0,I=j.length;B<I;B++)!function(n,t){var r=j[n];if(r){var a=d.attr(r,"data-xid");a&&e.Q(a).count().then((function(n){r.innerText=n})).catch((function(n){r.innerText=0}))}}(B);p&&x.add(AV.Object.extend("Counter"));var L=n.el||null,N=d.findAll(document,L);if(!(L=L instanceof HTMLElement?L:N[N.length-1]||null))return;e.el=L,e.el.classList.add("v"),g.hide&&e.el.classList.add("hide-avatar"),n.meta=(n.guest_info||n.meta||y).filter((function(n){return y.indexOf(n)>-1}));var P=(0==n.meta.length?y:n.meta).map((function(n){var t="mail"==n?"email":"text";return y.indexOf(n)>-1?'<input name="'+n+'" placeholder="'+e.locale.head[n]+'" class="v'+n+' vinput" type="'+t+'">':""}));e.placeholder=n.placeholder||"Just Go Go",e.el.innerHTML='<div class="vwrap"><div class="vheader item'+P.length+'">'+P.join("")+'</div><div class="vedit"><textarea id="veditor" class="veditor vinput" placeholder="'+e.placeholder+'"></textarea><div class="vctrl"><span class="vemoji-btn">'+e.locale.ctrl.emoji+'</span> | <span class="vpreview-btn">'+e.locale.ctrl.preview+'</span></div><div class="vemojis" style="display:none;"></div><div class="vinput vpreview" style="display:none;"></div></div><div class="vcontrol"><div class="col col-20" title="Markdown is supported"><a href="https://segmentfault.com/markdown" target="_blank"><svg class="markdown" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path fill-rule="evenodd" d="M14.85 3H1.15C.52 3 0 3.52 0 4.15v7.69C0 12.48.52 13 1.15 13h13.69c.64 0 1.15-.52 1.15-1.15v-7.7C16 3.52 15.48 3 14.85 3zM9 11H7V8L5.5 9.92 4 8v3H2V5h2l1.5 2L7 5h2v6zm2.99.5L9.5 8H11V5h2v3h1.5l-2.51 3.5z"></path></svg></a></div><div class="col col-80 text-right"><button type="button" title="Cmd|Ctrl+Enter" class="vsubmit vbtn">'+e.locale.ctrl.reply+'</button></div></div><div style="display:none;" class="vmark"></div></div><div class="vinfo" style="display:none;"><div class="vcount col"></div></div><div class="vlist"></div><div class="vempty" style="display:none;"></div><div class="vpage txt-center"></div><div class="info"><div class="power txt-right">Powered By <a href="https://valine.js.org" target="_blank">Valine</a><br>v'+i+"</div></div>";var q=d.find(e.el,".vempty");e.nodata={show:function(n){return q.innerHTML=n||e.locale.tips.sofa,d.attr(q,"style","display:block;"),e},hide:function(){return d.attr(q,"style","display:none;"),e}};var R=d.create("div","class","vloading"),F=d.find(e.el,".vlist");e.loading={show:function(n){var t=d.findAll(F,".vcard");return n?F.insertBefore(R,t[0]):F.appendChild(R),e.nodata.hide(),e},hide:function(){var n=d.find(F,".vloading");return n&&d.remove(n),0===d.findAll(F,".vcard").length&&e.nodata.show(),e}};var M=d.find(e.el,".vmark");e.alert={show:function(n){M.innerHTML='<div class="valert txt-center"><div class="vtext">'+(n&&n.text||1)+'</div><div class="vbtns"></div></div>';var t=d.find(M,".vbtns"),r='<button class="vcancel vbtn">'+(n&&n.ctxt||e.locale.ctrl.cancel)+"</button>",a='<button class="vsure vbtn">'+(n&&n.otxt||e.locale.ctrl.sure)+"</button>";if(t.innerHTML=""+r+(n&&n.type&&a),d.on("click",d.find(M,".vcancel"),(function(n){e.alert.hide()})),d.attr(M,"style","display:block;"),n&&n.type){var i=d.find(M,".vsure");d.on("click",i,(function(t){e.alert.hide(),n.cb&&n.cb()}))}return e},hide:function(){return d.attr(M,"style","display:none;"),e}},e.bind(n)}catch(n){e.ErrorHandler(n)}return e}console};var k=function(n,e){var t=new n,r=new AV.ACL;r.setPublicReadAccess(!0),r.setPublicWriteAccess(!0),t.setACL(r),t.set("url",e.url),t.set("xid",e.xid),t.set("title",e.title),t.set("time",1),t.save().then((function(n){d.find(e.el,".leancloud-visitors-count").innerText=1})).catch((function(n){}))},x={add:function(n){var e=d.findAll(document,".leancloud_visitors,.leancloud-visitors");if(e.length){var t=e[0],r=d.attr(t,"id"),a=d.attr(t,"data-flag-title"),i=encodeURI(r),o={el:t,url:r,xid:i,title:a};if(decodeURI(r)===decodeURI(w)){var s=new AV.Query(n);s.equalTo("url",r),s.find().then((function(e){if(e.length>0){var r=e[0];r.increment("time"),r.save().then((function(n){d.find(t,".leancloud-visitors-count").innerText=n.get("time")})).catch((function(n){}))}else k(n,o)})).catch((function(e){101==e.code&&k(n,o)}))}else x.show(n,e)}},show:function(n,e){d.each(e,(function(n,e){var t=d.find(e,".leancloud-visitors-count");t&&(t.innerText=0)}));var t=[];for(var r in e)e.hasOwnProperty(r)&&t.push(d.attr(e[r],"id"));if(t.length){var a=new AV.Query(n);a.containedIn("url",t),a.find().then((function(n){n.length>0&&d.each(n,(function(n,e){var t=e.get("url"),r=e.get("time"),a=d.find(document,'.leancloud_visitors[id="'+t+'"]')||d.find(document,'.leancloud-visitors[id="'+t+'"]'),i=d.find(a,".leancloud-visitors-count");i&&(i.innerText=r)}))})).catch((function(n){}))}}};r.prototype.Q=function(n){if(1==arguments.length){var e=new AV.Query("Comment");e.doesNotExist("rid");var t=new AV.Query("Comment");t.equalTo("rid","");var r=AV.Query.or(e,t);return r.equalTo("url",decodeURI(n)),r.addDescending("createdAt"),r.addDescending("insertedAt"),r}var a=JSON.stringify(arguments[1]).replace(/(\[|\])/g,""),i="select * from Comment where rid in ("+a+") order by -createdAt,-createdAt";return AV.Query.doCloudQuery(i)},r.prototype.ErrorHandler=function(n){var e=this;if(e.el&&e.loading.hide().nodata.hide(),"[object Error]"==={}.toString.call(n)){var t=n.code||"",r=e.locale.error[t]||n.message||n.error||"";101==t?e.nodata.show():e.el&&e.nodata.show('<pre style="text-align:left;">Code '+t+": "+r+"</pre>")||console}else e.el&&e.nodata.show('<pre style="text-align:left;">'+JSON.stringify(n)+"</pre>")||console},r.prototype.installLocale=function(n,e){return e=e||{},n&&(m[n]=e,this.locale=m[n]||m["zh-cn"]),this},r.prototype.setPath=function(n){return w=n||w,this},r.prototype.bind=function(n){var e=this,t=d.find(e.el,".vemojis"),r=d.find(e.el,".vpreview"),a=d.find(e.el,".vemoji-btn"),i=d.find(e.el,".vpreview-btn"),h=p.data;for(var f in h)h.hasOwnProperty(f)&&function(n,r){var a=d.create("i",{name:n,title:n});a.innerHTML=r,t.appendChild(a),d.on("click",a,(function(n){var t=d.find(e.el,".veditor");C(t,r),y(t)}))}(f,h[f]);e.emoji={show:function(){return e.preview.hide(),d.attr(a,"v",1),d.removeAttr(i,"v"),d.attr(t,"style","display:block"),e.emoji},hide:function(){return d.removeAttr(a,"v"),d.attr(t,"style","display:hide"),e.emoji}},e.preview={show:function(){return v.comment&&(e.emoji.hide(),d.attr(i,"v",1),d.removeAttr(a,"v"),r.innerHTML=v.comment,d.attr(r,"style","display:block"),B()),e.preview},hide:function(){return d.removeAttr(i,"v"),d.attr(r,"style","display:none"),e.preview},empty:function(){return r.innerHtml="",e.preview}};var m=function(n){var e=d.create("div");e.insertAdjacentHTML("afterbegin",n);var t=d.findAll(e,"*"),r=["INPUT","STYLE","SCRIPT","IFRAME","FRAME","AUDIO","VIDEO","EMBED","META","TITLE","LINK"];return d.each(t,(function(n,e){1===e.nodeType&&(r.indexOf(e.nodeName)>-1&&("INPUT"===e.nodeName&&"checkbox"===d.attr(e,"type")?d.attr(e,"disabled","disabled"):d.remove(e)),"A"===e.nodeName&&function(n,e){var t=d.attr(n,e);t&&d.attr(n,e,t.replace(/(javascript|eval)/gi,""))}(e,"href"),d.clearAttr(e))})),e.innerHTML},y=function(n){var e=n.value||"";e=p.parse(e),n.value=e;var t=m(s(e));v.comment=t,r.innerHTML=t,e?l(n):l.destroy(n)};d.on("click",a,(function(n){d.attr(a,"v")?e.emoji.hide():e.emoji.show()})),d.on("click",i,(function(n){d.attr(i,"v")?e.preview.hide():e.preview.show()}));for(var k=n.meta,x={},E={veditor:"comment"},A=0,_=k.length;A<_;A++)E["v"+k[A]]=k[A];for(var S in E)E.hasOwnProperty(S)&&function(){var n=E[S],t=d.find(e.el,"."+S);x[n]=t,t&&d.on("input change blur",t,(function(e){"comment"===n?y(t):v[n]=d.escape(t.value.replace(/(^\s*)|(\s*$)/g,""))}))}();var C=function(n,e){if(document.selection)n.focus(),document.selection.createRange().text=e,n.focus();else if(n.selectionStart||"0"==n.selectionStart){var t=n.selectionStart,r=n.selectionEnd,a=n.scrollTop;n.value=n.value.substring(0,t)+e+n.value.substring(r,n.value.length),n.focus(),n.selectionStart=t+e.length,n.selectionEnd=t+e.length,n.scrollTop=a}else n.focus(),n.value+=e},T=function(n){var t=d.find(e.el,".vh[rootid='"+n+"']"),r=d.find(t,".vquote");return r||(r=d.create("div","class","vquote"),t.appendChild(r)),r},O=function t(){var r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1,a=n.pageSize,i=Number(d.find(e.el,".vnum").innerText);e.loading.show();var o=e.Q(w);o.limit(a),o.skip((r-1)*a),o.find().then((function(n){for(var o=n.length,s=[],l=0;l<o;l++){var c=n[l];s.push(c.id),j(c,d.find(e.el,".vlist"),!0)}e.Q(w,s).then((function(n){for(var e=n&&n.results||[],t=0;t<e.length;t++){var r=e[t];j(r,T(r.get("rid")))}}));var u=d.find(e.el,".vpage");u.innerHTML=a*r<i?'<button type="button" class="vmore vbtn">'+e.locale.ctrl.more+"</button>":"";var p=d.find(u,".vmore");p&&d.on("click",p,(function(n){u.innerHTML="",t(++r)})),e.loading.hide()})).catch((function(n){e.loading.hide().ErrorHandler(n)}))};e.Q(w).count().then((function(n){n>0?(d.attr(d.find(e.el,".vinfo"),"style","display:block;"),d.find(e.el,".vcount").innerHTML='<span class="vnum">'+n+"</span> "+e.locale.tips.comments,O()):e.loading.hide()})).catch((function(n){e.ErrorHandler(n)}));var j=function(n,t,r){var a=d.create("div",{class:"vcard",id:n.id}),i=g.hide?"":'<img class="vimg" src="'+(g.cdn+o(n.get("mail"))+g.params)+'">',s=n.get("ua")||"",l="";s&&(l='<span class="vsys">'+(s=u(s)).browser+" "+s.version+'</span> <span class="vsys">'+s.os+" "+s.osVersion+"</span>");var p,h=n.get("link")||"";p=h?'<a class="vnick" rel="nofollow" href="'+h+'" target="_blank" >'+n.get("nick")+"</a>":'<span class="vnick">'+n.get("nick")+"</span>",a.innerHTML=i+'\n            <div class="vh" rootid='+(n.get("rid")||n.id)+'>\n                <div class="vhead">'+p+" "+l+'</div>\n                <div class="vmeta">\n                    <span class="vtime">'+c(n.get("insertedAt")||n.createdAt,e.locale)+'</span>\n                    <span class="vat">'+e.locale.ctrl.reply+'</span>\n                </div>\n                <div class="vcontent">\n                    '+m(n.get("comment"))+"\n                </div>\n            </div>";for(var f=d.find(a,".vat"),v=d.findAll(a,"a"),y=0,b=v.length;y<b;y++){var w=v[y];w&&-1==(d.attr(w,"class")||"").indexOf("at")&&d.attr(w,{target:"_blank",rel:"nofollow"})}var k=d.findAll(t,".vcard");r?t.appendChild(a):t.insertBefore(a,k[0]);var x=d.find(a,".vcontent");x&&I(x),f&&N(f,n),B()},B=function(){setTimeout((function(){try{var n=n||"";n&&n.Hub.Queue(["Typeset",n.Hub]),$("pre code").each((function(n,e){hljs.highlightBlock(e)})),$("code.hljs").each((function(n,e){hljs.lineNumbersBlock(e)}))}catch(n){}}),20)},I=function(n){setTimeout((function(){n.offsetHeight>180&&(n.classList.add("expand"),d.on("click",n,(function(e){d.attr(n,"class","vcontent")})))}))},L={},N=function(n,e){d.on("click",n,(function(n){var t="@"+d.escape(e.get("nick"));L={at:d.escape(t)+" ",rid:e.get("rid")||e.id,pid:e.id,rmail:e.get("mail")},d.attr(x.comment,"placeholder",t),x.comment.focus()}))};!function(){var n=b&&b.ValineCache;if(n){n=JSON.parse(n);var t=k;for(var r in t){var a=t[r];d.find(e.el,".v"+a).value=d.unescape(n[a]),v[a]=n[a]}}}();var P=d.find(e.el,".vsubmit"),q=function(n){return d.attr(P,"disabled")?void e.alert.show({type:0,text:e.locale.tips.busy+'ヾ(๑╹◡╹)ﾉ"',ctxt:e.locale.ctrl.ok}):""==v.comment?void x.comment.focus():(v.nick=v.nick||"Anonymous",void(e.notify||e.verify?M(F):F()))},R=function(){var n=new AV.ACL;return n.setPublicReadAccess(!0),n.setPublicWriteAccess(!1),n},F=function(){d.attr(P,"disabled",!0),e.loading.show(!0);var n=new(AV.Object.extend("Comment"));if(v.url=decodeURI(w),v.insertedAt=new Date,L.rid){var t=L.pid||L.rid;n.set("rid",L.rid),n.set("pid",t),v.comment=v.comment.replace("<p>",'<p><a class="at" href="#'+t+'">'+L.at+"</a> , ")}for(var r in v)if(v.hasOwnProperty(r)){var a=v[r];n.set(r,a)}n.setACL(R()),n.save().then((function(n){"Anonymous"!=v.nick&&b&&b.setItem("ValineCache",JSON.stringify({nick:v.nick,link:v.link,mail:v.mail}));var t=d.find(e.el,".vnum"),r=1;try{if(L.rid){var a=d.find(e.el,'.vquote[rid="'+L.rid+'"]')||T(L.rid);j(n,a,!0)}else t?(r=Number(t.innerText)+1,t.innerText=r):d.find(e.el,".vcount").innerHTML='<span class="num">1</span> '+e.locale.tips.comments,j(n,d.find(e.el,".vlist"));v.mail&&z({username:v.nick,mail:v.mail}),L.at&&L.rmail&&e.notify&&D({username:L.at.replace("@",""),mail:L.rmail}),d.removeAttr(P,"disabled"),e.loading.hide(),v.comment="",x.comment.value="",y(x.comment),d.attr(x.comment,"placeholder",e.placeholder),L={},e.preview.empty().hide()}catch(n){e.ErrorHandler(n)}})).catch((function(n){e.ErrorHandler(n)}))},M=function n(t){var r=Math.floor(10*Math.random()+1),a=Math.floor(10*Math.random()+1),i=Math.floor(10*Math.random()+1),o=["+","-","x"],s=""+r+o[Math.floor(3*Math.random())]+a+o[Math.floor(3*Math.random())]+i,l=s+" = <input class='vcode vinput' >";e.alert.show({type:1,text:l,ctxt:e.locale.ctrl.cancel,otxt:e.locale.ctrl.ok,cb:function(){var r=+d.find(e.el,".vcode").value;new Function("return "+s.replace(/x/g,"*"))()===r?t&&t():e.alert.show({type:1,text:"(T＿T)"+e.locale.tips.again,ctxt:e.locale.ctrl.cancel,otxt:e.locale.ctrl.try,cb:function(){n(t)}})}})},z=function(n){var e=new AV.User;return e.setUsername(n.username),e.setPassword(n.mail),e.setEmail(n.mail),e.setACL(R()),e.signUp()},D=function n(t){AV.User.requestPasswordReset(t.mail).then((function(n){})).catch((function(r){1==r.code?e.alert.show({type:0,text:"ヾ(ｏ･ω･)ﾉ At太频繁啦，提醒功能暂时宕机。<br>"+r.error,ctxt:e.locale.ctrl.ok}):z(t).then((function(e){n(t)})).catch((function(n){}))}))};d.on("click",P,q),d.on("keydown",document,(function(n){var t=(n=event||n).keyCode||n.which||n.charCode;if((n.ctrlKey||n.metaKey)&&13===t&&q(),9===t&&"veditor"==(document.activeElement.id||"")){n.preventDefault();var r=d.find(e.el,".veditor");C(r,"    ")}}))},n.exports=a,n.exports.default=a},function(n,e,t){"use strict";var r={data:t(11),parse:function(n){return String(n).replace(/:(.+?):/g,(function(n,e){return r.data[e]||n}))}};n.exports=r},function(n,e,t){"use strict";function r(n){var e=this,t={Trident:n.indexOf("Trident")>-1||n.indexOf("NET CLR")>-1,Presto:n.indexOf("Presto")>-1,WebKit:n.indexOf("AppleWebKit")>-1,Gecko:n.indexOf("Gecko/")>-1,Safari:n.indexOf("Safari")>-1,Chrome:n.indexOf("Chrome")>-1||n.indexOf("CriOS")>-1,IE:n.indexOf("MSIE")>-1||n.indexOf("Trident")>-1,Edge:n.indexOf("Edge")>-1,Firefox:n.indexOf("Firefox")>-1||n.indexOf("FxiOS")>-1,"Firefox Focus":n.indexOf("Focus")>-1,Chromium:n.indexOf("Chromium")>-1,Opera:n.indexOf("Opera")>-1||n.indexOf("OPR")>-1,Vivaldi:n.indexOf("Vivaldi")>-1,Yandex:n.indexOf("YaBrowser")>-1,Kindle:n.indexOf("Kindle")>-1||n.indexOf("Silk/")>-1,360:n.indexOf("360EE")>-1||n.indexOf("360SE")>-1,UC:n.indexOf("UC")>-1||n.indexOf(" UBrowser")>-1,QQBrowser:n.indexOf("QQBrowser")>-1,QQ:n.indexOf("QQ/")>-1,Baidu:n.indexOf("Baidu")>-1||n.indexOf("BIDUBrowser")>-1,Maxthon:n.indexOf("Maxthon")>-1,Sogou:n.indexOf("MetaSr")>-1||n.indexOf("Sogou")>-1,LBBROWSER:n.indexOf("LBBROWSER")>-1,"2345Explorer":n.indexOf("2345Explorer")>-1,TheWorld:n.indexOf("TheWorld")>-1,XiaoMi:n.indexOf("MiuiBrowser")>-1,Quark:n.indexOf("Quark")>-1,Qiyu:n.indexOf("Qiyu")>-1,Wechat:n.indexOf("MicroMessenger")>-1,Taobao:n.indexOf("AliApp(TB")>-1,Alipay:n.indexOf("AliApp(AP")>-1,Weibo:n.indexOf("Weibo")>-1,Douban:n.indexOf("com.douban.frodo")>-1,Suning:n.indexOf("SNEBUY-APP")>-1,iQiYi:n.indexOf("IqiyiApp")>-1,Windows:n.indexOf("Windows")>-1,Linux:n.indexOf("Linux")>-1||n.indexOf("X11")>-1,"Mac OS":n.indexOf("Macintosh")>-1,Android:n.indexOf("Android")>-1||n.indexOf("Adr")>-1,Ubuntu:n.indexOf("Ubuntu")>-1,FreeBSD:n.indexOf("FreeBSD")>-1,Debian:n.indexOf("Debian")>-1,"Windows Phone":n.indexOf("IEMobile")>-1||n.indexOf("Windows Phone")>-1,BlackBerry:n.indexOf("BlackBerry")>-1||n.indexOf("RIM")>-1,MeeGo:n.indexOf("MeeGo")>-1,Symbian:n.indexOf("Symbian")>-1,iOS:n.indexOf("like Mac OS X")>-1,"Chrome OS":n.indexOf("CrOS")>-1,WebOS:n.indexOf("hpwOS")>-1,Mobile:n.indexOf("Mobi")>-1||n.indexOf("iPh")>-1||n.indexOf("480")>-1,Tablet:n.indexOf("Tablet")>-1||n.indexOf("Pad")>-1||n.indexOf("Nexus 7")>-1};t.Mobile&&(t.Mobile=!(n.indexOf("iPad")>-1));var r={engine:["WebKit","Trident","Gecko","Presto"],browser:["Safari","Chrome","Edge","IE","Firefox","Firefox Focus","Chromium","Opera","Vivaldi","Yandex","Kindle","360","UC","QQBrowser","QQ","Baidu","Maxthon","Sogou","LBBROWSER","2345Explorer","TheWorld","XiaoMi","Quark","Qiyu","Wechat","Taobao","Alipay","Weibo","Douban","Suning","iQiYi"],os:["Windows","Linux","Mac OS","Android","Ubuntu","FreeBSD","Debian","iOS","Windows Phone","BlackBerry","MeeGo","Symbian","Chrome OS","WebOS"],device:["Mobile","Tablet"]};for(var a in e.device="PC",r)for(var i=0;i<r[a].length;i++){var o=r[a][i];t[o]&&(e[a]=o)}var s={Windows:function(){var e=n.replace(/^.*Windows NT ([\d.]+);.*$/,"$1");return{6.4:"10",6.3:"8.1",6.2:"8",6.1:"7","6.0":"Vista",5.2:"XP",5.1:"XP","5.0":"2000"}[e]||e},Android:function(){return n.replace(/^.*Android ([\d.]+);.*$/,"$1")},iOS:function(){return n.replace(/^.*OS ([\d_]+) like.*$/,"$1").replace(/_/g,".")},Debian:function(){return n.replace(/^.*Debian\/([\d.]+).*$/,"$1")},"Windows Phone":function(){return n.replace(/^.*Windows Phone( OS)? ([\d.]+);.*$/,"$2")},"Mac OS":function(){return n.replace(/^.*Mac OS X ([\d_]+).*$/,"$1").replace(/_/g,".")},WebOS:function(){return n.replace(/^.*hpwOS\/([\d.]+);.*$/,"$1")}};e.osVersion="",s[e.os]&&(e.osVersion=s[e.os](),e.osVersion==n&&(e.osVersion=""));var l={Safari:function(){return n.replace(/^.*Version\/([\d.]+).*$/,"$1")},Chrome:function(){return n.replace(/^.*Chrome\/([\d.]+).*$/,"$1").replace(/^.*CriOS\/([\d.]+).*$/,"$1")},IE:function(){return n.replace(/^.*MSIE ([\d.]+).*$/,"$1").replace(/^.*rv:([\d.]+).*$/,"$1")},Edge:function(){return n.replace(/^.*Edge\/([\d.]+).*$/,"$1")},Firefox:function(){return n.replace(/^.*Firefox\/([\d.]+).*$/,"$1").replace(/^.*FxiOS\/([\d.]+).*$/,"$1")},"Firefox Focus":function(){return n.replace(/^.*Focus\/([\d.]+).*$/,"$1")},Chromium:function(){return n.replace(/^.*Chromium\/([\d.]+).*$/,"$1")},Opera:function(){return n.replace(/^.*Opera\/([\d.]+).*$/,"$1").replace(/^.*OPR\/([\d.]+).*$/,"$1")},Vivaldi:function(){return n.replace(/^.*Vivaldi\/([\d.]+).*$/,"$1")},Yandex:function(){return n.replace(/^.*YaBrowser\/([\d.]+).*$/,"$1")},Kindle:function(){return n.replace(/^.*Version\/([\d.]+).*$/,"$1")},Maxthon:function(){return n.replace(/^.*Maxthon\/([\d.]+).*$/,"$1")},QQBrowser:function(){return n.replace(/^.*QQBrowser\/([\d.]+).*$/,"$1")},QQ:function(){return n.replace(/^.*QQ\/([\d.]+).*$/,"$1")},Baidu:function(){return n.replace(/^.*BIDUBrowser[\s\/]([\d.]+).*$/,"$1")},UC:function(){return n.replace(/^.*UC?Browser\/([\d.]+).*$/,"$1")},Sogou:function(){return n.replace(/^.*SE ([\d.X]+).*$/,"$1").replace(/^.*SogouMobileBrowser\/([\d.]+).*$/,"$1")},"2345Explorer":function(){return n.replace(/^.*2345Explorer\/([\d.]+).*$/,"$1")},TheWorld:function(){return n.replace(/^.*TheWorld ([\d.]+).*$/,"$1")},XiaoMi:function(){return n.replace(/^.*MiuiBrowser\/([\d.]+).*$/,"$1")},Quark:function(){return n.replace(/^.*Quark\/([\d.]+).*$/,"$1")},Qiyu:function(){return n.replace(/^.*Qiyu\/([\d.]+).*$/,"$1")},Wechat:function(){return n.replace(/^.*MicroMessenger\/([\d.]+).*$/,"$1")},Taobao:function(){return n.replace(/^.*AliApp\(TB\/([\d.]+).*$/,"$1")},Alipay:function(){return n.replace(/^.*AliApp\(AP\/([\d.]+).*$/,"$1")},Weibo:function(){return n.replace(/^.*weibo__([\d.]+).*$/,"$1")},Douban:function(){return n.replace(/^.*com.douban.frodo\/([\d.]+).*$/,"$1")},Suning:function(){return n.replace(/^.*SNEBUY-APP([\d.]+).*$/,"$1")},iQiYi:function(){return n.replace(/^.*IqiyiVersion\/([\d.]+).*$/,"$1")}};e.version="",l[e.browser]&&(e.version=l[e.browser](),e.version==n&&(e.version="")),"Edge"==e.browser?e.engine="EdgeHTML":"Chrome"==e.browser&&parseInt(e.version)>27||"Opera"==e.browser&&parseInt(e.version)>12||"Yandex"==e.browser?e.engine="Blink":null==e.browser&&(e.browser="Unknow App")}n.exports=function(n){return new r(n)}},function(n,e,t){"use strict";var r={},a={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","`":"&#x60;","\\":"&#x5c;"};for(var i in a)r[a[i]]=i;var o=/[&<>"'`\\]/g,s=RegExp(o.source),l=/&(?:amp|lt|gt|quot|#39|#x60|#x5c);/g,c=RegExp(l.source),u={on:function(n,e,t,r){for(var a=0,i=(n=n.split(" ")).length;a<i;a++)u.off(n[a],e,t,r),e.addEventListener?e.addEventListener(n[a],t,r||!1):e.attachEvent?e.attachEvent("on"+n[a],t):e["on"+n[a]]=t},off:function(n,e,t,r){e.removeEventListener?e.removeEventListener(n,t,r||!1):e.detachEvent?e.detachEvent("on"+n,t):e["on"+n]=null},escape:function(n){return n&&s.test(n)?n.replace(o,(function(n){return a[n]})):n},unescape:function(n){return n&&c.test(n)?n.replace(l,(function(n){return r[n]})):n},create:function(n,e,t){var r=document.createElement(n);return u.attr(r,e,t),r},find:function(n,e){return n.querySelector(e)},findAll:function(n,e){return n.querySelectorAll(e)},attr:function(n,e,t){if(void 0===n.getAttribute)return u.prop(n,e,t);if(void 0!==t)null===t?u.removeAttr(n,e):n.setAttribute(e,t);else{if("[object Object]"!=={}.toString.call(e))return n.getAttribute(e);u.each(e,(function(e,t){n.setAttribute(e,t)}))}},prop:function(n,e,t){return void 0!==t?n[e]=t:"[object Object]"!=={}.toString.call(e)?n[e]:void u.each(e,(function(e,t){n[e]=t}))},removeAttr:function(n,e){var t=void 0,r=0,a=e&&e.match(/[^\x20\t\r\n\f\*\/\\]+/g);if(a&&1===n.nodeType)for(;t=a[r++];)n.removeAttribute(t);return n},clearAttr:function(n){var e=n.attributes,t=["align","alt","disabled","href","id","target","title","type","src","class","style"];return u.each(e,(function(e,r){var a=r.name;switch(r.name.toLowerCase()){case"style":var i=r.value;u.each(i.split(";"),(function(e,t){if(t.indexOf("color")>-1)return u.attr(n,"style",t),!1;u.removeAttr(n,"style")}));break;case"class":if("CODE"==n.nodeName)return!1;if(r.value.indexOf("at")>-1)return u.attr(n,"class","at"),!1}t.indexOf(a)>-1||u.removeAttr(n,a)})),n},remove:function(n){try{n.parentNode&&n.parentNode.removeChild(n)}catch(n){}},each:function(n,e){var t=0,r=n.length,a={}.toString.call(n);if(["[object Array]","[object NodeList]"].indexOf(a)>-1)for(;t<r&&!1!==(e&&e.call(n[t],t,n[t]));t++);else for(t in n)if(n.hasOwnProperty(t)&&!1===(e&&e.call(n[t],t,n[t])))break;return n}};n.exports=u},function(n,e,t){"use strict";var r=function(n){var e=a(n.getDate(),2),t=a(n.getMonth()+1,2);return a(n.getFullYear(),2)+"-"+t+"-"+e},a=function(n,e){for(var t=n.toString();t.length<e;)t="0"+t;return t};n.exports=function(n,e){if(n)try{var t=n.getTime(),a=(new Date).getTime()-t,i=Math.floor(a/864e5);if(0===i){var o=a%864e5,s=Math.floor(o/36e5);if(0===s){var l=o%36e5,c=Math.floor(l/6e4);if(0===c){var u=l%6e4;return Math.round(u/1e3)+" "+e.timeago.seconds}return c+" "+e.timeago.minutes}return s+" "+e.timeago.hours}return i<0?e.timeago.now:i<8?i+" "+e.timeago.days:r(n)}catch(n){}}},function(n,e,t){var r;!function(a){"use strict";function i(n,e){var t=(65535&n)+(65535&e);return(n>>16)+(e>>16)+(t>>16)<<16|65535&t}function o(n,e,t,r,a,o){return i(function(n,e){return n<<e|n>>>32-e}(i(i(e,n),i(r,o)),a),t)}function s(n,e,t,r,a,i,s){return o(e&t|~e&r,n,e,a,i,s)}function l(n,e,t,r,a,i,s){return o(e&r|t&~r,n,e,a,i,s)}function c(n,e,t,r,a,i,s){return o(e^t^r,n,e,a,i,s)}function u(n,e,t,r,a,i,s){return o(t^(e|~r),n,e,a,i,s)}function d(n,e){n[e>>5]|=128<<e%32,n[14+(e+64>>>9<<4)]=e;var t,r,a,o,d,p=1732584193,h=-271733879,f=-1732584194,v=271733878;for(t=0;t<n.length;t+=16)r=p,a=h,o=f,d=v,p=s(p,h,f,v,n[t],7,-680876936),v=s(v,p,h,f,n[t+1],12,-389564586),f=s(f,v,p,h,n[t+2],17,606105819),h=s(h,f,v,p,n[t+3],22,-1044525330),p=s(p,h,f,v,n[t+4],7,-176418897),v=s(v,p,h,f,n[t+5],12,1200080426),f=s(f,v,p,h,n[t+6],17,-1473231341),h=s(h,f,v,p,n[t+7],22,-45705983),p=s(p,h,f,v,n[t+8],7,1770035416),v=s(v,p,h,f,n[t+9],12,-1958414417),f=s(f,v,p,h,n[t+10],17,-42063),h=s(h,f,v,p,n[t+11],22,-1990404162),p=s(p,h,f,v,n[t+12],7,1804603682),v=s(v,p,h,f,n[t+13],12,-40341101),f=s(f,v,p,h,n[t+14],17,-1502002290),p=l(p,h=s(h,f,v,p,n[t+15],22,1236535329),f,v,n[t+1],5,-165796510),v=l(v,p,h,f,n[t+6],9,-1069501632),f=l(f,v,p,h,n[t+11],14,643717713),h=l(h,f,v,p,n[t],20,-373897302),p=l(p,h,f,v,n[t+5],5,-701558691),v=l(v,p,h,f,n[t+10],9,38016083),f=l(f,v,p,h,n[t+15],14,-660478335),h=l(h,f,v,p,n[t+4],20,-405537848),p=l(p,h,f,v,n[t+9],5,568446438),v=l(v,p,h,f,n[t+14],9,-1019803690),f=l(f,v,p,h,n[t+3],14,-187363961),h=l(h,f,v,p,n[t+8],20,1163531501),p=l(p,h,f,v,n[t+13],5,-1444681467),v=l(v,p,h,f,n[t+2],9,-51403784),f=l(f,v,p,h,n[t+7],14,1735328473),p=c(p,h=l(h,f,v,p,n[t+12],20,-1926607734),f,v,n[t+5],4,-378558),v=c(v,p,h,f,n[t+8],11,-2022574463),f=c(f,v,p,h,n[t+11],16,1839030562),h=c(h,f,v,p,n[t+14],23,-35309556),p=c(p,h,f,v,n[t+1],4,-1530992060),v=c(v,p,h,f,n[t+4],11,1272893353),f=c(f,v,p,h,n[t+7],16,-155497632),h=c(h,f,v,p,n[t+10],23,-1094730640),p=c(p,h,f,v,n[t+13],4,681279174),v=c(v,p,h,f,n[t],11,-358537222),f=c(f,v,p,h,n[t+3],16,-722521979),h=c(h,f,v,p,n[t+6],23,76029189),p=c(p,h,f,v,n[t+9],4,-640364487),v=c(v,p,h,f,n[t+12],11,-421815835),f=c(f,v,p,h,n[t+15],16,530742520),p=u(p,h=c(h,f,v,p,n[t+2],23,-995338651),f,v,n[t],6,-198630844),v=u(v,p,h,f,n[t+7],10,1126891415),f=u(f,v,p,h,n[t+14],15,-1416354905),h=u(h,f,v,p,n[t+5],21,-57434055),p=u(p,h,f,v,n[t+12],6,1700485571),v=u(v,p,h,f,n[t+3],10,-1894986606),f=u(f,v,p,h,n[t+10],15,-1051523),h=u(h,f,v,p,n[t+1],21,-2054922799),p=u(p,h,f,v,n[t+8],6,1873313359),v=u(v,p,h,f,n[t+15],10,-30611744),f=u(f,v,p,h,n[t+6],15,-1560198380),h=u(h,f,v,p,n[t+13],21,1309151649),p=u(p,h,f,v,n[t+4],6,-145523070),v=u(v,p,h,f,n[t+11],10,-1120210379),f=u(f,v,p,h,n[t+2],15,718787259),h=u(h,f,v,p,n[t+9],21,-343485551),p=i(p,r),h=i(h,a),f=i(f,o),v=i(v,d);return[p,h,f,v]}function p(n){var e,t="",r=32*n.length;for(e=0;e<r;e+=8)t+=String.fromCharCode(n[e>>5]>>>e%32&255);return t}function h(n){var e,t=[];for(t[(n.length>>2)-1]=void 0,e=0;e<t.length;e+=1)t[e]=0;var r=8*n.length;for(e=0;e<r;e+=8)t[e>>5]|=(255&n.charCodeAt(e/8))<<e%32;return t}function f(n){var e,t,r="0123456789abcdef",a="";for(t=0;t<n.length;t+=1)e=n.charCodeAt(t),a+=r.charAt(e>>>4&15)+r.charAt(15&e);return a}function v(n){return unescape(encodeURIComponent(n))}function m(n){return function(n){return p(d(h(n),8*n.length))}(v(n))}function g(n,e){return function(n,e){var t,r,a=h(n),i=[],o=[];for(i[15]=o[15]=void 0,a.length>16&&(a=d(a,8*n.length)),t=0;t<16;t+=1)i[t]=909522486^a[t],o[t]=1549556828^a[t];return r=d(i.concat(h(e)),512+8*e.length),p(d(o.concat(r),640))}(v(n),v(e))}function y(n,e,t){return e?t?g(e,n):function(n,e){return f(g(n,e))}(e,n):t?m(n):function(n){return f(m(n))}(n)}void 0!==(r=function(){return y}.call(e,t,e,n))&&(n.exports=r)}()},function(n,e,t){n.exports=function(){"use strict";var n=function(n,e){return function(n){var e=n.exports=function(){return new RegExp("(?:"+e.line().source+")|(?:"+e.block().source+")","gm")};e.line=function(){return/(?:^|\s)\/\/(.+?)$/gm},e.block=function(){return/\/\*([\S\s]*?)\*\//gm}}(e={exports:{}}),e.exports}(),e=["23AC69","91C132","F19726","E8552D","1AAB8E","E1147F","2980C1","1BA1E6","9FA0A0","F19726","E30B20","E30B20","A3338B"];return function(t,r){void 0===r&&(r={});var a=r.colors;void 0===a&&(a=e);var i=0,o={},s=new RegExp("("+/[\u4E00-\u9FFF\u3400-\u4dbf\uf900-\ufaff\u3040-\u309f\uac00-\ud7af\u0400-\u04FF]+|\w+/.source+"|"+/</.source+")|("+n().source+")","gmi");return t.replace(s,(function(n,e,t){if(t)return function(n){return'<span style="color: slategray">'+n+"</span>"}(t);if("<"===e)return"&lt;";var r;o[e]?r=o[e]:(r=a[i],o[e]=r);var s='<span style="color: #'+r+'">'+e+"</span>";return i=++i%a.length,s}))}}()},function(n,e,t){(function(e){!function(e){"use strict";function t(n){this.tokens=[],this.tokens.links={},this.options=n||f.defaults,this.rules=v.normal,this.options.pedantic?this.rules=v.pedantic:this.options.gfm&&(this.options.tables?this.rules=v.tables:this.rules=v.gfm)}function r(n,e){if(this.options=e||f.defaults,this.links=n,this.rules=m.normal,this.renderer=this.options.renderer||new a,this.renderer.options=this.options,!this.links)throw new Error("Tokens array requires a `links` property.");this.options.pedantic?this.rules=m.pedantic:this.options.gfm&&(this.options.breaks?this.rules=m.breaks:this.rules=m.gfm)}function a(n){this.options=n||f.defaults}function i(){}function o(n){this.tokens=[],this.token=null,this.options=n||f.defaults,this.options.renderer=this.options.renderer||new a,this.renderer=this.options.renderer,this.renderer.options=this.options}function s(n,e){return n.replace(e?/&/g:/&(?!#?\w+;)/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;")}function l(n){return n.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi,(function(n,e){return"colon"===(e=e.toLowerCase())?":":"#"===e.charAt(0)?"x"===e.charAt(1)?String.fromCharCode(parseInt(e.substring(2),16)):String.fromCharCode(+e.substring(1)):""}))}function c(n,e){return n=n.source||n,e=e||"",{replace:function(e,t){return t=(t=t.source||t).replace(/(^|[^\[])\^/g,"$1"),n=n.replace(e,t),this},getRegex:function(){return new RegExp(n,e)}}}function u(n,e){return g[" "+n]||(/^[^:]+:\/*[^\/]*$/.test(n)?g[" "+n]=n+"/":g[" "+n]=n.replace(/[^\/]*$/,"")),n=g[" "+n],"//"===e.slice(0,2)?n.replace(/:[\s\S]*/,":")+e:"/"===e.charAt(0)?n.replace(/(:\/*[^\/]*)[\s\S]*/,"$1")+e:n+e}function d(){}function p(n){for(var e,t,r=1;r<arguments.length;r++)for(t in e=arguments[r])Object.prototype.hasOwnProperty.call(e,t)&&(n[t]=e[t]);return n}function h(n,e){var t=n.replace(/([^\\])\|/g,"$1 |").split(/ +\| */),r=0;if(t.length>e)t.splice(e);else for(;t.length<e;)t.push("");for(;r<t.length;r++)t[r]=t[r].replace(/\\\|/g,"|");return t}function f(n,e,r){if(null==n)throw new Error("marked(): input parameter is undefined or null");if("string"!=typeof n)throw new Error("marked(): input parameter is of type "+Object.prototype.toString.call(n)+", string expected");if(r||"function"==typeof e){r||(r=e,e=null);var a,i,l=(e=p({},f.defaults,e||{})).highlight,c=0;try{a=t.lex(n,e)}catch(n){return r(n)}i=a.length;var u=function(n){if(n)return e.highlight=l,r(n);var t;try{t=o.parse(a,e)}catch(e){n=e}return e.highlight=l,n?r(n):r(null,t)};if(!l||l.length<3)return u();if(delete e.highlight,!i)return u();for(;c<a.length;c++)!function(n){"code"!==n.type?--i||u():l(n.text,n.lang,(function(e,t){return e?u(e):null==t||t===n.text?--i||u():(n.text=t,n.escaped=!0,void(--i||u()))}))}(a[c])}else try{return e&&(e=p({},f.defaults,e)),o.parse(t.lex(n,e),e)}catch(n){if(n.message+="\nPlease report this to https://github.com/markedjs/marked.",(e||f.defaults).silent)return"<p>An error occurred:</p><pre>"+s(n.message+"",!0)+"</pre>";throw n}}var v={newline:/^\n+/,code:/^( {4}[^\n]+\n*)+/,fences:d,hr:/^ {0,3}((?:- *){3,}|(?:_ *){3,}|(?:\* *){3,})(?:\n+|$)/,heading:/^ *(#{1,6}) *([^\n]+?) *(?:#+ *)?(?:\n+|$)/,nptable:d,blockquote:/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/,list:/^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,html:"^ {0,3}(?:<(script|pre|style)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?\\?>\\n*|<![A-Z][\\s\\S]*?>\\n*|<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\n*|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:\\n{2,}|$)|<(?!script|pre|style)([a-z][\\w-]*)(?:attribute)*? */?>(?=\\h*\\n)[\\s\\S]*?(?:\\n{2,}|$)|</(?!script|pre|style)[a-z][\\w-]*\\s*>(?=\\h*\\n)[\\s\\S]*?(?:\\n{2,}|$))",def:/^ {0,3}\[(label)\]: *\n? *<?([^\s>]+)>?(?:(?: +\n? *| *\n *)(title))? *(?:\n+|$)/,table:d,lheading:/^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,paragraph:/^([^\n]+(?:\n(?!hr|heading|lheading| {0,3}>|<\/?(?:tag)(?: +|\n|\/?>)|<(?:script|pre|style|!--))[^\n]+)*)/,text:/^[^\n]+/,_label:/(?!\s*\])(?:\\[\[\]]|[^\[\]])+/,_title:/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/};v.def=c(v.def).replace("label",v._label).replace("title",v._title).getRegex(),v.bullet=/(?:[*+-]|\d+\.)/,v.item=/^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/,v.item=c(v.item,"gm").replace(/bull/g,v.bullet).getRegex(),v.list=c(v.list).replace(/bull/g,v.bullet).replace("hr","\\n+(?=\\1?(?:(?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$))").replace("def","\\n+(?="+v.def.source+")").getRegex(),v._tag="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",v._comment=/<!--(?!-?>)[\s\S]*?-->/,v.html=c(v.html,"i").replace("comment",v._comment).replace("tag",v._tag).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),v.paragraph=c(v.paragraph).replace("hr",v.hr).replace("heading",v.heading).replace("lheading",v.lheading).replace("tag",v._tag).getRegex(),v.blockquote=c(v.blockquote).replace("paragraph",v.paragraph).getRegex(),v.normal=p({},v),v.gfm=p({},v.normal,{fences:/^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\n? *\1 *(?:\n+|$)/,paragraph:/^/,heading:/^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/}),v.gfm.paragraph=c(v.paragraph).replace("(?!","(?!"+v.gfm.fences.source.replace("\\1","\\2")+"|"+v.list.source.replace("\\1","\\3")+"|").getRegex(),v.tables=p({},v.gfm,{nptable:/^ *([^|\n ].*\|.*)\n *([-:]+ *\|[-| :]*)(?:\n((?:.*[^>\n ].*(?:\n|$))*)\n*|$)/,table:/^ *\|(.+)\n *\|?( *[-:]+[-| :]*)(?:\n((?: *[^>\n ].*(?:\n|$))*)\n*|$)/}),v.pedantic=p({},v.normal,{html:c("^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\s[^'\"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))").replace("comment",v._comment).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/}),t.rules=v,t.lex=function(n,e){return new t(e).lex(n)},t.prototype.lex=function(n){return n=n.replace(/\r\n|\r/g,"\n").replace(/\t/g,"    ").replace(/\u00a0/g," ").replace(/\u2424/g,"\n"),this.token(n,!0)},t.prototype.token=function(n,e){n=n.replace(/^ +$/gm,"");for(var t,r,a,i,o,s,l,c,u,d,p,f,m;n;)if((a=this.rules.newline.exec(n))&&(n=n.substring(a[0].length),a[0].length>1&&this.tokens.push({type:"space"})),a=this.rules.code.exec(n))n=n.substring(a[0].length),a=a[0].replace(/^ {4}/gm,""),this.tokens.push({type:"code",text:this.options.pedantic?a:a.replace(/\n+$/,"")});else if(a=this.rules.fences.exec(n))n=n.substring(a[0].length),this.tokens.push({type:"code",lang:a[2],text:a[3]||""});else if(a=this.rules.heading.exec(n))n=n.substring(a[0].length),this.tokens.push({type:"heading",depth:a[1].length,text:a[2]});else if(e&&(a=this.rules.nptable.exec(n))&&(s={type:"table",header:h(a[1].replace(/^ *| *\| *$/g,"")),align:a[2].replace(/^ *|\| *$/g,"").split(/ *\| */),cells:a[3]?a[3].replace(/\n$/,"").split("\n"):[]}).header.length===s.align.length){for(n=n.substring(a[0].length),c=0;c<s.align.length;c++)/^ *-+: *$/.test(s.align[c])?s.align[c]="right":/^ *:-+: *$/.test(s.align[c])?s.align[c]="center":/^ *:-+ *$/.test(s.align[c])?s.align[c]="left":s.align[c]=null;for(c=0;c<s.cells.length;c++)s.cells[c]=h(s.cells[c],s.header.length);this.tokens.push(s)}else if(a=this.rules.hr.exec(n))n=n.substring(a[0].length),this.tokens.push({type:"hr"});else if(a=this.rules.blockquote.exec(n))n=n.substring(a[0].length),this.tokens.push({type:"blockquote_start"}),a=a[0].replace(/^ *> ?/gm,""),this.token(a,e),this.tokens.push({type:"blockquote_end"});else if(a=this.rules.list.exec(n)){for(n=n.substring(a[0].length),p=(i=a[2]).length>1,this.tokens.push({type:"list_start",ordered:p,start:p?+i:""}),t=!1,d=(a=a[0].match(this.rules.item)).length,c=0;c<d;c++)l=(s=a[c]).length,~(s=s.replace(/^ *([*+-]|\d+\.) +/,"")).indexOf("\n ")&&(l-=s.length,s=this.options.pedantic?s.replace(/^ {1,4}/gm,""):s.replace(new RegExp("^ {1,"+l+"}","gm"),"")),this.options.smartLists&&c!==d-1&&(i===(o=v.bullet.exec(a[c+1])[0])||i.length>1&&o.length>1||(n=a.slice(c+1).join("\n")+n,c=d-1)),r=t||/\n\n(?!\s*$)/.test(s),c!==d-1&&(t="\n"===s.charAt(s.length-1),r||(r=t)),m=void 0,(f=/^\[[ xX]\] /.test(s))&&(m=" "!==s[1],s=s.replace(/^\[[ xX]\] +/,"")),this.tokens.push({type:r?"loose_item_start":"list_item_start",task:f,checked:m}),this.token(s,!1),this.tokens.push({type:"list_item_end"});this.tokens.push({type:"list_end"})}else if(a=this.rules.html.exec(n))n=n.substring(a[0].length),this.tokens.push({type:this.options.sanitize?"paragraph":"html",pre:!this.options.sanitizer&&("pre"===a[1]||"script"===a[1]||"style"===a[1]),text:a[0]});else if(e&&(a=this.rules.def.exec(n)))n=n.substring(a[0].length),a[3]&&(a[3]=a[3].substring(1,a[3].length-1)),u=a[1].toLowerCase().replace(/\s+/g," "),this.tokens.links[u]||(this.tokens.links[u]={href:a[2],title:a[3]});else if(e&&(a=this.rules.table.exec(n))&&(s={type:"table",header:h(a[1].replace(/^ *| *\| *$/g,"")),align:a[2].replace(/^ *|\| *$/g,"").split(/ *\| */),cells:a[3]?a[3].replace(/(?: *\| *)?\n$/,"").split("\n"):[]}).header.length===s.align.length){for(n=n.substring(a[0].length),c=0;c<s.align.length;c++)/^ *-+: *$/.test(s.align[c])?s.align[c]="right":/^ *:-+: *$/.test(s.align[c])?s.align[c]="center":/^ *:-+ *$/.test(s.align[c])?s.align[c]="left":s.align[c]=null;for(c=0;c<s.cells.length;c++)s.cells[c]=h(s.cells[c].replace(/^ *\| *| *\| *$/g,""),s.header.length);this.tokens.push(s)}else if(a=this.rules.lheading.exec(n))n=n.substring(a[0].length),this.tokens.push({type:"heading",depth:"="===a[2]?1:2,text:a[1]});else if(e&&(a=this.rules.paragraph.exec(n)))n=n.substring(a[0].length),this.tokens.push({type:"paragraph",text:"\n"===a[1].charAt(a[1].length-1)?a[1].slice(0,-1):a[1]});else if(a=this.rules.text.exec(n))n=n.substring(a[0].length),this.tokens.push({type:"text",text:a[0]});else if(n)throw new Error("Infinite loop on byte: "+n.charCodeAt(0));return this.tokens};var m={escape:/^\\([!"#$%&'()*+,\-.\/:;<=>?@\[\]\\^_`{|}~])/,autolink:/^<(scheme:[^\s\x00-\x1f<>]*|email)>/,url:d,tag:"^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",link:/^!?\[(label)\]\(href(?:\s+(title))?\s*\)/,reflink:/^!?\[(label)\]\[(?!\s*\])((?:\\[\[\]]?|[^\[\]\\])+)\]/,nolink:/^!?\[(?!\s*\])((?:\[[^\[\]]*\]|\\[\[\]]|[^\[\]])*)\](?:\[\])?/,strong:/^__([^\s][\s\S]*?[^\s])__(?!_)|^\*\*([^\s][\s\S]*?[^\s])\*\*(?!\*)|^__([^\s])__(?!_)|^\*\*([^\s])\*\*(?!\*)/,em:/^_([^\s][\s\S]*?[^\s_])_(?!_)|^_([^\s_][\s\S]*?[^\s])_(?!_)|^\*([^\s][\s\S]*?[^\s*])\*(?!\*)|^\*([^\s*][\s\S]*?[^\s])\*(?!\*)|^_([^\s_])_(?!_)|^\*([^\s*])\*(?!\*)/,code:/^(`+)\s*([\s\S]*?[^`]?)\s*\1(?!`)/,br:/^ {2,}\n(?!\s*$)/,del:d,text:/^[\s\S]+?(?=[\\<!\[`*]|\b_| {2,}\n|$)/,_escapes:/\\([!"#$%&'()*+,\-.\/:;<=>?@\[\]\\^_`{|}~])/g,_scheme:/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/,_email:/[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/};m.autolink=c(m.autolink).replace("scheme",m._scheme).replace("email",m._email).getRegex(),m._attribute=/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/,m.tag=c(m.tag).replace("comment",v._comment).replace("attribute",m._attribute).getRegex(),m._label=/(?:\[[^\[\]]*\]|\\[\[\]]?|`[^`]*`|[^\[\]\\])*?/,m._href=/\s*(<(?:\\[<>]?|[^\s<>\\])*>|(?:\\[()]?|\([^\s\x00-\x1f()\\]*\)|[^\s\x00-\x1f()\\])*?)/,m._title=/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/,m.link=c(m.link).replace("label",m._label).replace("href",m._href).replace("title",m._title).getRegex(),m.reflink=c(m.reflink).replace("label",m._label).getRegex(),m.normal=p({},m),m.pedantic=p({},m.normal,{strong:/^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,em:/^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/,link:c(/^!?\[(label)\]\((.*?)\)/).replace("label",m._label).getRegex(),reflink:c(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",m._label).getRegex()}),m.gfm=p({},m.normal,{escape:c(m.escape).replace("])","~|])").getRegex(),url:c(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("email",m._email).getRegex(),_backpedal:/(?:[^?!.,:;*_~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_~)]+(?!$))+/,del:/^~~(?=\S)([\s\S]*?\S)~~/,text:c(m.text).replace("]|","~]|").replace("|","|https?://|ftp://|www\\.|[a-zA-Z0-9.!#$%&'*+/=?^_`{\\|}~-]+@|").getRegex()}),m.breaks=p({},m.gfm,{br:c(m.br).replace("{2,}","*").getRegex(),text:c(m.gfm.text).replace("{2,}","*").getRegex()}),r.rules=m,r.output=function(n,e,t){return new r(e,t).output(n)},r.prototype.output=function(n){for(var e,t,a,i,o,l="";n;)if(o=this.rules.escape.exec(n))n=n.substring(o[0].length),l+=o[1];else if(o=this.rules.autolink.exec(n))n=n.substring(o[0].length),a="@"===o[2]?"mailto:"+(t=s(this.mangle(o[1]))):t=s(o[1]),l+=this.renderer.link(a,null,t);else if(this.inLink||!(o=this.rules.url.exec(n))){if(o=this.rules.tag.exec(n))!this.inLink&&/^<a /i.test(o[0])?this.inLink=!0:this.inLink&&/^<\/a>/i.test(o[0])&&(this.inLink=!1),n=n.substring(o[0].length),l+=this.options.sanitize?this.options.sanitizer?this.options.sanitizer(o[0]):s(o[0]):o[0];else if(o=this.rules.link.exec(n))n=n.substring(o[0].length),this.inLink=!0,a=o[2],this.options.pedantic?(e=/^([^'"]*[^\s])\s+(['"])(.*)\2/.exec(a))?(a=e[1],i=e[3]):i="":i=o[3]?o[3].slice(1,-1):"",a=a.trim().replace(/^<([\s\S]*)>$/,"$1"),l+=this.outputLink(o,{href:r.escapes(a),title:r.escapes(i)}),this.inLink=!1;else if((o=this.rules.reflink.exec(n))||(o=this.rules.nolink.exec(n))){if(n=n.substring(o[0].length),e=(o[2]||o[1]).replace(/\s+/g," "),!(e=this.links[e.toLowerCase()])||!e.href){l+=o[0].charAt(0),n=o[0].substring(1)+n;continue}this.inLink=!0,l+=this.outputLink(o,e),this.inLink=!1}else if(o=this.rules.strong.exec(n))n=n.substring(o[0].length),l+=this.renderer.strong(this.output(o[4]||o[3]||o[2]||o[1]));else if(o=this.rules.em.exec(n))n=n.substring(o[0].length),l+=this.renderer.em(this.output(o[6]||o[5]||o[4]||o[3]||o[2]||o[1]));else if(o=this.rules.code.exec(n))n=n.substring(o[0].length),l+=this.renderer.codespan(s(o[2].trim(),!0));else if(o=this.rules.br.exec(n))n=n.substring(o[0].length),l+=this.renderer.br();else if(o=this.rules.del.exec(n))n=n.substring(o[0].length),l+=this.renderer.del(this.output(o[1]));else if(o=this.rules.text.exec(n))n=n.substring(o[0].length),l+=this.renderer.text(s(this.smartypants(o[0])));else if(n)throw new Error("Infinite loop on byte: "+n.charCodeAt(0))}else o[0]=this.rules._backpedal.exec(o[0])[0],n=n.substring(o[0].length),"@"===o[2]?a="mailto:"+(t=s(o[0])):(t=s(o[0]),a="www."===o[1]?"http://"+t:t),l+=this.renderer.link(a,null,t);return l},r.escapes=function(n){return n?n.replace(r.rules._escapes,"$1"):n},r.prototype.outputLink=function(n,e){var t=e.href,r=e.title?s(e.title):null;return"!"!==n[0].charAt(0)?this.renderer.link(t,r,this.output(n[1])):this.renderer.image(t,r,s(n[1]))},r.prototype.smartypants=function(n){return this.options.smartypants?n.replace(/---/g,"—").replace(/--/g,"–").replace(/(^|[-\u2014\/(\[{"\s])'/g,"$1‘").replace(/'/g,"’").replace(/(^|[-\u2014\/(\[{\u2018\s])"/g,"$1“").replace(/"/g,"”").replace(/\.{3}/g,"…"):n},r.prototype.mangle=function(n){if(!this.options.mangle)return n;for(var e,t="",r=n.length,a=0;a<r;a++)e=n.charCodeAt(a),Math.random()>.5&&(e="x"+e.toString(16)),t+="&#"+e+";";return t},a.prototype.code=function(n,e,t){if(this.options.highlight){var r=this.options.highlight(n,e);null!=r&&r!==n&&(t=!0,n=r)}return e?'<pre><code class="'+this.options.langPrefix+s(e,!0)+'">'+(t?n:s(n,!0))+"</code></pre>\n":"<pre><code>"+(t?n:s(n,!0))+"</code></pre>"},a.prototype.blockquote=function(n){return"<blockquote>\n"+n+"</blockquote>\n"},a.prototype.html=function(n){return n},a.prototype.heading=function(n,e,t){return this.options.headerIds?"<h"+e+' id="'+this.options.headerPrefix+t.toLowerCase().replace(/[^\w]+/g,"-")+'">'+n+"</h"+e+">\n":"<h"+e+">"+n+"</h"+e+">\n"},a.prototype.hr=function(){return this.options.xhtml?"<hr/>\n":"<hr>\n"},a.prototype.list=function(n,e,t){var r=e?"ol":"ul";return"<"+r+(e&&1!==t?' start="'+t+'"':"")+">\n"+n+"</"+r+">\n"},a.prototype.listitem=function(n){return"<li>"+n+"</li>\n"},a.prototype.checkbox=function(n){return"<input "+(n?'checked="" ':"")+'disabled="" type="checkbox"'+(this.options.xhtml?" /":"")+"> "},a.prototype.paragraph=function(n){return"<p>"+n+"</p>\n"},a.prototype.table=function(n,e){return e&&(e="<tbody>"+e+"</tbody>"),"<table>\n<thead>\n"+n+"</thead>\n"+e+"</table>\n"},a.prototype.tablerow=function(n){return"<tr>\n"+n+"</tr>\n"},a.prototype.tablecell=function(n,e){var t=e.header?"th":"td";return(e.align?"<"+t+' align="'+e.align+'">':"<"+t+">")+n+"</"+t+">\n"},a.prototype.strong=function(n){return"<strong>"+n+"</strong>"},a.prototype.em=function(n){return"<em>"+n+"</em>"},a.prototype.codespan=function(n){return"<code>"+n+"</code>"},a.prototype.br=function(){return this.options.xhtml?"<br/>":"<br>"},a.prototype.del=function(n){return"<del>"+n+"</del>"},a.prototype.link=function(n,e,t){if(this.options.sanitize){try{var r=decodeURIComponent(l(n)).replace(/[^\w:]/g,"").toLowerCase()}catch(n){return t}if(0===r.indexOf("javascript:")||0===r.indexOf("vbscript:")||0===r.indexOf("data:"))return t}this.options.baseUrl&&!y.test(n)&&(n=u(this.options.baseUrl,n));try{n=encodeURI(n).replace(/%25/g,"%")}catch(n){return t}var a='<a href="'+s(n)+'"';return e&&(a+=' title="'+e+'"'),a+">"+t+"</a>"},a.prototype.image=function(n,e,t){this.options.baseUrl&&!y.test(n)&&(n=u(this.options.baseUrl,n));var r='<img src="'+n+'" alt="'+t+'"';return e&&(r+=' title="'+e+'"'),r+(this.options.xhtml?"/>":">")},a.prototype.text=function(n){return n},i.prototype.strong=i.prototype.em=i.prototype.codespan=i.prototype.del=i.prototype.text=function(n){return n},i.prototype.link=i.prototype.image=function(n,e,t){return""+t},i.prototype.br=function(){return""},o.parse=function(n,e){return new o(e).parse(n)},o.prototype.parse=function(n){this.inline=new r(n.links,this.options),this.inlineText=new r(n.links,p({},this.options,{renderer:new i})),this.tokens=n.reverse();for(var e="";this.next();)e+=this.tok();return e},o.prototype.next=function(){return this.token=this.tokens.pop()},o.prototype.peek=function(){return this.tokens[this.tokens.length-1]||0},o.prototype.parseText=function(){for(var n=this.token.text;"text"===this.peek().type;)n+="\n"+this.next().text;return this.inline.output(n)},o.prototype.tok=function(){switch(this.token.type){case"space":return"";case"hr":return this.renderer.hr();case"heading":return this.renderer.heading(this.inline.output(this.token.text),this.token.depth,l(this.inlineText.output(this.token.text)));case"code":return this.renderer.code(this.token.text,this.token.lang,this.token.escaped);case"table":var n,e,t,r,a="",i="";for(t="",n=0;n<this.token.header.length;n++)t+=this.renderer.tablecell(this.inline.output(this.token.header[n]),{header:!0,align:this.token.align[n]});for(a+=this.renderer.tablerow(t),n=0;n<this.token.cells.length;n++){for(e=this.token.cells[n],t="",r=0;r<e.length;r++)t+=this.renderer.tablecell(this.inline.output(e[r]),{header:!1,align:this.token.align[r]});i+=this.renderer.tablerow(t)}return this.renderer.table(a,i);case"blockquote_start":for(i="";"blockquote_end"!==this.next().type;)i+=this.tok();return this.renderer.blockquote(i);case"list_start":i="";for(var o=this.token.ordered,s=this.token.start;"list_end"!==this.next().type;)i+=this.tok();return this.renderer.list(i,o,s);case"list_item_start":for(i="",this.token.task&&(i+=this.renderer.checkbox(this.token.checked));"list_item_end"!==this.next().type;)i+="text"===this.token.type?this.parseText():this.tok();return this.renderer.listitem(i);case"loose_item_start":for(i="";"list_item_end"!==this.next().type;)i+=this.tok();return this.renderer.listitem(i);case"html":return this.renderer.html(this.token.text);case"paragraph":return this.renderer.paragraph(this.inline.output(this.token.text));case"text":return this.renderer.paragraph(this.parseText())}};var g={},y=/^$|^[a-z][a-z0-9+.-]*:|^[?#]/i;d.exec=d,f.options=f.setOptions=function(n){return p(f.defaults,n),f},f.getDefaults=function(){return{baseUrl:null,breaks:!1,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,langPrefix:"language-",mangle:!0,pedantic:!1,renderer:new a,sanitize:!1,sanitizer:null,silent:!1,smartLists:!1,smartypants:!1,tables:!0,xhtml:!1}},f.defaults=f.getDefaults(),f.Parser=o,f.parser=o.parse,f.Renderer=a,f.TextRenderer=i,f.Lexer=t,f.lexer=t.lex,f.InlineLexer=r,f.inlineLexer=r.output,f.parse=f,n.exports=f}(this||"undefined"!=typeof window&&window)}).call(e,t(10))},function(n,e){n.exports={name:"valine",version:"1.3.6",description:"A simple comment system based on Leancloud.",main:"/dist/Valine.min.js",author:"xCss <xioveliu@gmail.com> (https://github.com/xCss)",scripts:{test:"webpack",build:"webpack",dev:"webpack-dev-server --env.dev",clean:"rm -rf dist/* "},keywords:["simple","easy-to-use","fast-and-safe","comment-system"],license:"GPL-2.0",repository:{type:"git",url:"git+https://github.com/xcss/Valine.git"},homepage:"https://github.com/xcss/Valine#readme",devDependencies:{autoprefixer:"^7.1.1",autosize:"^4.0.2","babel-core":"^6.25.0","babel-loader":"^7.1.1","babel-polyfill":"^6.23.0","babel-preset-es2015":"^6.24.1","babel-preset-stage-0":"^6.24.1","blueimp-md5":"^2.8.0","css-loader":"^0.28.4","exports-loader":"^0.6.3","file-loader":"^0.11.2",hanabi:"^0.4.0",marked:"^0.4.0","node-sass":"^4.9.2","postcss-loader":"^2.0.5","sass-loader":"^6.0.3","style-loader":"^0.18.2","url-loader":"^0.6.2",webpack:"^2.6.1","webpack-cli":"^3.3.0","webpack-dev-server":"^2.9.1"}}},function(n,e){var t;t=function(){return this}();try{t=t||Function("return this")()||(0,eval)("this")}catch(n){"object"==typeof window&&(t=window)}n.exports=t},function(n,e){n.exports={grinning:"😀",smiley:"😃",smile:"😄",grin:"😁",laughing:"😆",sweat_smile:"😅",joy:"😂",blush:"😊",innocent:"😇",wink:"😉",relieved:"😌",heart_eyes:"😍",kissing_heart:"😘",kissing:"😗",kissing_smiling_eyes:"😙",kissing_closed_eyes:"😚",yum:"😋",stuck_out_tongue_winking_eye:"😜",stuck_out_tongue_closed_eyes:"😝",stuck_out_tongue:"😛",sunglasses:"😎",smirk:"😏",unamused:"😒",disappointed:"😞",pensive:"😔",worried:"😟",confused:"😕",persevere:"😣",confounded:"😖",tired_face:"😫",weary:"😩",angry:"😠",rage:"😡",no_mouth:"😶",neutral_face:"😐",expressionless:"😑",hushed:"😯",frowning:"😦",anguished:"😧",open_mouth:"😮",astonished:"😲",dizzy_face:"😵",flushed:"😳",scream:"😱",fearful:"😨",cold_sweat:"😰",cry:"😢",disappointed_relieved:"😥",sob:"😭",sweat:"😓",sleepy:"😪",sleeping:"😴",mask:"😷",smiling_imp:"😈",smiley_cat:"😺",smile_cat:"😸",joy_cat:"😹",heart_eyes_cat:"😻",smirk_cat:"😼",kissing_cat:"😽",scream_cat:"🙀",crying_cat_face:"😿",pouting_cat:"😾",cat:"🐱",mouse:"🐭",cow:"🐮",monkey_face:"🐵",hand:"✋",fist:"✊",v:"✌️",point_up:"👆",point_down:"👇",point_left:"👈",point_right:"👉",facepunch:"👊",wave:"👋",clap:"👏",open_hands:"👐","+1":"👍","-1":"👎",ok_hand:"👌",pray:"🙏",ear:"👂",eyes:"👀",nose:"👃",lips:"👄",tongue:"👅",heart:"❤️",cupid:"💘",sparkling_heart:"💖",star:"⭐️",sparkles:"✨",zap:"⚡️",sunny:"☀️",cloud:"☁️",snowflake:"❄️",umbrella:"☔️",coffee:"☕️",airplane:"✈️",anchor:"⚓️",watch:"⌚️",phone:"☎️",hourglass:"⌛️",email:"✉️",scissors:"✂️",black_nib:"✒️",pencil2:"✏️",x:"❌",recycle:"♻️",white_check_mark:"✅",negative_squared_cross_mark:"❎",m:"Ⓜ️",i:"ℹ️",tm:"™️",copyright:"©️",registered:"®️"}},function(n,e,t){var r=t(13);"string"==typeof r&&(r=[[n.i,r,""]]);var a={transform:void 0};t(15)(r,a),r.locals&&(n.exports=r.locals)},function(n,e,t){(n.exports=t(14)(!1)).push([n.i,'.v *{-webkit-box-sizing:border-box;box-sizing:border-box;line-height:2;color:#555;-webkit-transition:all .3s ease;transition:all .3s ease}.v hr{margin:.825rem 0;border-color:#f6f6f6;border-style:dashed}.v.hide-avatar .vimg{display:none}.v a{position:relative;cursor:pointer;color:#1abc9c;display:inline-block}.v a:before{content:"";position:absolute;width:0;right:0;bottom:0;height:1px;background:#1abc9c;-webkit-transition:width .3s ease;transition:width .3s ease}.v a:hover{color:#d7191a}.v a:hover:before{width:100%;left:0;right:auto}.v code,.v pre{background-color:#f6f6f6;color:#555;padding:.2em .4em;border-radius:3px;font-size:85%;margin:0;font-family:Source Code Pro,courier new,Input Mono,PT Mono,SFMono-Regular,Consolas,Monaco,Menlo,PingFang SC,Liberation Mono,Microsoft YaHei,Courier，monospace}.v pre{padding:10px;overflow:auto;line-height:1.45}.v pre code{padding:0;background:transparent;white-space:pre-wrap;word-break:keep-all}.v blockquote{color:#666;margin:.5rem 0;padding:0 0 0 1rem;border-left:8px solid hsla(0,0%,93%,.5)}.v .vinput{border:none;resize:none;outline:none;padding:10px 5px;max-width:100%;font-size:.775rem}.v input[type=checkbox],.v input[type=radio]{display:inline-block;vertical-align:middle;margin-top:-2px}.v .vwrap{border:1px solid #f0f0f0;border-radius:4px;margin-bottom:10px;overflow:hidden;position:relative;padding:10px}.v .vwrap input{background:transparent}.v .vwrap .vedit{position:relative;padding-top:10px}.v .vwrap .vedit .vctrl{text-align:right;font-size:12px}.v .vwrap .vedit .vctrl span{padding:10px;display:inline-block;vertical-align:middle;cursor:pointer}.v .vwrap .vedit .vemojis{display:none;font-size:18px;text-align:justify;max-height:145px;overflow:auto;margin-bottom:10px;-webkit-box-shadow:0 0 1px #f0f0f0;box-shadow:0 0 1px #f0f0f0}.v .vwrap .vedit .vemojis i{font-style:normal;padding:7px 0;width:38px;cursor:pointer;text-align:center;display:inline-block;vertical-align:middle}.v .vwrap .vedit .vpreview{padding:7px;-webkit-box-shadow:0 0 1px #f0f0f0;box-shadow:0 0 1px #f0f0f0}.v .vwrap .vedit .vpreview frame,.v .vwrap .vedit .vpreview iframe,.v .vwrap .vedit .vpreview img{max-width:100%;border:none}.v .vwrap .vheader .vinput{width:33.33%;border-bottom:1px dashed #dedede}.v .vwrap .vheader.item2 .vinput{width:50%}.v .vwrap .vheader.item1 .vinput{width:100%}.v .vwrap .vheader .vinput:focus{border-bottom-color:#eb5055}@media screen and (max-width:520px){.v .vwrap .vheader.item2 .vinput,.v .vwrap .vheader .vinput{width:100%}}.v .vwrap .vcontrol{font-size:0;padding-top:15px}.v .vwrap .vcontrol .col{display:inline-block;font-size:.725rem;vertical-align:middle;color:#ccc}.v .vwrap .vcontrol .col.text-right{text-align:right}.v .vwrap .vcontrol .col svg{margin-right:2px;overflow:hidden;fill:currentColor;vertical-align:middle}.v .vwrap .vcontrol .col.col-20{width:20%}.v .vwrap .vcontrol .col.col-40{width:40%}.v .vwrap .vcontrol .col.col-60{width:60%}.v .vwrap .vcontrol .col.col-80{width:80%}.v .vwrap .vcontrol .col.split{width:50%}.v .vwrap .vmark{position:absolute;background:rgba(0,0,0,.65);width:100%;height:100%;left:0;top:0}.v .vwrap .vmark .valert{padding-top:3rem}.v .vwrap .vmark .valert .vtext{color:#fff;padding:1rem 0}.v .vwrap .vmark .valert .vcode{width:4.6875rem;border-radius:.3125rem;padding:.5rem;background:#dedede}.v .vwrap .vmark .valert .vcode:focus{border-color:#3090e4;background-color:#fff}@media screen and (max-width:720px){.v .vwrap .vmark .valert{padding-top:5.5rem}.v .vwrap .vmark .valert .vtext{color:#fff;padding:1rem 0}}.v .power{color:#999;padding:.5rem 0}.v .power,.v .power a{font-size:.75rem}.v .vinfo{font-size:0;padding:5px}.v .vinfo .col{font-size:.875rem;display:inline-block;width:50%;vertical-align:middle}.v .vinfo .vcount .vnum{font-weight:600;font-size:1.25rem}.v a{text-decoration:none;color:#555}.v a:hover{color:#222}.v ol,.v ul{padding:0;margin-left:1.25rem}.v .txt-center{text-align:center}.v .txt-right{text-align:right}.v .pd5{padding:5px}.v .pd10{padding:10px}.v .veditor{width:100%;min-height:8.75rem;font-size:.875rem;background:transparent;resize:vertical;-webkit-transition:all .25s ease;transition:all .25s ease}.v .vbtn{-webkit-transition-duration:.4s;transition-duration:.4s;text-align:center;color:#313131;border:1px solid #ededed;border-radius:.3rem;display:inline-block;background:#ededed;margin-bottom:0;font-weight:400;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;white-space:nowrap;padding:.5rem 1.25rem;font-size:.875rem;line-height:1.42857143;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;outline:none}.v .vbtn+.vbtn{margin-left:1.25rem}.v .vbtn:active,.v .vbtn:hover{color:#3090e4;border-color:#3090e4;background-color:#fff}.v .vempty{padding:1.25rem;text-align:center;color:#999}.v .vlist{width:100%}.v .vlist .vcard{padding-top:1.5rem;position:relative;display:block}.v .vlist .vcard:after{content:"";clear:both;display:block}.v .vlist .vcard .vimg{width:3.125rem;height:3.125rem;float:left;border-radius:50%;margin-right:.7525rem;border:1px solid #f5f5f5;padding:.125rem}@media screen and (max-width:720px){.v .vlist .vcard .vimg{width:2.5rem;height:2.5rem}}.v .vlist .vcard .vhead{line-height:1.5;margin-top:0}.v .vlist .vcard .vhead .vnick{position:relative;font-size:.875rem;font-weight:500;margin-right:.875rem;cursor:pointer;color:#1abc9c;text-decoration:none;display:inline-block}.v .vlist .vcard .vhead .vnick:before{content:"";position:absolute;width:0;right:0;bottom:0;height:1px;background:#1abc9c;-webkit-transition:width .3s ease;transition:width .3s ease}.v .vlist .vcard .vhead .vnick:hover{color:#d7191a}.v .vlist .vcard .vhead .vnick:hover:before{width:100%;left:0;right:auto}.v .vlist .vcard .vhead .vsys{display:inline-block;padding:.2rem .5rem;background:#ededed;color:#b3b1b1;font-size:.75rem;border-radius:.2rem;margin-right:.3rem}@media screen and (max-width:520px){.v .vlist .vcard .vhead .vsys{display:none}}.v .vlist .vcard .vh{overflow:hidden;padding-bottom:.5rem;border-bottom:1px dashed #f5f5f5}.v .vlist .vcard .vh .vtime{color:#b3b3b3;font-size:.75rem;margin-right:.875rem}.v .vlist .vcard .vh .vmeta{line-height:1;position:relative}.v .vlist .vcard .vh .vmeta .vat{font-size:.8125rem;color:#ef2f11;cursor:pointer;float:right}.v .vlist .vcard:last-child .vh{border-bottom:none}.v .vlist .vcard .vcontent{word-wrap:break-word;word-break:break-all;text-align:justify;color:#4a4a4a;font-size:.875rem;line-height:2;position:relative;margin-bottom:.75rem;padding-top:.625rem}.v .vlist .vcard .vcontent frame,.v .vlist .vcard .vcontent iframe,.v .vlist .vcard .vcontent img{max-width:100%;border:none}.v .vlist .vcard .vcontent.expand{cursor:pointer;max-height:11.25rem;overflow:hidden}.v .vlist .vcard .vcontent.expand:before{display:block;content:"";position:absolute;width:100%;left:0;top:0;bottom:3.15rem;pointer-events:none;background:-webkit-gradient(linear,left top,left bottom,from(hsla(0,0%,100%,0)),to(hsla(0,0%,100%,.9)));background:linear-gradient(180deg,hsla(0,0%,100%,0),hsla(0,0%,100%,.9))}.v .vlist .vcard .vcontent.expand:after{display:block;content:"Click on expand";text-align:center;color:#828586;position:absolute;width:100%;height:3.15rem;line-height:3.15rem;left:0;bottom:0;pointer-events:none;background:hsla(0,0%,100%,.9)}.v .vlist .vcard .vquote{color:#666;margin-top:1rem;padding-left:1rem;border-left:1px dashed hsla(0,0%,93%,.5)}.v .vlist .vcard .vquote .vimg{width:2.225rem;height:2.225rem}.v .vpage .vmore{margin:1rem 0}.v .clear{content:"";display:block;clear:both}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@-webkit-keyframes pulse{50%{background:#dcdcdc}}@keyframes pulse{50%{background:#dcdcdc}}.v .vloading{position:relative;padding:20px;display:block;height:80px}.v .vloading:before{-webkit-box-sizing:border-box;box-sizing:border-box;content:"";position:absolute;display:inline-block;top:20px;left:50%;margin-left:-20px;width:40px;height:40px;border:6px double #a0a0a0;border-top-color:transparent;border-bottom-color:transparent;border-radius:50%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}',""])},function(n,e){function t(n,e){var t=n[1]||"",r=n[3];if(!r)return t;if(e&&"function"==typeof btoa){var a=function(n){return"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(n))))+" */"}(r);return[t].concat(r.sources.map((function(n){return"/*# sourceURL="+r.sourceRoot+n+" */"}))).concat([a]).join("\n")}return[t].join("\n")}n.exports=function(n){var e=[];return e.toString=function(){return this.map((function(e){var r=t(e,n);return e[2]?"@media "+e[2]+"{"+r+"}":r})).join("")},e.i=function(n,t){"string"==typeof n&&(n=[[null,n,""]]);for(var r={},a=0;a<this.length;a++){var i=this[a][0];"number"==typeof i&&(r[i]=!0)}for(a=0;a<n.length;a++){var o=n[a];"number"==typeof o[0]&&r[o[0]]||(t&&!o[2]?o[2]=t:t&&(o[2]="("+o[2]+") and ("+t+")"),e.push(o))}},e}},function(n,e,t){function r(n,e){for(var t=0;t<n.length;t++){var r=n[t],a=f[r.id];if(a){a.refs++;for(var i=0;i<a.parts.length;i++)a.parts[i](r.parts[i]);for(;i<r.parts.length;i++)a.parts.push(u(r.parts[i],e))}else{var o=[];for(i=0;i<r.parts.length;i++)o.push(u(r.parts[i],e));f[r.id]={id:r.id,refs:1,parts:o}}}}function a(n,e){for(var t=[],r={},a=0;a<n.length;a++){var i=n[a],o=e.base?i[0]+e.base:i[0],s={css:i[1],media:i[2],sourceMap:i[3]};r[o]?r[o].parts.push(s):t.push(r[o]={id:o,parts:[s]})}return t}function i(n,e){var t=m(n.insertInto);if(!t)throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");var r=b[b.length-1];if("top"===n.insertAt)r?r.nextSibling?t.insertBefore(e,r.nextSibling):t.appendChild(e):t.insertBefore(e,t.firstChild),b.push(e);else{if("bottom"!==n.insertAt)throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");t.appendChild(e)}}function o(n){if(null===n.parentNode)return!1;n.parentNode.removeChild(n);var e=b.indexOf(n);e>=0&&b.splice(e,1)}function s(n){var e=document.createElement("style");return n.attrs.type="text/css",c(e,n.attrs),i(n,e),e}function l(n){var e=document.createElement("link");return n.attrs.type="text/css",n.attrs.rel="stylesheet",c(e,n.attrs),i(n,e),e}function c(n,e){Object.keys(e).forEach((function(t){n.setAttribute(t,e[t])}))}function u(n,e){var t,r,a,i;if(e.transform&&n.css){if(!(i=e.transform(n.css)))return function(){};n.css=i}if(e.singleton){var c=y++;t=g||(g=s(e)),r=d.bind(null,t,c,!1),a=d.bind(null,t,c,!0)}else n.sourceMap&&"function"==typeof URL&&"function"==typeof URL.createObjectURL&&"function"==typeof URL.revokeObjectURL&&"function"==typeof Blob&&"function"==typeof btoa?(t=l(e),r=h.bind(null,t,e),a=function(){o(t),t.href&&URL.revokeObjectURL(t.href)}):(t=s(e),r=p.bind(null,t),a=function(){o(t)});return r(n),function(e){if(e){if(e.css===n.css&&e.media===n.media&&e.sourceMap===n.sourceMap)return;r(n=e)}else a()}}function d(n,e,t,r){var a=t?"":r.css;if(n.styleSheet)n.styleSheet.cssText=k(e,a);else{var i=document.createTextNode(a),o=n.childNodes;o[e]&&n.removeChild(o[e]),o.length?n.insertBefore(i,o[e]):n.appendChild(i)}}function p(n,e){var t=e.css,r=e.media;if(r&&n.setAttribute("media",r),n.styleSheet)n.styleSheet.cssText=t;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(t))}}function h(n,e,t){var r=t.css,a=t.sourceMap,i=void 0===e.convertToAbsoluteUrls&&a;(e.convertToAbsoluteUrls||i)&&(r=w(r)),a&&(r+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(a))))+" */");var o=new Blob([r],{type:"text/css"}),s=n.href;n.href=URL.createObjectURL(o),s&&URL.revokeObjectURL(s)}var f={},v=function(n){var e;return function(){return void 0===e&&(e=n.apply(this,arguments)),e}}((function(){return window&&document&&document.all&&!window.atob})),m=function(n){var e={};return function(t){return void 0===e[t]&&(e[t]=n.call(this,t)),e[t]}}((function(n){return document.querySelector(n)})),g=null,y=0,b=[],w=t(16);n.exports=function(n,e){if("undefined"!=typeof DEBUG&&DEBUG&&"object"!=typeof document)throw new Error("The style-loader cannot be used in a non-browser environment");(e=e||{}).attrs="object"==typeof e.attrs?e.attrs:{},e.singleton||(e.singleton=v()),e.insertInto||(e.insertInto="head"),e.insertAt||(e.insertAt="bottom");var t=a(n,e);return r(t,e),function(n){for(var i=[],o=0;o<t.length;o++){var s=t[o];(l=f[s.id]).refs--,i.push(l)}for(n&&r(a(n,e),e),o=0;o<i.length;o++){var l;if(0===(l=i[o]).refs){for(var c=0;c<l.parts.length;c++)l.parts[c]();delete f[l.id]}}}};var k=function(){var n=[];return function(e,t){return n[e]=t,n.filter(Boolean).join("\n")}}()},function(n,e){n.exports=function(n){var e="undefined"!=typeof window&&window.location;if(!e)throw new Error("fixUrls requires window.location");if(!n||"string"!=typeof n)return n;var t=e.protocol+"//"+e.host,r=t+e.pathname.replace(/\/[^\/]*$/,"/");return n.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi,(function(n,e){var a,i=e.trim().replace(/^"(.*)"$/,(function(n,e){return e})).replace(/^'(.*)'$/,(function(n,e){return e}));return/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(i)?n:(a=0===i.indexOf("//")?i:0===i.indexOf("/")?t+i:r+i.replace(/^\.\//,""),"url("+JSON.stringify(a)+")")}))}},function(n,e,t){t(12),n.exports=t(1)}])},function(n,e,t){"undefined"!=typeof self&&self,n.exports=function(n){function e(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return n[r].call(a.exports,a,a.exports,e),a.l=!0,a.exports}var t={};return e.m=n,e.c=t,e.d=function(n,t,r){e.o(n,t)||Object.defineProperty(n,t,{configurable:!1,enumerable:!0,get:r})},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},e.p="",e(e.s=15)}([function(n,e,t){(function(n,t){var r;!function(){var a="object"==typeof self&&self.self===self&&self||"object"==typeof n&&n.global===n&&n||this||{},i=a._,o=Array.prototype,s=Object.prototype,l="undefined"!=typeof Symbol?Symbol.prototype:null,c=o.push,u=o.slice,d=s.toString,p=s.hasOwnProperty,h=Array.isArray,f=Object.keys,v=Object.create,m=function(){},g=function(n){return n instanceof g?n:this instanceof g?void(this._wrapped=n):new g(n)};void 0===e||e.nodeType?a._=g:(void 0!==t&&!t.nodeType&&t.exports&&(e=t.exports=g),e._=g),g.VERSION="1.9.1";var y,b=function(n,e,t){if(void 0===e)return n;switch(null==t?3:t){case 1:return function(t){return n.call(e,t)};case 3:return function(t,r,a){return n.call(e,t,r,a)};case 4:return function(t,r,a,i){return n.call(e,t,r,a,i)}}return function(){return n.apply(e,arguments)}},w=function(n,e,t){return g.iteratee!==y?g.iteratee(n,e):null==n?g.identity:g.isFunction(n)?b(n,e,t):g.isObject(n)&&!g.isArray(n)?g.matcher(n):g.property(n)};g.iteratee=y=function(n,e){return w(n,e,1/0)};var k=function(n,e){return e=null==e?n.length-1:+e,function(){for(var t=Math.max(arguments.length-e,0),r=Array(t),a=0;a<t;a++)r[a]=arguments[a+e];switch(e){case 0:return n.call(this,r);case 1:return n.call(this,arguments[0],r);case 2:return n.call(this,arguments[0],arguments[1],r)}var i=Array(e+1);for(a=0;a<e;a++)i[a]=arguments[a];return i[e]=r,n.apply(this,i)}},x=function(n){if(!g.isObject(n))return{};if(v)return v(n);m.prototype=n;var e=new m;return m.prototype=null,e},E=function(n){return function(e){return null==e?void 0:e[n]}},A=function(n,e){return null!=n&&p.call(n,e)},_=function(n,e){for(var t=e.length,r=0;r<t;r++){if(null==n)return;n=n[e[r]]}return t?n:void 0},S=Math.pow(2,53)-1,C=E("length"),T=function(n){var e=C(n);return"number"==typeof e&&e>=0&&e<=S};g.each=g.forEach=function(n,e,t){var r,a;if(e=b(e,t),T(n))for(r=0,a=n.length;r<a;r++)e(n[r],r,n);else{var i=g.keys(n);for(r=0,a=i.length;r<a;r++)e(n[i[r]],i[r],n)}return n},g.map=g.collect=function(n,e,t){e=w(e,t);for(var r=!T(n)&&g.keys(n),a=(r||n).length,i=Array(a),o=0;o<a;o++){var s=r?r[o]:o;i[o]=e(n[s],s,n)}return i};var O=function(n){var e=function(e,t,r,a){var i=!T(e)&&g.keys(e),o=(i||e).length,s=n>0?0:o-1;for(a||(r=e[i?i[s]:s],s+=n);s>=0&&s<o;s+=n){var l=i?i[s]:s;r=t(r,e[l],l,e)}return r};return function(n,t,r,a){var i=arguments.length>=3;return e(n,b(t,a,4),r,i)}};g.reduce=g.foldl=g.inject=O(1),g.reduceRight=g.foldr=O(-1),g.find=g.detect=function(n,e,t){var r=(T(n)?g.findIndex:g.findKey)(n,e,t);if(void 0!==r&&-1!==r)return n[r]},g.filter=g.select=function(n,e,t){var r=[];return e=w(e,t),g.each(n,(function(n,t,a){e(n,t,a)&&r.push(n)})),r},g.reject=function(n,e,t){return g.filter(n,g.negate(w(e)),t)},g.every=g.all=function(n,e,t){e=w(e,t);for(var r=!T(n)&&g.keys(n),a=(r||n).length,i=0;i<a;i++){var o=r?r[i]:i;if(!e(n[o],o,n))return!1}return!0},g.some=g.any=function(n,e,t){e=w(e,t);for(var r=!T(n)&&g.keys(n),a=(r||n).length,i=0;i<a;i++){var o=r?r[i]:i;if(e(n[o],o,n))return!0}return!1},g.contains=g.includes=g.include=function(n,e,t,r){return T(n)||(n=g.values(n)),("number"!=typeof t||r)&&(t=0),g.indexOf(n,e,t)>=0},g.invoke=k((function(n,e,t){var r,a;return g.isFunction(e)?a=e:g.isArray(e)&&(r=e.slice(0,-1),e=e[e.length-1]),g.map(n,(function(n){var i=a;if(!i){if(r&&r.length&&(n=_(n,r)),null==n)return;i=n[e]}return null==i?i:i.apply(n,t)}))})),g.pluck=function(n,e){return g.map(n,g.property(e))},g.where=function(n,e){return g.filter(n,g.matcher(e))},g.findWhere=function(n,e){return g.find(n,g.matcher(e))},g.max=function(n,e,t){var r,a,i=-1/0,o=-1/0;if(null==e||"number"==typeof e&&"object"!=typeof n[0]&&null!=n)for(var s=0,l=(n=T(n)?n:g.values(n)).length;s<l;s++)null!=(r=n[s])&&r>i&&(i=r);else e=w(e,t),g.each(n,(function(n,t,r){((a=e(n,t,r))>o||a===-1/0&&i===-1/0)&&(i=n,o=a)}));return i},g.min=function(n,e,t){var r,a,i=1/0,o=1/0;if(null==e||"number"==typeof e&&"object"!=typeof n[0]&&null!=n)for(var s=0,l=(n=T(n)?n:g.values(n)).length;s<l;s++)null!=(r=n[s])&&r<i&&(i=r);else e=w(e,t),g.each(n,(function(n,t,r){((a=e(n,t,r))<o||a===1/0&&i===1/0)&&(i=n,o=a)}));return i},g.shuffle=function(n){return g.sample(n,1/0)},g.sample=function(n,e,t){if(null==e||t)return T(n)||(n=g.values(n)),n[g.random(n.length-1)];var r=T(n)?g.clone(n):g.values(n),a=C(r);e=Math.max(Math.min(e,a),0);for(var i=a-1,o=0;o<e;o++){var s=g.random(o,i),l=r[o];r[o]=r[s],r[s]=l}return r.slice(0,e)},g.sortBy=function(n,e,t){var r=0;return e=w(e,t),g.pluck(g.map(n,(function(n,t,a){return{value:n,index:r++,criteria:e(n,t,a)}})).sort((function(n,e){var t=n.criteria,r=e.criteria;if(t!==r){if(t>r||void 0===t)return 1;if(t<r||void 0===r)return-1}return n.index-e.index})),"value")};var j=function(n,e){return function(t,r,a){var i=e?[[],[]]:{};return r=w(r,a),g.each(t,(function(e,a){var o=r(e,a,t);n(i,e,o)})),i}};g.groupBy=j((function(n,e,t){A(n,t)?n[t].push(e):n[t]=[e]})),g.indexBy=j((function(n,e,t){n[t]=e})),g.countBy=j((function(n,e,t){A(n,t)?n[t]++:n[t]=1}));var B=/[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;g.toArray=function(n){return n?g.isArray(n)?u.call(n):g.isString(n)?n.match(B):T(n)?g.map(n,g.identity):g.values(n):[]},g.size=function(n){return null==n?0:T(n)?n.length:g.keys(n).length},g.partition=j((function(n,e,t){n[t?0:1].push(e)}),!0),g.first=g.head=g.take=function(n,e,t){return null==n||n.length<1?null==e?void 0:[]:null==e||t?n[0]:g.initial(n,n.length-e)},g.initial=function(n,e,t){return u.call(n,0,Math.max(0,n.length-(null==e||t?1:e)))},g.last=function(n,e,t){return null==n||n.length<1?null==e?void 0:[]:null==e||t?n[n.length-1]:g.rest(n,Math.max(0,n.length-e))},g.rest=g.tail=g.drop=function(n,e,t){return u.call(n,null==e||t?1:e)},g.compact=function(n){return g.filter(n,Boolean)};var I=function(n,e,t,r){for(var a=(r=r||[]).length,i=0,o=C(n);i<o;i++){var s=n[i];if(T(s)&&(g.isArray(s)||g.isArguments(s)))if(e)for(var l=0,c=s.length;l<c;)r[a++]=s[l++];else I(s,e,t,r),a=r.length;else t||(r[a++]=s)}return r};g.flatten=function(n,e){return I(n,e,!1)},g.without=k((function(n,e){return g.difference(n,e)})),g.uniq=g.unique=function(n,e,t,r){g.isBoolean(e)||(r=t,t=e,e=!1),null!=t&&(t=w(t,r));for(var a=[],i=[],o=0,s=C(n);o<s;o++){var l=n[o],c=t?t(l,o,n):l;e&&!t?(o&&i===c||a.push(l),i=c):t?g.contains(i,c)||(i.push(c),a.push(l)):g.contains(a,l)||a.push(l)}return a},g.union=k((function(n){return g.uniq(I(n,!0,!0))})),g.intersection=function(n){for(var e=[],t=arguments.length,r=0,a=C(n);r<a;r++){var i=n[r];if(!g.contains(e,i)){var o;for(o=1;o<t&&g.contains(arguments[o],i);o++);o===t&&e.push(i)}}return e},g.difference=k((function(n,e){return e=I(e,!0,!0),g.filter(n,(function(n){return!g.contains(e,n)}))})),g.unzip=function(n){for(var e=n&&g.max(n,C).length||0,t=Array(e),r=0;r<e;r++)t[r]=g.pluck(n,r);return t},g.zip=k(g.unzip),g.object=function(n,e){for(var t={},r=0,a=C(n);r<a;r++)e?t[n[r]]=e[r]:t[n[r][0]]=n[r][1];return t};var L=function(n){return function(e,t,r){t=w(t,r);for(var a=C(e),i=n>0?0:a-1;i>=0&&i<a;i+=n)if(t(e[i],i,e))return i;return-1}};g.findIndex=L(1),g.findLastIndex=L(-1),g.sortedIndex=function(n,e,t,r){for(var a=(t=w(t,r,1))(e),i=0,o=C(n);i<o;){var s=Math.floor((i+o)/2);t(n[s])<a?i=s+1:o=s}return i};var N=function(n,e,t){return function(r,a,i){var o=0,s=C(r);if("number"==typeof i)n>0?o=i>=0?i:Math.max(i+s,o):s=i>=0?Math.min(i+1,s):i+s+1;else if(t&&i&&s)return r[i=t(r,a)]===a?i:-1;if(a!=a)return(i=e(u.call(r,o,s),g.isNaN))>=0?i+o:-1;for(i=n>0?o:s-1;i>=0&&i<s;i+=n)if(r[i]===a)return i;return-1}};g.indexOf=N(1,g.findIndex,g.sortedIndex),g.lastIndexOf=N(-1,g.findLastIndex),g.range=function(n,e,t){null==e&&(e=n||0,n=0),t||(t=e<n?-1:1);for(var r=Math.max(Math.ceil((e-n)/t),0),a=Array(r),i=0;i<r;i++,n+=t)a[i]=n;return a},g.chunk=function(n,e){if(null==e||e<1)return[];for(var t=[],r=0,a=n.length;r<a;)t.push(u.call(n,r,r+=e));return t};var P=function(n,e,t,r,a){if(!(r instanceof e))return n.apply(t,a);var i=x(n.prototype),o=n.apply(i,a);return g.isObject(o)?o:i};g.bind=k((function(n,e,t){if(!g.isFunction(n))throw new TypeError("Bind must be called on a function");var r=k((function(a){return P(n,r,e,this,t.concat(a))}));return r})),g.partial=k((function(n,e){var t=g.partial.placeholder,r=function(){for(var a=0,i=e.length,o=Array(i),s=0;s<i;s++)o[s]=e[s]===t?arguments[a++]:e[s];for(;a<arguments.length;)o.push(arguments[a++]);return P(n,r,this,this,o)};return r})),g.partial.placeholder=g,g.bindAll=k((function(n,e){var t=(e=I(e,!1,!1)).length;if(t<1)throw new Error("bindAll must be passed function names");for(;t--;){var r=e[t];n[r]=g.bind(n[r],n)}})),g.memoize=function(n,e){var t=function(r){var a=t.cache,i=""+(e?e.apply(this,arguments):r);return A(a,i)||(a[i]=n.apply(this,arguments)),a[i]};return t.cache={},t},g.delay=k((function(n,e,t){return setTimeout((function(){return n.apply(null,t)}),e)})),g.defer=g.partial(g.delay,g,1),g.throttle=function(n,e,t){var r,a,i,o,s=0;t||(t={});var l=function(){s=!1===t.leading?0:g.now(),r=null,o=n.apply(a,i),r||(a=i=null)},c=function(){var c=g.now();s||!1!==t.leading||(s=c);var u=e-(c-s);return a=this,i=arguments,u<=0||u>e?(r&&(clearTimeout(r),r=null),s=c,o=n.apply(a,i),r||(a=i=null)):r||!1===t.trailing||(r=setTimeout(l,u)),o};return c.cancel=function(){clearTimeout(r),s=0,r=a=i=null},c},g.debounce=function(n,e,t){var r,a,i=function(e,t){r=null,t&&(a=n.apply(e,t))},o=k((function(o){if(r&&clearTimeout(r),t){var s=!r;r=setTimeout(i,e),s&&(a=n.apply(this,o))}else r=g.delay(i,e,this,o);return a}));return o.cancel=function(){clearTimeout(r),r=null},o},g.wrap=function(n,e){return g.partial(e,n)},g.negate=function(n){return function(){return!n.apply(this,arguments)}},g.compose=function(){var n=arguments,e=n.length-1;return function(){for(var t=e,r=n[e].apply(this,arguments);t--;)r=n[t].call(this,r);return r}},g.after=function(n,e){return function(){if(--n<1)return e.apply(this,arguments)}},g.before=function(n,e){var t;return function(){return--n>0&&(t=e.apply(this,arguments)),n<=1&&(e=null),t}},g.once=g.partial(g.before,2),g.restArguments=k;var q=!{toString:null}.propertyIsEnumerable("toString"),R=["valueOf","isPrototypeOf","toString","propertyIsEnumerable","hasOwnProperty","toLocaleString"],F=function(n,e){var t=R.length,r=n.constructor,a=g.isFunction(r)&&r.prototype||s,i="constructor";for(A(n,i)&&!g.contains(e,i)&&e.push(i);t--;)(i=R[t])in n&&n[i]!==a[i]&&!g.contains(e,i)&&e.push(i)};g.keys=function(n){if(!g.isObject(n))return[];if(f)return f(n);var e=[];for(var t in n)A(n,t)&&e.push(t);return q&&F(n,e),e},g.allKeys=function(n){if(!g.isObject(n))return[];var e=[];for(var t in n)e.push(t);return q&&F(n,e),e},g.values=function(n){for(var e=g.keys(n),t=e.length,r=Array(t),a=0;a<t;a++)r[a]=n[e[a]];return r},g.mapObject=function(n,e,t){e=w(e,t);for(var r=g.keys(n),a=r.length,i={},o=0;o<a;o++){var s=r[o];i[s]=e(n[s],s,n)}return i},g.pairs=function(n){for(var e=g.keys(n),t=e.length,r=Array(t),a=0;a<t;a++)r[a]=[e[a],n[e[a]]];return r},g.invert=function(n){for(var e={},t=g.keys(n),r=0,a=t.length;r<a;r++)e[n[t[r]]]=t[r];return e},g.functions=g.methods=function(n){var e=[];for(var t in n)g.isFunction(n[t])&&e.push(t);return e.sort()};var M=function(n,e){return function(t){var r=arguments.length;if(e&&(t=Object(t)),r<2||null==t)return t;for(var a=1;a<r;a++)for(var i=arguments[a],o=n(i),s=o.length,l=0;l<s;l++){var c=o[l];e&&void 0!==t[c]||(t[c]=i[c])}return t}};g.extend=M(g.allKeys),g.extendOwn=g.assign=M(g.keys),g.findKey=function(n,e,t){e=w(e,t);for(var r,a=g.keys(n),i=0,o=a.length;i<o;i++)if(e(n[r=a[i]],r,n))return r};var z,D,U=function(n,e,t){return e in t};g.pick=k((function(n,e){var t={},r=e[0];if(null==n)return t;g.isFunction(r)?(e.length>1&&(r=b(r,e[1])),e=g.allKeys(n)):(r=U,e=I(e,!1,!1),n=Object(n));for(var a=0,i=e.length;a<i;a++){var o=e[a],s=n[o];r(s,o,n)&&(t[o]=s)}return t})),g.omit=k((function(n,e){var t,r=e[0];return g.isFunction(r)?(r=g.negate(r),e.length>1&&(t=e[1])):(e=g.map(I(e,!1,!1),String),r=function(n,t){return!g.contains(e,t)}),g.pick(n,r,t)})),g.defaults=M(g.allKeys,!0),g.create=function(n,e){var t=x(n);return e&&g.extendOwn(t,e),t},g.clone=function(n){return g.isObject(n)?g.isArray(n)?n.slice():g.extend({},n):n},g.tap=function(n,e){return e(n),n},g.isMatch=function(n,e){var t=g.keys(e),r=t.length;if(null==n)return!r;for(var a=Object(n),i=0;i<r;i++){var o=t[i];if(e[o]!==a[o]||!(o in a))return!1}return!0},z=function(n,e,t,r){if(n===e)return 0!==n||1/n==1/e;if(null==n||null==e)return!1;if(n!=n)return e!=e;var a=typeof n;return("function"===a||"object"===a||"object"==typeof e)&&D(n,e,t,r)},D=function(n,e,t,r){n instanceof g&&(n=n._wrapped),e instanceof g&&(e=e._wrapped);var a=d.call(n);if(a!==d.call(e))return!1;switch(a){case"[object RegExp]":case"[object String]":return""+n==""+e;case"[object Number]":return+n!=+n?+e!=+e:0==+n?1/+n==1/e:+n==+e;case"[object Date]":case"[object Boolean]":return+n==+e;case"[object Symbol]":return l.valueOf.call(n)===l.valueOf.call(e)}var i="[object Array]"===a;if(!i){if("object"!=typeof n||"object"!=typeof e)return!1;var o=n.constructor,s=e.constructor;if(o!==s&&!(g.isFunction(o)&&o instanceof o&&g.isFunction(s)&&s instanceof s)&&"constructor"in n&&"constructor"in e)return!1}r=r||[];for(var c=(t=t||[]).length;c--;)if(t[c]===n)return r[c]===e;if(t.push(n),r.push(e),i){if((c=n.length)!==e.length)return!1;for(;c--;)if(!z(n[c],e[c],t,r))return!1}else{var u,p=g.keys(n);if(c=p.length,g.keys(e).length!==c)return!1;for(;c--;)if(u=p[c],!A(e,u)||!z(n[u],e[u],t,r))return!1}return t.pop(),r.pop(),!0},g.isEqual=function(n,e){return z(n,e)},g.isEmpty=function(n){return null==n||(T(n)&&(g.isArray(n)||g.isString(n)||g.isArguments(n))?0===n.length:0===g.keys(n).length)},g.isElement=function(n){return!(!n||1!==n.nodeType)},g.isArray=h||function(n){return"[object Array]"===d.call(n)},g.isObject=function(n){var e=typeof n;return"function"===e||"object"===e&&!!n},g.each(["Arguments","Function","String","Number","Date","RegExp","Error","Symbol","Map","WeakMap","Set","WeakSet"],(function(n){g["is"+n]=function(e){return d.call(e)==="[object "+n+"]"}})),g.isArguments(arguments)||(g.isArguments=function(n){return A(n,"callee")});var $=a.document&&a.document.childNodes;"object"!=typeof Int8Array&&"function"!=typeof $&&(g.isFunction=function(n){return"function"==typeof n||!1}),g.isFinite=function(n){return!g.isSymbol(n)&&isFinite(n)&&!isNaN(parseFloat(n))},g.isNaN=function(n){return g.isNumber(n)&&isNaN(n)},g.isBoolean=function(n){return!0===n||!1===n||"[object Boolean]"===d.call(n)},g.isNull=function(n){return null===n},g.isUndefined=function(n){return void 0===n},g.has=function(n,e){if(!g.isArray(e))return A(n,e);for(var t=e.length,r=0;r<t;r++){var a=e[r];if(null==n||!p.call(n,a))return!1;n=n[a]}return!!t},g.noConflict=function(){return a._=i,this},g.identity=function(n){return n},g.constant=function(n){return function(){return n}},g.noop=function(){},g.property=function(n){return g.isArray(n)?function(e){return _(e,n)}:E(n)},g.propertyOf=function(n){return null==n?function(){}:function(e){return g.isArray(e)?_(n,e):n[e]}},g.matcher=g.matches=function(n){return n=g.extendOwn({},n),function(e){return g.isMatch(e,n)}},g.times=function(n,e,t){var r=Array(Math.max(0,n));e=b(e,t,1);for(var a=0;a<n;a++)r[a]=e(a);return r},g.random=function(n,e){return null==e&&(e=n,n=0),n+Math.floor(Math.random()*(e-n+1))},g.now=Date.now||function(){return(new Date).getTime()};var J={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},W=g.invert(J),Q=function(n){var e=function(e){return n[e]},t="(?:"+g.keys(n).join("|")+")",r=RegExp(t),a=RegExp(t,"g");return function(n){return n=null==n?"":""+n,r.test(n)?n.replace(a,e):n}};g.escape=Q(J),g.unescape=Q(W),g.result=function(n,e,t){g.isArray(e)||(e=[e]);var r=e.length;if(!r)return g.isFunction(t)?t.call(n):t;for(var a=0;a<r;a++){var i=null==n?void 0:n[e[a]];void 0===i&&(i=t,a=r),n=g.isFunction(i)?i.call(n):i}return n};var V=0;g.uniqueId=function(n){var e=++V+"";return n?n+e:e},g.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var H=/(.)^/,G={"'":"'","\\":"\\","\r":"r","\n":"n","\u2028":"u2028","\u2029":"u2029"},K=/\\|'|\r|\n|\u2028|\u2029/g,Y=function(n){return"\\"+G[n]};g.template=function(n,e,t){!e&&t&&(e=t),e=g.defaults({},e,g.templateSettings);var r,a=RegExp([(e.escape||H).source,(e.interpolate||H).source,(e.evaluate||H).source].join("|")+"|$","g"),i=0,o="__p+='";n.replace(a,(function(e,t,r,a,s){return o+=n.slice(i,s).replace(K,Y),i=s+e.length,t?o+="'+\n((__t=("+t+"))==null?'':_.escape(__t))+\n'":r?o+="'+\n((__t=("+r+"))==null?'':__t)+\n'":a&&(o+="';\n"+a+"\n__p+='"),e})),o+="';\n",e.variable||(o="with(obj||{}){\n"+o+"}\n"),o="var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n"+o+"return __p;\n";try{r=new Function(e.variable||"obj","_",o)}catch(n){throw n.source=o,n}var s=function(n){return r.call(this,n,g)};return s.source="function("+(e.variable||"obj")+"){\n"+o+"}",s},g.chain=function(n){var e=g(n);return e._chain=!0,e};var X=function(n,e){return n._chain?g(e).chain():e};g.mixin=function(n){return g.each(g.functions(n),(function(e){var t=g[e]=n[e];g.prototype[e]=function(){var n=[this._wrapped];return c.apply(n,arguments),X(this,t.apply(g,n))}})),g},g.mixin(g),g.each(["pop","push","reverse","shift","sort","splice","unshift"],(function(n){var e=o[n];g.prototype[n]=function(){var t=this._wrapped;return e.apply(t,arguments),"shift"!==n&&"splice"!==n||0!==t.length||delete t[0],X(this,t)}})),g.each(["concat","join","slice"],(function(n){var e=o[n];g.prototype[n]=function(){return X(this,e.apply(this._wrapped,arguments))}})),g.prototype.value=function(){return this._wrapped},g.prototype.valueOf=g.prototype.toJSON=g.prototype.value,g.prototype.toString=function(){return String(this._wrapped)},void 0!==(r=function(){return g}.apply(e,[]))&&(t.exports=r)}()}).call(e,t(7),t(17)(n))},function(n,e,t){"use strict";var r=t(29).Promise;r._continueWhile=function(n,e){return n()?e().then((function(){return r._continueWhile(n,e)})):r.resolve()},n.exports=r},function(n,e,t){"use strict";var r=t(0),a=t(44),i=t(0).extend,o=t(1),s=t(5),l=t(3),c=l.getSessionToken,u=l.ajax,d=function(n,e){var t=(new Date).getTime(),r=a(t+n);return e?r+","+t+",master":r+","+t},p=function(n,e){e?n["X-LC-Sign"]=d(s.applicationKey):n["X-LC-Key"]=s.applicationKey},h=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments[1],t={"X-LC-Id":s.applicationId,"Content-Type":"application/json;charset=UTF-8"},r=!1;return"boolean"==typeof n.useMasterKey?r=n.useMasterKey:"boolean"==typeof s._config.useMasterKey&&(r=s._config.useMasterKey),r?s.masterKey?e?t["X-LC-Sign"]=d(s.masterKey,!0):t["X-LC-Key"]=s.masterKey+",master":(console.warn("masterKey is not set, fall back to use appKey"),p(t,e)):p(t,e),s.hookKey&&(t["X-LC-Hook-Key"]=s.hookKey),null!==s._config.production&&(t["X-LC-Prod"]=String(s._config.production)),t["X-LC-UA"]=s._sharedConfig.userAgent,o.resolve().then((function(){var e=c(n);if(e)t["X-LC-Session"]=e;else if(!s._config.disableCurrentUser)return s.User.currentAsync().then((function(n){return n&&n._sessionToken&&(t["X-LC-Session"]=n._sessionToken),t}));return t}))},f=function(n){var e=n.service,t=n.version,a=n.method,i=n.path,o=n.query,l=n.data,c=n.authOptions,d=n.signKey,p=void 0===d||d;if(!s.applicationId||!s.applicationKey&&!s.masterKey)throw new Error("Not initialized");s._appRouter.refresh();var f=s._config.requestTimeout,v=function(n){var e=n.service,t=void 0===e?"api":e,r=n.version,a=void 0===r?"1.1":r,i=n.path,o=s._config.serverURLs[t];if(!o)throw new Error("undefined server URL for "+t);return"/"!==o.charAt(o.length-1)&&(o+="/"),o+=a,i&&(o+=i),o}({service:e,path:i,version:t});return h(c,p).then((function(n){return u({method:a,url:v,query:o,data:l,headers:n,timeout:f}).catch((function(n){var e={code:n.code||-1,error:n.message||n.responseText};if(n.response&&n.response.code)e=n.response;else if(n.responseText)try{e=JSON.parse(n.responseText)}catch(n){}e.rawMessage=e.rawMessage||e.error,s._sharedConfig.keepErrorRawMessage||(e.error+=" ["+(n.statusCode||"N/A")+" "+a+" "+v+"]");var t=new Error(e.error);throw delete e.error,r.extend(t,e)}))}))};s.request=f,n.exports={_request:function(n,e,t,r,a,o,s){var l="";if(n&&(l+="/"+n),e&&(l+="/"+e),t&&(l+="/"+t),a&&a._fetchWhenSave)throw new Error("_fetchWhenSave should be in the query");if(a&&a._where)throw new Error("_where should be in the query");return r&&"get"===r.toLowerCase()&&(s=i({},s,a),a=null),f({method:r,path:l,query:s,data:a,authOptions:o})},request:f}},function(n,e,t){"use strict";var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},a=t(0),i=t(8),o=t(6),s=o("leancloud:request"),l=o("leancloud:request:error"),c=t(1),u=0,d=function(n){return a.isArray(n)?n:null==n?[]:[n]},p=function(){};n.exports={ajax:function(n){var e=n.method,t=n.url,a=n.query,d=n.data,p=n.headers,h=void 0===p?{}:p,f=n.onprogress,v=n.timeout,m={};if(a)for(var g in a){var y=a[g];void 0!==y&&("object"===(void 0===y?"undefined":r(y))?m[g]=JSON.stringify(y):m[g]=y)}var b=u++;return s("request(%d) %s %s %o %o %o",b,e,t,m,d,h),new c((function(n,r){var c=i(e,t).set(h).query(m).send(d);f&&c.on("progress",f),v&&c.timeout(v),c.end((function(i,c){return i?(c&&(o.enabled("leancloud:request")||l("request(%d) %s %s %o %o %o",b,e,t,a,d,h),l("response(%d) %d %O %o",b,c.status,c.body||c.text,c.header),i.statusCode=c.status,i.responseText=c.text,i.response=c.body),r(i)):(s("response(%d) %d %O %o",b,c.status,c.body||c.text,c.header),n(c.body))}))}))},isNullOrUndefined:function(n){return a.isNull(n)||a.isUndefined(n)},ensureArray:d,transformFetchOptions:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.keys,t=n.include,r=n.includeACL,a={};return e&&(a.keys=d(e).join(",")),t&&(a.include=d(t).join(",")),r&&(a.returnACL=r),a},getSessionToken:function(n){return n.sessionToken?n.sessionToken:n.user&&"function"==typeof n.user.getSessionToken?n.user.getSessionToken():void 0},tap:function(n){return function(e){return n(e),e}},inherits:function(n,e,t){var r;return r=e&&e.hasOwnProperty("constructor")?e.constructor:function(){n.apply(this,arguments)},a.extend(r,n),p.prototype=n.prototype,r.prototype=new p,e&&a.extend(r.prototype,e),t&&a.extend(r,t),r.prototype.constructor=r,r.__super__=n.prototype,r},parseDate:function(n){var e=new RegExp("^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})T([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})(.([0-9]+))?Z$").exec(n);if(!e)return null;var t=e[1]||0,r=(e[2]||1)-1,a=e[3]||0,i=e[4]||0,o=e[5]||0,s=e[6]||0,l=e[8]||0;return new Date(Date.UTC(t,r,a,i,o,s,l))},setValue:function(n,e,t){var r=e.split("."),a=r.pop(),i=n;return r.forEach((function(n){void 0===i[n]&&(i[n]={}),i=i[n]})),i[a]=t,n},findValue:function(n,e){for(var t=e.split("."),r=t[0],a=t.pop(),i=n,o=0;o<t.length;o++)if(void 0===(i=i[t[o]]))return[void 0,void 0,a];return[i[a],i,a,r]},isPlainObject:function(n){return a.isObject(n)&&Object.getPrototypeOf(n)===Object.prototype}}},function(n,e,t){"use strict";function r(n,e){var t=new Error(e);return t.code=n,t}t(0).extend(r,{OTHER_CAUSE:-1,INTERNAL_SERVER_ERROR:1,CONNECTION_FAILED:100,OBJECT_NOT_FOUND:101,INVALID_QUERY:102,INVALID_CLASS_NAME:103,MISSING_OBJECT_ID:104,INVALID_KEY_NAME:105,INVALID_POINTER:106,INVALID_JSON:107,COMMAND_UNAVAILABLE:108,NOT_INITIALIZED:109,INCORRECT_TYPE:111,INVALID_CHANNEL_NAME:112,PUSH_MISCONFIGURED:115,OBJECT_TOO_LARGE:116,OPERATION_FORBIDDEN:119,CACHE_MISS:120,INVALID_NESTED_KEY:121,INVALID_FILE_NAME:122,INVALID_ACL:123,TIMEOUT:124,INVALID_EMAIL_ADDRESS:125,MISSING_CONTENT_TYPE:126,MISSING_CONTENT_LENGTH:127,INVALID_CONTENT_LENGTH:128,FILE_TOO_LARGE:129,FILE_SAVE_ERROR:130,FILE_DELETE_ERROR:153,DUPLICATE_VALUE:137,INVALID_ROLE_NAME:139,EXCEEDED_QUOTA:140,SCRIPT_FAILED:141,VALIDATION_ERROR:142,INVALID_IMAGE_DATA:150,UNSAVED_FILE_ERROR:151,INVALID_PUSH_TIME_ERROR:152,USERNAME_MISSING:200,PASSWORD_MISSING:201,USERNAME_TAKEN:202,EMAIL_TAKEN:203,EMAIL_MISSING:204,EMAIL_NOT_FOUND:205,SESSION_MISSING:206,MUST_CREATE_USER_THROUGH_SIGNUP:207,ACCOUNT_ALREADY_LINKED:208,LINKED_ID_MISSING:250,INVALID_LINKED_SESSION:251,UNSUPPORTED_SERVICE:252,X_DOMAIN_REQUEST:602}),n.exports=r},function(n,e,t){"use strict";(function(e){var r=t(0),a=t(9),i=t(20),o=t(3),s=o.inherits,l=o.parseDate,c=t(1),u=e.AV||{};u._config={serverURLs:{},useMasterKey:!1,production:null,realtime:null,requestTimeout:null},u._sharedConfig={userAgent:i,liveQueryRealtime:null},u._getAVPath=function(n){if(!u.applicationId)throw new Error("You need to call AV.initialize before using AV.");if(n||(n=""),!r.isString(n))throw new Error("Tried to get a localStorage path that wasn't a String.");return"/"===n[0]&&(n=n.substring(1)),"AV/"+u.applicationId+"/"+n},u._installationId=null,u._getInstallationId=function(){if(u._installationId)return c.resolve(u._installationId);var n=u._getAVPath("installationId");return u.localStorage.getItemAsync(n).then((function(e){return u._installationId=e,u._installationId?e:(u._installationId=e=a(),u.localStorage.setItemAsync(n,e).then((function(){return e})))}))},u._subscriptionId=null,u._refreshSubscriptionId=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:u._getAVPath("subscriptionId"),e=u._subscriptionId=a();return u.localStorage.setItemAsync(n,e).then((function(){return e}))},u._getSubscriptionId=function(){if(u._subscriptionId)return c.resolve(u._subscriptionId);var n=u._getAVPath("subscriptionId");return u.localStorage.getItemAsync(n).then((function(e){return u._subscriptionId=e,u._subscriptionId||(e=u._refreshSubscriptionId(n)),e}))},u._parseDate=l,u._extend=function(n,e){var t=s(this,n,e);return t.extend=this.extend,t},u._encode=function(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];if(n instanceof u.Object){if(t)throw new Error("AV.Objects not allowed here");return e&&!r.include(e,n)&&n._hasData?n._toFullJSON(e.concat(n),a):n._toPointer()}if(n instanceof u.ACL)return n.toJSON();if(r.isDate(n))return a?{__type:"Date",iso:n.toJSON()}:n.toJSON();if(n instanceof u.GeoPoint)return n.toJSON();if(r.isArray(n))return r.map(n,(function(n){return u._encode(n,e,t,a)}));if(r.isRegExp(n))return n.source;if(n instanceof u.Relation)return n.toJSON();if(n instanceof u.Op)return n.toJSON();if(n instanceof u.File){if(!n.url()&&!n.id)throw new Error("Tried to save an object containing an unsaved file.");return n._toFullJSON(e,a)}return r.isObject(n)?r.mapObject(n,(function(n,r){return u._encode(n,e,t,a)})):n},u._decode=function(n,e){if(!r.isObject(n)||r.isDate(n))return n;if(r.isArray(n))return r.map(n,(function(n){return u._decode(n)}));if(n instanceof u.Object)return n;if(n instanceof u.File)return n;if(n instanceof u.Op)return n;if(n instanceof u.GeoPoint)return n;if(n instanceof u.ACL)return n;if("ACL"===e)return new u.ACL(n);if(n.__op)return u.Op._decode(n);var t;if("Pointer"===n.__type){t=n.className;var a=u.Object._create(t);if(Object.keys(n).length>3){var i=r.clone(n);delete i.__type,delete i.className,a._finishFetch(i,!0)}else a._finishFetch({objectId:n.objectId},!1);return a}if("Object"===n.__type){t=n.className;var o=r.clone(n);delete o.__type,delete o.className;var s=u.Object._create(t);return s._finishFetch(o,!0),s}if("Date"===n.__type)return u._parseDate(n.iso);if("GeoPoint"===n.__type)return new u.GeoPoint({latitude:n.latitude,longitude:n.longitude});if("Relation"===n.__type){if(!e)throw new Error("key missing decoding a Relation");var l=new u.Relation(null,e);return l.targetClassName=n.className,l}if("File"===n.__type){var c=new u.File(n.name),d=r.clone(n);return delete d.__type,c._finishFetch(d),c}return r.mapObject(n,u._decode)},u.parseJSON=u._decode,u._encodeObjectOrArray=function(n){var e=function(n){return n&&n._toFullJSON&&(n=n._toFullJSON([])),r.mapObject(n,(function(n){return u._encode(n,[])}))};return r.isArray(n)?n.map((function(n){return e(n)})):e(n)},u._arrayEach=r.each,u._traverse=function(n,e,t){if(n instanceof u.Object){if(t=t||[],r.indexOf(t,n)>=0)return;return t.push(n),u._traverse(n.attributes,e,t),e(n)}return n instanceof u.Relation||n instanceof u.File?e(n):r.isArray(n)?(r.each(n,(function(r,a){var i=u._traverse(r,e,t);i&&(n[a]=i)})),e(n)):r.isObject(n)?(u._each(n,(function(r,a){var i=u._traverse(r,e,t);i&&(n[a]=i)})),e(n)):e(n)},u._objectEach=u._each=function(n,e){r.isObject(n)?r.each(r.keys(n),(function(t){e(n[t],t)})):r.each(n,e)},n.exports=u}).call(e,t(7))},function(n,e,t){"use strict";function r(n){return(r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}e.log=function(){var n;return"object"===("undefined"==typeof console?"undefined":r(console))&&console.log&&(n=console).log.apply(n,arguments)},e.formatArgs=function(e){if(e[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+e[0]+(this.useColors?"%c ":" ")+"+"+n.exports.humanize(this.diff),this.useColors){var t="color: "+this.color;e.splice(1,0,t,"color: inherit");var r=0,a=0;e[0].replace(/%[a-zA-Z%]/g,(function(n){"%%"!==n&&(r++,"%c"===n&&(a=r))})),e.splice(a,0,t)}},e.save=function(n){try{n?e.storage.setItem("debug",n):e.storage.removeItem("debug")}catch(n){}},e.load=function(){var n;try{n=e.storage.getItem("debug")}catch(n){}return!n&&"undefined"!=typeof process&&"env"in process&&(n=process.env.DEBUG),n},e.useColors=function(){return!("undefined"==typeof window||!window.process||"renderer"!==window.process.type&&!window.process.__nwjs)||("undefined"==typeof navigator||!navigator.userAgent||!navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))&&("undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))},e.storage=function(){try{return localStorage}catch(n){}}(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],n.exports=t(27)(e),n.exports.formatters.j=function(n){try{return JSON.stringify(n)}catch(n){return"[UnexpectedJSONParseError]: "+n.message}}},function(n,e){var t;t=function(){return this}();try{t=t||Function("return this")()||(0,eval)("this")}catch(n){"object"==typeof window&&(t=window)}n.exports=t},function(n,e,t){function r(){}function a(n){if(!f(n))return n;var e=[];for(var t in n)i(e,t,n[t]);return e.join("&")}function i(n,e,t){if(null!=t)if(Array.isArray(t))t.forEach((function(t){i(n,e,t)}));else if(f(t))for(var r in t)i(n,e+"["+r+"]",t[r]);else n.push(encodeURIComponent(e)+"="+encodeURIComponent(t));else null===t&&n.push(encodeURIComponent(e))}function o(n){for(var e,t,r={},a=n.split("&"),i=0,o=a.length;i<o;++i)-1==(t=(e=a[i]).indexOf("="))?r[decodeURIComponent(e)]="":r[decodeURIComponent(e.slice(0,t))]=decodeURIComponent(e.slice(t+1));return r}function s(n){return/[\/+]json($|[^-\w])/.test(n)}function l(n){this.req=n,this.xhr=this.req.xhr,this.text="HEAD"!=this.req.method&&(""===this.xhr.responseType||"text"===this.xhr.responseType)||void 0===this.xhr.responseType?this.xhr.responseText:null,this.statusText=this.req.xhr.statusText;var e=this.xhr.status;1223===e&&(e=204),this._setStatusProperties(e),this.header=this.headers=function(n){for(var e,t,r,a,i=n.split(/\r?\n/),o={},s=0,l=i.length;s<l;++s)-1!==(e=(t=i[s]).indexOf(":"))&&(r=t.slice(0,e).toLowerCase(),a=y(t.slice(e+1)),o[r]=a);return o}(this.xhr.getAllResponseHeaders()),this.header["content-type"]=this.xhr.getResponseHeader("content-type"),this._setHeaderProperties(this.header),null===this.text&&n._responseType?this.body=this.xhr.response:this.body="HEAD"!=this.req.method?this._parseBody(this.text?this.text:this.xhr.response):null}function c(n,e){var t=this;this._query=this._query||[],this.method=n,this.url=e,this.header={},this._header={},this.on("end",(function(){var n,e=null,r=null;try{r=new l(t)}catch(r){return(e=new Error("Parser is unable to parse the response")).parse=!0,e.original=r,t.xhr?(e.rawResponse=void 0===t.xhr.responseType?t.xhr.responseText:t.xhr.response,e.status=t.xhr.status?t.xhr.status:null,e.statusCode=e.status):(e.rawResponse=null,e.status=null),t.callback(e)}t.emit("response",r);try{t._isResponseOK(r)||(n=new Error(r.statusText||"Unsuccessful HTTP response"))}catch(e){n=e}n?(n.original=e,n.response=r,n.status=r.status,t.callback(n,r)):t.callback(null,r)}))}function u(n,e,t){var r=g("DELETE",n);return"function"==typeof e&&(t=e,e=null),e&&r.send(e),t&&r.end(t),r}var d;"undefined"!=typeof window?d=window:"undefined"!=typeof self?d=self:(console.warn("Using browser-only version of superagent in non-browser environment"),d=this);var p=t(22),h=t(23),f=t(11),v=t(24),m=t(26),g=e=n.exports=function(n,t){return"function"==typeof t?new e.Request("GET",n).end(t):1==arguments.length?new e.Request("GET",n):new e.Request(n,t)};e.Request=c,g.getXHR=function(){if(!(!d.XMLHttpRequest||d.location&&"file:"==d.location.protocol&&d.ActiveXObject))return new XMLHttpRequest;try{return new ActiveXObject("Microsoft.XMLHTTP")}catch(n){}try{return new ActiveXObject("Msxml2.XMLHTTP.6.0")}catch(n){}try{return new ActiveXObject("Msxml2.XMLHTTP.3.0")}catch(n){}try{return new ActiveXObject("Msxml2.XMLHTTP")}catch(n){}throw Error("Browser-only version of superagent could not find XHR")};var y="".trim?function(n){return n.trim()}:function(n){return n.replace(/(^\s*|\s*$)/g,"")};g.serializeObject=a,g.parseString=o,g.types={html:"text/html",json:"application/json",xml:"text/xml",urlencoded:"application/x-www-form-urlencoded",form:"application/x-www-form-urlencoded","form-data":"application/x-www-form-urlencoded"},g.serialize={"application/x-www-form-urlencoded":a,"application/json":JSON.stringify},g.parse={"application/x-www-form-urlencoded":o,"application/json":JSON.parse},v(l.prototype),l.prototype._parseBody=function(n){var e=g.parse[this.type];return this.req._parser?this.req._parser(this,n):(!e&&s(this.type)&&(e=g.parse["application/json"]),e&&n&&(n.length||n instanceof Object)?e(n):null)},l.prototype.toError=function(){var n=this.req,e=n.method,t=n.url,r="cannot "+e+" "+t+" ("+this.status+")",a=new Error(r);return a.status=this.status,a.method=e,a.url=t,a},g.Response=l,p(c.prototype),h(c.prototype),c.prototype.type=function(n){return this.set("Content-Type",g.types[n]||n),this},c.prototype.accept=function(n){return this.set("Accept",g.types[n]||n),this},c.prototype.auth=function(n,e,t){1===arguments.length&&(e=""),"object"==typeof e&&null!==e&&(t=e,e=""),t||(t={type:"function"==typeof btoa?"basic":"auto"});var r=function(n){if("function"==typeof btoa)return btoa(n);throw new Error("Cannot use basic auth, btoa is not a function")};return this._auth(n,e,t,r)},c.prototype.query=function(n){return"string"!=typeof n&&(n=a(n)),n&&this._query.push(n),this},c.prototype.attach=function(n,e,t){if(e){if(this._data)throw Error("superagent can't mix .send() and .attach()");this._getFormData().append(n,e,t||e.name)}return this},c.prototype._getFormData=function(){return this._formData||(this._formData=new d.FormData),this._formData},c.prototype.callback=function(n,e){if(this._shouldRetry(n,e))return this._retry();var t=this._callback;this.clearTimeout(),n&&(this._maxRetries&&(n.retries=this._retries-1),this.emit("error",n)),t(n,e)},c.prototype.crossDomainError=function(){var n=new Error("Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.");n.crossDomain=!0,n.status=this.status,n.method=this.method,n.url=this.url,this.callback(n)},c.prototype.buffer=c.prototype.ca=c.prototype.agent=function(){return console.warn("This is not supported in browser version of superagent"),this},c.prototype.pipe=c.prototype.write=function(){throw Error("Streaming is not supported in browser version of superagent")},c.prototype._isHost=function(n){return n&&"object"==typeof n&&!Array.isArray(n)&&"[object Object]"!==Object.prototype.toString.call(n)},c.prototype.end=function(n){return this._endCalled&&console.warn("Warning: .end() was called twice. This is not supported in superagent"),this._endCalled=!0,this._callback=n||r,this._finalizeQueryString(),this._end()},c.prototype._end=function(){var n=this,e=this.xhr=g.getXHR(),t=this._formData||this._data;this._setTimeouts(),e.onreadystatechange=function(){var t=e.readyState;if(t>=2&&n._responseTimeoutTimer&&clearTimeout(n._responseTimeoutTimer),4==t){var r;try{r=e.status}catch(n){r=0}if(!r){if(n.timedout||n._aborted)return;return n.crossDomainError()}n.emit("end")}};var r=function(e,t){t.total>0&&(t.percent=t.loaded/t.total*100),t.direction=e,n.emit("progress",t)};if(this.hasListeners("progress"))try{e.onprogress=r.bind(null,"download"),e.upload&&(e.upload.onprogress=r.bind(null,"upload"))}catch(n){}try{this.username&&this.password?e.open(this.method,this.url,!0,this.username,this.password):e.open(this.method,this.url,!0)}catch(n){return this.callback(n)}if(this._withCredentials&&(e.withCredentials=!0),!this._formData&&"GET"!=this.method&&"HEAD"!=this.method&&"string"!=typeof t&&!this._isHost(t)){var a=this._header["content-type"],i=this._serializer||g.serialize[a?a.split(";")[0]:""];!i&&s(a)&&(i=g.serialize["application/json"]),i&&(t=i(t))}for(var o in this.header)null!=this.header[o]&&this.header.hasOwnProperty(o)&&e.setRequestHeader(o,this.header[o]);return this._responseType&&(e.responseType=this._responseType),this.emit("request",this),e.send(void 0!==t?t:null),this},g.agent=function(){return new m},["GET","POST","OPTIONS","PATCH","PUT","DELETE"].forEach((function(n){m.prototype[n.toLowerCase()]=function(e,t){var r=new g.Request(n,e);return this._setDefaults(r),t&&r.end(t),r}})),m.prototype.del=m.prototype.delete,g.get=function(n,e,t){var r=g("GET",n);return"function"==typeof e&&(t=e,e=null),e&&r.query(e),t&&r.end(t),r},g.head=function(n,e,t){var r=g("HEAD",n);return"function"==typeof e&&(t=e,e=null),e&&r.query(e),t&&r.end(t),r},g.options=function(n,e,t){var r=g("OPTIONS",n);return"function"==typeof e&&(t=e,e=null),e&&r.send(e),t&&r.end(t),r},g.del=u,g.delete=u,g.patch=function(n,e,t){var r=g("PATCH",n);return"function"==typeof e&&(t=e,e=null),e&&r.send(e),t&&r.end(t),r},g.post=function(n,e,t){var r=g("POST",n);return"function"==typeof e&&(t=e,e=null),e&&r.send(e),t&&r.end(t),r},g.put=function(n,e,t){var r=g("PUT",n);return"function"==typeof e&&(t=e,e=null),e&&r.send(e),t&&r.end(t),r}},function(n,e,t){var r=t(18),a=t(19);n.exports=function(n,e,t){var i=e&&t||0;"string"==typeof n&&(e="binary"===n?new Array(16):null,n=null);var o=(n=n||{}).random||(n.rng||r)();if(o[6]=15&o[6]|64,o[8]=63&o[8]|128,e)for(var s=0;s<16;++s)e[i+s]=o[s];return e||a(o)}},function(n,e,t){"use strict";n.exports="3.13.2"},function(n,e,t){"use strict";n.exports=function(n){return null!==n&&"object"==typeof n}},function(n,e,t){"use strict";var r=t(0),a=t(1),i=t(31),o=["getItem","setItem","removeItem","clear"];i.async?r(o).each((function(n){"function"!=typeof i[n]&&(i[n]=function(){var e=new Error("Synchronous API ["+n+"] is not available in this runtime.");throw e.code="SYNC_API_NOT_AVAILABLE",e})})):r(o).each((function(n){"function"==typeof i[n]&&(i[n+"Async"]=function(){return a.resolve(i[n].apply(i,arguments))})})),n.exports=i},function(n,e,t){"use strict";var r=t(12),a=t(5),i=e.removeAsync=r.removeItemAsync.bind(r);e.getAsync=function(n){return n="AV/"+a.applicationId+"/"+n,r.getItemAsync(n).then((function(e){return function(n,e){try{n=JSON.parse(n)}catch(n){return null}return n?n.expiredAt&&n.expiredAt<Date.now()?i(e).then((function(){return null})):n.value:null}(e,n)}))},e.setAsync=function(n,e,t){var i={value:e};return"number"==typeof t&&(i.expiredAt=Date.now()+t),r.setItemAsync("AV/"+a.applicationId+"/"+n,JSON.stringify(i))}},function(n,e){var t={utf8:{stringToBytes:function(n){return t.bin.stringToBytes(unescape(encodeURIComponent(n)))},bytesToString:function(n){return decodeURIComponent(escape(t.bin.bytesToString(n)))}},bin:{stringToBytes:function(n){for(var e=[],t=0;t<n.length;t++)e.push(255&n.charCodeAt(t));return e},bytesToString:function(n){for(var e=[],t=0;t<n.length;t++)e.push(String.fromCharCode(n[t]));return e.join("")}}};n.exports=t},function(n,e,t){"use strict";
/*!
 * LeanCloud JavaScript SDK
 * https://leancloud.cn
 *
 * Copyright 2016 LeanCloud.cn, Inc.
 * The LeanCloud JavaScript SDK is freely distributable under the MIT license.
 */t(16);var r=t(0),a=t(5);a._=r,a.version=t(10),a.Promise=t(1),a.localStorage=t(12),a.Cache=t(13),a.Error=t(4),t(33),t(35)(a),t(36)(a),t(37)(a),t(38)(a),t(39)(a),t(40)(a),t(48)(a),t(49)(a),t(50)(a),t(51)(a),t(52)(a),t(54)(a),t(55)(a),t(56)(a),t(57)(a),t(58)(a),t(59)(a),a.Conversation=t(60),t(61),n.exports=a},function(n,e,t){},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof window.msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto);if(t){var r=new Uint8Array(16);n.exports=function(){return t(r),r}}else{var a=new Array(16);n.exports=function(){for(var n,e=0;e<16;e++)0==(3&e)&&(n=4294967296*Math.random()),a[e]=n>>>((3&e)<<3)&255;return a}}},function(n,e){for(var t=[],r=0;r<256;++r)t[r]=(r+256).toString(16).substr(1);n.exports=function(n,e){var r=e||0,a=t;return[a[n[r++]],a[n[r++]],a[n[r++]],a[n[r++]],"-",a[n[r++]],a[n[r++]],"-",a[n[r++]],a[n[r++]],"-",a[n[r++]],a[n[r++]],"-",a[n[r++]],a[n[r++]],a[n[r++]],a[n[r++]],a[n[r++]],a[n[r++]]].join("")}},function(n,e,t){"use strict";var r=t(10),a=["Browser"].concat(t(21));n.exports="LeanCloud-JS-SDK/"+r+" ("+a.join("; ")+")"},function(n,e,t){"use strict";n.exports=[]},function(n,e,t){function r(n){if(n)return function(n){for(var e in r.prototype)n[e]=r.prototype[e];return n}(n)}n.exports=r,r.prototype.on=r.prototype.addEventListener=function(n,e){return this._callbacks=this._callbacks||{},(this._callbacks["$"+n]=this._callbacks["$"+n]||[]).push(e),this},r.prototype.once=function(n,e){function t(){this.off(n,t),e.apply(this,arguments)}return t.fn=e,this.on(n,t),this},r.prototype.off=r.prototype.removeListener=r.prototype.removeAllListeners=r.prototype.removeEventListener=function(n,e){if(this._callbacks=this._callbacks||{},0==arguments.length)return this._callbacks={},this;var t=this._callbacks["$"+n];if(!t)return this;if(1==arguments.length)return delete this._callbacks["$"+n],this;for(var r,a=0;a<t.length;a++)if((r=t[a])===e||r.fn===e){t.splice(a,1);break}return 0===t.length&&delete this._callbacks["$"+n],this},r.prototype.emit=function(n){this._callbacks=this._callbacks||{};for(var e=new Array(arguments.length-1),t=this._callbacks["$"+n],r=1;r<arguments.length;r++)e[r-1]=arguments[r];if(t){r=0;for(var a=(t=t.slice(0)).length;r<a;++r)t[r].apply(this,e)}return this},r.prototype.listeners=function(n){return this._callbacks=this._callbacks||{},this._callbacks["$"+n]||[]},r.prototype.hasListeners=function(n){return!!this.listeners(n).length}},function(n,e,t){"use strict";function r(n){if(n)return function(n){for(var e in r.prototype)n[e]=r.prototype[e];return n}(n)}var a=t(11);n.exports=r,r.prototype.clearTimeout=function(){return clearTimeout(this._timer),clearTimeout(this._responseTimeoutTimer),delete this._timer,delete this._responseTimeoutTimer,this},r.prototype.parse=function(n){return this._parser=n,this},r.prototype.responseType=function(n){return this._responseType=n,this},r.prototype.serialize=function(n){return this._serializer=n,this},r.prototype.timeout=function(n){if(!n||"object"!=typeof n)return this._timeout=n,this._responseTimeout=0,this;for(var e in n)switch(e){case"deadline":this._timeout=n.deadline;break;case"response":this._responseTimeout=n.response;break;default:console.warn("Unknown timeout option",e)}return this},r.prototype.retry=function(n,e){return 0!==arguments.length&&!0!==n||(n=1),n<=0&&(n=0),this._maxRetries=n,this._retries=0,this._retryCallback=e,this};var i=["ECONNRESET","ETIMEDOUT","EADDRINFO","ESOCKETTIMEDOUT"];r.prototype._shouldRetry=function(n,e){if(!this._maxRetries||this._retries++>=this._maxRetries)return!1;if(this._retryCallback)try{var t=this._retryCallback(n,e);if(!0===t)return!0;if(!1===t)return!1}catch(n){console.error(n)}if(e&&e.status&&e.status>=500&&501!=e.status)return!0;if(n){if(n.code&&~i.indexOf(n.code))return!0;if(n.timeout&&"ECONNABORTED"==n.code)return!0;if(n.crossDomain)return!0}return!1},r.prototype._retry=function(){return this.clearTimeout(),this.req&&(this.req=null,this.req=this.request()),this._aborted=!1,this.timedout=!1,this._end()},r.prototype.then=function(n,e){if(!this._fullfilledPromise){var t=this;this._endCalled&&console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises"),this._fullfilledPromise=new Promise((function(n,e){t.end((function(t,r){t?e(t):n(r)}))}))}return this._fullfilledPromise.then(n,e)},r.prototype.catch=function(n){return this.then(void 0,n)},r.prototype.use=function(n){return n(this),this},r.prototype.ok=function(n){if("function"!=typeof n)throw Error("Callback required");return this._okCallback=n,this},r.prototype._isResponseOK=function(n){return!!n&&(this._okCallback?this._okCallback(n):n.status>=200&&n.status<300)},r.prototype.get=function(n){return this._header[n.toLowerCase()]},r.prototype.getHeader=r.prototype.get,r.prototype.set=function(n,e){if(a(n)){for(var t in n)this.set(t,n[t]);return this}return this._header[n.toLowerCase()]=e,this.header[n]=e,this},r.prototype.unset=function(n){return delete this._header[n.toLowerCase()],delete this.header[n],this},r.prototype.field=function(n,e){if(null==n)throw new Error(".field(name, val) name can not be empty");if(this._data&&console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()"),a(n)){for(var t in n)this.field(t,n[t]);return this}if(Array.isArray(e)){for(var r in e)this.field(n,e[r]);return this}if(null==e)throw new Error(".field(name, val) val can not be empty");return"boolean"==typeof e&&(e=""+e),this._getFormData().append(n,e),this},r.prototype.abort=function(){return this._aborted||(this._aborted=!0,this.xhr&&this.xhr.abort(),this.req&&this.req.abort(),this.clearTimeout(),this.emit("abort")),this},r.prototype._auth=function(n,e,t,r){switch(t.type){case"basic":this.set("Authorization","Basic "+r(n+":"+e));break;case"auto":this.username=n,this.password=e;break;case"bearer":this.set("Authorization","Bearer "+n)}return this},r.prototype.withCredentials=function(n){return null==n&&(n=!0),this._withCredentials=n,this},r.prototype.redirects=function(n){return this._maxRedirects=n,this},r.prototype.maxResponseSize=function(n){if("number"!=typeof n)throw TypeError("Invalid argument");return this._maxResponseSize=n,this},r.prototype.toJSON=function(){return{method:this.method,url:this.url,data:this._data,headers:this._header}},r.prototype.send=function(n){var e=a(n),t=this._header["content-type"];if(this._formData&&console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()"),e&&!this._data)Array.isArray(n)?this._data=[]:this._isHost(n)||(this._data={});else if(n&&this._data&&this._isHost(this._data))throw Error("Can't merge these send calls");if(e&&a(this._data))for(var r in n)this._data[r]=n[r];else"string"==typeof n?(t||this.type("form"),t=this._header["content-type"],this._data="application/x-www-form-urlencoded"==t?this._data?this._data+"&"+n:n:(this._data||"")+n):this._data=n;return!e||this._isHost(n)||t||this.type("json"),this},r.prototype.sortQuery=function(n){return this._sort=void 0===n||n,this},r.prototype._finalizeQueryString=function(){var n=this._query.join("&");if(n&&(this.url+=(this.url.indexOf("?")>=0?"&":"?")+n),this._query.length=0,this._sort){var e=this.url.indexOf("?");if(e>=0){var t=this.url.substring(e+1).split("&");"function"==typeof this._sort?t.sort(this._sort):t.sort(),this.url=this.url.substring(0,e)+"?"+t.join("&")}}},r.prototype._appendQueryString=function(){console.trace("Unsupported")},r.prototype._timeoutError=function(n,e,t){if(!this._aborted){var r=new Error(n+e+"ms exceeded");r.timeout=e,r.code="ECONNABORTED",r.errno=t,this.timedout=!0,this.abort(),this.callback(r)}},r.prototype._setTimeouts=function(){var n=this;this._timeout&&!this._timer&&(this._timer=setTimeout((function(){n._timeoutError("Timeout of ",n._timeout,"ETIME")}),this._timeout)),this._responseTimeout&&!this._responseTimeoutTimer&&(this._responseTimeoutTimer=setTimeout((function(){n._timeoutError("Response timeout of ",n._responseTimeout,"ETIMEDOUT")}),this._responseTimeout))}},function(n,e,t){"use strict";function r(n){if(n)return function(n){for(var e in r.prototype)n[e]=r.prototype[e];return n}(n)}var a=t(25);n.exports=r,r.prototype.get=function(n){return this.header[n.toLowerCase()]},r.prototype._setHeaderProperties=function(n){var e=n["content-type"]||"";this.type=a.type(e);var t=a.params(e);for(var r in t)this[r]=t[r];this.links={};try{n.link&&(this.links=a.parseLinks(n.link))}catch(n){}},r.prototype._setStatusProperties=function(n){var e=n/100|0;this.status=this.statusCode=n,this.statusType=e,this.info=1==e,this.ok=2==e,this.redirect=3==e,this.clientError=4==e,this.serverError=5==e,this.error=(4==e||5==e)&&this.toError(),this.created=201==n,this.accepted=202==n,this.noContent=204==n,this.badRequest=400==n,this.unauthorized=401==n,this.notAcceptable=406==n,this.forbidden=403==n,this.notFound=404==n,this.unprocessableEntity=422==n}},function(n,e,t){"use strict";e.type=function(n){return n.split(/ *; */).shift()},e.params=function(n){return n.split(/ *; */).reduce((function(n,e){var t=e.split(/ *= */),r=t.shift(),a=t.shift();return r&&a&&(n[r]=a),n}),{})},e.parseLinks=function(n){return n.split(/ *, */).reduce((function(n,e){var t=e.split(/ *; */),r=t[0].slice(1,-1);return n[t[1].split(/ *= */)[1].slice(1,-1)]=r,n}),{})},e.cleanHeader=function(n,e){return delete n["content-type"],delete n["content-length"],delete n["transfer-encoding"],delete n.host,e&&(delete n.authorization,delete n.cookie),n}},function(n,e){function t(){this._defaults=[]}["use","on","once","set","query","type","accept","auth","withCredentials","sortQuery","retry","ok","redirects","timeout","buffer","serialize","parse","ca","key","pfx","cert"].forEach((function(n){t.prototype[n]=function(){return this._defaults.push({fn:n,arguments:arguments}),this}})),t.prototype._setDefaults=function(n){this._defaults.forEach((function(e){n[e.fn].apply(n,e.arguments)}))},n.exports=t},function(n,e,t){"use strict";n.exports=function(n){function e(n){for(var e=0,t=0;t<n.length;t++)e=(e<<5)-e+n.charCodeAt(t),e|=0;return r.colors[Math.abs(e)%r.colors.length]}function r(n){function t(){if(t.enabled){for(var n=arguments.length,e=new Array(n),a=0;a<n;a++)e[a]=arguments[a];var i=t,s=Number(new Date),l=s-(o||s);i.diff=l,i.prev=o,i.curr=s,o=s,e[0]=r.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");var c=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,(function(n,t){if("%%"===n)return n;c++;var a=r.formatters[t];if("function"==typeof a){var o=e[c];n=a.call(i,o),e.splice(c,1),c--}return n})),r.formatArgs.call(i,e),(i.log||r.log).apply(i,e)}}var o;return t.namespace=n,t.enabled=r.enabled(n),t.useColors=r.useColors(),t.color=e(n),t.destroy=a,t.extend=i,"function"==typeof r.init&&r.init(t),r.instances.push(t),t}function a(){var n=r.instances.indexOf(this);return-1!==n&&(r.instances.splice(n,1),!0)}function i(n,e){return r(this.namespace+(void 0===e?":":e)+n)}return r.debug=r,r.default=r,r.coerce=function(n){return n instanceof Error?n.stack||n.message:n},r.disable=function(){r.enable("")},r.enable=function(n){r.save(n),r.names=[],r.skips=[];var e,t=("string"==typeof n?n:"").split(/[\s,]+/),a=t.length;for(e=0;e<a;e++)t[e]&&("-"===(n=t[e].replace(/\*/g,".*?"))[0]?r.skips.push(new RegExp("^"+n.substr(1)+"$")):r.names.push(new RegExp("^"+n+"$")));for(e=0;e<r.instances.length;e++){var i=r.instances[e];i.enabled=r.enabled(i.namespace)}},r.enabled=function(n){if("*"===n[n.length-1])return!0;var e,t;for(e=0,t=r.skips.length;e<t;e++)if(r.skips[e].test(n))return!1;for(e=0,t=r.names.length;e<t;e++)if(r.names[e].test(n))return!0;return!1},r.humanize=t(28),Object.keys(n).forEach((function(e){r[e]=n[e]})),r.instances=[],r.names=[],r.skips=[],r.formatters={},r.selectColor=e,r.enable(r.load()),r}},function(n,e){function t(n){var e=Math.abs(n);return e>=s?r(n,e,s,"day"):e>=o?r(n,e,o,"hour"):e>=i?r(n,e,i,"minute"):e>=a?r(n,e,a,"second"):n+" ms"}function r(n,e,t,r){var a=e>=1.5*t;return Math.round(n/t)+" "+r+(a?"s":"")}var a=1e3,i=60*a,o=60*i,s=24*o,l=7*s,c=365.25*s;n.exports=function(n,e){e=e||{};var r=typeof n;if("string"===r&&n.length>0)return function(n){if(!((n=String(n)).length>100)){var e=/^((?:\d+)?\-?\d?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(n);if(e){var t=parseFloat(e[1]);switch((e[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return t*c;case"weeks":case"week":case"w":return t*l;case"days":case"day":case"d":return t*s;case"hours":case"hour":case"hrs":case"hr":case"h":return t*o;case"minutes":case"minute":case"mins":case"min":case"m":return t*i;case"seconds":case"second":case"secs":case"sec":case"s":return t*a;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:return}}}}(n);if("number"===r&&!1===isNaN(n))return e.long?t(n):function(n){var e=Math.abs(n);return e>=s?Math.round(n/s)+"d":e>=o?Math.round(n/o)+"h":e>=i?Math.round(n/i)+"m":e>=a?Math.round(n/a)+"s":n+"ms"}(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))}},function(n,e,t){(function(e){
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.3+b33f4734
 */
!function(e,t){n.exports=t()}(0,(function(){"use strict";function n(n){return"function"==typeof n}function r(){var n=setTimeout;return function(){return n(a,1)}}function a(){for(var n=0;n<b;n+=2)(0,T[n])(T[n+1]),T[n]=void 0,T[n+1]=void 0;b=0}function i(n,e){var t=this,r=new this.constructor(s);void 0===r[j]&&g(r);var a=t._state;if(a){var i=arguments[a-1];x((function(){return m(a,r,i,t._result)}))}else f(t,r,n,e);return r}function o(n){if(n&&"object"==typeof n&&n.constructor===this)return n;var e=new this(s);return u(e,n),e}function s(){}function l(n){try{return n.then}catch(n){return N.error=n,N}}function c(e,t,r){t.constructor===e.constructor&&r===i&&t.constructor.resolve===o?function(n,e){e._state===I?p(n,e._result):e._state===L?h(n,e._result):f(e,void 0,(function(e){return u(n,e)}),(function(e){return h(n,e)}))}(e,t):r===N?(h(e,N.error),N.error=null):void 0===r?p(e,t):n(r)?function(n,e,t){x((function(n){var r=!1,a=function(n,e,t,r){try{n.call(e,t,r)}catch(n){return n}}(t,e,(function(t){r||(r=!0,e!==t?u(n,t):p(n,t))}),(function(e){r||(r=!0,h(n,e))}),n._label);!r&&a&&(r=!0,h(n,a))}),n)}(e,t,r):p(e,t)}function u(n,e){n===e?h(n,new TypeError("You cannot resolve a promise with itself")):function(n){var e=typeof n;return null!==n&&("object"===e||"function"===e)}(e)?c(n,e,l(e)):p(n,e)}function d(n){n._onerror&&n._onerror(n._result),v(n)}function p(n,e){n._state===B&&(n._result=e,n._state=I,0!==n._subscribers.length&&x(v,n))}function h(n,e){n._state===B&&(n._state=L,n._result=e,x(d,n))}function f(n,e,t,r){var a=n._subscribers,i=a.length;n._onerror=null,a[i]=e,a[i+I]=t,a[i+L]=r,0===i&&n._state&&x(v,n)}function v(n){var e=n._subscribers,t=n._state;if(0!==e.length){for(var r=void 0,a=void 0,i=n._result,o=0;o<e.length;o+=3)r=e[o],a=e[o+t],r?m(t,r,a,i):a(i);n._subscribers.length=0}}function m(e,t,r,a){var i=n(r),o=void 0,s=void 0,l=void 0,c=void 0;if(i){if((o=function(n,e){try{return n(e)}catch(n){return N.error=n,N}}(r,a))===N?(c=!0,s=o.error,o.error=null):l=!0,t===o)return void h(t,new TypeError("A promises callback cannot return that same promise."))}else o=a,l=!0;t._state!==B||(i&&l?u(t,o):c?h(t,s):e===I?p(t,o):e===L&&h(t,o))}function g(n){n[j]=P++,n._state=void 0,n._result=void 0,n._subscribers=[]}var y=Array.isArray?Array.isArray:function(n){return"[object Array]"===Object.prototype.toString.call(n)},b=0,w=void 0,k=void 0,x=function(n,e){T[b]=n,T[b+1]=e,2===(b+=2)&&(k?k(a):O())},E="undefined"!=typeof window?window:void 0,A=E||{},_=A.MutationObserver||A.WebKitMutationObserver,S="undefined"==typeof self&&"undefined"!=typeof process&&"[object process]"==={}.toString.call(process),C="undefined"!=typeof Uint8ClampedArray&&"undefined"!=typeof importScripts&&"undefined"!=typeof MessageChannel,T=new Array(1e3),O=void 0;O=S?function(){return process.nextTick(a)}:_?function(){var n=0,e=new _(a),t=document.createTextNode("");return e.observe(t,{characterData:!0}),function(){t.data=n=++n%2}}():C?function(){var n=new MessageChannel;return n.port1.onmessage=a,function(){return n.port2.postMessage(0)}}():void 0===E?function(){try{var n=t(30);return void 0!==(w=n.runOnLoop||n.runOnContext)?function(){w(a)}:r()}catch(n){return r()}}():r();var j=Math.random().toString(36).substring(2),B=void 0,I=1,L=2,N={error:null},P=0,q=function(){function n(n,e){this._instanceConstructor=n,this.promise=new n(s),this.promise[j]||g(this.promise),y(e)?(this.length=e.length,this._remaining=e.length,this._result=new Array(this.length),0===this.length?p(this.promise,this._result):(this.length=this.length||0,this._enumerate(e),0===this._remaining&&p(this.promise,this._result))):h(this.promise,new Error("Array Methods must be provided an Array"))}return n.prototype._enumerate=function(n){for(var e=0;this._state===B&&e<n.length;e++)this._eachEntry(n[e],e)},n.prototype._eachEntry=function(n,e){var t=this._instanceConstructor,r=t.resolve;if(r===o){var a=l(n);if(a===i&&n._state!==B)this._settledAt(n._state,e,n._result);else if("function"!=typeof a)this._remaining--,this._result[e]=n;else if(t===R){var u=new t(s);c(u,n,a),this._willSettleAt(u,e)}else this._willSettleAt(new t((function(e){return e(n)})),e)}else this._willSettleAt(r(n),e)},n.prototype._settledAt=function(n,e,t){var r=this.promise;r._state===B&&(this._remaining--,n===L?h(r,t):this._result[e]=t),0===this._remaining&&p(r,this._result)},n.prototype._willSettleAt=function(n,e){var t=this;f(n,void 0,(function(n){return t._settledAt(I,e,n)}),(function(n){return t._settledAt(L,e,n)}))},n}(),R=function(){function n(e){this[j]=P++,this._result=this._state=void 0,this._subscribers=[],s!==e&&("function"!=typeof e&&function(){throw new TypeError("You must pass a resolver function as the first argument to the promise constructor")}(),this instanceof n?function(n,e){try{e((function(e){u(n,e)}),(function(e){h(n,e)}))}catch(e){h(n,e)}}(this,e):function(){throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.")}())}return n.prototype.catch=function(n){return this.then(null,n)},n.prototype.finally=function(n){var e=this.constructor;return this.then((function(t){return e.resolve(n()).then((function(){return t}))}),(function(t){return e.resolve(n()).then((function(){throw t}))}))},n}();return R.prototype.then=i,R.all=function(n){return new q(this,n).promise},R.race=function(n){var e=this;return new e(y(n)?function(t,r){for(var a=n.length,i=0;i<a;i++)e.resolve(n[i]).then(t,r)}:function(n,e){return e(new TypeError("You must pass an array to race."))})},R.resolve=o,R.reject=function(n){var e=new this(s);return h(e,n),e},R._setScheduler=function(n){k=n},R._setAsap=function(n){x=n},R._asap=x,R.polyfill=function(){var n=void 0;if(void 0!==e)n=e;else if("undefined"!=typeof self)n=self;else try{n=Function("return this")()}catch(n){throw new Error("polyfill failed because global object is unavailable in this environment")}var t=n.Promise;if(t){var r=null;try{r=Object.prototype.toString.call(t.resolve())}catch(n){}if("[object Promise]"===r&&!t.cast)return}n.Promise=R},R.Promise=R,R}))}).call(e,t(7))},function(n,e){},function(n,e,t){"use strict";(function(e){var r=t(0),a={},i=e.localStorage;try{var o="__storejs__";if(i.setItem(o,o),i.getItem(o)!=o)throw new Error;i.removeItem(o)}catch(n){i=t(32)}r(["getItem","setItem","removeItem","clear"]).each((function(n){a[n]=function(){return i[n].apply(i,arguments)}})),a.async=!1,n.exports=a}).call(e,t(7))},function(n,e,t){!function(e){var t={},r={};t.length=0,t.getItem=function(n){return n in r?r[n]:null},t.setItem=function(n,e){void 0===e?t.removeItem(n):(r.hasOwnProperty(n)||t.length++,r[n]=""+e)},t.removeItem=function(n){r.hasOwnProperty(n)&&(delete r[n],t.length--)},t.key=function(n){return Object.keys(r)[n]||null},t.clear=function(){r={},t.length=0},n.exports=t}()},function(n,e,t){"use strict";function r(n){var e=void 0,t=n.slice(0,8).toLowerCase();switch(n.slice(-9)){case"-9Nh9j0Va":e="lncldapi.com";break;case"-MdYXbMMI":e="lncldglobal.com";break;default:e="lncld.net"}return{push:"https://"+t+".push."+e,stats:"https://"+t+".stats."+e,engine:"https://"+t+".engine."+e,api:"https://"+t+".api."+e}}var a=t(5),i=t(34),o=t(3).isNullOrUndefined,s=t(0),l=s.extend,c=s.isObject,u=function(n){return{push:n,stats:n,engine:n,api:n}},d=!1;a.init=function(n){if(!c(n))return a.init({appId:n,appKey:arguments.length<=1?void 0:arguments[1],masterKey:arguments.length<=2?void 0:arguments[2]});var e=n.appId,t=n.appKey,o=n.masterKey,s=(n.hookKey,n.serverURLs),p=n.disableCurrentUser,h=n.production,f=n.realtime;if(a.applicationId)throw new Error("SDK is already initialized.");if(!e)throw new TypeError("appId must be a string");if(!t)throw new TypeError("appKey must be a string");o&&console.warn("MasterKey is not supposed to be used in browser."),a._config.applicationId=e,a._config.applicationKey=t,a._config.masterKey=o,void 0!==h&&(a._config.production=h),void 0!==p&&(a._config.disableCurrentUser=p),a._appRouter=new i(a);var v=d||void 0!==s;a._setServerURLs(l({},r(e),a._config.serverURLs,"string"==typeof s?u(s):s),v),f?a._config.realtime=f:a._sharedConfig.liveQueryRealtime&&(a._config.realtime=new a._sharedConfig.liveQueryRealtime({appId:e,appKey:t}))},a.setProduction=function(n){o(n)?a._config.production=null:a._config.production=n?1:0},a._setServerURLs=function(n){var e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];"string"!=typeof n?l(a._config.serverURLs,n):a._config.serverURLs=u(n),e&&(a._appRouter?a._appRouter.disable():d=!0)},a.setServerURLs=function(n){return a._setServerURLs(n)},a.keepErrorRawMessage=function(n){a._sharedConfig.keepErrorRawMessage=n},a.setRequestTimeout=function(n){a._config.requestTimeout=n},a.initialize=a.init,["applicationId","applicationKey","masterKey","hookKey"].forEach((function(n){return Object.defineProperty(a,n,{get:function(){return a._config[n]},set:function(e){a._config[n]=e}})}))},function(n,e,t){"use strict";function r(n){var e=this;this.AV=n,this.lockedUntil=0,i.getAsync("serverURLs").then((function(n){if(!e.disabled){if(!n)return e.lock(0);var t=n.serverURLs,r=n.lockedUntil;e.AV._setServerURLs(t,!1),e.lockedUntil=r}})).catch((function(){return e.lock(0)}))}var a=t(3).ajax,i=t(13);r.prototype.disable=function(){this.disabled=!0},r.prototype.lock=function(n){this.lockedUntil=Date.now()+n},r.prototype.refresh=function(){var n=this;if(!(this.disabled||Date.now()<this.lockedUntil))return this.lock(10),a({method:"get",url:"https://app-router.leancloud.cn/2/route",query:{appId:this.AV.applicationId}}).then((function(e){if(!n.disabled){var t=e.ttl;if(!t)throw new Error("missing ttl");t*=1e3;var r={push:"https://"+e.push_server,stats:"https://"+e.stats_server,engine:"https://"+e.engine_server,api:"https://"+e.api_server};return n.AV._setServerURLs(r,!1),n.lock(t),i.setAsync("serverURLs",{serverURLs:r,lockedUntil:n.lockedUntil},t)}})).catch((function(e){console.warn("refresh server URLs failed: "+e.message),n.lock(600)}))},n.exports=r},function(n,e,t){"use strict";var r=t(0);n.exports=function(n){var e=/\s+/,t=Array.prototype.slice;n.Events={on:function(n,t,r){var a,i,o,s,l;if(!t)return this;for(n=n.split(e),a=this._callbacks||(this._callbacks={}),i=n.shift();i;)(o=(l=a[i])?l.tail:{}).next=s={},o.context=r,o.callback=t,a[i]={tail:s,next:l?l.next:o},i=n.shift();return this},off:function(n,t,a){var i,o,s,l,c,u;if(o=this._callbacks){if(!(n||t||a))return delete this._callbacks,this;for(i=(n=n?n.split(e):r.keys(o)).shift();i;)if(s=o[i],delete o[i],s&&(t||a)){for(l=s.tail,s=s.next;s!==l;)c=s.callback,u=s.context,(t&&c!==t||a&&u!==a)&&this.on(i,c,u),s=s.next;i=n.shift()}return this}},trigger:function(n){var r,a,i,o,s,l,c;if(!(i=this._callbacks))return this;for(l=i.all,n=n.split(e),c=t.call(arguments,1),r=n.shift();r;){if(a=i[r])for(o=a.tail;(a=a.next)!==o;)a.callback.apply(a.context||this,c);if(a=l)for(o=a.tail,s=[r].concat(c);(a=a.next)!==o;)a.callback.apply(a.context||this,s);r=n.shift()}return this}},n.Events.bind=n.Events.on,n.Events.unbind=n.Events.off}},function(n,e,t){"use strict";var r=t(0),a=t(1);n.exports=function(n){n.GeoPoint=function(e,t){r.isArray(e)?(n.GeoPoint._validate(e[0],e[1]),this.latitude=e[0],this.longitude=e[1]):r.isObject(e)?(n.GeoPoint._validate(e.latitude,e.longitude),this.latitude=e.latitude,this.longitude=e.longitude):r.isNumber(e)&&r.isNumber(t)?(n.GeoPoint._validate(e,t),this.latitude=e,this.longitude=t):(this.latitude=0,this.longitude=0);var a=this;this.__defineGetter__&&this.__defineSetter__&&(this._latitude=this.latitude,this._longitude=this.longitude,this.__defineGetter__("latitude",(function(){return a._latitude})),this.__defineGetter__("longitude",(function(){return a._longitude})),this.__defineSetter__("latitude",(function(e){n.GeoPoint._validate(e,a.longitude),a._latitude=e})),this.__defineSetter__("longitude",(function(e){n.GeoPoint._validate(a.latitude,e),a._longitude=e})))},n.GeoPoint._validate=function(n,e){if(n<-90)throw new Error("AV.GeoPoint latitude "+n+" < -90.0.");if(n>90)throw new Error("AV.GeoPoint latitude "+n+" > 90.0.");if(e<-180)throw new Error("AV.GeoPoint longitude "+e+" < -180.0.");if(e>180)throw new Error("AV.GeoPoint longitude "+e+" > 180.0.")},n.GeoPoint.current=function(){return new a((function(e,t){navigator.geolocation.getCurrentPosition((function(t){e(new n.GeoPoint({latitude:t.coords.latitude,longitude:t.coords.longitude}))}),t)}))},r.extend(n.GeoPoint.prototype,{toJSON:function(){return n.GeoPoint._validate(this.latitude,this.longitude),{__type:"GeoPoint",latitude:this.latitude,longitude:this.longitude}},radiansTo:function(n){var e=Math.PI/180,t=this.latitude*e,r=this.longitude*e,a=n.latitude*e,i=t-a,o=r-n.longitude*e,s=Math.sin(i/2),l=Math.sin(o/2),c=s*s+Math.cos(t)*Math.cos(a)*l*l;return c=Math.min(1,c),2*Math.asin(Math.sqrt(c))},kilometersTo:function(n){return 6371*this.radiansTo(n)},milesTo:function(n){return 3958.8*this.radiansTo(n)}})}},function(n,e,t){"use strict";var r=t(0);n.exports=function(n){n.ACL=function(e){var t=this;if(t.permissionsById={},r.isObject(e))if(e instanceof n.User)t.setReadAccess(e,!0),t.setWriteAccess(e,!0);else{if(r.isFunction(e))throw new Error("AV.ACL() called with a function.  Did you forget ()?");n._objectEach(e,(function(e,a){if(!r.isString(a))throw new Error("Tried to create an ACL with an invalid userId.");t.permissionsById[a]={},n._objectEach(e,(function(n,e){if("read"!==e&&"write"!==e)throw new Error("Tried to create an ACL with an invalid permission type.");if(!r.isBoolean(n))throw new Error("Tried to create an ACL with an invalid permission value.");t.permissionsById[a][e]=n}))}))}},n.ACL.prototype.toJSON=function(){return r.clone(this.permissionsById)},n.ACL.prototype._setAccess=function(e,t,a){if(t instanceof n.User?t=t.id:t instanceof n.Role&&(t="role:"+t.getName()),!r.isString(t))throw new Error("userId must be a string.");if(!r.isBoolean(a))throw new Error("allowed must be either true or false.");var i=this.permissionsById[t];if(!i){if(!a)return;i={},this.permissionsById[t]=i}a?this.permissionsById[t][e]=!0:(delete i[e],r.isEmpty(i)&&delete this.permissionsById[t])},n.ACL.prototype._getAccess=function(e,t){t instanceof n.User?t=t.id:t instanceof n.Role&&(t="role:"+t.getName());var r=this.permissionsById[t];return!!r&&!!r[e]},n.ACL.prototype.setReadAccess=function(n,e){this._setAccess("read",n,e)},n.ACL.prototype.getReadAccess=function(n){return this._getAccess("read",n)},n.ACL.prototype.setWriteAccess=function(n,e){this._setAccess("write",n,e)},n.ACL.prototype.getWriteAccess=function(n){return this._getAccess("write",n)},n.ACL.prototype.setPublicReadAccess=function(n){this.setReadAccess("*",n)},n.ACL.prototype.getPublicReadAccess=function(){return this.getReadAccess("*")},n.ACL.prototype.setPublicWriteAccess=function(n){this.setWriteAccess("*",n)},n.ACL.prototype.getPublicWriteAccess=function(){return this.getWriteAccess("*")},n.ACL.prototype.getRoleReadAccess=function(e){if(e instanceof n.Role&&(e=e.getName()),r.isString(e))return this.getReadAccess("role:"+e);throw new Error("role must be a AV.Role or a String")},n.ACL.prototype.getRoleWriteAccess=function(e){if(e instanceof n.Role&&(e=e.getName()),r.isString(e))return this.getWriteAccess("role:"+e);throw new Error("role must be a AV.Role or a String")},n.ACL.prototype.setRoleReadAccess=function(e,t){if(e instanceof n.Role&&(e=e.getName()),!r.isString(e))throw new Error("role must be a AV.Role or a String");this.setReadAccess("role:"+e,t)},n.ACL.prototype.setRoleWriteAccess=function(e,t){if(e instanceof n.Role&&(e=e.getName()),!r.isString(e))throw new Error("role must be a AV.Role or a String");this.setWriteAccess("role:"+e,t)}}},function(n,e,t){"use strict";var r=t(0);n.exports=function(n){n.Op=function(){this._initialize.apply(this,arguments)},r.extend(n.Op.prototype,{_initialize:function(){}}),r.extend(n.Op,{_extend:n._extend,_opDecoderMap:{},_registerDecoder:function(e,t){n.Op._opDecoderMap[e]=t},_decode:function(e){var t=n.Op._opDecoderMap[e.__op];return t?t(e):void 0}}),n.Op._registerDecoder("Batch",(function(e){var t=null;return n._arrayEach(e.ops,(function(e){e=n.Op._decode(e),t=e._mergeWithPrevious(t)})),t})),n.Op.Set=n.Op._extend({_initialize:function(n){this._value=n},value:function(){return this._value},toJSON:function(){return n._encode(this.value())},_mergeWithPrevious:function(n){return this},_estimate:function(n){return this.value()}}),n.Op._UNSET={},n.Op.Unset=n.Op._extend({toJSON:function(){return{__op:"Delete"}},_mergeWithPrevious:function(n){return this},_estimate:function(e){return n.Op._UNSET}}),n.Op._registerDecoder("Delete",(function(e){return new n.Op.Unset})),n.Op.Increment=n.Op._extend({_initialize:function(n){this._amount=n},amount:function(){return this._amount},toJSON:function(){return{__op:"Increment",amount:this._amount}},_mergeWithPrevious:function(e){if(e){if(e instanceof n.Op.Unset)return new n.Op.Set(this.amount());if(e instanceof n.Op.Set)return new n.Op.Set(e.value()+this.amount());if(e instanceof n.Op.Increment)return new n.Op.Increment(this.amount()+e.amount());throw new Error("Op is invalid after previous op.")}return this},_estimate:function(n){return n?n+this.amount():this.amount()}}),n.Op._registerDecoder("Increment",(function(e){return new n.Op.Increment(e.amount)})),n.Op.BitAnd=n.Op._extend({_initialize:function(n){this._value=n},value:function(){return this._value},toJSON:function(){return{__op:"BitAnd",value:this.value()}},_mergeWithPrevious:function(e){if(e){if(e instanceof n.Op.Unset)return new n.Op.Set(0);if(e instanceof n.Op.Set)return new n.Op.Set(e.value()&this.value());throw new Error("Op is invalid after previous op.")}return this},_estimate:function(n){return n&this.value()}}),n.Op._registerDecoder("BitAnd",(function(e){return new n.Op.BitAnd(e.value)})),n.Op.BitOr=n.Op._extend({_initialize:function(n){this._value=n},value:function(){return this._value},toJSON:function(){return{__op:"BitOr",value:this.value()}},_mergeWithPrevious:function(e){if(e){if(e instanceof n.Op.Unset)return new n.Op.Set(this.value());if(e instanceof n.Op.Set)return new n.Op.Set(e.value()|this.value());throw new Error("Op is invalid after previous op.")}return this},_estimate:function(n){return n|this.value()}}),n.Op._registerDecoder("BitOr",(function(e){return new n.Op.BitOr(e.value)})),n.Op.BitXor=n.Op._extend({_initialize:function(n){this._value=n},value:function(){return this._value},toJSON:function(){return{__op:"BitXor",value:this.value()}},_mergeWithPrevious:function(e){if(e){if(e instanceof n.Op.Unset)return new n.Op.Set(this.value());if(e instanceof n.Op.Set)return new n.Op.Set(e.value()^this.value());throw new Error("Op is invalid after previous op.")}return this},_estimate:function(n){return n^this.value()}}),n.Op._registerDecoder("BitXor",(function(e){return new n.Op.BitXor(e.value)})),n.Op.Add=n.Op._extend({_initialize:function(n){this._objects=n},objects:function(){return this._objects},toJSON:function(){return{__op:"Add",objects:n._encode(this.objects())}},_mergeWithPrevious:function(e){if(e){if(e instanceof n.Op.Unset)return new n.Op.Set(this.objects());if(e instanceof n.Op.Set)return new n.Op.Set(this._estimate(e.value()));if(e instanceof n.Op.Add)return new n.Op.Add(e.objects().concat(this.objects()));throw new Error("Op is invalid after previous op.")}return this},_estimate:function(n){return n?n.concat(this.objects()):r.clone(this.objects())}}),n.Op._registerDecoder("Add",(function(e){return new n.Op.Add(n._decode(e.objects))})),n.Op.AddUnique=n.Op._extend({_initialize:function(n){this._objects=r.uniq(n)},objects:function(){return this._objects},toJSON:function(){return{__op:"AddUnique",objects:n._encode(this.objects())}},_mergeWithPrevious:function(e){if(e){if(e instanceof n.Op.Unset)return new n.Op.Set(this.objects());if(e instanceof n.Op.Set)return new n.Op.Set(this._estimate(e.value()));if(e instanceof n.Op.AddUnique)return new n.Op.AddUnique(this._estimate(e.objects()));throw new Error("Op is invalid after previous op.")}return this},_estimate:function(e){if(e){var t=r.clone(e);return n._arrayEach(this.objects(),(function(e){if(e instanceof n.Object&&e.id){var a=r.find(t,(function(t){return t instanceof n.Object&&t.id===e.id}));if(a){var i=r.indexOf(t,a);t[i]=e}else t.push(e)}else r.contains(t,e)||t.push(e)})),t}return r.clone(this.objects())}}),n.Op._registerDecoder("AddUnique",(function(e){return new n.Op.AddUnique(n._decode(e.objects))})),n.Op.Remove=n.Op._extend({_initialize:function(n){this._objects=r.uniq(n)},objects:function(){return this._objects},toJSON:function(){return{__op:"Remove",objects:n._encode(this.objects())}},_mergeWithPrevious:function(e){if(e){if(e instanceof n.Op.Unset)return e;if(e instanceof n.Op.Set)return new n.Op.Set(this._estimate(e.value()));if(e instanceof n.Op.Remove)return new n.Op.Remove(r.union(e.objects(),this.objects()));throw new Error("Op is invalid after previous op.")}return this},_estimate:function(e){if(e){var t=r.difference(e,this.objects());return n._arrayEach(this.objects(),(function(e){e instanceof n.Object&&e.id&&(t=r.reject(t,(function(t){return t instanceof n.Object&&t.id===e.id})))})),t}return[]}}),n.Op._registerDecoder("Remove",(function(e){return new n.Op.Remove(n._decode(e.objects))})),n.Op.Relation=n.Op._extend({_initialize:function(e,t){this._targetClassName=null;var a=this,i=function(e){if(e instanceof n.Object){if(!e.id)throw new Error("You can't add an unsaved AV.Object to a relation.");if(a._targetClassName||(a._targetClassName=e.className),a._targetClassName!==e.className)throw new Error("Tried to create a AV.Relation with 2 different types: "+a._targetClassName+" and "+e.className+".");return e.id}return e};this.relationsToAdd=r.uniq(r.map(e,i)),this.relationsToRemove=r.uniq(r.map(t,i))},added:function(){var e=this;return r.map(this.relationsToAdd,(function(t){var r=n.Object._create(e._targetClassName);return r.id=t,r}))},removed:function(){var e=this;return r.map(this.relationsToRemove,(function(t){var r=n.Object._create(e._targetClassName);return r.id=t,r}))},toJSON:function(){var n=null,e=null,t=this,a=function(n){return{__type:"Pointer",className:t._targetClassName,objectId:n}};return this.relationsToAdd.length>0&&(n={__op:"AddRelation",objects:r.map(this.relationsToAdd,a)}),this.relationsToRemove.length>0&&(e={__op:"RemoveRelation",objects:r.map(this.relationsToRemove,a)}),n&&e?{__op:"Batch",ops:[n,e]}:n||e||{}},_mergeWithPrevious:function(e){if(e){if(e instanceof n.Op.Unset)throw new Error("You can't modify a relation after deleting it.");if(e instanceof n.Op.Relation){if(e._targetClassName&&e._targetClassName!==this._targetClassName)throw new Error("Related object must be of class "+e._targetClassName+", but "+this._targetClassName+" was passed in.");var t=r.union(r.difference(e.relationsToAdd,this.relationsToRemove),this.relationsToAdd),a=r.union(r.difference(e.relationsToRemove,this.relationsToAdd),this.relationsToRemove),i=new n.Op.Relation(t,a);return i._targetClassName=this._targetClassName,i}throw new Error("Op is invalid after previous op.")}return this},_estimate:function(e,t,r){if(e){if(e instanceof n.Relation){if(this._targetClassName)if(e.targetClassName){if(e.targetClassName!==this._targetClassName)throw new Error("Related object must be a "+e.targetClassName+", but a "+this._targetClassName+" was passed in.")}else e.targetClassName=this._targetClassName;return e}throw new Error("Op is invalid after previous op.")}new n.Relation(t,r).targetClassName=this._targetClassName}}),n.Op._registerDecoder("AddRelation",(function(e){return new n.Op.Relation(n._decode(e.objects),[])})),n.Op._registerDecoder("RemoveRelation",(function(e){return new n.Op.Relation([],n._decode(e.objects))}))}},function(n,e,t){"use strict";var r=t(0);n.exports=function(n){n.Relation=function(n,e){if(!r.isString(e))throw new TypeError("key must be a string");this.parent=n,this.key=e,this.targetClassName=null},n.Relation.reverseQuery=function(e,t,r){var a=new n.Query(e);return a.equalTo(t,r._toPointer()),a},r.extend(n.Relation.prototype,{_ensureParentAndKey:function(n,e){if(this.parent=this.parent||n,this.key=this.key||e,this.parent!==n)throw new Error("Internal Error. Relation retrieved from two different Objects.");if(this.key!==e)throw new Error("Internal Error. Relation retrieved from two different keys.")},add:function(e){r.isArray(e)||(e=[e]);var t=new n.Op.Relation(e,[]);this.parent.set(this.key,t),this.targetClassName=t._targetClassName},remove:function(e){r.isArray(e)||(e=[e]);var t=new n.Op.Relation([],e);this.parent.set(this.key,t),this.targetClassName=t._targetClassName},toJSON:function(){return{__type:"Relation",className:this.targetClassName}},query:function(){var e,t;return this.targetClassName?(e=n.Object._getSubclass(this.targetClassName),t=new n.Query(e)):(e=n.Object._getSubclass(this.parent.className),(t=new n.Query(e))._extraOptions.redirectClassNameForKey=this.key),t._addCondition("$relatedTo","object",this.parent._toPointer()),t._addCondition("$relatedTo","key",this.key),t}})}},function(n,e,t){"use strict";var r=t(0),a=t(41),i=t(42),o=t(43),s=t(4),l=t(2)._request,c=t(1),u=t(3),d=u.tap,p=u.transformFetchOptions,h=t(6)("leancloud:file"),f=t(47);n.exports=function(n){var e=function(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)},t=function(n){return r.isString(n)?n.match(/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/)[4]:""},u=function(n){if(n<26)return String.fromCharCode(65+n);if(n<52)return String.fromCharCode(n-26+97);if(n<62)return String.fromCharCode(n-52+48);if(62===n)return"+";if(63===n)return"/";throw new Error("Tried to encode large digit "+n+" in base64.")},v=function(n){var e=[];return e.length=Math.ceil(n.length/3),r.times(e.length,(function(t){var r=n[3*t],a=n[3*t+1]||0,i=n[3*t+2]||0,o=3*t+1<n.length,s=3*t+2<n.length;e[t]=[u(r>>2&63),u(r<<4&48|a>>4&15),o?u(a<<2&60|i>>6&3):"=",s?u(63&i):"="].join("")})),e.join("")};n.File=function(e,a,i){if(this.attributes={name:e,url:"",metaData:{},base64:""},r.isString(a))throw new TypeError("Creating an AV.File from a String is not yet supported.");r.isArray(a)&&(this.attributes.metaData.size=a.length,a={base64:v(a)}),this._extName="",this._data=a,this._uploadHeaders={},"undefined"!=typeof Blob&&a instanceof Blob&&(a.size&&(this.attributes.metaData.size=a.size),a.name&&(this._extName=t(a.name)));var o=void 0;if(a&&a.owner)o=a.owner;else if(!n._config.disableCurrentUser)try{o=n.User.current()}catch(n){if("SYNC_API_NOT_AVAILABLE"!==n.code)throw n}this.attributes.metaData.owner=o?o.id:"unknown",this.set("mime_type",i)},n.File.withURL=function(e,t,r,a){if(!e||!t)throw new Error("Please provide file name and url");var i=new n.File(e,null,a);if(r)for(var o in r)i.attributes.metaData[o]||(i.attributes.metaData[o]=r[o]);return i.attributes.url=t,i.attributes.metaData.__source="external",i},n.File.createWithoutData=function(e){var t=new n.File;return t.id=e,t},r.extend(n.File.prototype,{className:"_File",_toFullJSON:function(e){var t=this,a=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=r.clone(this.attributes);return n._objectEach(i,(function(t,r){i[r]=n._encode(t,e,void 0,a)})),n._objectEach(this._operations,(function(n,e){i[e]=n})),r.has(this,"id")&&(i.objectId=this.id),r(["createdAt","updatedAt"]).each((function(n){if(r.has(t,n)){var e=t[n];i[n]=r.isDate(e)?e.toJSON():e}})),a&&(i.__type="File"),i},toFullJSON:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return this._toFullJSON(n)},toJSON:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[this];return this._toFullJSON(t,!1)},_toPointer:function(){return{__type:"Pointer",className:this.className,objectId:this.id}},getACL:function(){return this._acl},setACL:function(e){return e instanceof n.ACL?(this._acl=e,this):new s(s.OTHER_CAUSE,"ACL must be a AV.ACL.")},name:function(){return this.get("name")},url:function(){return this.get("url")},get:function(n){switch(n){case"objectId":return this.id;case"url":case"name":case"mime_type":case"metaData":case"createdAt":case"updatedAt":return this.attributes[n];default:return this.attributes.metaData[n]}},set:function(){for(var n=this,e=function(e,t){switch(e){case"name":case"url":case"mime_type":case"base64":case"metaData":n.attributes[e]=t;break;default:n.attributes.metaData[e]=t}},t=arguments.length,r=Array(t),a=0;a<t;a++)r[a]=arguments[a];switch(r.length){case 1:for(var i in r[0])e(i,r[0][i]);break;case 2:e(r[0],r[1])}return this},setUploadHeader:function(n,e){return this._uploadHeaders[n]=e,this},metaData:function(n,e){return n&&e?(this.attributes.metaData[n]=e,this):n&&!e?this.attributes.metaData[n]:this.attributes.metaData},thumbnailURL:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:100,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"png",i=this.attributes.url;if(!i)throw new Error("Invalid url.");if(!n||!e||n<=0||e<=0)throw new Error("Invalid width or height value.");if(t<=0||t>100)throw new Error("Invalid quality value.");return i+"?imageView/"+(r?2:1)+"/w/"+n+"/h/"+e+"/q/"+t+"/format/"+a},size:function(){return this.metaData().size},ownerId:function(){return this.metaData().owner},destroy:function(n){return this.id?l("files",null,this.id,"DELETE",null,n):c.reject(new Error("The file id does not eixst."))},_fileToken:function(n,r){var a=this.attributes.name,i=t(a);!i&&this._extName&&(a+=this._extName,i=this._extName);var o=e()+e()+e()+e()+e()+i,s={key:o,name:a,keep_file_name:r.keepFileName,ACL:this._acl,mime_type:n,metaData:this.attributes.metaData};return this._qiniu_key=o,l("fileTokens",null,null,"POST",s,r)},save:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(this.id)throw new Error("File is already saved.");if(!this._previousSave)if(this._data){var t=this.get("mime_type");this._previousSave=this._fileToken(t,e).then((function(s){return s.mime_type&&(t=s.mime_type,n.set("mime_type",t)),n._token=s.token,c.resolve().then((function(){var e=n._data;if(e&&e.base64)return f(e.base64,t);if(e&&e.blob)return!e.blob.type&&t&&(e.blob.type=t),e.blob.name||(e.blob.name=n.get("name")),e.blob;if("undefined"!=typeof Blob&&e instanceof Blob)return e;throw new TypeError("malformed file data")})).then((function(t){var l=r.extend({},e);switch(e.onprogress&&(l.onprogress=function(n){if("download"!==n.direction)return e.onprogress(n)}),s.provider){case"s3":return o(s,t,n,l);case"qcloud":return a(s,t,n,l);case"qiniu":default:return i(s,t,n,l)}})).then(d((function(){return n._callback(!0)})),(function(e){throw n._callback(!1),e}))}))}else if(this.attributes.url&&"external"===this.attributes.metaData.__source){var s={name:this.attributes.name,ACL:this._acl,metaData:this.attributes.metaData,mime_type:this.mimeType,url:this.attributes.url};this._previousSave=l("files",this.attributes.name,null,"post",s,e).then((function(e){return n.attributes.name=e.name,n.attributes.url=e.url,n.id=e.objectId,e.size&&(n.attributes.metaData.size=e.size),n}))}return this._previousSave},_callback:function(n){l("fileCallback",null,null,"post",{token:this._token,result:n}).catch(h),delete this._token,delete this._data},fetch:function(n,e){return l("files",null,this.id,"GET",p(n),e).then(this._finishFetch.bind(this))},_finishFetch:function(e){var t=n.Object.prototype.parse(e);return t.attributes={name:t.name,url:t.url,mime_type:t.mime_type,bucket:t.bucket},t.attributes.metaData=t.metaData||{},t.id=t.objectId,delete t.objectId,delete t.metaData,delete t.url,delete t.name,delete t.mime_type,delete t.bucket,r.extend(this,t),this}})}},function(n,e,t){"use strict";var r=t(8),a=t(6)("cos"),i=t(1);n.exports=function(n,e,t){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};t.attributes.url=n.url,t._bucket=n.bucket,t.id=n.objectId;var s=n.upload_url+"?sign="+encodeURIComponent(n.token);return new i((function(n,i){var l=r("POST",s).set(t._uploadHeaders).attach("fileContent",e,t.attributes.name).field("op","upload");o.onprogress&&l.on("progress",o.onprogress),l.end((function(e,r){if(r&&a(r.status,r.body,r.text),e)return r&&(e.statusCode=r.status,e.responseText=r.text,e.response=r.body),i(e);n(t)}))}))}},function(n,e,t){"use strict";var r=t(8),a=t(1),i=t(6)("qiniu");n.exports=function(n,e,t){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};t.attributes.url=n.url,t._bucket=n.bucket,t.id=n.objectId;var s=n.token,l=n.upload_url||"https://upload.qiniup.com";return new a((function(a,c){var u=r("POST",l).set(t._uploadHeaders).attach("file",e,t.attributes.name).field("name",t.attributes.name).field("key",n.key||t._qiniu_key).field("token",s);o.onprogress&&u.on("progress",o.onprogress),u.end((function(n,e){if(e&&i(e.status,e.body,e.text),n)return e&&(n.statusCode=e.status,n.responseText=e.text,n.response=e.body),c(n);a(t)}))}))}},function(n,e,t){"use strict";var r=t(8),a=t(1),i=function(n,e){return e&&(n.statusCode=e.status,n.responseText=e.text,n.response=e.body),n};n.exports=function(n,e,t){var o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return t.attributes.url=n.url,t._bucket=n.bucket,t.id=n.objectId,new a((function(a,s){var l=r("PUT",n.upload_url).set(Object.assign({"Content-Type":t.get("mime_type"),"Cache-Control":"public, max-age=31536000"},t._uploadHeaders));o.onprogress&&l.on("progress",o.onprogress),l.on("response",(function(n){if(n.ok)return a(t);s(i(n.error,n))})),l.on("error",(function(n,e){return s(i(n,e))})),l.send(e).end()}))}},function(n,e,t){!function(){var e=t(45),r=t(14).utf8,a=t(46),i=t(14).bin,o=function(n,t){n.constructor==String?n=t&&"binary"===t.encoding?i.stringToBytes(n):r.stringToBytes(n):a(n)?n=Array.prototype.slice.call(n,0):Array.isArray(n)||(n=n.toString());for(var s=e.bytesToWords(n),l=8*n.length,c=1732584193,u=-271733879,d=-1732584194,p=271733878,h=0;h<s.length;h++)s[h]=16711935&(s[h]<<8|s[h]>>>24)|4278255360&(s[h]<<24|s[h]>>>8);s[l>>>5]|=128<<l%32,s[14+(l+64>>>9<<4)]=l;var f=o._ff,v=o._gg,m=o._hh,g=o._ii;for(h=0;h<s.length;h+=16){var y=c,b=u,w=d,k=p;c=f(c,u,d,p,s[h+0],7,-680876936),p=f(p,c,u,d,s[h+1],12,-389564586),d=f(d,p,c,u,s[h+2],17,606105819),u=f(u,d,p,c,s[h+3],22,-1044525330),c=f(c,u,d,p,s[h+4],7,-176418897),p=f(p,c,u,d,s[h+5],12,1200080426),d=f(d,p,c,u,s[h+6],17,-1473231341),u=f(u,d,p,c,s[h+7],22,-45705983),c=f(c,u,d,p,s[h+8],7,1770035416),p=f(p,c,u,d,s[h+9],12,-1958414417),d=f(d,p,c,u,s[h+10],17,-42063),u=f(u,d,p,c,s[h+11],22,-1990404162),c=f(c,u,d,p,s[h+12],7,1804603682),p=f(p,c,u,d,s[h+13],12,-40341101),d=f(d,p,c,u,s[h+14],17,-1502002290),c=v(c,u=f(u,d,p,c,s[h+15],22,1236535329),d,p,s[h+1],5,-165796510),p=v(p,c,u,d,s[h+6],9,-1069501632),d=v(d,p,c,u,s[h+11],14,643717713),u=v(u,d,p,c,s[h+0],20,-373897302),c=v(c,u,d,p,s[h+5],5,-701558691),p=v(p,c,u,d,s[h+10],9,38016083),d=v(d,p,c,u,s[h+15],14,-660478335),u=v(u,d,p,c,s[h+4],20,-405537848),c=v(c,u,d,p,s[h+9],5,568446438),p=v(p,c,u,d,s[h+14],9,-1019803690),d=v(d,p,c,u,s[h+3],14,-187363961),u=v(u,d,p,c,s[h+8],20,1163531501),c=v(c,u,d,p,s[h+13],5,-1444681467),p=v(p,c,u,d,s[h+2],9,-51403784),d=v(d,p,c,u,s[h+7],14,1735328473),c=m(c,u=v(u,d,p,c,s[h+12],20,-1926607734),d,p,s[h+5],4,-378558),p=m(p,c,u,d,s[h+8],11,-2022574463),d=m(d,p,c,u,s[h+11],16,1839030562),u=m(u,d,p,c,s[h+14],23,-35309556),c=m(c,u,d,p,s[h+1],4,-1530992060),p=m(p,c,u,d,s[h+4],11,1272893353),d=m(d,p,c,u,s[h+7],16,-155497632),u=m(u,d,p,c,s[h+10],23,-1094730640),c=m(c,u,d,p,s[h+13],4,681279174),p=m(p,c,u,d,s[h+0],11,-358537222),d=m(d,p,c,u,s[h+3],16,-722521979),u=m(u,d,p,c,s[h+6],23,76029189),c=m(c,u,d,p,s[h+9],4,-640364487),p=m(p,c,u,d,s[h+12],11,-421815835),d=m(d,p,c,u,s[h+15],16,530742520),c=g(c,u=m(u,d,p,c,s[h+2],23,-995338651),d,p,s[h+0],6,-198630844),p=g(p,c,u,d,s[h+7],10,1126891415),d=g(d,p,c,u,s[h+14],15,-1416354905),u=g(u,d,p,c,s[h+5],21,-57434055),c=g(c,u,d,p,s[h+12],6,1700485571),p=g(p,c,u,d,s[h+3],10,-1894986606),d=g(d,p,c,u,s[h+10],15,-1051523),u=g(u,d,p,c,s[h+1],21,-2054922799),c=g(c,u,d,p,s[h+8],6,1873313359),p=g(p,c,u,d,s[h+15],10,-30611744),d=g(d,p,c,u,s[h+6],15,-1560198380),u=g(u,d,p,c,s[h+13],21,1309151649),c=g(c,u,d,p,s[h+4],6,-145523070),p=g(p,c,u,d,s[h+11],10,-1120210379),d=g(d,p,c,u,s[h+2],15,718787259),u=g(u,d,p,c,s[h+9],21,-343485551),c=c+y>>>0,u=u+b>>>0,d=d+w>>>0,p=p+k>>>0}return e.endian([c,u,d,p])};o._ff=function(n,e,t,r,a,i,o){var s=n+(e&t|~e&r)+(a>>>0)+o;return(s<<i|s>>>32-i)+e},o._gg=function(n,e,t,r,a,i,o){var s=n+(e&r|t&~r)+(a>>>0)+o;return(s<<i|s>>>32-i)+e},o._hh=function(n,e,t,r,a,i,o){var s=n+(e^t^r)+(a>>>0)+o;return(s<<i|s>>>32-i)+e},o._ii=function(n,e,t,r,a,i,o){var s=n+(t^(e|~r))+(a>>>0)+o;return(s<<i|s>>>32-i)+e},o._blocksize=16,o._digestsize=16,n.exports=function(n,t){if(null==n)throw new Error("Illegal argument "+n);var r=e.wordsToBytes(o(n,t));return t&&t.asBytes?r:t&&t.asString?i.bytesToString(r):e.bytesToHex(r)}}()},function(n,e){!function(){var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",t={rotl:function(n,e){return n<<e|n>>>32-e},rotr:function(n,e){return n<<32-e|n>>>e},endian:function(n){if(n.constructor==Number)return 16711935&t.rotl(n,8)|4278255360&t.rotl(n,24);for(var e=0;e<n.length;e++)n[e]=t.endian(n[e]);return n},randomBytes:function(n){for(var e=[];n>0;n--)e.push(Math.floor(256*Math.random()));return e},bytesToWords:function(n){for(var e=[],t=0,r=0;t<n.length;t++,r+=8)e[r>>>5]|=n[t]<<24-r%32;return e},wordsToBytes:function(n){for(var e=[],t=0;t<32*n.length;t+=8)e.push(n[t>>>5]>>>24-t%32&255);return e},bytesToHex:function(n){for(var e=[],t=0;t<n.length;t++)e.push((n[t]>>>4).toString(16)),e.push((15&n[t]).toString(16));return e.join("")},hexToBytes:function(n){for(var e=[],t=0;t<n.length;t+=2)e.push(parseInt(n.substr(t,2),16));return e},bytesToBase64:function(n){for(var t=[],r=0;r<n.length;r+=3)for(var a=n[r]<<16|n[r+1]<<8|n[r+2],i=0;i<4;i++)8*r+6*i<=8*n.length?t.push(e.charAt(a>>>6*(3-i)&63)):t.push("=");return t.join("")},base64ToBytes:function(n){n=n.replace(/[^A-Z0-9+\/]/gi,"");for(var t=[],r=0,a=0;r<n.length;a=++r%4)0!=a&&t.push((e.indexOf(n.charAt(r-1))&Math.pow(2,-2*a+8)-1)<<2*a|e.indexOf(n.charAt(r))>>>6-2*a);return t}};n.exports=t}()},function(n,e){function t(n){return!!n.constructor&&"function"==typeof n.constructor.isBuffer&&n.constructor.isBuffer(n)}
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
n.exports=function(n){return null!=n&&(t(n)||function(n){return"function"==typeof n.readFloatLE&&"function"==typeof n.slice&&t(n.slice(0,0))}(n)||!!n._isBuffer)}},function(n,e,t){"use strict";n.exports=function(n,e){var t;n.indexOf("base64")<0?t=atob(n):n.split(",")[0].indexOf("base64")>=0?(e=e||n.split(",")[0].split(":")[1].split(";")[0],t=atob(n.split(",")[1])):t=unescape(n.split(",")[1]);for(var r=new Uint8Array(t.length),a=0;a<t.length;a++)r[a]=t.charCodeAt(a);return new Blob([r],{type:e})}},function(n,e,t){"use strict";function r(n,e){return n&&n[e]?i.isFunction(n[e])?n[e]():n[e]:null}var a=function(n,e){if(Array.isArray(n))return n;if(Symbol.iterator in Object(n))return function(n,e){var t=[],r=!0,a=!1,i=void 0;try{for(var o,s=n[Symbol.iterator]();!(r=(o=s.next()).done)&&(t.push(o.value),!e||t.length!==e);r=!0);}catch(n){a=!0,i=n}finally{try{!r&&s.return&&s.return()}finally{if(a)throw i}}return t}(n,e);throw new TypeError("Invalid attempt to destructure non-iterable instance")},i=t(0),o=t(4),s=t(1),l=t(2)._request,c=t(3),u=c.isNullOrUndefined,d=c.ensureArray,p=c.transformFetchOptions,h=c.setValue,f=c.findValue,v=c.isPlainObject,m=["objectId","createdAt","updatedAt"],g=function(n){if(-1!==m.indexOf(n))throw new Error("key["+n+"] is reserved")},y=function(n){var e=i.find(n,(function(n){return n instanceof Error}));if(!e)return n;var t=new o(e.code,e.message);throw t.results=n,t};n.exports=function(n){n.Object=function(e,t){if(i.isString(e))return n.Object._create.apply(this,arguments);e=e||{},t&&t.parse&&(e=this.parse(e),e=this._mergeMagicFields(e));var a=r(this,"defaults");a&&(e=i.extend({},a,e)),t&&t.collection&&(this.collection=t.collection),this._serverData={},this._opSetQueue=[{}],this._flags={},this.attributes={},this._hashedJSON={},this._escapedAttributes={},this.cid=i.uniqueId("c"),this.changed={},this._silent={},this._pending={},this.set(e,{silent:!0}),this.changed={},this._silent={},this._pending={},this._hasData=!0,this._previousAttributes=i.clone(this.attributes),this.initialize.apply(this,arguments)},n.Object.saveAll=function(e,t){return n.Object._deepSaveAsync(e,null,t)},n.Object.fetchAll=function(n,e){return s.resolve().then((function(){return l("batch",null,null,"POST",{requests:i.map(n,(function(n){if(!n.className)throw new Error("object must have className to fetch");if(!n.id)throw new Error("object must have id to fetch");if(n.dirty())throw new Error("object is modified but not saved");return{method:"GET",path:"/1.1/classes/"+n.className+"/"+n.id}}))},e)})).then((function(e){var t=i.map(n,(function(n,t){if(e[t].success){var r=n.parse(e[t].success);return n._cleanupUnsetKeys(r),n._finishFetch(r),n}return null===e[t].success?new o(o.OBJECT_NOT_FOUND,"Object not found."):new o(e[t].error.code,e[t].error.error)}));return y(t)}))},i.extend(n.Object.prototype,n.Events,{_fetchWhenSave:!1,initialize:function(){},fetchWhenSave:function(n){if(console.warn("AV.Object#fetchWhenSave is deprecated, use AV.Object#save with options.fetchWhenSave instead."),!i.isBoolean(n))throw new Error("Expect boolean value for fetchWhenSave");this._fetchWhenSave=n},getObjectId:function(){return this.id},getCreatedAt:function(){return this.createdAt||this.get("createdAt")},getUpdatedAt:function(){return this.updatedAt||this.get("updatedAt")},toJSON:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return this._toFullJSON(t,!1)},toFullJSON:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return this._toFullJSON(n)},_toFullJSON:function(e){var t=this,r=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],a=i.clone(this.attributes);if(i.isArray(e))var o=e.concat(this);return n._objectEach(a,(function(e,t){a[t]=n._encode(e,o,void 0,r)})),n._objectEach(this._operations,(function(n,e){a[e]=n})),i.has(this,"id")&&(a.objectId=this.id),i(["createdAt","updatedAt"]).each((function(n){if(i.has(t,n)){var e=t[n];a[n]=i.isDate(e)?e.toJSON():e}})),r&&(a.__type="Object",i.isArray(e)&&e.length&&(a.__type="Pointer"),a.className=this.className),a},_refreshCache:function(){var e=this;e._refreshingCache||(e._refreshingCache=!0,n._objectEach(this.attributes,(function(t,r){t instanceof n.Object?t._refreshCache():i.isObject(t)&&e._resetCacheForKey(r)&&e.set(r,new n.Op.Set(t),{silent:!0})})),delete e._refreshingCache)},dirty:function(n){this._refreshCache();var e=i.last(this._opSetQueue);return n?!!e[n]:!this.id||i.keys(e).length>0},_toPointer:function(){return{__type:"Pointer",className:this.className,objectId:this.id}},get:function(n){switch(n){case"objectId":return this.id;case"createdAt":case"updatedAt":return this[n];default:return this.attributes[n]}},relation:function(e){var t=this.get(e);if(t){if(!(t instanceof n.Relation))throw new Error("Called relation() on non-relation field "+e);return t._ensureParentAndKey(this,e),t}return new n.Relation(this,e)},escape:function(n){var e=this._escapedAttributes[n];if(e)return e;var t,r=this.attributes[n];return t=u(r)?"":i.escape(r.toString()),this._escapedAttributes[n]=t,t},has:function(n){return!u(this.attributes[n])},_mergeMagicFields:function(e){var t=this;return n._arrayEach(["objectId","createdAt","updatedAt"],(function(r){e[r]&&("objectId"===r?t.id=e[r]:"createdAt"!==r&&"updatedAt"!==r||i.isDate(e[r])?t[r]=e[r]:t[r]=n._parseDate(e[r]),delete e[r])})),e},_startSave:function(){this._opSetQueue.push({})},_cancelSave:function(){var e=i.first(this._opSetQueue);this._opSetQueue=i.rest(this._opSetQueue);var t=i.first(this._opSetQueue);n._objectEach(e,(function(n,r){var a=e[r],i=t[r];a&&i?t[r]=i._mergeWithPrevious(a):a&&(t[r]=a)})),this._saving=this._saving-1},_finishSave:function(e){var t={};n._traverse(this.attributes,(function(e){e instanceof n.Object&&e.id&&e._hasData&&(t[e.id]=e)}));var r=i.first(this._opSetQueue);this._opSetQueue=i.rest(this._opSetQueue),this._applyOpSet(r,this._serverData),this._mergeMagicFields(e);var a=this;n._objectEach(e,(function(e,r){a._serverData[r]=n._decode(e,r);var i=n._traverse(a._serverData[r],(function(e){if(e instanceof n.Object&&t[e.id])return t[e.id]}));i&&(a._serverData[r]=i)})),this._rebuildAllEstimatedData();var o=this._opSetQueue.map(i.clone);this._refreshCache(),this._opSetQueue=o,this._saving=this._saving-1},_finishFetch:function(e,t){this._opSetQueue=[{}],this._mergeMagicFields(e);var r=this;n._objectEach(e,(function(e,t){r._serverData[t]=n._decode(e,t)})),this._rebuildAllEstimatedData(),this._refreshCache(),this._opSetQueue=[{}],this._hasData=t},_applyOpSet:function(e,t){var r=this;n._objectEach(e,(function(e,i){var o=f(t,i),s=a(o,3),l=s[0],c=s[1],u=s[2];h(t,i,e._estimate(l,r,i)),c&&c[u]===n.Op._UNSET&&delete c[u]}))},_resetCacheForKey:function(e){var t=this.attributes[e];if(i.isObject(t)&&!(t instanceof n.Object)&&!(t instanceof n.File)){var r=JSON.stringify(function n(e){return i.isArray(e)?e.map(n):v(e)?i.mapObject(e,n):i.isObject(e)&&e._toPointer?e._toPointer():e}(t));if(this._hashedJSON[e]!==r){var a=!!this._hashedJSON[e];return this._hashedJSON[e]=r,a}}return!1},_rebuildEstimatedDataForKey:function(e){var t=this;delete this.attributes[e],this._serverData[e]&&(this.attributes[e]=this._serverData[e]),n._arrayEach(this._opSetQueue,(function(r){var i=r[e];if(i){var o=f(t.attributes,e),s=a(o,4),l=s[0],c=s[1],u=s[2],d=s[3];h(t.attributes,e,i._estimate(l,t,e)),c&&c[u]===n.Op._UNSET&&delete c[u],t._resetCacheForKey(d)}}))},_rebuildAllEstimatedData:function(){var e=this,t=i.clone(this.attributes);this.attributes=i.clone(this._serverData),n._arrayEach(this._opSetQueue,(function(t){e._applyOpSet(t,e.attributes),n._objectEach(t,(function(n,t){e._resetCacheForKey(t)}))})),n._objectEach(t,(function(n,t){e.attributes[t]!==n&&e.trigger("change:"+t,e,e.attributes[t],{})})),n._objectEach(this.attributes,(function(n,r){i.has(t,r)||e.trigger("change:"+r,e,n,{})}))},set:function(e,t,r){var a;if(i.isObject(e)||u(e)?(a=i.mapObject(e,(function(e,t){return g(t),n._decode(e,t)})),r=t):(a={},g(e),a[e]=n._decode(t,e)),r=r||{},!a)return this;a instanceof n.Object&&(a=a.attributes),r.unset&&n._objectEach(a,(function(e,t){a[t]=new n.Op.Unset}));var o=i.clone(a),s=this;n._objectEach(o,(function(e,t){e instanceof n.Op&&(o[t]=e._estimate(s.attributes[t],s,t),o[t]===n.Op._UNSET&&delete o[t])})),this._validate(a,r),r.changes={};var l=this._escapedAttributes;return n._arrayEach(i.keys(a),(function(e){var t=a[e];t instanceof n.Relation&&(t.parent=s),t instanceof n.Op||(t=new n.Op.Set(t));var o=!0;t instanceof n.Op.Set&&i.isEqual(s.attributes[e],t.value)&&(o=!1),o&&(delete l[e],r.silent?s._silent[e]=!0:r.changes[e]=!0);var c=i.last(s._opSetQueue);c[e]=t._mergeWithPrevious(c[e]),s._rebuildEstimatedDataForKey(e),o?(s.changed[e]=s.attributes[e],r.silent||(s._pending[e]=!0)):(delete s.changed[e],delete s._pending[e])})),r.silent||this.change(r),this},unset:function(n,e){return(e=e||{}).unset=!0,this.set(n,null,e)},increment:function(e,t){return(i.isUndefined(t)||i.isNull(t))&&(t=1),this.set(e,new n.Op.Increment(t))},add:function(e,t){return this.set(e,new n.Op.Add(d(t)))},addUnique:function(e,t){return this.set(e,new n.Op.AddUnique(d(t)))},remove:function(e,t){return this.set(e,new n.Op.Remove(d(t)))},bitAnd:function(e,t){return this.set(e,new n.Op.BitAnd(t))},bitOr:function(e,t){return this.set(e,new n.Op.BitOr(t))},bitXor:function(e,t){return this.set(e,new n.Op.BitXor(t))},op:function(n){return i.last(this._opSetQueue)[n]},clear:function(n){(n=n||{}).unset=!0;var e=i.extend(this.attributes,this._operations);return this.set(e,n)},revert:function(n){var e=i.last(this._opSetQueue);return d(n||i.keys(e)).forEach((function(n){delete e[n]})),this._rebuildAllEstimatedData(),this},_getSaveJSON:function(){var e=i.clone(i.first(this._opSetQueue));return n._objectEach(e,(function(n,t){e[t]=n.toJSON()})),e},_canBeSerialized:function(){return n.Object._canBeSerializedAsValue(this.attributes)},fetch:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=arguments[1],t=this;return l("classes",this.className,this.id,"GET",p(n),e).then((function(e){var r=t.parse(e);return n.keys||t._cleanupUnsetKeys(r),t._finishFetch(r,!0),t}))},_cleanupUnsetKeys:function(e){var t=this;n._objectEach(this._serverData,(function(n,r){void 0===e[r]&&delete t._serverData[r]}))},save:function(e,t,r){var a,o,c;i.isObject(e)||u(e)?(a=e,c=t):((a={})[e]=t,c=r),(c=i.clone(c)||{}).wait&&(o=i.clone(this.attributes));var d=i.clone(c)||{};d.wait&&(d.silent=!0),a&&this.set(a,d);var p=this,h=[],f=[];return n.Object._findUnsavedChildren(p,h,f),h.length+f.length>1?n.Object._deepSaveAsync(this,p,c):(this._startSave(),this._saving=(this._saving||0)+1,this._allPreviousSaves=this._allPreviousSaves||s.resolve(),this._allPreviousSaves=this._allPreviousSaves.catch((function(n){})).then((function(){var n,e=p.id?"PUT":"POST",t=p._getSaveJSON(),r={};if((p._fetchWhenSave||c.fetchWhenSave)&&(r.new="true"),c._failOnNotExist&&(r.failOnNotExist="true"),c.query&&("function"==typeof c.query.toJSON&&(n=c.query.toJSON())&&(r.where=n.where),!r.where))throw new Error("options.query is not an AV.Query");i.extend(t,p._flags);var s="classes",u=p.className;"_User"!==p.className||p.id||(s="users",u=null);var h=(c._makeRequest||l)(s,u,p.id,e,t,c,r);return h.then((function(n){var e=p.parse(n);return c.wait&&(e=i.extend(a||{},e)),p._finishSave(e),c.wait&&p.set(o,d),p}),(function(n){throw p._cancelSave(),n}))})),this._allPreviousSaves)},destroy:function(n){n=n||{};var e=this,t=function(){e.trigger("destroy",e,e.collection,n)};return this.id?(n.wait||t(),l("classes",this.className,this.id,"DELETE",this._flags,n).then((function(){return n.wait&&t(),e}))):t()},parse:function(e){var t=i.clone(e);return i(["createdAt","updatedAt"]).each((function(e){t[e]&&(t[e]=n._parseDate(t[e]))})),t.createdAt&&!t.updatedAt&&(t.updatedAt=t.createdAt),t},clone:function(){return new this.constructor(this.attributes)},isNew:function(){return!this.id},change:function(e){e=e||{};var t=this._changing;this._changing=!0;var r=this;n._objectEach(this._silent,(function(n){r._pending[n]=!0}));var a=i.extend({},e.changes,this._silent);if(this._silent={},n._objectEach(a,(function(n,t){r.trigger("change:"+t,r,r.get(t),e)})),t)return this;for(var o=function(n,e){r._pending[e]||r._silent[e]||delete r.changed[e]};!i.isEmpty(this._pending);)this._pending={},this.trigger("change",this,e),n._objectEach(this.changed,o),r._previousAttributes=i.clone(this.attributes);return this._changing=!1,this},hasChanged:function(n){return arguments.length?this.changed&&i.has(this.changed,n):!i.isEmpty(this.changed)},changedAttributes:function(e){if(!e)return!!this.hasChanged()&&i.clone(this.changed);var t={},r=this._previousAttributes;return n._objectEach(e,(function(n,e){i.isEqual(r[e],n)||(t[e]=n)})),t},previous:function(n){return arguments.length&&this._previousAttributes?this._previousAttributes[n]:null},previousAttributes:function(){return i.clone(this._previousAttributes)},isValid:function(){try{this.validate(this.attributes)}catch(n){return!1}return!0},validate:function(e){if(i.has(e,"ACL")&&!(e.ACL instanceof n.ACL))throw new o(o.OTHER_CAUSE,"ACL must be a AV.ACL.")},_validate:function(n,e){!e.silent&&this.validate&&(n=i.extend({},this.attributes,n),this.validate(n))},getACL:function(){return this.get("ACL")},setACL:function(n,e){return this.set("ACL",n,e)},disableBeforeHook:function(){this.ignoreHook("beforeSave"),this.ignoreHook("beforeUpdate"),this.ignoreHook("beforeDelete")},disableAfterHook:function(){this.ignoreHook("afterSave"),this.ignoreHook("afterUpdate"),this.ignoreHook("afterDelete")},ignoreHook:function(e){i.contains(["beforeSave","afterSave","beforeUpdate","afterUpdate","beforeDelete","afterDelete"],e)||console.trace("Unsupported hookName: "+e),n.hookKey||console.trace("ignoreHook required hookKey"),this._flags.__ignore_hooks||(this._flags.__ignore_hooks=[]),this._flags.__ignore_hooks.push(e)}}),n.Object.createWithoutData=function(e,t,r){var a=void 0;if(i.isString(e))a=n.Object._getSubclass(e);else{if(!(e.prototype&&e.prototype instanceof n.Object))throw new Error("class must be a string or a subclass of AV.Object.");a=e}var o=new a;return o.id=t,o._hasData=r,o},n.Object.destroyAll=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!n||0===n.length)return s.resolve();var t=i.groupBy(n,(function(n){return JSON.stringify({className:n.className,flags:n._flags})})),r={requests:i.map(t,(function(n){var e=i.map(n,"id").join(",");return{method:"DELETE",path:"/1.1/classes/"+n[0].className+"/"+e,body:n[0]._flags}}))};return l("batch",null,null,"POST",r,e).then((function(n){var e=i.find(n,(function(n){return!n.success}));if(e)throw new o(e.error.code,e.error.error)}))},n.Object._getSubclass=function(e){if(!i.isString(e))throw new Error("AV.Object._getSubclass requires a string argument.");var t=n.Object._classMap[e];return t||(t=n.Object.extend(e),n.Object._classMap[e]=t),t},n.Object._create=function(e,t,r){return new(n.Object._getSubclass(e))(t,r)},n.Object._classMap={},n.Object._extend=n._extend,n.Object.new=function(e,t){return new n.Object(e,t)},n.Object.extend=function(e,t,r){if(!i.isString(e)){if(e&&i.has(e,"className"))return n.Object.extend(e.className,e,t);throw new Error("AV.Object.extend's first argument should be the className.")}"User"===e&&(e="_User");var a=null;if(i.has(n.Object._classMap,e)){var o=n.Object._classMap[e];if(!t&&!r)return o;a=o._extend(t,r)}else(t=t||{})._className=e,a=this._extend(t,r);return a.extend=function(t){if(i.isString(t)||t&&i.has(t,"className"))return n.Object.extend.apply(a,arguments);var r=[e].concat(i.toArray(arguments));return n.Object.extend.apply(a,r)},Object.defineProperty(a,"query",Object.getOwnPropertyDescriptor(n.Object,"query")),a.new=function(n,e){return new a(n,e)},n.Object._classMap[e]=a,a},Object.defineProperty(n.Object.prototype,"className",{get:function(){var n=this._className||this.constructor._LCClassName||this.constructor.name;return"User"===n?"_User":n}}),n.Object.register=function(e,t){if(!(e.prototype instanceof n.Object))throw new Error("registered class is not a subclass of AV.Object");var r=t||e.name;if(!r.length)throw new Error("registered class must be named");t&&(e._LCClassName=t),n.Object._classMap[r]=e},Object.defineProperty(n.Object,"query",{get:function(){return new n.Query(this.prototype.className)}}),n.Object._findUnsavedChildren=function(e,t,r){n._traverse(e,(function(e){return e instanceof n.Object?void(e.dirty()&&t.push(e)):e instanceof n.File?void(e.id||r.push(e)):void 0}))},n.Object._canBeSerializedAsValue=function(e){var t=!0;return e instanceof n.Object||e instanceof n.File?t=!!e.id:i.isArray(e)?n._arrayEach(e,(function(e){n.Object._canBeSerializedAsValue(e)||(t=!1)})):i.isObject(e)&&n._objectEach(e,(function(e){n.Object._canBeSerializedAsValue(e)||(t=!1)})),t},n.Object._deepSaveAsync=function(e,t,r){var a=[],c=[];n.Object._findUnsavedChildren(e,a,c);var u=s.resolve();i.each(c,(function(n){u=u.then((function(){return n.save()}))}));var d=i.uniq(a),p=i.uniq(d);return u.then((function(){return s._continueWhile((function(){return p.length>0}),(function(){var e=[],t=[];if(n._arrayEach(p,(function(n){e.length>20?t.push(n):n._canBeSerialized()?e.push(n):t.push(n)})),p=t,0===e.length)return s.reject(new o(o.OTHER_CAUSE,"Tried to save a batch with a cycle."));var a=s.resolve(i.map(e,(function(n){return n._allPreviousSaves||s.resolve()}))).then((function(){return l("batch",null,null,"POST",{requests:i.map(e,(function(n){var e=n.id?"PUT":"POST",t=n._getSaveJSON();i.extend(t,n._flags);var r="/classes/"+n.className;return"_User"!==n.className||n.id||(r="/users"),r="/1.1"+r,n.id&&(r=r+"/"+n.id),n._startSave(),{method:e,path:r,body:t}}))},r).then((function(n){var t=i.map(e,(function(e,t){return n[t].success?(e._finishSave(e.parse(n[t].success)),e):(e._cancelSave(),new o(n[t].error.code,n[t].error.error))}));return y(t)}))}));return n._arrayEach(e,(function(n){n._allPreviousSaves=a})),a}))})).then((function(){return e}))}}},function(n,e,t){"use strict";var r=t(0),a=t(4);n.exports=function(n){n.Role=n.Object.extend("_Role",{constructor:function(e,t){if(r.isString(e)?(n.Object.prototype.constructor.call(this,null,null),this.setName(e)):n.Object.prototype.constructor.call(this,e,t),t){if(!(t instanceof n.ACL))throw new TypeError("acl must be an instance of AV.ACL");this.setACL(t)}},getName:function(){return this.get("name")},setName:function(n,e){return this.set("name",n,e)},getUsers:function(){return this.relation("users")},getRoles:function(){return this.relation("roles")},validate:function(e,t){if("name"in e&&e.name!==this.getName()){var i=e.name;if(this.id&&this.id!==e.objectId)return new a(a.OTHER_CAUSE,"A role's name can only be set before it has been saved.");if(!r.isString(i))return new a(a.OTHER_CAUSE,"A role's name must be a String.");if(!/^[0-9a-zA-Z\-_ ]+$/.test(i))return new a(a.OTHER_CAUSE,"A role's name can only contain alphanumeric characters, _, -, and spaces.")}return!!n.Object.prototype.validate&&n.Object.prototype.validate.call(this,e,t)}})}},function(n,e,t){"use strict";function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}var a=t(0),i=t(9),o=t(4),s=t(2),l=s._request,c=s.request,u=t(1),d=function(){if("undefined"==typeof wx||"function"!=typeof wx.login)throw new Error("Weapp Login is only available in Weapp");return new u((function(n,e){wx.login({success:function(t){var r=t.code,a=t.errMsg;r?n(r):e(new Error(a))},fail:function(){return e(new Error("wx.login 失败"))}})}))},p=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=e.preferUnionId,r=e.unionIdPlatform,a=void 0===r?"weixin":r,i=e.asMainAccount,o=void 0===i||i;return t?{platform:a,main_account:o,code:n}:{code:n}},h=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=t.unionIdPlatform,i=void 0===r?"weixin":r,s=t.asMainAccount,l=void 0!==s&&s;if("string"!=typeof e)throw new o(o.OTHER_CAUSE,"unionId is not a string");if("string"!=typeof i)throw new o(o.OTHER_CAUSE,"unionIdPlatform is not a string");return a.extend({},n,{platform:i,unionid:e,main_account:Boolean(l)})};n.exports=function(n){n.User=n.Object.extend("_User",{_isCurrentUser:!1,_mergeMagicFields:function(e){return e.sessionToken&&(this._sessionToken=e.sessionToken,delete e.sessionToken),n.User.__super__._mergeMagicFields.call(this,e)},_cleanupAuthData:function(){if(this.isCurrent()){var e=this.get("authData");e&&n._objectEach(this.get("authData"),(function(n,t){e[t]||delete e[t]}))}},_synchronizeAllAuthData:function(){if(this.get("authData")){var e=this;n._objectEach(this.get("authData"),(function(n,t){e._synchronizeAuthData(t)}))}},_synchronizeAuthData:function(e){if(this.isCurrent()){var t;a.isString(e)?(t=e,e=n.User._authProviders[t]):t=e.getAuthType();var r=this.get("authData");r&&e&&(e.restoreAuthentication(r[t])||this.dissociateAuthData(e))}},_handleSaveResult:function(e){return e&&!n._config.disableCurrentUser&&(this._isCurrentUser=!0),this._cleanupAuthData(),this._synchronizeAllAuthData(),delete this._serverData.password,this._rebuildEstimatedDataForKey("password"),this._refreshCache(),!e&&!this.isCurrent()||n._config.disableCurrentUser?u.resolve():u.resolve(n.User._saveCurrentUser(this))},_linkWith:function(e,t){var i,o=this,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},l=s.failOnNotExist,c=void 0!==l&&l;return a.isString(e)?(i=e,e=n.User._authProviders[e]):i=e.getAuthType(),t?this.save({authData:r({},i,t)},{fetchWhenSave:!!this.get("authData"),_failOnNotExist:c}).then((function(n){return n._handleSaveResult(!0).then((function(){return n}))})):e.authenticate().then((function(n){return o._linkWith(e,n)}))},associateWithAuthData:function(n,e){return this._linkWith(e,n)},associateWithAuthDataAndUnionId:function(n,e,t,r){return this._linkWith(e,h(n,t,r))},associateWithWeapp:function(n){var e=this;return d().then((function(t){return e._linkWith("lc_weapp",p(t,n))}))},linkWithWeapp:function(n){return console.warn("DEPRECATED: User#linkWithWeapp 已废弃，请使用 User#associateWithWeapp 代替"),this.associateWithWeapp(n)},associateWithWeappWithUnionId:function(n,e){var t=this;return d().then((function(r){return t._linkWith("lc_weapp",h({code:r},n,e))}))},dissociateAuthData:function(n){return this.unset("authData."+n),this.save().then((function(n){return n._handleSaveResult(!0).then((function(){return n}))}))},_unlinkFrom:function(n){return console.warn("DEPRECATED: User#_unlinkFrom 已废弃，请使用 User#dissociateAuthData 代替"),this.dissociateAuthData(n)},_isLinked:function(n){var e;return e=a.isString(n)?n:n.getAuthType(),!!(this.get("authData")||{})[e]},isAnonymous:function(){return this._isLinked("anonymous")},logOut:function(){this._logOutWithAll(),this._isCurrentUser=!1},_logOutWithAll:function(){if(this.get("authData")){var e=this;n._objectEach(this.get("authData"),(function(n,t){e._logOutWith(t)}))}},_logOutWith:function(e){this.isCurrent()&&(a.isString(e)&&(e=n.User._authProviders[e]),e&&e.deauthenticate&&e.deauthenticate())},signUp:function(n,e){var t=n&&n.username||this.get("username");if(!t||""===t)throw new o(o.OTHER_CAUSE,"Cannot sign up user with an empty name.");var r=n&&n.password||this.get("password");if(!r||""===r)throw new o(o.OTHER_CAUSE,"Cannot sign up user with an empty password.");return this.save(n,e).then((function(n){return n.isAnonymous()&&(n.unset("authData.anonymous"),n._opSetQueue=[{}]),n._handleSaveResult(!0).then((function(){return n}))}))},signUpOrlogInWithMobilePhone:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=n&&n.mobilePhoneNumber||this.get("mobilePhoneNumber");if(!t||""===t)throw new o(o.OTHER_CAUSE,"Cannot sign up or login user by mobilePhoneNumber with an empty mobilePhoneNumber.");var r=n&&n.smsCode||this.get("smsCode");if(!r||""===r)throw new o(o.OTHER_CAUSE,"Cannot sign up or login user by mobilePhoneNumber  with an empty smsCode.");return e._makeRequest=function(n,e,t,r,a){return l("usersByMobilePhone",null,null,"POST",a)},this.save(n,e).then((function(n){return delete n.attributes.smsCode,delete n._serverData.smsCode,n._handleSaveResult(!0).then((function(){return n}))}))},loginWithAuthData:function(n,e,t){return this._linkWith(e,n,t)},loginWithAuthDataAndUnionId:function(n,e,t,r){return this.loginWithAuthData(h(n,t,r),e,r)},loginWithWeapp:function(n){var e=this;return d().then((function(t){return e.loginWithAuthData(p(t,n),"lc_weapp",n)}))},loginWithWeappWithUnionId:function(n,e){var t=this;return d().then((function(r){return t.loginWithAuthData(h({code:r},n,e),"lc_weapp",e)}))},logIn:function(){var n=this;return l("login",null,null,"POST",this.toJSON()).then((function(e){var t=n.parse(e);return n._finishFetch(t),n._handleSaveResult(!0).then((function(){return t.smsCode||delete n.attributes.smsCode,n}))}))},save:function(e,t,r){var i,o;return a.isObject(e)||a.isNull(e)||a.isUndefined(e)?(i=e,o=t):((i={})[e]=t,o=r),o=o||{},n.Object.prototype.save.call(this,i,o).then((function(n){return n._handleSaveResult(!1).then((function(){return n}))}))},follow:function(e,t){if(!this.id)throw new Error("Please signin.");var r=void 0,i=void 0;e.user?(r=e.user,i=e.attributes):r=e;var o=a.isString(r)?r:r.id;if(!o)throw new Error("Invalid target user.");var s="users/"+this.id+"/friendship/"+o;return l(s,null,null,"POST",n._encode(i),t)},unfollow:function(n,e){if(!this.id)throw new Error("Please signin.");var t;t=n.user?n.user:n;var r=a.isString(t)?t:t.id;if(!r)throw new Error("Invalid target user.");var i="users/"+this.id+"/friendship/"+r;return l(i,null,null,"DELETE",null,e)},followerQuery:function(){return n.User.followerQuery(this.id)},followeeQuery:function(){return n.User.followeeQuery(this.id)},fetch:function(e,t){return n.Object.prototype.fetch.call(this,e,t).then((function(n){return n._handleSaveResult(!1).then((function(){return n}))}))},updatePassword:function(n,e,t){var r="users/"+this.id+"/updatePassword";return l(r,null,null,"PUT",{old_password:n,new_password:e},t)},isCurrent:function(){return this._isCurrentUser},getUsername:function(){return this.get("username")},getMobilePhoneNumber:function(){return this.get("mobilePhoneNumber")},setMobilePhoneNumber:function(n,e){return this.set("mobilePhoneNumber",n,e)},setUsername:function(n,e){return this.set("username",n,e)},setPassword:function(n,e){return this.set("password",n,e)},getEmail:function(){return this.get("email")},setEmail:function(n,e){return this.set("email",n,e)},authenticated:function(){return console.warn("DEPRECATED: 如果要判断当前用户的登录状态是否有效，请使用 currentUser.isAuthenticated().then()，如果要判断该用户是否是当前登录用户，请使用 user.id === currentUser.id。"),!!this._sessionToken&&!n._config.disableCurrentUser&&n.User.current()&&n.User.current().id===this.id},isAuthenticated:function(){var e=this;return u.resolve().then((function(){return!!e._sessionToken&&n.User._fetchUserBySessionToken(e._sessionToken).then((function(){return!0}),(function(n){if(211===n.code)return!1;throw n}))}))},getSessionToken:function(){return this._sessionToken},refreshSessionToken:function(n){var e=this;return l("users/"+this.id+"/refreshSessionToken",null,null,"PUT",null,n).then((function(n){return e._finishFetch(n),e._handleSaveResult(!0).then((function(){return e}))}))},getRoles:function(e){return n.Relation.reverseQuery("_Role","users",this).find(e)}},{_currentUser:null,_currentUserMatchesDisk:!1,_CURRENT_USER_KEY:"currentUser",_authProviders:{},signUp:function(e,t,r,a){return(r=r||{}).username=e,r.password=t,n.Object._create("_User").signUp(r,a)},logIn:function(e,t){var r=n.Object._create("_User");return r._finishFetch({username:e,password:t}),r.logIn()},become:function(n){return this._fetchUserBySessionToken(n).then((function(n){return n._handleSaveResult(!0).then((function(){return n}))}))},_fetchUserBySessionToken:function(e){var t=n.Object._create("_User");return c({method:"GET",path:"/users/me",authOptions:{sessionToken:e}}).then((function(n){var e=t.parse(n);return t._finishFetch(e),t}))},logInWithMobilePhoneSmsCode:function(e,t){var r=n.Object._create("_User");return r._finishFetch({mobilePhoneNumber:e,smsCode:t}),r.logIn()},signUpOrlogInWithMobilePhone:function(e,t,r,a){return(r=r||{}).mobilePhoneNumber=e,r.smsCode=t,n.Object._create("_User").signUpOrlogInWithMobilePhone(r,a)},logInWithMobilePhone:function(e,t){var r=n.Object._create("_User");return r._finishFetch({mobilePhoneNumber:e,password:t}),r.logIn()},loginWithEmail:function(e,t){var r=n.Object._create("_User");return r._finishFetch({email:e,password:t}),r.logIn()},loginWithAuthData:function(e,t,r){return n.User._logInWith(t,e,r)},signUpOrlogInWithAuthData:function(){return console.warn("DEPRECATED: User.signUpOrlogInWithAuthData 已废弃，请使用 User#loginWithAuthData 代替"),this.loginWithAuthData.apply(this,arguments)},loginWithAuthDataAndUnionId:function(n,e,t,r){return this.loginWithAuthData(h(n,t,r),e,r)},signUpOrlogInWithAuthDataAndUnionId:function(){return console.warn("DEPRECATED: User.signUpOrlogInWithAuthDataAndUnionId 已废弃，请使用 User#loginWithAuthDataAndUnionId 代替"),this.loginWithAuthDataAndUnionId.apply(this,arguments)},loginWithWeapp:function(n){var e=this;return d().then((function(t){return e.loginWithAuthData(p(t,n),"lc_weapp",n)}))},loginWithWeappWithUnionId:function(n,e){var t=this;return d().then((function(r){return t.loginWithAuthData(h({code:r},n,e),"lc_weapp",e)}))},loginAnonymously:function(){return this.loginWithAuthData({id:i()},"anonymous")},associateWithAuthData:function(n,e,t){return console.warn("DEPRECATED: User.associateWithAuthData 已废弃，请使用 User#associateWithAuthData 代替"),n._linkWith(e,t)},logOut:function(){return n._config.disableCurrentUser?(console.warn("AV.User.current() was disabled in multi-user environment, call logOut() from user object instead https://leancloud.cn/docs/leanengine-node-sdk-upgrade-1.html"),u.resolve(null)):(null!==n.User._currentUser&&(n.User._currentUser._logOutWithAll(),n.User._currentUser._isCurrentUser=!1),n.User._currentUserMatchesDisk=!0,n.User._currentUser=null,n.localStorage.removeItemAsync(n._getAVPath(n.User._CURRENT_USER_KEY)).then((function(){return n._refreshSubscriptionId()})))},followerQuery:function(e){if(!e||!a.isString(e))throw new Error("Invalid user object id.");var t=new n.FriendShipQuery("_Follower");return t._friendshipTag="follower",t.equalTo("user",n.Object.createWithoutData("_User",e)),t},followeeQuery:function(e){if(!e||!a.isString(e))throw new Error("Invalid user object id.");var t=new n.FriendShipQuery("_Followee");return t._friendshipTag="followee",t.equalTo("user",n.Object.createWithoutData("_User",e)),t},requestPasswordReset:function(n){return l("requestPasswordReset",null,null,"POST",{email:n})},requestEmailVerify:function(n){return l("requestEmailVerify",null,null,"POST",{email:n})},requestMobilePhoneVerify:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t={mobilePhoneNumber:n};return e.validateToken&&(t.validate_token=e.validateToken),l("requestMobilePhoneVerify",null,null,"POST",t,e)},requestPasswordResetBySmsCode:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t={mobilePhoneNumber:n};return e.validateToken&&(t.validate_token=e.validateToken),l("requestPasswordResetBySmsCode",null,null,"POST",t,e)},resetPasswordBySmsCode:function(n,e){return l("resetPasswordBySmsCode",null,n,"PUT",{password:e})},verifyMobilePhone:function(n){return l("verifyMobilePhone",null,n,"POST",null)},requestLoginSmsCode:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t={mobilePhoneNumber:n};return e.validateToken&&(t.validate_token=e.validateToken),l("requestLoginSmsCode",null,null,"POST",t,e)},currentAsync:function(){return n._config.disableCurrentUser?(console.warn("AV.User.currentAsync() was disabled in multi-user environment, access user from request instead https://leancloud.cn/docs/leanengine-node-sdk-upgrade-1.html"),u.resolve(null)):n.User._currentUser||n.User._currentUserMatchesDisk?u.resolve(n.User._currentUser):n.localStorage.getItemAsync(n._getAVPath(n.User._CURRENT_USER_KEY)).then((function(e){if(!e)return null;n.User._currentUserMatchesDisk=!0,n.User._currentUser=n.Object._create("_User"),n.User._currentUser._isCurrentUser=!0;var t=JSON.parse(e);return n.User._currentUser.id=t._id,delete t._id,n.User._currentUser._sessionToken=t._sessionToken,delete t._sessionToken,n.User._currentUser._finishFetch(t),n.User._currentUser._synchronizeAllAuthData(),n.User._currentUser._refreshCache(),n.User._currentUser._opSetQueue=[{}],n.User._currentUser}))},current:function(){if(n._config.disableCurrentUser)return console.warn("AV.User.current() was disabled in multi-user environment, access user from request instead https://leancloud.cn/docs/leanengine-node-sdk-upgrade-1.html"),null;if(n.User._currentUser)return n.User._currentUser;if(n.User._currentUserMatchesDisk)return n.User._currentUser;n.User._currentUserMatchesDisk=!0;var e=n.localStorage.getItem(n._getAVPath(n.User._CURRENT_USER_KEY));if(!e)return null;n.User._currentUser=n.Object._create("_User"),n.User._currentUser._isCurrentUser=!0;var t=JSON.parse(e);return n.User._currentUser.id=t._id,delete t._id,n.User._currentUser._sessionToken=t._sessionToken,delete t._sessionToken,n.User._currentUser._finishFetch(t),n.User._currentUser._synchronizeAllAuthData(),n.User._currentUser._refreshCache(),n.User._currentUser._opSetQueue=[{}],n.User._currentUser},_saveCurrentUser:function(e){return(n.User._currentUser!==e?n.User.logOut():u.resolve()).then((function(){e._isCurrentUser=!0,n.User._currentUser=e;var t=e._toFullJSON();return t._id=e.id,t._sessionToken=e._sessionToken,n.localStorage.setItemAsync(n._getAVPath(n.User._CURRENT_USER_KEY),JSON.stringify(t)).then((function(){return n.User._currentUserMatchesDisk=!0,n._refreshSubscriptionId()}))}))},_registerAuthenticationProvider:function(e){n.User._authProviders[e.getAuthType()]=e,!n._config.disableCurrentUser&&n.User.current()&&n.User.current()._synchronizeAuthData(e.getAuthType())},_logInWith:function(e,t,r){return n.Object._create("_User")._linkWith(e,t,r)}})}},function(n,e,t){"use strict";var r=t(0),a=t(6)("leancloud:query"),i=t(1),o=t(4),s=t(2),l=s._request,c=s.request,u=t(3),d=u.ensureArray,p=u.transformFetchOptions,h=function(n,e){if(void 0===n)throw new Error(e)};n.exports=function(n){n.Query=function(e){r.isString(e)&&(e=n.Object._getSubclass(e)),this.objectClass=e,this.className=e.prototype.className,this._where={},this._include=[],this._select=[],this._limit=-1,this._skip=0,this._extraOptions={}},n.Query.or=function(){var e=r.toArray(arguments),t=null;n._arrayEach(e,(function(n){if(r.isNull(t)&&(t=n.className),t!==n.className)throw new Error("All queries must be for the same class")}));var a=new n.Query(t);return a._orQuery(e),a},n.Query.and=function(){var e=r.toArray(arguments),t=null;n._arrayEach(e,(function(n){if(r.isNull(t)&&(t=n.className),t!==n.className)throw new Error("All queries must be for the same class")}));var a=new n.Query(t);return a._andQuery(e),a},n.Query.doCloudQuery=function(e,t,a){var i={cql:e};return r.isArray(t)?i.pvalues=t:a=t,l("cloudQuery",null,null,"GET",i,a).then((function(e){var t=new n.Query(e.className);return{results:r.map(e.results,(function(n){var r=t._newObject(e);return r._finishFetch&&r._finishFetch(t._processResult(n),!0),r})),count:e.count,className:e.className}}))},n.Query._extend=n._extend,r.extend(n.Query.prototype,{_processResult:function(n){return n},get:function(n,e){if(!n)throw new o(o.OBJECT_NOT_FOUND,"Object not found.");var t=this._newObject();t.id=n;var a=this.toJSON(),i={};return a.keys&&(i.keys=a.keys),a.include&&(i.include=a.include),a.includeACL&&(i.includeACL=a.includeACL),l("classes",this.className,n,"GET",p(i),e).then((function(n){if(r.isEmpty(n))throw new o(o.OBJECT_NOT_FOUND,"Object not found.");return t._finishFetch(t.parse(n),!0),t}))},toJSON:function(){var e={where:this._where};return this._include.length>0&&(e.include=this._include.join(",")),this._select.length>0&&(e.keys=this._select.join(",")),void 0!==this._includeACL&&(e.returnACL=this._includeACL),this._limit>=0&&(e.limit=this._limit),this._skip>0&&(e.skip=this._skip),void 0!==this._order&&(e.order=this._order),n._objectEach(this._extraOptions,(function(n,t){e[t]=n})),e},_newObject:function(e){return e&&e.className?new n.Object(e.className):new this.objectClass},_createRequest:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.toJSON(),e=arguments[1],t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"/classes/"+this.className;return encodeURIComponent(JSON.stringify(n)).length>2e3?c({path:"/batch",method:"POST",data:{requests:[{method:"GET",path:"/1.1"+t,params:n}]},authOptions:e}).then((function(n){var e=n[0];if(e.success)return e.success;var t=new Error(e.error.error||"Unknown batch error");throw t.code=e.error.code,t})):c({method:"GET",path:t,query:n,authOptions:e})},_parseResponse:function(n){var e=this;return r.map(n.results,(function(t){var r=e._newObject(n);return r._finishFetch&&r._finishFetch(e._processResult(t),!0),r}))},find:function(n){return this._createRequest(void 0,n).then(this._parseResponse.bind(this))},scan:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.orderedBy,o=e.batchSize,s=arguments[1],c=this.toJSON();a("scan %O",c),c.order&&(console.warn("The order of the query is ignored for Query#scan. Checkout the orderedBy option of Query#scan."),delete c.order),c.skip&&(console.warn("The skip option of the query is ignored for Query#scan."),delete c.skip),c.limit&&(console.warn("The limit option of the query is ignored for Query#scan."),delete c.limit),t&&(c.scan_key=t),o&&(c.limit=o);var u=i.resolve([]),d=void 0,p=!1;return{next:function(){return(u=u.then((function(e){return p?[]:e.length>1?e:d||0===e.length?l("scan/classes",n.className,null,"GET",d?r.extend({},c,{cursor:d}):c,s).then((function(e){return d=e.cursor,n._parseResponse(e)})).then((function(n){return n.length||(p=!0),e.concat(n)})):(p=!0,e)}))).then((function(n){return n.shift()})).then((function(n){return{value:n,done:p}}))}}},destroyAll:function(e){return this.find(e).then((function(t){return n.Object.destroyAll(t,e)}))},count:function(n){var e=this.toJSON();return e.limit=0,e.count=1,this._createRequest(e,n).then((function(n){return n.count}))},first:function(n){var e=this,t=this.toJSON();return t.limit=1,this._createRequest(t,n).then((function(n){return r.map(n.results,(function(n){var t=e._newObject();return t._finishFetch&&t._finishFetch(e._processResult(n),!0),t}))[0]}))},skip:function(n){return h(n,"undefined is not a valid skip value"),this._skip=n,this},limit:function(n){return h(n,"undefined is not a valid limit value"),this._limit=n,this},equalTo:function(e,t){return h(e,"undefined is not a valid key"),h(t,"undefined is not a valid value"),this._where[e]=n._encode(t),this},_addCondition:function(e,t,r){return h(e,"undefined is not a valid condition key"),h(t,"undefined is not a valid condition"),h(r,"undefined is not a valid condition value"),this._where[e]||(this._where[e]={}),this._where[e][t]=n._encode(r),this},sizeEqualTo:function(n,e){return this._addCondition(n,"$size",e),this},notEqualTo:function(n,e){return this._addCondition(n,"$ne",e),this},lessThan:function(n,e){return this._addCondition(n,"$lt",e),this},greaterThan:function(n,e){return this._addCondition(n,"$gt",e),this},lessThanOrEqualTo:function(n,e){return this._addCondition(n,"$lte",e),this},greaterThanOrEqualTo:function(n,e){return this._addCondition(n,"$gte",e),this},containedIn:function(n,e){return this._addCondition(n,"$in",e),this},notContainedIn:function(n,e){return this._addCondition(n,"$nin",e),this},containsAll:function(n,e){return this._addCondition(n,"$all",e),this},exists:function(n){return this._addCondition(n,"$exists",!0),this},doesNotExist:function(n){return this._addCondition(n,"$exists",!1),this},matches:function(n,e,t){return this._addCondition(n,"$regex",e),t||(t=""),e.ignoreCase&&(t+="i"),e.multiline&&(t+="m"),t&&t.length&&this._addCondition(n,"$options",t),this},matchesQuery:function(n,e){var t=e.toJSON();return t.className=e.className,this._addCondition(n,"$inQuery",t),this},doesNotMatchQuery:function(n,e){var t=e.toJSON();return t.className=e.className,this._addCondition(n,"$notInQuery",t),this},matchesKeyInQuery:function(n,e,t){var r=t.toJSON();return r.className=t.className,this._addCondition(n,"$select",{key:e,query:r}),this},doesNotMatchKeyInQuery:function(n,e,t){var r=t.toJSON();return r.className=t.className,this._addCondition(n,"$dontSelect",{key:e,query:r}),this},_orQuery:function(n){var e=r.map(n,(function(n){return n.toJSON().where}));return this._where.$or=e,this},_andQuery:function(n){var e=r.map(n,(function(n){return n.toJSON().where}));return this._where.$and=e,this},_quote:function(n){return"\\Q"+n.replace("\\E","\\E\\\\E\\Q")+"\\E"},contains:function(n,e){return this._addCondition(n,"$regex",this._quote(e)),this},startsWith:function(n,e){return this._addCondition(n,"$regex","^"+this._quote(e)),this},endsWith:function(n,e){return this._addCondition(n,"$regex",this._quote(e)+"$"),this},ascending:function(n){return h(n,"undefined is not a valid key"),this._order=n,this},addAscending:function(n){return h(n,"undefined is not a valid key"),this._order?this._order+=","+n:this._order=n,this},descending:function(n){return h(n,"undefined is not a valid key"),this._order="-"+n,this},addDescending:function(n){return h(n,"undefined is not a valid key"),this._order?this._order+=",-"+n:this._order="-"+n,this},near:function(e,t){return t instanceof n.GeoPoint||(t=new n.GeoPoint(t)),this._addCondition(e,"$nearSphere",t),this},withinRadians:function(n,e,t){return this.near(n,e),this._addCondition(n,"$maxDistance",t),this},withinMiles:function(n,e,t){return this.withinRadians(n,e,t/3958.8)},withinKilometers:function(n,e,t){return this.withinRadians(n,e,t/6371)},withinGeoBox:function(e,t,r){return t instanceof n.GeoPoint||(t=new n.GeoPoint(t)),r instanceof n.GeoPoint||(r=new n.GeoPoint(r)),this._addCondition(e,"$within",{$box:[t,r]}),this},include:function(n){var e=this;return h(n,"undefined is not a valid key"),r(arguments).forEach((function(n){e._include=e._include.concat(d(n))})),this},includeACL:function(){var n=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return this._includeACL=n,this},select:function(n){var e=this;return h(n,"undefined is not a valid key"),r(arguments).forEach((function(n){e._select=e._select.concat(d(n))})),this},each:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(this._order||this._skip||this._limit>=0){var a=new Error("Cannot iterate on a query with sort, skip, or limit.");return i.reject(a)}var o=new n.Query(this.objectClass);o._limit=t.batchSize||100,o._where=r.clone(this._where),o._include=r.clone(this._include),o.ascending("objectId");var s=!1;return i._continueWhile((function(){return!s}),(function(){return o.find(t).then((function(n){var t=i.resolve();return r.each(n,(function(n){t=t.then((function(){return e(n)}))})),t.then((function(){n.length>=o._limit?o.greaterThan("objectId",n[n.length-1].id):s=!0}))}))}))},subscribe:function(e){return n.LiveQuery.init(this,e)}}),n.FriendShipQuery=n.Query._extend({_newObject:function(){return new(n.Object._getSubclass("_User"))},_processResult:function(n){if(n&&n[this._friendshipTag]){var e=n[this._friendshipTag];return"Pointer"===e.__type&&"_User"===e.className&&(delete e.__type,delete e.className),e}return null}})}},function(n,e,t){"use strict";var r=t(0),a=t(53),i=t(1),o=t(3).inherits,s=t(2).request,l=function(n,e){return s({method:"POST",path:"/LiveQuery/subscribe",data:{query:n,id:e}})};n.exports=function(n){var e=function(){if(!n._config.realtime)throw new Error("LiveQuery not supported. Please use the LiveQuery bundle. https://url.leanapp.cn/enable-live-query")};n.LiveQuery=o(a,{constructor:function(n,e,t,r){var i=this;a.apply(this),this.id=n,this._client=e,this._client.register(this),this._queryJSON=t,this._subscriptionId=r,this._onMessage=this._dispatch.bind(this),this._onReconnect=function(){l(i._queryJSON,i._subscriptionId).catch((function(n){return console.error("LiveQuery resubscribe error: "+n.message)}))},e.on("message",this._onMessage),e.on("reconnect",this._onReconnect)},_dispatch:function(e){var t=this;e.forEach((function(e){var a=e.op,i=e.object,o=e.query_id,s=e.updatedKeys;if(o===t.id){var l=n.parseJSON(r.extend({__type:"_File"===i.className?"File":"Object"},i));s?t.emit(a,l,s):t.emit(a,l)}}))},unsubscribe:function(){var n=this._client;return n.off("message",this._onMessage),n.off("reconnect",this._onReconnect),n.deregister(this),s({method:"POST",path:"/LiveQuery/unsubscribe",data:{id:n.id,query_id:this.id}})}},{init:function(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},a=r.subscriptionId,o=void 0===a?n._getSubscriptionId():a;if(e(),!(t instanceof n.Query))throw new TypeError("LiveQuery must be inited with a Query");return i.resolve(o).then((function(e){return n._config.realtime.createLiveQueryClient(e).then((function(r){var a=t.toJSON(),i={where:a.where,keys:a.keys,returnACL:a.returnACL,className:t.className},o=l(i,e).then((function(t){var a=t.query_id;return new n.LiveQuery(a,r,i,e)})).finally((function(){r.deregister(o)}));return r.register(o),o}))}))},pause:function(){return e(),n._config.realtime.pause()},resume:function(){return e(),n._config.realtime.resume()}})}},function(n,e,t){"use strict";function r(){}function a(n,e,t){this.fn=n,this.context=e,this.once=t||!1}function i(){this._events=new r,this._eventsCount=0}var o=Object.prototype.hasOwnProperty,s="~";Object.create&&(r.prototype=Object.create(null),(new r).__proto__||(s=!1)),i.prototype.eventNames=function(){var n,e,t=[];if(0===this._eventsCount)return t;for(e in n=this._events)o.call(n,e)&&t.push(s?e.slice(1):e);return Object.getOwnPropertySymbols?t.concat(Object.getOwnPropertySymbols(n)):t},i.prototype.listeners=function(n,e){var t=s?s+n:n,r=this._events[t];if(e)return!!r;if(!r)return[];if(r.fn)return[r.fn];for(var a=0,i=r.length,o=new Array(i);a<i;a++)o[a]=r[a].fn;return o},i.prototype.emit=function(n,e,t,r,a,i){var o=s?s+n:n;if(!this._events[o])return!1;var l,c,u=this._events[o],d=arguments.length;if(u.fn){switch(u.once&&this.removeListener(n,u.fn,void 0,!0),d){case 1:return u.fn.call(u.context),!0;case 2:return u.fn.call(u.context,e),!0;case 3:return u.fn.call(u.context,e,t),!0;case 4:return u.fn.call(u.context,e,t,r),!0;case 5:return u.fn.call(u.context,e,t,r,a),!0;case 6:return u.fn.call(u.context,e,t,r,a,i),!0}for(c=1,l=new Array(d-1);c<d;c++)l[c-1]=arguments[c];u.fn.apply(u.context,l)}else{var p,h=u.length;for(c=0;c<h;c++)switch(u[c].once&&this.removeListener(n,u[c].fn,void 0,!0),d){case 1:u[c].fn.call(u[c].context);break;case 2:u[c].fn.call(u[c].context,e);break;case 3:u[c].fn.call(u[c].context,e,t);break;case 4:u[c].fn.call(u[c].context,e,t,r);break;default:if(!l)for(p=1,l=new Array(d-1);p<d;p++)l[p-1]=arguments[p];u[c].fn.apply(u[c].context,l)}}return!0},i.prototype.on=function(n,e,t){var r=new a(e,t||this),i=s?s+n:n;return this._events[i]?this._events[i].fn?this._events[i]=[this._events[i],r]:this._events[i].push(r):(this._events[i]=r,this._eventsCount++),this},i.prototype.once=function(n,e,t){var r=new a(e,t||this,!0),i=s?s+n:n;return this._events[i]?this._events[i].fn?this._events[i]=[this._events[i],r]:this._events[i].push(r):(this._events[i]=r,this._eventsCount++),this},i.prototype.removeListener=function(n,e,t,a){var i=s?s+n:n;if(!this._events[i])return this;if(!e)return 0==--this._eventsCount?this._events=new r:delete this._events[i],this;var o=this._events[i];if(o.fn)o.fn!==e||a&&!o.once||t&&o.context!==t||(0==--this._eventsCount?this._events=new r:delete this._events[i]);else{for(var l=0,c=[],u=o.length;l<u;l++)(o[l].fn!==e||a&&!o[l].once||t&&o[l].context!==t)&&c.push(o[l]);c.length?this._events[i]=1===c.length?c[0]:c:0==--this._eventsCount?this._events=new r:delete this._events[i]}return this},i.prototype.removeAllListeners=function(n){var e;return n?(e=s?s+n:n,this._events[e]&&(0==--this._eventsCount?this._events=new r:delete this._events[e])):(this._events=new r,this._eventsCount=0),this},i.prototype.off=i.prototype.removeListener,i.prototype.addListener=i.prototype.on,i.prototype.setMaxListeners=function(){return this},i.prefixed=s,i.EventEmitter=i,n.exports=i},function(n,e,t){"use strict";var r=t(0),a=t(3).tap;n.exports=function(n){n.Captcha=function(n,e){this._options=n,this._authOptions=e,this.url=void 0,this.captchaToken=void 0,this.validateToken=void 0},n.Captcha.prototype.refresh=function(){var e=this;return n.Cloud._requestCaptcha(this._options,this._authOptions).then((function(n){var t=n.captchaToken,a=n.url;return r.extend(e,{captchaToken:t,url:a}),a}))},n.Captcha.prototype.verify=function(e){var t=this;return n.Cloud.verifyCaptcha(e,this.captchaToken).then(a((function(n){return t.validateToken=n})))},n.Captcha.prototype.bind=function(n,e){var t=this,r=n.textInput,a=n.image,i=n.verifyButton,o=e.success,s=e.error;if("string"==typeof r&&!(r=document.getElementById(r)))throw new Error("textInput with id "+r+" not found");if("string"==typeof a&&!(a=document.getElementById(a)))throw new Error("image with id "+a+" not found");if("string"==typeof i&&!(i=document.getElementById(i)))throw new Error("verifyButton with id "+i+" not found");this.__refresh=function(){return t.refresh().then((function(n){a.src=n,r&&(r.value="",r.focus())})).catch((function(n){return console.warn("refresh captcha fail: "+n.message)}))},a&&(this.__image=a,a.src=this.url,a.addEventListener("click",this.__refresh)),this.__verify=function(){var n=r.value;t.verify(n).catch((function(n){throw t.__refresh(),n})).then(o,s).catch((function(n){return console.warn("verify captcha fail: "+n.message)}))},r&&i&&(this.__verifyButton=i,i.addEventListener("click",this.__verify))},n.Captcha.prototype.unbind=function(){this.__image&&this.__image.removeEventListener("click",this.__refresh),this.__verifyButton&&this.__verifyButton.removeEventListener("click",this.__verify)},n.Captcha.request=function(e,t){var r=new n.Captcha(e,t);return r.refresh().then((function(){return r}))}}},function(n,e,t){"use strict";var r=t(0),a=t(2),i=a._request,o=a.request,s=t(1);n.exports=function(n){n.Cloud=n.Cloud||{},r.extend(n.Cloud,{run:function(e,t,r){return o({service:"engine",method:"POST",path:"/functions/"+e,data:n._encode(t,null,!0),authOptions:r}).then((function(e){return n._decode(e).result}))},rpc:function(e,t,a){return r.isArray(t)?s.reject(new Error("Can't pass Array as the param of rpc function in JavaScript SDK.")):o({service:"engine",method:"POST",path:"/call/"+e,data:n._encodeObjectOrArray(t),authOptions:a}).then((function(e){return n._decode(e).result}))},getServerDate:function(){return i("date",null,null,"GET").then((function(e){return n._decode(e)}))},requestSmsCode:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(r.isString(n)&&(n={mobilePhoneNumber:n}),!n.mobilePhoneNumber)throw new Error("Missing mobilePhoneNumber.");return e.validateToken&&(n=r.extend({},n,{validate_token:e.validateToken})),i("requestSmsCode",null,null,"POST",n,e)},verifySmsCode:function(n,e){if(!n)throw new Error("Missing sms code.");var t={};return r.isString(e)&&(t.mobilePhoneNumber=e),i("verifySmsCode",n,null,"POST",t)},_requestCaptcha:function(n,e){return i("requestCaptcha",null,null,"GET",n,e).then((function(n){var e=n.captcha_url;return{captchaToken:n.captcha_token,url:e}}))},requestCaptcha:n.Captcha.request,verifyCaptcha:function(n,e){return i("verifyCaptcha",null,null,"POST",{captcha_code:n,captcha_token:e}).then((function(n){return n.validate_token}))}})}},function(n,e,t){"use strict";var r=t(2).request;n.exports=function(n){n.Installation=n.Object.extend("_Installation"),n.Push=n.Push||{},n.Push.send=function(n,e){if(n.where&&(n.where=n.where.toJSON().where),n.where&&n.cql)throw new Error("Both where and cql can't be set");if(n.push_time&&(n.push_time=n.push_time.toJSON()),n.expiration_time&&(n.expiration_time=n.expiration_time.toJSON()),n.expiration_time&&n.expiration_time_interval)throw new Error("Both expiration_time and expiration_time_interval can't be set");return r({service:"push",method:"POST",path:"/push",data:n,authOptions:e})}}},function(n,e,t){"use strict";var r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},a=t(0),i=t(1),o=t(2)._request,s=t(3).getSessionToken;n.exports=function(n){var e=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return s(e)?n.User._fetchUserBySessionToken(s(e)):n.User.currentAsync()},t=function(t){return e(t).then((function(e){return n.Object.createWithoutData("_User",e.id)._toPointer()}))};n.Status=function(n,e){return this.data={},this.inboxType="default",this.query=null,n&&"object"===(void 0===n?"undefined":r(n))?this.data=n:(n&&(this.data.image=n),e&&(this.data.message=e)),this},a.extend(n.Status.prototype,{get:function(n){return this.data[n]},set:function(n,e){return this.data[n]=e,this},destroy:function(n){return this.id?o("statuses",null,this.id,"DELETE",n):i.reject(new Error("The status id is not exists."))},toObject:function(){return this.id?n.Object.createWithoutData("_Status",this.id):null},_getDataJSON:function(){var e=a.clone(this.data);return n._encode(e)},send:function(){var e=this,r=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(!s(r)&&!n.User.current())throw new Error("Please signin an user.");return this.query?t(r).then((function(n){var t=e.query.toJSON();t.className=e.query.className;var a={};return a.query=t,e.data=e.data||{},e.data.source=e.data.source||n,a.data=e._getDataJSON(),a.inboxType=e.inboxType||"default",o("statuses",null,null,"POST",a,r)})).then((function(t){return e.id=t.objectId,e.createdAt=n._parseDate(t.createdAt),e})):n.Status.sendStatusToFollowers(this,r)},_finishFetch:function(e){this.id=e.objectId,this.createdAt=n._parseDate(e.createdAt),this.updatedAt=n._parseDate(e.updatedAt),this.messageId=e.messageId,delete e.messageId,delete e.objectId,delete e.createdAt,delete e.updatedAt,this.data=n._decode(e)}}),n.Status.sendStatusToFollowers=function(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!s(r)&&!n.User.current())throw new Error("Please signin an user.");return t(r).then((function(t){var a={className:"_Follower",keys:"follower"};a.where={user:t};var i={};return i.query=a,e.data=e.data||{},e.data.source=e.data.source||t,i.data=e._getDataJSON(),i.inboxType=e.inboxType||"default",o("statuses",null,null,"POST",i,r).then((function(t){return e.id=t.objectId,e.createdAt=n._parseDate(t.createdAt),e}))}))},n.Status.sendPrivateStatus=function(e,r){var i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!s(i)&&!n.User.current())throw new Error("Please signin an user.");if(!r)throw new Error("Invalid target user.");var l=a.isString(r)?r:r.id;if(!l)throw new Error("Invalid target user.");return t(i).then((function(t){var r={className:"_User"};r.where={objectId:l};var a={};return a.query=r,e.data=e.data||{},e.data.source=e.data.source||t,a.data=e._getDataJSON(),a.inboxType="private",e.inboxType="private",o("statuses",null,null,"POST",a,i).then((function(t){return e.id=t.objectId,e.createdAt=n._parseDate(t.createdAt),e}))}))},n.Status.countUnreadStatuses=function(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default",l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(a.isString(r)||(l=r),!s(l)&&null==t&&!n.User.current())throw new Error("Please signin an user or pass the owner objectId.");return i.resolve(t||e(l)).then((function(e){var t={};return t.inboxType=n._encode(r),t.owner=n._encode(e),o("subscribe/statuses/count",null,null,"GET",t,l)}))},n.Status.resetUnreadCount=function(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default",l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(a.isString(r)||(l=r),!s(l)&&null==t&&!n.User.current())throw new Error("Please signin an user or pass the owner objectId.");return i.resolve(t||e(l)).then((function(e){var t={};return t.inboxType=n._encode(r),t.owner=n._encode(e),o("subscribe/statuses/resetUnreadCount",null,null,"POST",t,l)}))},n.Status.statusQuery=function(e){var t=new n.Query("_Status");return e&&t.equalTo("source",e),t},n.InboxQuery=n.Query._extend({_objectClass:n.Status,_sinceId:0,_maxId:0,_inboxType:"default",_owner:null,_newObject:function(){return new n.Status},_createRequest:function(e,t){return n.InboxQuery.__super__._createRequest.call(this,e,t,"/subscribe/statuses")},sinceId:function(n){return this._sinceId=n,this},maxId:function(n){return this._maxId=n,this},owner:function(n){return this._owner=n,this},inboxType:function(n){return this._inboxType=n,this},toJSON:function(){var e=n.InboxQuery.__super__.toJSON.call(this);return e.owner=n._encode(this._owner),e.inboxType=n._encode(this._inboxType),e.sinceId=n._encode(this._sinceId),e.maxId=n._encode(this._maxId),e}}),n.Status.inboxQuery=function(e,t){var r=new n.InboxQuery(n.Status);return e&&(r._owner=e),t&&(r._inboxType=t),r}}},function(n,e,t){"use strict";var r=t(0),a=t(2)._request;n.exports=function(n){n.SearchSortBuilder=function(){this._sortFields=[]},r.extend(n.SearchSortBuilder.prototype,{_addField:function(n,e,t,r){var a={};return a[n]={order:e||"asc",mode:t||"avg",missing:"_"+(r||"last")},this._sortFields.push(a),this},ascending:function(n,e,t){return this._addField(n,"asc",e,t)},descending:function(n,e,t){return this._addField(n,"desc",e,t)},whereNear:function(n,e,t){t=t||{};var r={},a={lat:e.latitude,lon:e.longitude},i={order:t.order||"asc",mode:t.mode||"avg",unit:t.unit||"km"};return i[n]=a,r._geo_distance=i,this._sortFields.push(r),this},build:function(){return JSON.stringify(n._encode(this._sortFields))}}),n.SearchQuery=n.Query._extend({_sid:null,_hits:0,_queryString:null,_highlights:null,_sortBuilder:null,_createRequest:function(n,e){return a("search/select",null,null,"GET",n||this.toJSON(),e)},sid:function(n){return this._sid=n,this},queryString:function(n){return this._queryString=n,this},highlights:function(n){var e;return e=n&&r.isString(n)?arguments:n,this._highlights=e,this},sortBy:function(n){return this._sortBuilder=n,this},hits:function(){return this._hits||(this._hits=0),this._hits},_processResult:function(n){return delete n.className,delete n._app_url,delete n._deeplink,n},hasMore:function(){return!this._hitEnd},reset:function(){this._hitEnd=!1,this._sid=null,this._hits=0},find:function(){var n=this;return this._createRequest().then((function(e){return e.sid?(n._oldSid=n._sid,n._sid=e.sid):(n._sid=null,n._hitEnd=!0),n._hits=e.hits||0,r.map(e.results,(function(t){t.className&&(e.className=t.className);var r=n._newObject(e);return r.appURL=t._app_url,r._finishFetch(n._processResult(t),!0),r}))}))},toJSON:function(){var e=n.SearchQuery.__super__.toJSON.call(this);if(delete e.where,this.className&&(e.clazz=this.className),this._sid&&(e.sid=this._sid),!this._queryString)throw new Error("Please set query string.");if(e.q=this._queryString,this._highlights&&(e.highlights=this._highlights.join(",")),this._sortBuilder&&e.order)throw new Error("sort and order can not be set at same time.");return this._sortBuilder&&(e.sort=this._sortBuilder.build()),e}})}},function(n,e,t){"use strict";var r=t(0),a=t(4),i=t(2).request,o=t(1);n.exports=function(n){n.Insight=n.Insight||{},r.extend(n.Insight,{startJob:function(e,t){if(!e||!e.sql)throw new Error("Please provide the sql to run the job.");var r={jobConfig:e,appId:n.applicationId};return i({path:"/bigquery/jobs",method:"POST",data:n._encode(r,null,!0),authOptions:t,signKey:!1}).then((function(e){return n._decode(e).id}))},on:function(n,e){}}),n.Insight.JobQuery=function(n,e){if(!n)throw new Error("Please provide the job id.");this.id=n,this.className=e,this._skip=0,this._limit=100},r.extend(n.Insight.JobQuery.prototype,{skip:function(n){return this._skip=n,this},limit:function(n){return this._limit=n,this},find:function(n){var e={skip:this._skip,limit:this._limit};return i({path:"/bigquery/jobs/"+this.id,method:"GET",query:e,authOptions:n,signKey:!1}).then((function(n){return n.error?o.reject(new a(n.code,n.error)):o.resolve(n)}))}})}},function(n,e,t){"use strict";var r=t(0),a=t(2)._request,i=t(5),o=function(n){return"string"==typeof n?n:"function"==typeof n.getPayload?JSON.stringify(n.getPayload()):JSON.stringify(n)};n.exports=i.Object.extend("_Conversation",{constructor:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};i.Object.prototype.constructor.call(this,null,null),this.set("name",n),void 0!==e.isSystem&&this.set("sys",!!e.isSystem),void 0!==e.isTransient&&this.set("tr",!!e.isTransient)},getCreator:function(){return this.get("c")},getLastMessageAt:function(){return this.get("lm")},getMembers:function(){return this.get("m")},addMember:function(n){return this.add("m",n)},getMutedMembers:function(){return this.get("mu")},getName:function(){return this.get("name")},isTransient:function(){return this.get("tr")},isSystem:function(){return this.get("sys")},send:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},i={from_peer:n,conv_id:this.id,transient:!1,message:o(e)};return void 0!==t.toClients&&(i.to_peers=t.toClients),void 0!==t.transient&&(i.transient=!!t.transient),void 0!==t.pushData&&(i.push_data=t.pushData),a("rtm","messages",null,"POST",i,r)},broadcast:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},s={from_peer:n,conv_id:this.id,message:o(e)};if(void 0!==t.pushData&&(s.push=t.pushData),void 0!==t.validTill){var l=t.validTill;r.isDate(l)&&(l=l.getTime()),t.valid_till=l}return a("rtm","broadcast",null,"POST",s,i)}})},function(n,e,t){"use strict";function r(n){var e=n.name,t=n.value,r=n.version;this.name=e,this.value=t,this.version=r}var a=t(0),i=t(1),o=t(2).request,s=t(3),l=s.ensureArray,c=s.parseDate,u=t(5);u.LeaderboardVersionChangeInterval={NEVER:"never",DAY:"day",WEEK:"week",MONTH:"month"},u.LeaderboardOrder={ASCENDING:"ascending",DESCENDING:"descending"},u.LeaderboardUpdateStrategy={BETTER:"better",LAST:"last",SUM:"sum"};var d=function(n){var e=u._decode(n);return new r({name:e.statisticName,value:e.statisticValue,version:e.version})};u.Leaderboard=function(n){this.statisticName=n,this.order=void 0,this.updateStrategy=void 0,this.versionChangeInterval=void 0,this.version=void 0,this.nextResetAt=void 0,this.createdAt=void 0};var p=u.Leaderboard;u.Leaderboard.createWithoutData=function(n){return new p(n)},u.Leaderboard.createLeaderboard=function(n,e){var t=n.statisticName,r=n.order,a=n.versionChangeInterval,i=n.updateStrategy;return o({method:"POST",path:"/leaderboard/leaderboards",data:{statisticName:t,order:r,versionChangeInterval:a,updateStrategy:i},authOptions:e}).then((function(n){return new p(t)._finishFetch(n)}))},u.Leaderboard.getLeaderboard=function(n,e){return p.createWithoutData(n).fetch(e)},u.Leaderboard.getStatistics=function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=e.statisticNames,r=arguments[2];return i.resolve().then((function(){if(!n||!n.id)throw new Error("user must be an AV.User");return o({method:"GET",path:"/leaderboard/users/"+n.id+"/statistics",query:{statistics:t?l(t).join(","):void 0},authOptions:r}).then((function(n){return n.results.map(d)}))}))},u.Leaderboard.updateStatistics=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return i.resolve().then((function(){if(!n||!n.id)throw new Error("user must be an AV.User");var r=a.map(e,(function(n,e){return{statisticName:e,statisticValue:n}})),i=t.overwrite;return o({method:"POST",path:"/leaderboard/users/"+n.id+"/statistics",query:{overwrite:i?1:void 0},data:r,authOptions:t}).then((function(n){return n.results.map(d)}))}))},u.Leaderboard.deleteStatistics=function(n,e,t){return i.resolve().then((function(){if(!n||!n.id)throw new Error("user must be an AV.User");return o({method:"DELETE",path:"/leaderboard/users/"+n.id+"/statistics",query:{statistics:l(e).join(",")},authOptions:t}).then((function(){}))}))},a.extend(p.prototype,{_finishFetch:function(n){var e=this;return a.forEach(n,(function(n,t){"updatedAt"!==t&&"objectId"!==t&&("expiredAt"===t&&(t="nextResetAt"),"createdAt"===t&&(n=c(n)),n&&"Date"===n.__type&&(n=c(n.iso)),e[t]=n)})),this},fetch:function(n){var e=this;return o({method:"GET",path:"/leaderboard/leaderboards/"+this.statisticName,authOptions:n}).then((function(n){return e._finishFetch(n)}))},_getResults:function(n,e,t){var r=n.skip,a=n.limit,i=n.selectUserKeys,s=n.includeStatistics,c=n.version;return o({method:"GET",path:"/leaderboard/leaderboards/"+this.statisticName+"/ranks"+(t?"/"+t:""),query:{skip:r,limit:a,includeUser:i?l(i).join(","):void 0,includeStatistics:s?l(s).join(","):void 0,version:c},authOptions:e}).then((function(n){return n.results.map((function(n){var e=u._decode(n),t=e.user,r=e.statisticValue,a=e.rank,i=e.statistics;return{user:t,value:r,rank:a,includedStatistics:(void 0===i?[]:i).map(d)}}))}))},getResults:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.skip,t=n.limit,r=n.selectUserKeys,a=n.includeStatistics,i=n.version,o=arguments[1];return this._getResults({skip:e,limit:t,selectUserKeys:r,includeStatistics:a,version:i},o)},getResultsAroundUser:function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=arguments[2];if(n&&"string"!=typeof n.id)return this.getResultsAroundUser(void 0,n,e);var r=e.limit,a=e.selectUserKeys,i=e.includeStatistics,o=e.version;return this._getResults({limit:r,selectUserKeys:a,includeStatistics:i,version:o},t,n?n.id:"self")},_update:function(n,e){var t=this;return o({method:"PUT",path:"/leaderboard/leaderboards/"+this.statisticName,data:n,authOptions:e}).then((function(n){return t._finishFetch(n)}))},updateVersionChangeInterval:function(n,e){return this._update({versionChangeInterval:n},e)},updateUpdateStrategy:function(n,e){return this._update({updateStrategy:n},e)},reset:function(n){var e=this;return o({method:"PUT",path:"/leaderboard/leaderboards/"+this.statisticName+"/incrementVersion",authOptions:n}).then((function(n){return e._finishFetch(n)}))},destroy:function(n){return u.request({method:"DELETE",path:"/leaderboard/leaderboards/"+this.statisticName,authOptions:n}).then((function(){}))},getArchives:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.skip,r=e.limit,a=arguments[1];return o({method:"GET",path:"/leaderboard/leaderboards/"+this.statisticName+"/archives",query:{skip:t,limit:r},authOptions:a}).then((function(e){return e.results.map((function(e){var t=e.version,r=e.status,a=e.url,i=e.activatedAt,o=e.deactivatedAt;return{statisticName:n.statisticName,version:t,status:r,url:a,activatedAt:c(i.iso),deactivatedAt:c(o.iso)}}))}))}})}])},function(n,e,t){"use strict";t(246)},function(n,e,t){"use strict";var r=t(450),a=t(247),i=t(165),o=Object.prototype.hasOwnProperty,s={brackets:function(n){return n+"[]"},comma:"comma",indices:function(n,e){return n+"["+e+"]"},repeat:function(n){return n}},l=Array.isArray,c=String.prototype.split,u=Array.prototype.push,d=function(n,e){u.apply(n,l(e)?e:[e])},p=Date.prototype.toISOString,h=i.default,f={addQueryPrefix:!1,allowDots:!1,charset:"utf-8",charsetSentinel:!1,delimiter:"&",encode:!0,encoder:a.encode,encodeValuesOnly:!1,format:h,formatter:i.formatters[h],indices:!1,serializeDate:function(n){return p.call(n)},skipNulls:!1,strictNullHandling:!1},v={},m=function n(e,t,i,o,s,u,p,h,m,g,y,b,w,k,x){for(var E,A=e,_=x,S=0,C=!1;void 0!==(_=_.get(v))&&!C;){var T=_.get(e);if(S+=1,void 0!==T){if(T===S)throw new RangeError("Cyclic object value");C=!0}void 0===_.get(v)&&(S=0)}if("function"==typeof p?A=p(t,A):A instanceof Date?A=g(A):"comma"===i&&l(A)&&(A=a.maybeMap(A,(function(n){return n instanceof Date?g(n):n}))),null===A){if(o)return u&&!w?u(t,f.encoder,k,"key",y):t;A=""}if("string"==typeof(E=A)||"number"==typeof E||"boolean"==typeof E||"symbol"==typeof E||"bigint"==typeof E||a.isBuffer(A)){if(u){var O=w?t:u(t,f.encoder,k,"key",y);if("comma"===i&&w){for(var j=c.call(String(A),","),B="",I=0;I<j.length;++I)B+=(0===I?"":",")+b(u(j[I],f.encoder,k,"value",y));return[b(O)+"="+B]}return[b(O)+"="+b(u(A,f.encoder,k,"value",y))]}return[b(t)+"="+b(String(A))]}var L,N=[];if(void 0===A)return N;if("comma"===i&&l(A))L=[{value:A.length>0?A.join(",")||null:void 0}];else if(l(p))L=p;else{var P=Object.keys(A);L=h?P.sort(h):P}for(var q=0;q<L.length;++q){var R=L[q],F="object"==typeof R&&void 0!==R.value?R.value:A[R];if(!s||null!==F){var M=l(A)?"function"==typeof i?i(t,R):t:t+(m?"."+R:"["+R+"]");x.set(e,S);var z=r();z.set(v,x),d(N,n(F,M,i,o,s,u,p,h,m,g,y,b,w,k,z))}}return N};n.exports=function(n,e){var t,a=n,c=function(n){if(!n)return f;if(null!==n.encoder&&void 0!==n.encoder&&"function"!=typeof n.encoder)throw new TypeError("Encoder has to be a function.");var e=n.charset||f.charset;if(void 0!==n.charset&&"utf-8"!==n.charset&&"iso-8859-1"!==n.charset)throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");var t=i.default;if(void 0!==n.format){if(!o.call(i.formatters,n.format))throw new TypeError("Unknown format option provided.");t=n.format}var r=i.formatters[t],a=f.filter;return("function"==typeof n.filter||l(n.filter))&&(a=n.filter),{addQueryPrefix:"boolean"==typeof n.addQueryPrefix?n.addQueryPrefix:f.addQueryPrefix,allowDots:void 0===n.allowDots?f.allowDots:!!n.allowDots,charset:e,charsetSentinel:"boolean"==typeof n.charsetSentinel?n.charsetSentinel:f.charsetSentinel,delimiter:void 0===n.delimiter?f.delimiter:n.delimiter,encode:"boolean"==typeof n.encode?n.encode:f.encode,encoder:"function"==typeof n.encoder?n.encoder:f.encoder,encodeValuesOnly:"boolean"==typeof n.encodeValuesOnly?n.encodeValuesOnly:f.encodeValuesOnly,filter:a,format:t,formatter:r,serializeDate:"function"==typeof n.serializeDate?n.serializeDate:f.serializeDate,skipNulls:"boolean"==typeof n.skipNulls?n.skipNulls:f.skipNulls,sort:"function"==typeof n.sort?n.sort:null,strictNullHandling:"boolean"==typeof n.strictNullHandling?n.strictNullHandling:f.strictNullHandling}}(e);"function"==typeof c.filter?a=(0,c.filter)("",a):l(c.filter)&&(t=c.filter);var u,p=[];if("object"!=typeof a||null===a)return"";u=e&&e.arrayFormat in s?e.arrayFormat:e&&"indices"in e?e.indices?"indices":"repeat":"indices";var h=s[u];t||(t=Object.keys(a)),c.sort&&t.sort(c.sort);for(var v=r(),g=0;g<t.length;++g){var y=t[g];c.skipNulls&&null===a[y]||d(p,m(a[y],y,h,c.strictNullHandling,c.skipNulls,c.encode?c.encoder:null,c.filter,c.sort,c.allowDots,c.serializeDate,c.format,c.formatter,c.encodeValuesOnly,c.charset,v))}var b=p.join(c.delimiter),w=!0===c.addQueryPrefix?"?":"";return c.charsetSentinel&&("iso-8859-1"===c.charset?w+="utf8=%26%2310003%3B&":w+="utf8=%E2%9C%93&"),b.length>0?w+b:""}},function(n,e,t){"use strict";var r=t(163),a=t(455),i=t(457),o=r("%TypeError%"),s=r("%WeakMap%",!0),l=r("%Map%",!0),c=a("WeakMap.prototype.get",!0),u=a("WeakMap.prototype.set",!0),d=a("WeakMap.prototype.has",!0),p=a("Map.prototype.get",!0),h=a("Map.prototype.set",!0),f=a("Map.prototype.has",!0),v=function(n,e){for(var t,r=n;null!==(t=r.next);r=t)if(t.key===e)return r.next=t.next,t.next=n.next,n.next=t,t};n.exports=function(){var n,e,t,r={assert:function(n){if(!r.has(n))throw new o("Side channel does not contain "+i(n))},get:function(r){if(s&&r&&("object"==typeof r||"function"==typeof r)){if(n)return c(n,r)}else if(l){if(e)return p(e,r)}else if(t)return function(n,e){var t=v(n,e);return t&&t.value}(t,r)},has:function(r){if(s&&r&&("object"==typeof r||"function"==typeof r)){if(n)return d(n,r)}else if(l){if(e)return f(e,r)}else if(t)return function(n,e){return!!v(n,e)}(t,r);return!1},set:function(r,a){s&&r&&("object"==typeof r||"function"==typeof r)?(n||(n=new s),u(n,r,a)):l?(e||(e=new l),h(e,r,a)):(t||(t={key:{},next:null}),function(n,e,t){var r=v(n,e);r?r.value=t:n.next={key:e,next:n.next,value:t}}(t,r,a))}};return r}},function(n,e,t){"use strict";var r="undefined"!=typeof Symbol&&Symbol,a=t(452);n.exports=function(){return"function"==typeof r&&("function"==typeof Symbol&&("symbol"==typeof r("foo")&&("symbol"==typeof Symbol("bar")&&a())))}},function(n,e,t){"use strict";n.exports=function(){if("function"!=typeof Symbol||"function"!=typeof Object.getOwnPropertySymbols)return!1;if("symbol"==typeof Symbol.iterator)return!0;var n={},e=Symbol("test"),t=Object(e);if("string"==typeof e)return!1;if("[object Symbol]"!==Object.prototype.toString.call(e))return!1;if("[object Symbol]"!==Object.prototype.toString.call(t))return!1;for(e in n[e]=42,n)return!1;if("function"==typeof Object.keys&&0!==Object.keys(n).length)return!1;if("function"==typeof Object.getOwnPropertyNames&&0!==Object.getOwnPropertyNames(n).length)return!1;var r=Object.getOwnPropertySymbols(n);if(1!==r.length||r[0]!==e)return!1;if(!Object.prototype.propertyIsEnumerable.call(n,e))return!1;if("function"==typeof Object.getOwnPropertyDescriptor){var a=Object.getOwnPropertyDescriptor(n,e);if(42!==a.value||!0!==a.enumerable)return!1}return!0}},function(n,e,t){"use strict";var r="Function.prototype.bind called on incompatible ",a=Array.prototype.slice,i=Object.prototype.toString;n.exports=function(n){var e=this;if("function"!=typeof e||"[object Function]"!==i.call(e))throw new TypeError(r+e);for(var t,o=a.call(arguments,1),s=function(){if(this instanceof t){var r=e.apply(this,o.concat(a.call(arguments)));return Object(r)===r?r:this}return e.apply(n,o.concat(a.call(arguments)))},l=Math.max(0,e.length-o.length),c=[],u=0;u<l;u++)c.push("$"+u);if(t=Function("binder","return function ("+c.join(",")+"){ return binder.apply(this,arguments); }")(s),e.prototype){var d=function(){};d.prototype=e.prototype,t.prototype=new d,d.prototype=null}return t}},function(n,e,t){"use strict";var r=t(164);n.exports=r.call(Function.call,Object.prototype.hasOwnProperty)},function(n,e,t){"use strict";var r=t(163),a=t(456),i=a(r("String.prototype.indexOf"));n.exports=function(n,e){var t=r(n,!!e);return"function"==typeof t&&i(n,".prototype.")>-1?a(t):t}},function(n,e,t){"use strict";var r=t(164),a=t(163),i=a("%Function.prototype.apply%"),o=a("%Function.prototype.call%"),s=a("%Reflect.apply%",!0)||r.call(o,i),l=a("%Object.getOwnPropertyDescriptor%",!0),c=a("%Object.defineProperty%",!0),u=a("%Math.max%");if(c)try{c({},"a",{value:1})}catch(n){c=null}n.exports=function(n){var e=s(r,o,arguments);if(l&&c){var t=l(e,"length");t.configurable&&c(e,"length",{value:1+u(0,n.length-(arguments.length-1))})}return e};var d=function(){return s(r,i,arguments)};c?c(n.exports,"apply",{value:d}):n.exports.apply=d},function(n,e,t){var r="function"==typeof Map&&Map.prototype,a=Object.getOwnPropertyDescriptor&&r?Object.getOwnPropertyDescriptor(Map.prototype,"size"):null,i=r&&a&&"function"==typeof a.get?a.get:null,o=r&&Map.prototype.forEach,s="function"==typeof Set&&Set.prototype,l=Object.getOwnPropertyDescriptor&&s?Object.getOwnPropertyDescriptor(Set.prototype,"size"):null,c=s&&l&&"function"==typeof l.get?l.get:null,u=s&&Set.prototype.forEach,d="function"==typeof WeakMap&&WeakMap.prototype?WeakMap.prototype.has:null,p="function"==typeof WeakSet&&WeakSet.prototype?WeakSet.prototype.has:null,h="function"==typeof WeakRef&&WeakRef.prototype?WeakRef.prototype.deref:null,f=Boolean.prototype.valueOf,v=Object.prototype.toString,m=Function.prototype.toString,g=String.prototype.match,y=String.prototype.slice,b=String.prototype.replace,w=String.prototype.toUpperCase,k=String.prototype.toLowerCase,x=RegExp.prototype.test,E=Array.prototype.concat,A=Array.prototype.join,_=Array.prototype.slice,S=Math.floor,C="function"==typeof BigInt?BigInt.prototype.valueOf:null,T=Object.getOwnPropertySymbols,O="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?Symbol.prototype.toString:null,j="function"==typeof Symbol&&"object"==typeof Symbol.iterator,B="function"==typeof Symbol&&Symbol.toStringTag&&(typeof Symbol.toStringTag===j||"symbol")?Symbol.toStringTag:null,I=Object.prototype.propertyIsEnumerable,L=("function"==typeof Reflect?Reflect.getPrototypeOf:Object.getPrototypeOf)||([].__proto__===Array.prototype?function(n){return n.__proto__}:null);function N(n,e){if(n===1/0||n===-1/0||n!=n||n&&n>-1e3&&n<1e3||x.call(/e/,e))return e;var t=/[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;if("number"==typeof n){var r=n<0?-S(-n):S(n);if(r!==n){var a=String(r),i=y.call(e,a.length+1);return b.call(a,t,"$&_")+"."+b.call(b.call(i,/([0-9]{3})/g,"$&_"),/_$/,"")}}return b.call(e,t,"$&_")}var P=t(458).custom,q=P&&z(P)?P:null;function R(n,e,t){var r="double"===(t.quoteStyle||e)?'"':"'";return r+n+r}function F(n){return b.call(String(n),/"/g,"&quot;")}function M(n){return!("[object Array]"!==$(n)||B&&"object"==typeof n&&B in n)}function z(n){if(j)return n&&"object"==typeof n&&n instanceof Symbol;if("symbol"==typeof n)return!0;if(!n||"object"!=typeof n||!O)return!1;try{return O.call(n),!0}catch(n){}return!1}n.exports=function n(e,t,r,a){var s=t||{};if(U(s,"quoteStyle")&&"single"!==s.quoteStyle&&"double"!==s.quoteStyle)throw new TypeError('option "quoteStyle" must be "single" or "double"');if(U(s,"maxStringLength")&&("number"==typeof s.maxStringLength?s.maxStringLength<0&&s.maxStringLength!==1/0:null!==s.maxStringLength))throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');var l=!U(s,"customInspect")||s.customInspect;if("boolean"!=typeof l&&"symbol"!==l)throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");if(U(s,"indent")&&null!==s.indent&&"\t"!==s.indent&&!(parseInt(s.indent,10)===s.indent&&s.indent>0))throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');if(U(s,"numericSeparator")&&"boolean"!=typeof s.numericSeparator)throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');var v=s.numericSeparator;if(void 0===e)return"undefined";if(null===e)return"null";if("boolean"==typeof e)return e?"true":"false";if("string"==typeof e)return function n(e,t){if(e.length>t.maxStringLength){var r=e.length-t.maxStringLength,a="... "+r+" more character"+(r>1?"s":"");return n(y.call(e,0,t.maxStringLength),t)+a}return R(b.call(b.call(e,/(['\\])/g,"\\$1"),/[\x00-\x1f]/g,W),"single",t)}(e,s);if("number"==typeof e){if(0===e)return 1/0/e>0?"0":"-0";var w=String(e);return v?N(e,w):w}if("bigint"==typeof e){var x=String(e)+"n";return v?N(e,x):x}var S=void 0===s.depth?5:s.depth;if(void 0===r&&(r=0),r>=S&&S>0&&"object"==typeof e)return M(e)?"[Array]":"[Object]";var T=function(n,e){var t;if("\t"===n.indent)t="\t";else{if(!("number"==typeof n.indent&&n.indent>0))return null;t=A.call(Array(n.indent+1)," ")}return{base:t,prev:A.call(Array(e+1),t)}}(s,r);if(void 0===a)a=[];else if(J(a,e)>=0)return"[Circular]";function P(e,t,i){if(t&&(a=_.call(a)).push(t),i){var o={depth:s.depth};return U(s,"quoteStyle")&&(o.quoteStyle=s.quoteStyle),n(e,o,r+1,a)}return n(e,s,r+1,a)}if("function"==typeof e){var D=function(n){if(n.name)return n.name;var e=g.call(m.call(n),/^function\s*([\w$]+)/);if(e)return e[1];return null}(e),Y=K(e,P);return"[Function"+(D?": "+D:" (anonymous)")+"]"+(Y.length>0?" { "+A.call(Y,", ")+" }":"")}if(z(e)){var X=j?b.call(String(e),/^(Symbol\(.*\))_[^)]*$/,"$1"):O.call(e);return"object"!=typeof e||j?X:Q(X)}if(function(n){if(!n||"object"!=typeof n)return!1;if("undefined"!=typeof HTMLElement&&n instanceof HTMLElement)return!0;return"string"==typeof n.nodeName&&"function"==typeof n.getAttribute}(e)){for(var Z="<"+k.call(String(e.nodeName)),nn=e.attributes||[],en=0;en<nn.length;en++)Z+=" "+nn[en].name+"="+R(F(nn[en].value),"double",s);return Z+=">",e.childNodes&&e.childNodes.length&&(Z+="..."),Z+="</"+k.call(String(e.nodeName))+">"}if(M(e)){if(0===e.length)return"[]";var tn=K(e,P);return T&&!function(n){for(var e=0;e<n.length;e++)if(J(n[e],"\n")>=0)return!1;return!0}(tn)?"["+G(tn,T)+"]":"[ "+A.call(tn,", ")+" ]"}if(function(n){return!("[object Error]"!==$(n)||B&&"object"==typeof n&&B in n)}(e)){var rn=K(e,P);return"cause"in e&&!I.call(e,"cause")?"{ ["+String(e)+"] "+A.call(E.call("[cause]: "+P(e.cause),rn),", ")+" }":0===rn.length?"["+String(e)+"]":"{ ["+String(e)+"] "+A.call(rn,", ")+" }"}if("object"==typeof e&&l){if(q&&"function"==typeof e[q])return e[q]();if("symbol"!==l&&"function"==typeof e.inspect)return e.inspect()}if(function(n){if(!i||!n||"object"!=typeof n)return!1;try{i.call(n);try{c.call(n)}catch(n){return!0}return n instanceof Map}catch(n){}return!1}(e)){var an=[];return o.call(e,(function(n,t){an.push(P(t,e,!0)+" => "+P(n,e))})),H("Map",i.call(e),an,T)}if(function(n){if(!c||!n||"object"!=typeof n)return!1;try{c.call(n);try{i.call(n)}catch(n){return!0}return n instanceof Set}catch(n){}return!1}(e)){var on=[];return u.call(e,(function(n){on.push(P(n,e))})),H("Set",c.call(e),on,T)}if(function(n){if(!d||!n||"object"!=typeof n)return!1;try{d.call(n,d);try{p.call(n,p)}catch(n){return!0}return n instanceof WeakMap}catch(n){}return!1}(e))return V("WeakMap");if(function(n){if(!p||!n||"object"!=typeof n)return!1;try{p.call(n,p);try{d.call(n,d)}catch(n){return!0}return n instanceof WeakSet}catch(n){}return!1}(e))return V("WeakSet");if(function(n){if(!h||!n||"object"!=typeof n)return!1;try{return h.call(n),!0}catch(n){}return!1}(e))return V("WeakRef");if(function(n){return!("[object Number]"!==$(n)||B&&"object"==typeof n&&B in n)}(e))return Q(P(Number(e)));if(function(n){if(!n||"object"!=typeof n||!C)return!1;try{return C.call(n),!0}catch(n){}return!1}(e))return Q(P(C.call(e)));if(function(n){return!("[object Boolean]"!==$(n)||B&&"object"==typeof n&&B in n)}(e))return Q(f.call(e));if(function(n){return!("[object String]"!==$(n)||B&&"object"==typeof n&&B in n)}(e))return Q(P(String(e)));if(!function(n){return!("[object Date]"!==$(n)||B&&"object"==typeof n&&B in n)}(e)&&!function(n){return!("[object RegExp]"!==$(n)||B&&"object"==typeof n&&B in n)}(e)){var sn=K(e,P),ln=L?L(e)===Object.prototype:e instanceof Object||e.constructor===Object,cn=e instanceof Object?"":"null prototype",un=!ln&&B&&Object(e)===e&&B in e?y.call($(e),8,-1):cn?"Object":"",dn=(ln||"function"!=typeof e.constructor?"":e.constructor.name?e.constructor.name+" ":"")+(un||cn?"["+A.call(E.call([],un||[],cn||[]),": ")+"] ":"");return 0===sn.length?dn+"{}":T?dn+"{"+G(sn,T)+"}":dn+"{ "+A.call(sn,", ")+" }"}return String(e)};var D=Object.prototype.hasOwnProperty||function(n){return n in this};function U(n,e){return D.call(n,e)}function $(n){return v.call(n)}function J(n,e){if(n.indexOf)return n.indexOf(e);for(var t=0,r=n.length;t<r;t++)if(n[t]===e)return t;return-1}function W(n){var e=n.charCodeAt(0),t={8:"b",9:"t",10:"n",12:"f",13:"r"}[e];return t?"\\"+t:"\\x"+(e<16?"0":"")+w.call(e.toString(16))}function Q(n){return"Object("+n+")"}function V(n){return n+" { ? }"}function H(n,e,t,r){return n+" ("+e+") {"+(r?G(t,r):A.call(t,", "))+"}"}function G(n,e){if(0===n.length)return"";var t="\n"+e.prev+e.base;return t+A.call(n,","+t)+"\n"+e.prev}function K(n,e){var t=M(n),r=[];if(t){r.length=n.length;for(var a=0;a<n.length;a++)r[a]=U(n,a)?e(n[a],n):""}var i,o="function"==typeof T?T(n):[];if(j){i={};for(var s=0;s<o.length;s++)i["$"+o[s]]=o[s]}for(var l in n)U(n,l)&&(t&&String(Number(l))===l&&l<n.length||j&&i["$"+l]instanceof Symbol||(x.call(/[^\w$]/,l)?r.push(e(l,n)+": "+e(n[l],n)):r.push(l+": "+e(n[l],n))));if("function"==typeof T)for(var c=0;c<o.length;c++)I.call(n,o[c])&&r.push("["+e(o[c])+"]: "+e(n[o[c]],n));return r}},function(n,e){},function(n,e,t){"use strict";var r=t(247),a=Object.prototype.hasOwnProperty,i=Array.isArray,o={allowDots:!1,allowPrototypes:!1,allowSparse:!1,arrayLimit:20,charset:"utf-8",charsetSentinel:!1,comma:!1,decoder:r.decode,delimiter:"&",depth:5,ignoreQueryPrefix:!1,interpretNumericEntities:!1,parameterLimit:1e3,parseArrays:!0,plainObjects:!1,strictNullHandling:!1},s=function(n){return n.replace(/&#(\d+);/g,(function(n,e){return String.fromCharCode(parseInt(e,10))}))},l=function(n,e){return n&&"string"==typeof n&&e.comma&&n.indexOf(",")>-1?n.split(","):n},c=function(n,e,t,r){if(n){var i=t.allowDots?n.replace(/\.([^.[]+)/g,"[$1]"):n,o=/(\[[^[\]]*])/g,s=t.depth>0&&/(\[[^[\]]*])/.exec(i),c=s?i.slice(0,s.index):i,u=[];if(c){if(!t.plainObjects&&a.call(Object.prototype,c)&&!t.allowPrototypes)return;u.push(c)}for(var d=0;t.depth>0&&null!==(s=o.exec(i))&&d<t.depth;){if(d+=1,!t.plainObjects&&a.call(Object.prototype,s[1].slice(1,-1))&&!t.allowPrototypes)return;u.push(s[1])}return s&&u.push("["+i.slice(s.index)+"]"),function(n,e,t,r){for(var a=r?e:l(e,t),i=n.length-1;i>=0;--i){var o,s=n[i];if("[]"===s&&t.parseArrays)o=[].concat(a);else{o=t.plainObjects?Object.create(null):{};var c="["===s.charAt(0)&&"]"===s.charAt(s.length-1)?s.slice(1,-1):s,u=parseInt(c,10);t.parseArrays||""!==c?!isNaN(u)&&s!==c&&String(u)===c&&u>=0&&t.parseArrays&&u<=t.arrayLimit?(o=[])[u]=a:"__proto__"!==c&&(o[c]=a):o={0:a}}a=o}return a}(u,e,t,r)}};n.exports=function(n,e){var t=function(n){if(!n)return o;if(null!==n.decoder&&void 0!==n.decoder&&"function"!=typeof n.decoder)throw new TypeError("Decoder has to be a function.");if(void 0!==n.charset&&"utf-8"!==n.charset&&"iso-8859-1"!==n.charset)throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");var e=void 0===n.charset?o.charset:n.charset;return{allowDots:void 0===n.allowDots?o.allowDots:!!n.allowDots,allowPrototypes:"boolean"==typeof n.allowPrototypes?n.allowPrototypes:o.allowPrototypes,allowSparse:"boolean"==typeof n.allowSparse?n.allowSparse:o.allowSparse,arrayLimit:"number"==typeof n.arrayLimit?n.arrayLimit:o.arrayLimit,charset:e,charsetSentinel:"boolean"==typeof n.charsetSentinel?n.charsetSentinel:o.charsetSentinel,comma:"boolean"==typeof n.comma?n.comma:o.comma,decoder:"function"==typeof n.decoder?n.decoder:o.decoder,delimiter:"string"==typeof n.delimiter||r.isRegExp(n.delimiter)?n.delimiter:o.delimiter,depth:"number"==typeof n.depth||!1===n.depth?+n.depth:o.depth,ignoreQueryPrefix:!0===n.ignoreQueryPrefix,interpretNumericEntities:"boolean"==typeof n.interpretNumericEntities?n.interpretNumericEntities:o.interpretNumericEntities,parameterLimit:"number"==typeof n.parameterLimit?n.parameterLimit:o.parameterLimit,parseArrays:!1!==n.parseArrays,plainObjects:"boolean"==typeof n.plainObjects?n.plainObjects:o.plainObjects,strictNullHandling:"boolean"==typeof n.strictNullHandling?n.strictNullHandling:o.strictNullHandling}}(e);if(""===n||null==n)return t.plainObjects?Object.create(null):{};for(var u="string"==typeof n?function(n,e){var t,c={},u=e.ignoreQueryPrefix?n.replace(/^\?/,""):n,d=e.parameterLimit===1/0?void 0:e.parameterLimit,p=u.split(e.delimiter,d),h=-1,f=e.charset;if(e.charsetSentinel)for(t=0;t<p.length;++t)0===p[t].indexOf("utf8=")&&("utf8=%E2%9C%93"===p[t]?f="utf-8":"utf8=%26%2310003%3B"===p[t]&&(f="iso-8859-1"),h=t,t=p.length);for(t=0;t<p.length;++t)if(t!==h){var v,m,g=p[t],y=g.indexOf("]="),b=-1===y?g.indexOf("="):y+1;-1===b?(v=e.decoder(g,o.decoder,f,"key"),m=e.strictNullHandling?null:""):(v=e.decoder(g.slice(0,b),o.decoder,f,"key"),m=r.maybeMap(l(g.slice(b+1),e),(function(n){return e.decoder(n,o.decoder,f,"value")}))),m&&e.interpretNumericEntities&&"iso-8859-1"===f&&(m=s(m)),g.indexOf("[]=")>-1&&(m=i(m)?[m]:m),a.call(c,v)?c[v]=r.combine(c[v],m):c[v]=m}return c}(n,t):n,d=t.plainObjects?Object.create(null):{},p=Object.keys(u),h=0;h<p.length;++h){var f=p[h],v=c(f,u[f],t,"string"==typeof n);d=r.merge(d,v,t)}return!0===t.allowSparse?d:r.compact(d)}},function(n,e,t){var r=t(53),a=t(462),i=t(463);n.exports=function(n){var e=r(n);return i(e,a(e))+1}},function(n,e){n.exports=function(n){var e=new Date(n.getTime()),t=e.getTimezoneOffset();return e.setSeconds(0,0),6e4*t+e.getTime()%6e4}},function(n,e,t){var r=t(53);n.exports=function(n){var e=r(n),t=new Date(0);return t.setFullYear(e.getFullYear(),0,1),t.setHours(0,0,0,0),t}},function(n,e,t){var r=t(464);n.exports=function(n,e){var t=r(n),a=r(e),i=t.getTime()-6e4*t.getTimezoneOffset(),o=a.getTime()-6e4*a.getTimezoneOffset();return Math.round((i-o)/864e5)}},function(n,e,t){var r=t(53);n.exports=function(n){var e=r(n);return e.setHours(0,0,0,0),e}},function(n,e,t){var r=t(53),a=t(166),i=t(467);n.exports=function(n){var e=r(n),t=a(e).getTime()-i(e).getTime();return Math.round(t/6048e5)+1}},function(n,e,t){var r=t(53);n.exports=function(n,e){var t=e&&Number(e.weekStartsOn)||0,a=r(n),i=a.getDay(),o=(i<t?7:0)+i-t;return a.setDate(a.getDate()-o),a.setHours(0,0,0,0),a}},function(n,e,t){var r=t(249),a=t(166);n.exports=function(n){var e=r(n),t=new Date(0);return t.setFullYear(e,0,4),t.setHours(0,0,0,0),a(t)}},function(n,e,t){var r=t(248);n.exports=function(n){if(r(n))return!isNaN(n);throw new TypeError(toString.call(n)+" is not an instance of Date")}},function(n,e,t){var r=t(470),a=t(471);n.exports={distanceInWords:r(),format:a()}},function(n,e){n.exports=function(){var n={lessThanXSeconds:{one:"less than a second",other:"less than {{count}} seconds"},xSeconds:{one:"1 second",other:"{{count}} seconds"},halfAMinute:"half a minute",lessThanXMinutes:{one:"less than a minute",other:"less than {{count}} minutes"},xMinutes:{one:"1 minute",other:"{{count}} minutes"},aboutXHours:{one:"about 1 hour",other:"about {{count}} hours"},xHours:{one:"1 hour",other:"{{count}} hours"},xDays:{one:"1 day",other:"{{count}} days"},aboutXMonths:{one:"about 1 month",other:"about {{count}} months"},xMonths:{one:"1 month",other:"{{count}} months"},aboutXYears:{one:"about 1 year",other:"about {{count}} years"},xYears:{one:"1 year",other:"{{count}} years"},overXYears:{one:"over 1 year",other:"over {{count}} years"},almostXYears:{one:"almost 1 year",other:"almost {{count}} years"}};return{localize:function(e,t,r){var a;return r=r||{},a="string"==typeof n[e]?n[e]:1===t?n[e].one:n[e].other.replace("{{count}}",t),r.addSuffix?r.comparison>0?"in "+a:a+" ago":a}}}},function(n,e,t){var r=t(472);n.exports=function(){var n=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],e=["January","February","March","April","May","June","July","August","September","October","November","December"],t=["Su","Mo","Tu","We","Th","Fr","Sa"],a=["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],i=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],o=["AM","PM"],s=["am","pm"],l=["a.m.","p.m."],c={MMM:function(e){return n[e.getMonth()]},MMMM:function(n){return e[n.getMonth()]},dd:function(n){return t[n.getDay()]},ddd:function(n){return a[n.getDay()]},dddd:function(n){return i[n.getDay()]},A:function(n){return n.getHours()/12>=1?o[1]:o[0]},a:function(n){return n.getHours()/12>=1?s[1]:s[0]},aa:function(n){return n.getHours()/12>=1?l[1]:l[0]}};return["M","D","DDD","d","Q","W"].forEach((function(n){c[n+"o"]=function(e,t){return function(n){var e=n%100;if(e>20||e<10)switch(e%10){case 1:return n+"st";case 2:return n+"nd";case 3:return n+"rd"}return n+"th"}(t[n](e))}})),{formatters:c,formattingTokensRegExp:r(c)}}},function(n,e){var t=["M","MM","Q","D","DD","DDD","DDDD","d","E","W","WW","YY","YYYY","GG","GGGG","H","HH","h","hh","m","mm","s","ss","S","SS","SSS","Z","ZZ","X","x"];n.exports=function(n){var e=[];for(var r in n)n.hasOwnProperty(r)&&e.push(r);var a=t.concat(e).sort().reverse();return new RegExp("(\\[[^\\[]*\\])|(\\\\)?("+a.join("|")+"|.)","g")}},function(n,e,t){"use strict";var r=t(21),a=t(250),i=t(474),o=t(256);function s(n){var e=new i(n),t=a(i.prototype.request,e);return r.extend(t,i.prototype,e),r.extend(t,e),t}var l=s(t(253));l.Axios=i,l.create=function(n){return s(o(l.defaults,n))},l.Cancel=t(257),l.CancelToken=t(487),l.isCancel=t(252),l.all=function(n){return Promise.all(n)},l.spread=t(488),n.exports=l,n.exports.default=l},function(n,e,t){"use strict";var r=t(21),a=t(251),i=t(475),o=t(476),s=t(256);function l(n){this.defaults=n,this.interceptors={request:new i,response:new i}}l.prototype.request=function(n){"string"==typeof n?(n=arguments[1]||{}).url=arguments[0]:n=n||{},(n=s(this.defaults,n)).method?n.method=n.method.toLowerCase():this.defaults.method?n.method=this.defaults.method.toLowerCase():n.method="get";var e=[o,void 0],t=Promise.resolve(n);for(this.interceptors.request.forEach((function(n){e.unshift(n.fulfilled,n.rejected)})),this.interceptors.response.forEach((function(n){e.push(n.fulfilled,n.rejected)}));e.length;)t=t.then(e.shift(),e.shift());return t},l.prototype.getUri=function(n){return n=s(this.defaults,n),a(n.url,n.params,n.paramsSerializer).replace(/^\?/,"")},r.forEach(["delete","get","head","options"],(function(n){l.prototype[n]=function(e,t){return this.request(r.merge(t||{},{method:n,url:e}))}})),r.forEach(["post","put","patch"],(function(n){l.prototype[n]=function(e,t,a){return this.request(r.merge(a||{},{method:n,url:e,data:t}))}})),n.exports=l},function(n,e,t){"use strict";var r=t(21);function a(){this.handlers=[]}a.prototype.use=function(n,e){return this.handlers.push({fulfilled:n,rejected:e}),this.handlers.length-1},a.prototype.eject=function(n){this.handlers[n]&&(this.handlers[n]=null)},a.prototype.forEach=function(n){r.forEach(this.handlers,(function(e){null!==e&&n(e)}))},n.exports=a},function(n,e,t){"use strict";var r=t(21),a=t(477),i=t(252),o=t(253);function s(n){n.cancelToken&&n.cancelToken.throwIfRequested()}n.exports=function(n){return s(n),n.headers=n.headers||{},n.data=a(n.data,n.headers,n.transformRequest),n.headers=r.merge(n.headers.common||{},n.headers[n.method]||{},n.headers),r.forEach(["delete","get","head","post","put","patch","common"],(function(e){delete n.headers[e]})),(n.adapter||o.adapter)(n).then((function(e){return s(n),e.data=a(e.data,e.headers,n.transformResponse),e}),(function(e){return i(e)||(s(n),e&&e.response&&(e.response.data=a(e.response.data,e.response.headers,n.transformResponse))),Promise.reject(e)}))}},function(n,e,t){"use strict";var r=t(21);n.exports=function(n,e,t){return r.forEach(t,(function(t){n=t(n,e)})),n}},function(n,e,t){"use strict";var r=t(21);n.exports=function(n,e){r.forEach(n,(function(t,r){r!==e&&r.toUpperCase()===e.toUpperCase()&&(n[e]=t,delete n[r])}))}},function(n,e,t){"use strict";var r=t(255);n.exports=function(n,e,t){var a=t.config.validateStatus;!a||a(t.status)?n(t):e(r("Request failed with status code "+t.status,t.config,null,t.request,t))}},function(n,e,t){"use strict";n.exports=function(n,e,t,r,a){return n.config=e,t&&(n.code=t),n.request=r,n.response=a,n.isAxiosError=!0,n.toJSON=function(){return{message:this.message,name:this.name,description:this.description,number:this.number,fileName:this.fileName,lineNumber:this.lineNumber,columnNumber:this.columnNumber,stack:this.stack,config:this.config,code:this.code}},n}},function(n,e,t){"use strict";var r=t(482),a=t(483);n.exports=function(n,e){return n&&!r(e)?a(n,e):e}},function(n,e,t){"use strict";n.exports=function(n){return/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(n)}},function(n,e,t){"use strict";n.exports=function(n,e){return e?n.replace(/\/+$/,"")+"/"+e.replace(/^\/+/,""):n}},function(n,e,t){"use strict";var r=t(21),a=["age","authorization","content-length","content-type","etag","expires","from","host","if-modified-since","if-unmodified-since","last-modified","location","max-forwards","proxy-authorization","referer","retry-after","user-agent"];n.exports=function(n){var e,t,i,o={};return n?(r.forEach(n.split("\n"),(function(n){if(i=n.indexOf(":"),e=r.trim(n.substr(0,i)).toLowerCase(),t=r.trim(n.substr(i+1)),e){if(o[e]&&a.indexOf(e)>=0)return;o[e]="set-cookie"===e?(o[e]?o[e]:[]).concat([t]):o[e]?o[e]+", "+t:t}})),o):o}},function(n,e,t){"use strict";var r=t(21);n.exports=r.isStandardBrowserEnv()?function(){var n,e=/(msie|trident)/i.test(navigator.userAgent),t=document.createElement("a");function a(n){var r=n;return e&&(t.setAttribute("href",r),r=t.href),t.setAttribute("href",r),{href:t.href,protocol:t.protocol?t.protocol.replace(/:$/,""):"",host:t.host,search:t.search?t.search.replace(/^\?/,""):"",hash:t.hash?t.hash.replace(/^#/,""):"",hostname:t.hostname,port:t.port,pathname:"/"===t.pathname.charAt(0)?t.pathname:"/"+t.pathname}}return n=a(window.location.href),function(e){var t=r.isString(e)?a(e):e;return t.protocol===n.protocol&&t.host===n.host}}():function(){return!0}},function(n,e,t){"use strict";var r=t(21);n.exports=r.isStandardBrowserEnv()?{write:function(n,e,t,a,i,o){var s=[];s.push(n+"="+encodeURIComponent(e)),r.isNumber(t)&&s.push("expires="+new Date(t).toGMTString()),r.isString(a)&&s.push("path="+a),r.isString(i)&&s.push("domain="+i),!0===o&&s.push("secure"),document.cookie=s.join("; ")},read:function(n){var e=document.cookie.match(new RegExp("(^|;\\s*)("+n+")=([^;]*)"));return e?decodeURIComponent(e[3]):null},remove:function(n){this.write(n,"",Date.now()-864e5)}}:{write:function(){},read:function(){return null},remove:function(){}}},function(n,e,t){"use strict";var r=t(257);function a(n){if("function"!=typeof n)throw new TypeError("executor must be a function.");var e;this.promise=new Promise((function(n){e=n}));var t=this;n((function(n){t.reason||(t.reason=new r(n),e(t.reason))}))}a.prototype.throwIfRequested=function(){if(this.reason)throw this.reason},a.source=function(){var n;return{token:new a((function(e){n=e})),cancel:n}},n.exports=a},function(n,e,t){"use strict";n.exports=function(n){return function(e){return n.apply(null,e)}}},function(n,e,t){},function(n,e,t){"use strict";t(258)},function(n,e,t){var r;function a(n){function t(){if(t.enabled){var n=t,a=+new Date,i=a-(r||a);n.diff=i,n.prev=r,n.curr=a,r=a;for(var o=new Array(arguments.length),s=0;s<o.length;s++)o[s]=arguments[s];o[0]=e.coerce(o[0]),"string"!=typeof o[0]&&o.unshift("%O");var l=0;o[0]=o[0].replace(/%([a-zA-Z%])/g,(function(t,r){if("%%"===t)return t;l++;var a=e.formatters[r];if("function"==typeof a){var i=o[l];t=a.call(n,i),o.splice(l,1),l--}return t})),e.formatArgs.call(n,o);var c=t.log||e.log||console.log.bind(console);c.apply(n,o)}}return t.namespace=n,t.enabled=e.enabled(n),t.useColors=e.useColors(),t.color=function(n){var t,r=0;for(t in n)r=(r<<5)-r+n.charCodeAt(t),r|=0;return e.colors[Math.abs(r)%e.colors.length]}(n),"function"==typeof e.init&&e.init(t),t}(e=n.exports=a.debug=a.default=a).coerce=function(n){return n instanceof Error?n.stack||n.message:n},e.disable=function(){e.enable("")},e.enable=function(n){e.save(n),e.names=[],e.skips=[];for(var t=("string"==typeof n?n:"").split(/[\s,]+/),r=t.length,a=0;a<r;a++)t[a]&&("-"===(n=t[a].replace(/\*/g,".*?"))[0]?e.skips.push(new RegExp("^"+n.substr(1)+"$")):e.names.push(new RegExp("^"+n+"$")))},e.enabled=function(n){var t,r;for(t=0,r=e.skips.length;t<r;t++)if(e.skips[t].test(n))return!1;for(t=0,r=e.names.length;t<r;t++)if(e.names[t].test(n))return!0;return!1},e.humanize=t(492),e.names=[],e.skips=[],e.formatters={}},function(n,e){var t=1e3,r=6e4,a=60*r,i=24*a;function o(n,e,t){if(!(n<e))return n<1.5*e?Math.floor(n/e)+" "+t:Math.ceil(n/e)+" "+t+"s"}n.exports=function(n,e){e=e||{};var s,l=typeof n;if("string"===l&&n.length>0)return function(n){if((n=String(n)).length>100)return;var e=/^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(n);if(!e)return;var o=parseFloat(e[1]);switch((e[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*o;case"days":case"day":case"d":return o*i;case"hours":case"hour":case"hrs":case"hr":case"h":return o*a;case"minutes":case"minute":case"mins":case"min":case"m":return o*r;case"seconds":case"second":case"secs":case"sec":case"s":return o*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return o;default:return}}(n);if("number"===l&&!1===isNaN(n))return e.long?o(s=n,i,"day")||o(s,a,"hour")||o(s,r,"minute")||o(s,t,"second")||s+" ms":function(n){if(n>=i)return Math.round(n/i)+"d";if(n>=a)return Math.round(n/a)+"h";if(n>=r)return Math.round(n/r)+"m";if(n>=t)return Math.round(n/t)+"s";return n+"ms"}(n);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(n))}},function(n,e,t){"use strict";t(259)},function(n,e,t){},function(n,e,t){"use strict";t(260)},function(n,e,t){n.exports=function(n){var e={};function t(r){if(e[r])return e[r].exports;var a=e[r]={i:r,l:!1,exports:{}};return n[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}return t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:r})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)t.d(r,a,function(e){return n[e]}.bind(null,a));return r},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s="fb15")}({"01f9":function(n,e,t){"use strict";var r=t("2d00"),a=t("5ca1"),i=t("2aba"),o=t("32e9"),s=t("84f2"),l=t("41a0"),c=t("7f20"),u=t("38fd"),d=t("2b4c")("iterator"),p=!([].keys&&"next"in[].keys()),h=function(){return this};n.exports=function(n,e,t,f,v,m,g){l(t,e,f);var y,b,w,k=function(n){if(!p&&n in _)return _[n];switch(n){case"keys":case"values":return function(){return new t(this,n)}}return function(){return new t(this,n)}},x=e+" Iterator",E="values"==v,A=!1,_=n.prototype,S=_[d]||_["@@iterator"]||v&&_[v],C=S||k(v),T=v?E?k("entries"):C:void 0,O="Array"==e&&_.entries||S;if(O&&(w=u(O.call(new n)))!==Object.prototype&&w.next&&(c(w,x,!0),r||"function"==typeof w[d]||o(w,d,h)),E&&S&&"values"!==S.name&&(A=!0,C=function(){return S.call(this)}),r&&!g||!p&&!A&&_[d]||o(_,d,C),s[e]=C,s[x]=h,v)if(y={values:E?C:k("values"),keys:m?C:k("keys"),entries:T},g)for(b in y)b in _||i(_,b,y[b]);else a(a.P+a.F*(p||A),e,y);return y}},"0a49":function(n,e,t){var r=t("9b43"),a=t("626a"),i=t("4bf8"),o=t("9def"),s=t("cd1c");n.exports=function(n,e){var t=1==n,l=2==n,c=3==n,u=4==n,d=6==n,p=5==n||d,h=e||s;return function(e,s,f){for(var v,m,g=i(e),y=a(g),b=r(s,f,3),w=o(y.length),k=0,x=t?h(e,w):l?h(e,0):void 0;w>k;k++)if((p||k in y)&&(m=b(v=y[k],k,g),n))if(t)x[k]=m;else if(m)switch(n){case 3:return!0;case 5:return v;case 6:return k;case 2:x.push(v)}else if(u)return!1;return d?-1:c||u?u:x}}},"0bfb":function(n,e,t){"use strict";var r=t("cb7c");n.exports=function(){var n=r(this),e="";return n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},"0d58":function(n,e,t){var r=t("ce10"),a=t("e11e");n.exports=Object.keys||function(n){return r(n,a)}},1169:function(n,e,t){var r=t("2d95");n.exports=Array.isArray||function(n){return"Array"==r(n)}},"11e9":function(n,e,t){var r=t("52a7"),a=t("4630"),i=t("6821"),o=t("6a99"),s=t("69a8"),l=t("c69a"),c=Object.getOwnPropertyDescriptor;e.f=t("9e1e")?c:function(n,e){if(n=i(n),e=o(e,!0),l)try{return c(n,e)}catch(n){}if(s(n,e))return a(!r.f.call(n,e),n[e])}},1495:function(n,e,t){var r=t("86cc"),a=t("cb7c"),i=t("0d58");n.exports=t("9e1e")?Object.defineProperties:function(n,e){a(n);for(var t,o=i(e),s=o.length,l=0;s>l;)r.f(n,t=o[l++],e[t]);return n}},1991:function(n,e,t){var r,a,i,o=t("9b43"),s=t("31f4"),l=t("fab2"),c=t("230e"),u=t("7726"),d=u.process,p=u.setImmediate,h=u.clearImmediate,f=u.MessageChannel,v=u.Dispatch,m=0,g={},y=function(){var n=+this;if(g.hasOwnProperty(n)){var e=g[n];delete g[n],e()}},b=function(n){y.call(n.data)};p&&h||(p=function(n){for(var e=[],t=1;arguments.length>t;)e.push(arguments[t++]);return g[++m]=function(){s("function"==typeof n?n:Function(n),e)},r(m),m},h=function(n){delete g[n]},"process"==t("2d95")(d)?r=function(n){d.nextTick(o(y,n,1))}:v&&v.now?r=function(n){v.now(o(y,n,1))}:f?(i=(a=new f).port2,a.port1.onmessage=b,r=o(i.postMessage,i,1)):u.addEventListener&&"function"==typeof postMessage&&!u.importScripts?(r=function(n){u.postMessage(n+"","*")},u.addEventListener("message",b,!1)):r="onreadystatechange"in c("script")?function(n){l.appendChild(c("script")).onreadystatechange=function(){l.removeChild(this),y.call(n)}}:function(n){setTimeout(o(y,n,1),0)}),n.exports={set:p,clear:h}},"1fa8":function(n,e,t){var r=t("cb7c");n.exports=function(n,e,t,a){try{return a?e(r(t)[0],t[1]):e(t)}catch(e){var i=n.return;throw void 0!==i&&r(i.call(n)),e}}},"20d6":function(n,e,t){"use strict";var r=t("5ca1"),a=t("0a49")(6),i="findIndex",o=!0;i in[]&&Array(1)[i]((function(){o=!1})),r(r.P+r.F*o,"Array",{findIndex:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}}),t("9c6c")(i)},"214f":function(n,e,t){"use strict";var r=t("32e9"),a=t("2aba"),i=t("79e5"),o=t("be13"),s=t("2b4c");n.exports=function(n,e,t){var l=s(n),c=t(o,l,""[n]),u=c[0],d=c[1];i((function(){var e={};return e[l]=function(){return 7},7!=""[n](e)}))&&(a(String.prototype,n,u),r(RegExp.prototype,l,2==e?function(n,e){return d.call(n,this,e)}:function(n){return d.call(n,this)}))}},"230e":function(n,e,t){var r=t("d3f4"),a=t("7726").document,i=r(a)&&r(a.createElement);n.exports=function(n){return i?a.createElement(n):{}}},2350:function(n,e){n.exports=function(n){var e=[];return e.toString=function(){return this.map((function(e){var t=function(n,e){var t=n[1]||"",r=n[3];if(!r)return t;if(e&&"function"==typeof btoa){var a=(o=r,"/*# sourceMappingURL=data:application/json;charset=utf-8;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(o))))+" */"),i=r.sources.map((function(n){return"/*# sourceURL="+r.sourceRoot+n+" */"}));return[t].concat(i).concat([a]).join("\n")}var o;return[t].join("\n")}(e,n);return e[2]?"@media "+e[2]+"{"+t+"}":t})).join("")},e.i=function(n,t){"string"==typeof n&&(n=[[null,n,""]]);for(var r={},a=0;a<this.length;a++){var i=this[a][0];"number"==typeof i&&(r[i]=!0)}for(a=0;a<n.length;a++){var o=n[a];"number"==typeof o[0]&&r[o[0]]||(t&&!o[2]?o[2]=t:t&&(o[2]="("+o[2]+") and ("+t+")"),e.push(o))}},e}},"23c6":function(n,e,t){var r=t("2d95"),a=t("2b4c")("toStringTag"),i="Arguments"==r(function(){return arguments}());n.exports=function(n){var e,t,o;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=Object(n),a))?t:i?r(e):"Object"==(o=r(e))&&"function"==typeof e.callee?"Arguments":o}},2621:function(n,e){e.f=Object.getOwnPropertySymbols},"27ee":function(n,e,t){var r=t("23c6"),a=t("2b4c")("iterator"),i=t("84f2");n.exports=t("8378").getIteratorMethod=function(n){if(null!=n)return n[a]||n["@@iterator"]||i[r(n)]}},"28a5":function(n,e,t){t("214f")("split",2,(function(n,e,r){"use strict";var a=t("aae3"),i=r,o=[].push,s="length";if("c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1)[s]||2!="ab".split(/(?:ab)*/)[s]||4!=".".split(/(.?)(.?)/)[s]||".".split(/()()/)[s]>1||"".split(/.?/)[s]){var l=void 0===/()??/.exec("")[1];r=function(n,e){var t=String(this);if(void 0===n&&0===e)return[];if(!a(n))return i.call(t,n,e);var r,c,u,d,p,h=[],f=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),v=0,m=void 0===e?4294967295:e>>>0,g=new RegExp(n.source,f+"g");for(l||(r=new RegExp("^"+g.source+"$(?!\\s)",f));(c=g.exec(t))&&!((u=c.index+c[0][s])>v&&(h.push(t.slice(v,c.index)),!l&&c[s]>1&&c[0].replace(r,(function(){for(p=1;p<arguments[s]-2;p++)void 0===arguments[p]&&(c[p]=void 0)})),c[s]>1&&c.index<t[s]&&o.apply(h,c.slice(1)),d=c[0][s],v=u,h[s]>=m));)g.lastIndex===c.index&&g.lastIndex++;return v===t[s]?!d&&g.test("")||h.push(""):h.push(t.slice(v)),h[s]>m?h.slice(0,m):h}}else"0".split(void 0,0)[s]&&(r=function(n,e){return void 0===n&&0===e?[]:i.call(this,n,e)});return[function(t,a){var i=n(this),o=null==t?void 0:t[e];return void 0!==o?o.call(t,i,a):r.call(String(i),t,a)},r]}))},"2aba":function(n,e,t){var r=t("7726"),a=t("32e9"),i=t("69a8"),o=t("ca5a")("src"),s=Function.toString,l=(""+s).split("toString");t("8378").inspectSource=function(n){return s.call(n)},(n.exports=function(n,e,t,s){var c="function"==typeof t;c&&(i(t,"name")||a(t,"name",e)),n[e]!==t&&(c&&(i(t,o)||a(t,o,n[e]?""+n[e]:l.join(String(e)))),n===r?n[e]=t:s?n[e]?n[e]=t:a(n,e,t):(delete n[e],a(n,e,t)))})(Function.prototype,"toString",(function(){return"function"==typeof this&&this[o]||s.call(this)}))},"2aeb":function(n,e,t){var r=t("cb7c"),a=t("1495"),i=t("e11e"),o=t("613b")("IE_PROTO"),s=function(){},l=function(){var n,e=t("230e")("iframe"),r=i.length;for(e.style.display="none",t("fab2").appendChild(e),e.src="javascript:",(n=e.contentWindow.document).open(),n.write("<script>document.F=Object<\/script>"),n.close(),l=n.F;r--;)delete l.prototype[i[r]];return l()};n.exports=Object.create||function(n,e){var t;return null!==n?(s.prototype=r(n),t=new s,s.prototype=null,t[o]=n):t=l(),void 0===e?t:a(t,e)}},"2b4c":function(n,e,t){var r=t("5537")("wks"),a=t("ca5a"),i=t("7726").Symbol,o="function"==typeof i;(n.exports=function(n){return r[n]||(r[n]=o&&i[n]||(o?i:a)("Symbol."+n))}).store=r},"2d00":function(n,e){n.exports=!1},"2d95":function(n,e){var t={}.toString;n.exports=function(n){return t.call(n).slice(8,-1)}},"2e08":function(n,e,t){var r=t("9def"),a=t("9744"),i=t("be13");n.exports=function(n,e,t,o){var s=String(i(n)),l=s.length,c=void 0===t?" ":String(t),u=r(e);if(u<=l||""==c)return s;var d=u-l,p=a.call(c,Math.ceil(d/c.length));return p.length>d&&(p=p.slice(0,d)),o?p+s:s+p}},"2f21":function(n,e,t){"use strict";var r=t("79e5");n.exports=function(n,e){return!!n&&r((function(){e?n.call(null,(function(){}),1):n.call(null)}))}},"2fdb":function(n,e,t){"use strict";var r=t("5ca1"),a=t("d2c8");r(r.P+r.F*t("5147")("includes"),"String",{includes:function(n){return!!~a(this,n,"includes").indexOf(n,arguments.length>1?arguments[1]:void 0)}})},"31f4":function(n,e){n.exports=function(n,e,t){var r=void 0===t;switch(e.length){case 0:return r?n():n.call(t);case 1:return r?n(e[0]):n.call(t,e[0]);case 2:return r?n(e[0],e[1]):n.call(t,e[0],e[1]);case 3:return r?n(e[0],e[1],e[2]):n.call(t,e[0],e[1],e[2]);case 4:return r?n(e[0],e[1],e[2],e[3]):n.call(t,e[0],e[1],e[2],e[3])}return n.apply(t,e)}},"32e9":function(n,e,t){var r=t("86cc"),a=t("4630");n.exports=t("9e1e")?function(n,e,t){return r.f(n,e,a(1,t))}:function(n,e,t){return n[e]=t,n}},"33a4":function(n,e,t){var r=t("84f2"),a=t("2b4c")("iterator"),i=Array.prototype;n.exports=function(n){return void 0!==n&&(r.Array===n||i[a]===n)}},"37e7":function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32"}},[t("path",{attrs:{d:"M25.468 6.947a1.004 1.004 0 0 0-1.03.057L18 11.384V7.831a1.001 1.001 0 0 0-1.562-.827l-12 8.164a1 1 0 0 0 0 1.654l12 8.168A.999.999 0 0 0 18 24.164v-3.556l6.438 4.382A.999.999 0 0 0 26 24.164V7.831c0-.371-.205-.71-.532-.884z"}})])}}},3846:function(n,e,t){t("9e1e")&&"g"!=/./g.flags&&t("86cc").f(RegExp.prototype,"flags",{configurable:!0,get:t("0bfb")})},"386b":function(n,e,t){var r=t("5ca1"),a=t("79e5"),i=t("be13"),o=/"/g,s=function(n,e,t,r){var a=String(i(n)),s="<"+e;return""!==t&&(s+=" "+t+'="'+String(r).replace(o,"&quot;")+'"'),s+">"+a+"</"+e+">"};n.exports=function(n,e){var t={};t[n]=e(s),r(r.P+r.F*a((function(){var e=""[n]('"');return e!==e.toLowerCase()||e.split('"').length>3})),"String",t)}},"38fd":function(n,e,t){var r=t("69a8"),a=t("4bf8"),i=t("613b")("IE_PROTO"),o=Object.prototype;n.exports=Object.getPrototypeOf||function(n){return n=a(n),r(n,i)?n[i]:"function"==typeof n.constructor&&n instanceof n.constructor?n.constructor.prototype:n instanceof Object?o:null}},"41a0":function(n,e,t){"use strict";var r=t("2aeb"),a=t("4630"),i=t("7f20"),o={};t("32e9")(o,t("2b4c")("iterator"),(function(){return this})),n.exports=function(n,e,t){n.prototype=r(o,{next:a(1,t)}),i(n,e+" Iterator")}},"456d":function(n,e,t){var r=t("4bf8"),a=t("0d58");t("5eda")("keys",(function(){return function(n){return a(r(n))}}))},4588:function(n,e){var t=Math.ceil,r=Math.floor;n.exports=function(n){return isNaN(n=+n)?0:(n>0?r:t)(n)}},4630:function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},4713:function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32"}},[t("path",{attrs:{d:"M26.667 5.333H5.334h-.001a2.667 2.667 0 0 0-2.666 2.666V24.001a2.667 2.667 0 0 0 2.666 2.666h21.335a2.667 2.667 0 0 0 2.666-2.666V8v-.001a2.667 2.667 0 0 0-2.666-2.666h-.001zM5.333 16h5.333v2.667H5.333V16zm13.334 8H5.334v-2.667h13.333V24zm8 0h-5.333v-2.667h5.333V24zm0-5.333H13.334V16h13.333v2.667z"}})])}}},"475a":function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32"}},[t("path",{attrs:{d:"M.622 18.334h19.54v7.55l11.052-9.412-11.052-9.413v7.549H.622v3.725z"}})])}}},"48d3":function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0}),function(n){for(var t in n)e.hasOwnProperty(t)||(e[t]=n[t])}(t("b349"));var r=t("66a1");e.modifiers=r.modifiers},4917:function(n,e,t){t("214f")("match",1,(function(n,e,t){return[function(t){"use strict";var r=n(this),a=null==t?void 0:t[e];return void 0!==a?a.call(t,r):new RegExp(t)[e](String(r))},t]}))},"499e":function(n,e,t){"use strict";function r(n,e){for(var t=[],r={},a=0;a<e.length;a++){var i=e[a],o=i[0],s={id:n+":"+a,css:i[1],media:i[2],sourceMap:i[3]};r[o]?r[o].parts.push(s):t.push(r[o]={id:o,parts:[s]})}return t}t.r(e),t.d(e,"default",(function(){return h}));var a="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!a)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var i={},o=a&&(document.head||document.getElementsByTagName("head")[0]),s=null,l=0,c=!1,u=function(){},d=null,p="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function h(n,e,t,a){c=t,d=a||{};var o=r(n,e);return f(o),function(e){for(var t=[],a=0;a<o.length;a++){var s=o[a];(l=i[s.id]).refs--,t.push(l)}e?f(o=r(n,e)):o=[];for(a=0;a<t.length;a++){var l;if(0===(l=t[a]).refs){for(var c=0;c<l.parts.length;c++)l.parts[c]();delete i[l.id]}}}}function f(n){for(var e=0;e<n.length;e++){var t=n[e],r=i[t.id];if(r){r.refs++;for(var a=0;a<r.parts.length;a++)r.parts[a](t.parts[a]);for(;a<t.parts.length;a++)r.parts.push(m(t.parts[a]));r.parts.length>t.parts.length&&(r.parts.length=t.parts.length)}else{var o=[];for(a=0;a<t.parts.length;a++)o.push(m(t.parts[a]));i[t.id]={id:t.id,refs:1,parts:o}}}}function v(){var n=document.createElement("style");return n.type="text/css",o.appendChild(n),n}function m(n){var e,t,r=document.querySelector('style[data-vue-ssr-id~="'+n.id+'"]');if(r){if(c)return u;r.parentNode.removeChild(r)}if(p){var a=l++;r=s||(s=v()),e=b.bind(null,r,a,!1),t=b.bind(null,r,a,!0)}else r=v(),e=w.bind(null,r),t=function(){r.parentNode.removeChild(r)};return e(n),function(r){if(r){if(r.css===n.css&&r.media===n.media&&r.sourceMap===n.sourceMap)return;e(n=r)}else t()}}var g,y=(g=[],function(n,e){return g[n]=e,g.filter(Boolean).join("\n")});function b(n,e,t,r){var a=t?"":r.css;if(n.styleSheet)n.styleSheet.cssText=y(e,a);else{var i=document.createTextNode(a),o=n.childNodes;o[e]&&n.removeChild(o[e]),o.length?n.insertBefore(i,o[e]):n.appendChild(i)}}function w(n,e){var t=e.css,r=e.media,a=e.sourceMap;if(r&&n.setAttribute("media",r),d.ssrId&&n.setAttribute("data-vue-ssr-id",e.id),a&&(t+="\n/*# sourceURL="+a.sources[0]+" */",t+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(a))))+" */"),n.styleSheet)n.styleSheet.cssText=t;else{for(;n.firstChild;)n.removeChild(n.firstChild);n.appendChild(document.createTextNode(t))}}},"4a59":function(n,e,t){var r=t("9b43"),a=t("1fa8"),i=t("33a4"),o=t("cb7c"),s=t("9def"),l=t("27ee"),c={},u={};(e=n.exports=function(n,e,t,d,p){var h,f,v,m,g=p?function(){return n}:l(n),y=r(t,d,e?2:1),b=0;if("function"!=typeof g)throw TypeError(n+" is not iterable!");if(i(g)){for(h=s(n.length);h>b;b++)if((m=e?y(o(f=n[b])[0],f[1]):y(n[b]))===c||m===u)return m}else for(v=g.call(n);!(f=v.next()).done;)if((m=a(v,y,f.value,e))===c||m===u)return m}).BREAK=c,e.RETURN=u},"4b41":function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 28 32"}},[t("path",{attrs:{d:"M13.728 6.272v19.456q0 .448-.352.8t-.8.32-.8-.32l-5.952-5.952H1.152q-.48 0-.8-.352t-.352-.8v-6.848q0-.48.352-.8t.8-.352h4.672l5.952-5.952q.32-.32.8-.32t.8.32.352.8zM20.576 16q0 1.344-.768 2.528t-2.016 1.664q-.16.096-.448.096-.448 0-.8-.32t-.32-.832q0-.384.192-.64t.544-.448.608-.384.512-.64.192-1.024-.192-1.024-.512-.64-.608-.384-.544-.448-.192-.64q0-.48.32-.832t.8-.32q.288 0 .448.096 1.248.48 2.016 1.664T20.576 16zm4.576 0q0 2.72-1.536 5.056t-4 3.36q-.256.096-.448.096-.48 0-.832-.352t-.32-.8q0-.704.672-1.056 1.024-.512 1.376-.8 1.312-.96 2.048-2.4T22.848 16t-.736-3.104-2.048-2.4q-.352-.288-1.376-.8-.672-.352-.672-1.056 0-.448.32-.8t.8-.352q.224 0 .48.096 2.496 1.056 4 3.36T25.152 16zm4.576 0q0 4.096-2.272 7.552t-6.048 5.056q-.224.096-.448.096-.48 0-.832-.352t-.32-.8q0-.64.704-1.056l.384-.192q.256-.128.416-.192.8-.448 1.44-.896 2.208-1.632 3.456-4.064T27.424 16t-1.216-5.152-3.456-4.064q-.64-.448-1.44-.896-.128-.096-.416-.192t-.384-.192q-.704-.416-.704-1.056 0-.448.32-.8t.832-.352q.224 0 .448.096 3.776 1.632 6.048 5.056T29.728 16z"}})])}}},"4bf8":function(n,e,t){var r=t("be13");n.exports=function(n){return Object(r(n))}},"4d26":function(n,e,t){var r;
/*!
  Copyright (c) 2017 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/!function(){"use strict";var t={}.hasOwnProperty;function a(){for(var n=[],e=0;e<arguments.length;e++){var r=arguments[e];if(r){var i=typeof r;if("string"===i||"number"===i)n.push(r);else if(Array.isArray(r)&&r.length){var o=a.apply(null,r);o&&n.push(o)}else if("object"===i)for(var s in r)t.call(r,s)&&r[s]&&n.push(s)}}return n.join(" ")}n.exports?(a.default=a,n.exports=a):void 0===(r=function(){return a}.apply(e,[]))||(n.exports=r)}()},5147:function(n,e,t){var r=t("2b4c")("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[r]=!1,!"/./"[n](e)}catch(n){}}return!0}},"52a7":function(n,e){e.f={}.propertyIsEnumerable},"52f0":function(n,e,t){var r={"./loading.svg":"885d","./loop-all.svg":"f866","./loop-none.svg":"c3ab","./loop-one.svg":"5527","./lrc.svg":"4713","./menu.svg":"906b","./order-list.svg":"475a","./order-random.svg":"7a1a","./pause.svg":"daf8","./play.svg":"84d8","./right.svg":"bf5c","./skip.svg":"37e7","./volume-down.svg":"bdba","./volume-off.svg":"adec","./volume-up.svg":"4b41"};function a(n){var e=i(n);return t(e)}function i(n){var e=r[n];if(!(e+1)){var t=new Error("Cannot find module '"+n+"'");throw t.code="MODULE_NOT_FOUND",t}return e}a.keys=function(){return Object.keys(r)},a.resolve=i,n.exports=a,a.id="52f0"},"551c":function(n,e,t){"use strict";var r,a,i,o,s=t("2d00"),l=t("7726"),c=t("9b43"),u=t("23c6"),d=t("5ca1"),p=t("d3f4"),h=t("d8e8"),f=t("f605"),v=t("4a59"),m=t("ebd6"),g=t("1991").set,y=t("8079")(),b=t("a5b8"),w=t("9c80"),k=t("a25f"),x=t("bcaa"),E=l.TypeError,A=l.process,_=A&&A.versions,S=_&&_.v8||"",C=l.Promise,T="process"==u(A),O=function(){},j=a=b.f,B=!!function(){try{var n=C.resolve(1),e=(n.constructor={})[t("2b4c")("species")]=function(n){n(O,O)};return(T||"function"==typeof PromiseRejectionEvent)&&n.then(O)instanceof e&&0!==S.indexOf("6.6")&&-1===k.indexOf("Chrome/66")}catch(n){}}(),I=function(n){var e;return!(!p(n)||"function"!=typeof(e=n.then))&&e},L=function(n,e){if(!n._n){n._n=!0;var t=n._c;y((function(){for(var r=n._v,a=1==n._s,i=0,o=function(e){var t,i,o,s=a?e.ok:e.fail,l=e.resolve,c=e.reject,u=e.domain;try{s?(a||(2==n._h&&q(n),n._h=1),!0===s?t=r:(u&&u.enter(),t=s(r),u&&(u.exit(),o=!0)),t===e.promise?c(E("Promise-chain cycle")):(i=I(t))?i.call(t,l,c):l(t)):c(r)}catch(n){u&&!o&&u.exit(),c(n)}};t.length>i;)o(t[i++]);n._c=[],n._n=!1,e&&!n._h&&N(n)}))}},N=function(n){g.call(l,(function(){var e,t,r,a=n._v,i=P(n);if(i&&(e=w((function(){T?A.emit("unhandledRejection",a,n):(t=l.onunhandledrejection)?t({promise:n,reason:a}):(r=l.console)&&r.error&&r.error("Unhandled promise rejection",a)})),n._h=T||P(n)?2:1),n._a=void 0,i&&e.e)throw e.v}))},P=function(n){return 1!==n._h&&0===(n._a||n._c).length},q=function(n){g.call(l,(function(){var e;T?A.emit("rejectionHandled",n):(e=l.onrejectionhandled)&&e({promise:n,reason:n._v})}))},R=function(n){var e=this;e._d||(e._d=!0,(e=e._w||e)._v=n,e._s=2,e._a||(e._a=e._c.slice()),L(e,!0))},F=function(n){var e,t=this;if(!t._d){t._d=!0,t=t._w||t;try{if(t===n)throw E("Promise can't be resolved itself");(e=I(n))?y((function(){var r={_w:t,_d:!1};try{e.call(n,c(F,r,1),c(R,r,1))}catch(n){R.call(r,n)}})):(t._v=n,t._s=1,L(t,!1))}catch(n){R.call({_w:t,_d:!1},n)}}};B||(C=function(n){f(this,C,"Promise","_h"),h(n),r.call(this);try{n(c(F,this,1),c(R,this,1))}catch(n){R.call(this,n)}},(r=function(n){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1}).prototype=t("dcbc")(C.prototype,{then:function(n,e){var t=j(m(this,C));return t.ok="function"!=typeof n||n,t.fail="function"==typeof e&&e,t.domain=T?A.domain:void 0,this._c.push(t),this._a&&this._a.push(t),this._s&&L(this,!1),t.promise},catch:function(n){return this.then(void 0,n)}}),i=function(){var n=new r;this.promise=n,this.resolve=c(F,n,1),this.reject=c(R,n,1)},b.f=j=function(n){return n===C||n===o?new i(n):a(n)}),d(d.G+d.W+d.F*!B,{Promise:C}),t("7f20")(C,"Promise"),t("7a56")("Promise"),o=t("8378").Promise,d(d.S+d.F*!B,"Promise",{reject:function(n){var e=j(this);return(0,e.reject)(n),e.promise}}),d(d.S+d.F*(s||!B),"Promise",{resolve:function(n){return x(s&&this===o?C:this,n)}}),d(d.S+d.F*!(B&&t("5cc5")((function(n){C.all(n).catch(O)}))),"Promise",{all:function(n){var e=this,t=j(e),r=t.resolve,a=t.reject,i=w((function(){var t=[],i=0,o=1;v(n,!1,(function(n){var s=i++,l=!1;t.push(void 0),o++,e.resolve(n).then((function(n){l||(l=!0,t[s]=n,--o||r(t))}),a)})),--o||r(t)}));return i.e&&a(i.v),t.promise},race:function(n){var e=this,t=j(e),r=t.reject,a=w((function(){v(n,!1,(function(n){e.resolve(n).then(t.resolve,r)}))}));return a.e&&r(a.v),t.promise}})},5527:function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 33 32"}},[t("path",{attrs:{d:"M9.333 9.333h13.333v4L27.999 8l-5.333-5.333v4h-16v8h2.667V9.334zm13.334 13.334H9.334v-4L4.001 24l5.333 5.333v-4h16v-8h-2.667v5.333zM17.333 20v-8H16l-2.667 1.333v1.333h2v5.333h2z"}})])}}},5537:function(n,e,t){var r=t("8378"),a=t("7726"),i=a["__core-js_shared__"]||(a["__core-js_shared__"]={});(n.exports=function(n,e){return i[n]||(i[n]=void 0!==e?e:{})})("versions",[]).push({version:r.version,mode:t("2d00")?"pure":"global",copyright:"© 2018 Denis Pushkarev (zloirock.ru)"})},"55dd":function(n,e,t){"use strict";var r=t("5ca1"),a=t("d8e8"),i=t("4bf8"),o=t("79e5"),s=[].sort,l=[1,2,3];r(r.P+r.F*(o((function(){l.sort(void 0)}))||!o((function(){l.sort(null)}))||!t("2f21")(s)),"Array",{sort:function(n){return void 0===n?s.call(i(this)):s.call(i(this),a(n))}})},"5ca1":function(n,e,t){var r=t("7726"),a=t("8378"),i=t("32e9"),o=t("2aba"),s=t("9b43"),l=function(n,e,t){var c,u,d,p,h=n&l.F,f=n&l.G,v=n&l.S,m=n&l.P,g=n&l.B,y=f?r:v?r[e]||(r[e]={}):(r[e]||{}).prototype,b=f?a:a[e]||(a[e]={}),w=b.prototype||(b.prototype={});for(c in f&&(t=e),t)d=((u=!h&&y&&void 0!==y[c])?y:t)[c],p=g&&u?s(d,r):m&&"function"==typeof d?s(Function.call,d):d,y&&o(y,c,d,n&l.U),b[c]!=d&&i(b,c,p),m&&w[c]!=d&&(w[c]=d)};r.core=a,l.F=1,l.G=2,l.S=4,l.P=8,l.B=16,l.W=32,l.U=64,l.R=128,n.exports=l},"5cc5":function(n,e,t){var r=t("2b4c")("iterator"),a=!1;try{var i=[7][r]();i.return=function(){a=!0},Array.from(i,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!a)return!1;var t=!1;try{var i=[7],o=i[r]();o.next=function(){return{done:t=!0}},i[r]=function(){return o},n(i)}catch(n){}return t}},"5dbc":function(n,e,t){var r=t("d3f4"),a=t("8b97").set;n.exports=function(n,e,t){var i,o=e.constructor;return o!==t&&"function"==typeof o&&(i=o.prototype)!==t.prototype&&r(i)&&a&&a(n,i),n}},"5eda":function(n,e,t){var r=t("5ca1"),a=t("8378"),i=t("79e5");n.exports=function(n,e){var t=(a.Object||{})[n]||Object[n],o={};o[n]=e(t),r(r.S+r.F*i((function(){t(1)})),"Object",o)}},"610a":function(n,e,t){var r=t("ab57");"string"==typeof r&&(r=[[n.i,r,""]]),r.locals&&(n.exports=r.locals);(0,t("499e").default)("4573c8b0",r,!0,{sourceMap:!1,shadowMode:!1})},"613b":function(n,e,t){var r=t("5537")("keys"),a=t("ca5a");n.exports=function(n){return r[n]||(r[n]=a(n))}},"626a":function(n,e,t){var r=t("2d95");n.exports=Object("z").propertyIsEnumerable(0)?Object:function(n){return"String"==r(n)?n.split(""):Object(n)}},"65d9":function(n,e,t){"use strict";
/**
  * vue-class-component v6.3.2
  * (c) 2015-present Evan You
  * @license MIT
  */Object.defineProperty(e,"__esModule",{value:!0});var r,a=(r=t("8bbf"))&&"object"==typeof r&&"default"in r?r.default:r,i="undefined"!=typeof Reflect&&Reflect.defineMetadata;function o(n,e,t){(t?Reflect.getOwnMetadataKeys(e,t):Reflect.getOwnMetadataKeys(e)).forEach((function(r){var a=t?Reflect.getOwnMetadata(r,e,t):Reflect.getOwnMetadata(r,e);t?Reflect.defineMetadata(r,a,n,t):Reflect.defineMetadata(r,a,n)}))}var s={__proto__:[]}instanceof Array;var l=["data","beforeCreate","created","beforeMount","mounted","beforeDestroy","destroyed","beforeUpdate","updated","activated","deactivated","render","errorCaptured"];function c(n,e){void 0===e&&(e={}),e.name=e.name||n._componentTag||n.name;var t=n.prototype;Object.getOwnPropertyNames(t).forEach((function(n){if("constructor"!==n)if(l.indexOf(n)>-1)e[n]=t[n];else{var r=Object.getOwnPropertyDescriptor(t,n);void 0!==r.value?"function"==typeof r.value?(e.methods||(e.methods={}))[n]=r.value:(e.mixins||(e.mixins=[])).push({data:function(){var e;return(e={})[n]=r.value,e}}):(r.get||r.set)&&((e.computed||(e.computed={}))[n]={get:r.get,set:r.set})}})),(e.mixins||(e.mixins=[])).push({data:function(){return function(n,e){var t=e.prototype._init;e.prototype._init=function(){var e=this,t=Object.getOwnPropertyNames(n);if(n.$options.props)for(var r in n.$options.props)n.hasOwnProperty(r)||t.push(r);t.forEach((function(t){"_"!==t.charAt(0)&&Object.defineProperty(e,t,{get:function(){return n[t]},set:function(e){n[t]=e},configurable:!0})}))};var r=new e;e.prototype._init=t;var a={};return Object.keys(r).forEach((function(n){void 0!==r[n]&&(a[n]=r[n])})),a}(this,n)}});var r=n.__decorators__;r&&(r.forEach((function(n){return n(e)})),delete n.__decorators__);var c,u,d=Object.getPrototypeOf(n.prototype),p=d instanceof a?d.constructor:a,h=p.extend(e);return function(n,e,t){Object.getOwnPropertyNames(e).forEach((function(r){if("prototype"!==r){var a=Object.getOwnPropertyDescriptor(n,r);if(!a||a.configurable){var i,o,l=Object.getOwnPropertyDescriptor(e,r);if(!s){if("cid"===r)return;var c=Object.getOwnPropertyDescriptor(t,r);if(i=l.value,o=typeof i,null!=i&&("object"===o||"function"===o)&&c&&c.value===l.value)return}0,Object.defineProperty(n,r,l)}}}))}(h,n,p),i&&(o(c=h,u=n),Object.getOwnPropertyNames(u.prototype).forEach((function(n){o(c.prototype,u.prototype,n)})),Object.getOwnPropertyNames(u).forEach((function(n){o(c,u,n)}))),h}function u(n){return"function"==typeof n?c(n):function(e){return c(e,n)}}u.registerHooks=function(n){l.push.apply(l,n)},e.default=u,e.createDecorator=function(n){return function(e,t,r){var a="function"==typeof e?e:e.constructor;a.__decorators__||(a.__decorators__=[]),"number"!=typeof r&&(r=void 0),a.__decorators__.push((function(e){return n(e,t,r)}))}},e.mixins=function(){for(var n=[],e=0;e<arguments.length;e++)n[e]=arguments[e];return a.extend({mixins:n})}},"66a1":function(n,e,t){"use strict";var r=this&&this.__assign||Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++)for(var a in e=arguments[t])Object.prototype.hasOwnProperty.call(e,a)&&(n[a]=e[a]);return n};function a(n,e,t){for(var r=0,a=e;r<a.length;r++){if(!(0,a[r])(n))return}t&&t(n)}Object.defineProperty(e,"__esModule",{value:!0});var i={esc:27,tab:9,enter:13,space:32,up:38,down:40,del:[8,46],left:37,right:39};function o(n){for(var e=[],t=0,r=n;t<r.length;t++){var a=r[t];if("number"==typeof a)e.push(a);else{var o=i[a];"number"==typeof o?e.push(o):e.push.apply(e,o)}}switch(e.length){case 0:return function(n){return!1};case 1:var s=e[0];return function(n){return n.keyCode===s};default:return function(n){return e.indexOf(n.keyCode)>=0}}}function s(n,e,t,r,a){Object.defineProperty(n,t,{get:function(){var i=l(e.concat([r]),a);return Object.defineProperty(n,t,{value:i,enumerable:!0}),i},enumerable:!0,configurable:!0})}function l(n,e){function t(e){return e instanceof Function?function(t){return a(t,n,e)}:void a(e,n)}if(e.keyboard||e.mouse){var l=r({},e,{keyboard:!1,mouse:!1});e.keyboard&&(function(n,e,t){var r=function(r){var a=r;if("left"===a||"right"===a)return"continue";var o=i[a];if("number"==typeof o)s(n,e,a,(function(n){return n.keyCode===o}),t);else{var l=o[0],c=o[1];s(n,e,a,(function(n){return n.keyCode===l||n.keyCode===c}),t)}};for(var a in i)r(a)}(t,n,l),function(n,e,t){Object.defineProperty(n,"keys",{get:function(){var n=this,r=function(){for(var r=[],a=0;a<arguments.length;a++)r[a]=arguments[a];var i="keys:"+r.toString(),l=n[i];if(void 0!==l)return l;var c=o(r);return s(n,e,i,c,t),n[i]};return Object.defineProperty(this,"keys",{value:r,enumerable:!0}),r},enumerable:!0,configurable:!0})}(t,n,l)),e.mouse&&s(t,n,"middle",(function(n){return 1===n.button}),l),s(t,n,"left",(function(n){return 37===n.keyCode||0===n.button}),l),s(t,n,"right",(function(n){return 39===n.keyCode||2===n.button}),l)}if(e.exact){l=r({},e,{exact:!1,modkey:!1});!function(n,e,t){Object.defineProperty(n,"exact",{get:function(){var n=this,r=function(){for(var r=[],a=0;a<arguments.length;a++)r[a]=arguments[a];var i="exact:"+r.toString(),o=n[i];if(void 0!==o)return o;var l={ctrl:!1,shift:!1,alt:!1,meta:!1};r.forEach((function(n){return l[n]=!0}));var c=function(n){return!!n.ctrlKey===l.ctrl&&!!n.shiftKey===l.shift&&!!n.altKey===l.alt&&!!n.metaKey===l.meta};return s(n,e,i,c,t),n[i]};return Object.defineProperty(this,"exact",{value:r,enumerable:!0}),r},enumerable:!0,configurable:!0})}(t,n,l)}if(e.modkey){l=r({},e,{exact:!1});s(t,n,"ctrl",(function(n){return n.ctrlKey}),l),s(t,n,"shift",(function(n){return n.shiftKey}),l),s(t,n,"alt",(function(n){return n.altKey}),l),s(t,n,"meta",(function(n){return n.metaKey}),l),s(t,n,"noctrl",(function(n){return!n.ctrlKey}),l),s(t,n,"noshift",(function(n){return!n.shiftKey}),l),s(t,n,"noalt",(function(n){return!n.altKey}),l),s(t,n,"nometa",(function(n){return!n.metaKey}),l)}return s(t,n,"stop",(function(n){return n.stopPropagation()||!0}),e),s(t,n,"prevent",(function(n){return n.preventDefault()||!0}),e),s(t,n,"self",(function(n){return n.target===n.currentTarget}),e),t}e.modifiers=l([],{keyboard:!0,mouse:!0,modkey:!0,exact:!0})},6762:function(n,e,t){"use strict";var r=t("5ca1"),a=t("c366")(!0);r(r.P,"Array",{includes:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}}),t("9c6c")("includes")},6821:function(n,e,t){var r=t("626a"),a=t("be13");n.exports=function(n){return r(a(n))}},"69a8":function(n,e){var t={}.hasOwnProperty;n.exports=function(n,e){return t.call(n,e)}},"6a99":function(n,e,t){var r=t("d3f4");n.exports=function(n,e){if(!r(n))return n;var t,a;if(e&&"function"==typeof(t=n.toString)&&!r(a=t.call(n)))return a;if("function"==typeof(t=n.valueOf)&&!r(a=t.call(n)))return a;if(!e&&"function"==typeof(t=n.toString)&&!r(a=t.call(n)))return a;throw TypeError("Can't convert object to primitive value")}},"6b54":function(n,e,t){"use strict";t("3846");var r=t("cb7c"),a=t("0bfb"),i=t("9e1e"),o=/./.toString,s=function(n){t("2aba")(RegExp.prototype,"toString",n,!0)};t("79e5")((function(){return"/a/b"!=o.call({source:"a",flags:"b"})}))?s((function(){var n=r(this);return"/".concat(n.source,"/","flags"in n?n.flags:!i&&n instanceof RegExp?a.call(n):void 0)})):"toString"!=o.name&&s((function(){return o.call(this)}))},7333:function(n,e,t){"use strict";var r=t("0d58"),a=t("2621"),i=t("52a7"),o=t("4bf8"),s=t("626a"),l=Object.assign;n.exports=!l||t("79e5")((function(){var n={},e={},t=Symbol(),r="abcdefghijklmnopqrst";return n[t]=7,r.split("").forEach((function(n){e[n]=n})),7!=l({},n)[t]||Object.keys(l({},e)).join("")!=r}))?function(n,e){for(var t=o(n),l=arguments.length,c=1,u=a.f,d=i.f;l>c;)for(var p,h=s(arguments[c++]),f=u?r(h).concat(u(h)):r(h),v=f.length,m=0;v>m;)d.call(h,p=f[m++])&&(t[p]=h[p]);return t}:l},7514:function(n,e,t){"use strict";var r=t("5ca1"),a=t("0a49")(5),i=!0;"find"in[]&&Array(1).find((function(){i=!1})),r(r.P+r.F*i,"Array",{find:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}}),t("9c6c")("find")},7726:function(n,e){var t=n.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=t)},"77f1":function(n,e,t){var r=t("4588"),a=Math.max,i=Math.min;n.exports=function(n,e){return(n=r(n))<0?a(n+e,0):i(n,e)}},"79e5":function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},"7a1a":function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32"}},[t("path",{attrs:{d:"M22.667 4l7 6-7 6 7 6-7 6v-4h-3.653l-3.76-3.76 2.827-2.827L20.668 20h2v-8h-2l-12 12h-6v-4h4.347l12-12h3.653V4zm-20 4h6l3.76 3.76L9.6 14.587 7.013 12H2.666V8z"}})])}}},"7a56":function(n,e,t){"use strict";var r=t("7726"),a=t("86cc"),i=t("9e1e"),o=t("2b4c")("species");n.exports=function(n){var e=r[n];i&&e&&!e[o]&&a.f(e,o,{configurable:!0,get:function(){return this}})}},"7f20":function(n,e,t){var r=t("86cc").f,a=t("69a8"),i=t("2b4c")("toStringTag");n.exports=function(n,e,t){n&&!a(n=t?n:n.prototype,i)&&r(n,i,{configurable:!0,value:e})}},"7f7f":function(n,e,t){var r=t("86cc").f,a=Function.prototype,i=/^\s*function ([^ (]*)/;"name"in a||t("9e1e")&&r(a,"name",{configurable:!0,get:function(){try{return(""+this).match(i)[1]}catch(n){return""}}})},8079:function(n,e,t){var r=t("7726"),a=t("1991").set,i=r.MutationObserver||r.WebKitMutationObserver,o=r.process,s=r.Promise,l="process"==t("2d95")(o);n.exports=function(){var n,e,t,c=function(){var r,a;for(l&&(r=o.domain)&&r.exit();n;){a=n.fn,n=n.next;try{a()}catch(r){throw n?t():e=void 0,r}}e=void 0,r&&r.enter()};if(l)t=function(){o.nextTick(c)};else if(!i||r.navigator&&r.navigator.standalone)if(s&&s.resolve){var u=s.resolve(void 0);t=function(){u.then(c)}}else t=function(){a.call(r,c)};else{var d=!0,p=document.createTextNode("");new i(c).observe(p,{characterData:!0}),t=function(){p.data=d=!d}}return function(r){var a={fn:r,next:void 0};e&&(e.next=a),n||(n=a,t()),e=a}}},8378:function(n,e){var t=n.exports={version:"2.5.7"};"number"==typeof __e&&(__e=t)},"84d8":function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 16 31"}},[t("path",{attrs:{d:"M15.552 15.168q.448.32.448.832 0 .448-.448.768L1.856 25.28q-.768.512-1.312.192T0 24.192V7.744q0-.96.544-1.28t1.312.192z"}})])}}},"84f2":function(n,e){n.exports={}},"86cc":function(n,e,t){var r=t("cb7c"),a=t("c69a"),i=t("6a99"),o=Object.defineProperty;e.f=t("9e1e")?Object.defineProperty:function(n,e,t){if(r(n),e=i(e,!0),r(t),a)try{return o(n,e,t)}catch(n){}if("get"in t||"set"in t)throw TypeError("Accessors not supported!");return"value"in t&&(n[e]=t.value),n}},"885d":function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32"}},[t("path",{attrs:{d:"M4 16C4 9.4 9.4 4 16 4s12 5.4 12 12c0 1.2-.8 2-2 2s-2-.8-2-2c0-4.4-3.6-8-8-8s-8 3.6-8 8 3.6 8 8 8c1.2 0 2 .8 2 2s-.8 2-2 2C9.4 28 4 22.6 4 16z"}})])}}},"8b97":function(n,e,t){var r=t("d3f4"),a=t("cb7c"),i=function(n,e){if(a(n),!r(e)&&null!==e)throw TypeError(e+": can't set as prototype!")};n.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(n,e,r){try{(r=t("9b43")(Function.call,t("11e9").f(Object.prototype,"__proto__").set,2))(n,[]),e=!(n instanceof Array)}catch(n){e=!0}return function(n,t){return i(n,t),e?n.__proto__=t:r(n,t),n}}({},!1):void 0),check:i}},"8bbf":function(n,e){n.exports=t(2)},"906b":function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 22 32"}},[t("path",{attrs:{d:"M20.8 14.4q.704 0 1.152.48T22.4 16t-.48 1.12-1.12.48H1.6q-.64 0-1.12-.48T0 16t.448-1.12T1.6 14.4h19.2zM1.6 11.2q-.64 0-1.12-.48T0 9.6t.448-1.12T1.6 8h19.2q.704 0 1.152.48T22.4 9.6t-.48 1.12-1.12.48H1.6zm19.2 9.6q.704 0 1.152.48t.448 1.12-.48 1.12-1.12.48H1.6q-.64 0-1.12-.48T0 22.4t.448-1.12T1.6 20.8h19.2z"}})])}}},9093:function(n,e,t){var r=t("ce10"),a=t("e11e").concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},"96cf":function(n,e){!function(e){"use strict";var t=Object.prototype,r=t.hasOwnProperty,a="function"==typeof Symbol?Symbol:{},i=a.iterator||"@@iterator",o=a.asyncIterator||"@@asyncIterator",s=a.toStringTag||"@@toStringTag",l="object"==typeof n,c=e.regeneratorRuntime;if(c)l&&(n.exports=c);else{(c=e.regeneratorRuntime=l?n.exports:{}).wrap=v;var u={},d={};d[i]=function(){return this};var p=Object.getPrototypeOf,h=p&&p(p(S([])));h&&h!==t&&r.call(h,i)&&(d=h);var f=b.prototype=g.prototype=Object.create(d);y.prototype=f.constructor=b,b.constructor=y,b[s]=y.displayName="GeneratorFunction",c.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===y||"GeneratorFunction"===(e.displayName||e.name))},c.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,b):(n.__proto__=b,s in n||(n[s]="GeneratorFunction")),n.prototype=Object.create(f),n},c.awrap=function(n){return{__await:n}},w(k.prototype),k.prototype[o]=function(){return this},c.AsyncIterator=k,c.async=function(n,e,t,r){var a=new k(v(n,e,t,r));return c.isGeneratorFunction(e)?a:a.next().then((function(n){return n.done?n.value:a.next()}))},w(f),f[s]="Generator",f[i]=function(){return this},f.toString=function(){return"[object Generator]"},c.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var r=e.pop();if(r in n)return t.value=r,t.done=!1,t}return t.done=!0,t}},c.values=S,_.prototype={constructor:_,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(A),!n)for(var e in this)"t"===e.charAt(0)&&r.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function t(t,r){return o.type="throw",o.arg=n,e.next=t,r&&(e.method="next",e.arg=void 0),!!r}for(var a=this.tryEntries.length-1;a>=0;--a){var i=this.tryEntries[a],o=i.completion;if("root"===i.tryLoc)return t("end");if(i.tryLoc<=this.prev){var s=r.call(i,"catchLoc"),l=r.call(i,"finallyLoc");if(s&&l){if(this.prev<i.catchLoc)return t(i.catchLoc,!0);if(this.prev<i.finallyLoc)return t(i.finallyLoc)}else if(s){if(this.prev<i.catchLoc)return t(i.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return t(i.finallyLoc)}}}},abrupt:function(n,e){for(var t=this.tryEntries.length-1;t>=0;--t){var a=this.tryEntries[t];if(a.tryLoc<=this.prev&&r.call(a,"finallyLoc")&&this.prev<a.finallyLoc){var i=a;break}}i&&("break"===n||"continue"===n)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=n,o.arg=e,i?(this.method="next",this.next=i.finallyLoc,u):this.complete(o)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),u},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),A(t),u}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var r=t.completion;if("throw"===r.type){var a=r.arg;A(t)}return a}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:S(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),u}}}function v(n,e,t,r){var a=e&&e.prototype instanceof g?e:g,i=Object.create(a.prototype),o=new _(r||[]);return i._invoke=function(n,e,t){var r="suspendedStart";return function(a,i){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===a)throw i;return C()}for(t.method=a,t.arg=i;;){var o=t.delegate;if(o){var s=x(o,t);if(s){if(s===u)continue;return s}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===r)throw r="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);r="executing";var l=m(n,e,t);if("normal"===l.type){if(r=t.done?"completed":"suspendedYield",l.arg===u)continue;return{value:l.arg,done:t.done}}"throw"===l.type&&(r="completed",t.method="throw",t.arg=l.arg)}}}(n,t,o),i}function m(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}function g(){}function y(){}function b(){}function w(n){["next","throw","return"].forEach((function(e){n[e]=function(n){return this._invoke(e,n)}}))}function k(n){var e;this._invoke=function(t,a){function i(){return new Promise((function(e,i){!function e(t,a,i,o){var s=m(n[t],n,a);if("throw"!==s.type){var l=s.arg,c=l.value;return c&&"object"==typeof c&&r.call(c,"__await")?Promise.resolve(c.__await).then((function(n){e("next",n,i,o)}),(function(n){e("throw",n,i,o)})):Promise.resolve(c).then((function(n){l.value=n,i(l)}),o)}o(s.arg)}(t,a,e,i)}))}return e=e?e.then(i,i):i()}}function x(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,x(n,e),"throw"===e.method))return u;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return u}var r=m(t,n.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,u;var a=r.arg;return a?a.done?(e[n.resultName]=a.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,u):a:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,u)}function E(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function A(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function _(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(E,this),this.reset(!0)}function S(n){if(n){var e=n[i];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var t=-1,a=function e(){for(;++t<n.length;)if(r.call(n,t))return e.value=n[t],e.done=!1,e;return e.value=void 0,e.done=!0,e};return a.next=a}}return{next:C}}function C(){return{value:void 0,done:!0}}}(function(){return this}()||Function("return this")())},9744:function(n,e,t){"use strict";var r=t("4588"),a=t("be13");n.exports=function(n){var e=String(a(this)),t="",i=r(n);if(i<0||i==1/0)throw RangeError("Count can't be negative");for(;i>0;(i>>>=1)&&(e+=e))1&i&&(t+=e);return t}},"9b43":function(n,e,t){var r=t("d8e8");n.exports=function(n,e,t){if(r(n),void 0===e)return n;switch(t){case 1:return function(t){return n.call(e,t)};case 2:return function(t,r){return n.call(e,t,r)};case 3:return function(t,r,a){return n.call(e,t,r,a)}}return function(){return n.apply(e,arguments)}}},"9c6c":function(n,e,t){var r=t("2b4c")("unscopables"),a=Array.prototype;null==a[r]&&t("32e9")(a,r,{}),n.exports=function(n){a[r][n]=!0}},"9c80":function(n,e){n.exports=function(n){try{return{e:!1,v:n()}}catch(n){return{e:!0,v:n}}}},"9def":function(n,e,t){var r=t("4588"),a=Math.min;n.exports=function(n){return n>0?a(r(n),9007199254740991):0}},"9e1e":function(n,e,t){n.exports=!t("79e5")((function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a}))},a25f:function(n,e,t){var r=t("7726").navigator;n.exports=r&&r.userAgent||""},a481:function(n,e,t){t("214f")("replace",2,(function(n,e,t){return[function(r,a){"use strict";var i=n(this),o=null==r?void 0:r[e];return void 0!==o?o.call(r,i,a):t.call(String(i),r,a)},t]}))},a5b8:function(n,e,t){"use strict";var r=t("d8e8");function a(n){var e,t;this.promise=new n((function(n,r){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=r})),this.resolve=r(e),this.reject=r(t)}n.exports.f=function(n){return new a(n)}},aa77:function(n,e,t){var r=t("5ca1"),a=t("be13"),i=t("79e5"),o=t("fdef"),s="["+o+"]",l=RegExp("^"+s+s+"*"),c=RegExp(s+s+"*$"),u=function(n,e,t){var a={},s=i((function(){return!!o[n]()||"​"!="​"[n]()})),l=a[n]=s?e(d):o[n];t&&(a[t]=l),r(r.P+r.F*s,"String",a)},d=u.trim=function(n,e){return n=String(a(n)),1&e&&(n=n.replace(l,"")),2&e&&(n=n.replace(c,"")),n};n.exports=u},aae3:function(n,e,t){var r=t("d3f4"),a=t("2d95"),i=t("2b4c")("match");n.exports=function(n){var e;return r(n)&&(void 0!==(e=n[i])?!!e:"RegExp"==a(n))}},ab57:function(n,e,t){(n.exports=t("2350")(!1)).push([n.i,'.aplayer{background:#fff;font-family:Arial,Helvetica,sans-serif;margin:5px;-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,.07),0 1px 5px 0 rgba(0,0,0,.1);box-shadow:0 2px 2px 0 rgba(0,0,0,.07),0 1px 5px 0 rgba(0,0,0,.1);border-radius:2px;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;line-height:normal;position:relative}.aplayer *{-webkit-box-sizing:content-box;box-sizing:content-box}.aplayer svg{width:100%;height:100%}.aplayer svg circle,.aplayer svg path{fill:#fff}.aplayer.aplayer-withlist .aplayer-info{border-bottom:1px solid #e9e9e9}.aplayer.aplayer-withlist .aplayer-list{display:block;width:100%}.aplayer.aplayer-withlist .aplayer-icon-order,.aplayer.aplayer-withlist .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu{display:inline}.aplayer.aplayer-withlrc .aplayer-pic{height:90px;width:90px}.aplayer.aplayer-withlrc .aplayer-info{margin-left:90px;height:90px;padding:10px 7px 0 7px}.aplayer.aplayer-withlrc .aplayer-lrc{display:block}.aplayer.aplayer-narrow{width:66px}.aplayer.aplayer-narrow .aplayer-info,.aplayer.aplayer-narrow .aplayer-list{display:none}.aplayer.aplayer-narrow .aplayer-body,.aplayer.aplayer-narrow .aplayer-pic{height:66px;width:66px}.aplayer.aplayer-fixed{position:fixed;bottom:0;left:0;right:0;margin:0;z-index:99;overflow:visible;max-width:400px;-webkit-box-shadow:none;box-shadow:none}.aplayer.aplayer-fixed .aplayer-list{margin-bottom:65px;border:1px solid #eee;border-bottom:none;-webkit-box-sizing:border-box;box-sizing:border-box}.aplayer.aplayer-fixed .aplayer-body{position:fixed;bottom:0;left:0;right:0;margin:0;z-index:99;background:#fff;padding-right:18px;-webkit-transition:width .3s ease;transition:width .3s ease;max-width:400px;width:calc(100% - 18px)}.aplayer.aplayer-fixed .aplayer-lrc{display:block;position:fixed;bottom:10px;left:0;right:0;margin:0;z-index:98;pointer-events:none;text-shadow:-1px -1px 0 #fff}.aplayer.aplayer-fixed .aplayer-lrc:after,.aplayer.aplayer-fixed .aplayer-lrc:before{display:none}.aplayer.aplayer-fixed .aplayer-info{-webkit-transform:scaleX(1);transform:scaleX(1);-webkit-transform-origin:0 0;transform-origin:0 0;-webkit-transition:all .3s ease;transition:all .3s ease;border-bottom:none;border-top:1px solid #e9e9e9}.aplayer.aplayer-fixed .aplayer-info .aplayer-music{width:calc(100% - 105px)}.aplayer.aplayer-fixed .aplayer-miniswitcher{display:block}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-info{display:block;-webkit-transform:scaleX(0);transform:scaleX(0)}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-body{width:66px!important}.aplayer.aplayer-fixed.aplayer-narrow .aplayer-miniswitcher .aplayer-icon{-webkit-transform:rotateY(0);transform:rotateY(0)}.aplayer.aplayer-fixed .aplayer-icon-back,.aplayer.aplayer-fixed .aplayer-icon-forward,.aplayer.aplayer-fixed .aplayer-icon-lrc,.aplayer.aplayer-fixed .aplayer-icon-play{display:inline-block}.aplayer.aplayer-fixed .aplayer-icon-back,.aplayer.aplayer-fixed .aplayer-icon-forward,.aplayer.aplayer-fixed .aplayer-icon-menu,.aplayer.aplayer-fixed .aplayer-icon-play{position:absolute;bottom:27px;width:20px;height:20px}.aplayer.aplayer-fixed .aplayer-icon-back{right:75px}.aplayer.aplayer-fixed .aplayer-icon-play{right:50px}.aplayer.aplayer-fixed .aplayer-icon-forward{right:25px}.aplayer.aplayer-fixed .aplayer-icon-menu{right:0}.aplayer.aplayer-arrow .aplayer-icon-loop,.aplayer.aplayer-arrow .aplayer-icon-order,.aplayer.aplayer-mobile .aplayer-icon-volume-down,.aplayer.aplayer-mobile .aplayer-icon-volume-up{display:none}.aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-loading-icon{display:block}.aplayer.aplayer-loading .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb{-webkit-transform:scale(1);transform:scale(1)}.aplayer .aplayer-body{position:relative}.aplayer .aplayer-icon{width:15px;height:15px;border:none;background-color:transparent;outline:none;cursor:pointer;opacity:.8;vertical-align:middle;padding:0;font-size:12px;margin:0;display:inline-block}.aplayer .aplayer-icon path{-webkit-transition:all .2s ease-in-out;transition:all .2s ease-in-out}.aplayer .aplayer-icon-back,.aplayer .aplayer-icon-forward,.aplayer .aplayer-icon-lrc,.aplayer .aplayer-icon-order,.aplayer .aplayer-icon-play{display:none}.aplayer .aplayer-icon-lrc-inactivity svg{opacity:.4}.aplayer .aplayer-icon-forward{-webkit-transform:rotate(180deg);transform:rotate(180deg)}.aplayer .aplayer-lrc-content{display:none}.aplayer .aplayer-pic{position:relative;float:left;height:66px;width:66px;background-size:cover;background-position:50%;-webkit-transition:all .3s ease;transition:all .3s ease;cursor:pointer}.aplayer .aplayer-pic:hover .aplayer-button{opacity:1}.aplayer .aplayer-pic .aplayer-button{position:absolute;border-radius:50%;opacity:.8;text-shadow:0 1px 1px rgba(0,0,0,.2);-webkit-box-shadow:0 1px 1px rgba(0,0,0,.2);box-shadow:0 1px 1px rgba(0,0,0,.2);background:rgba(0,0,0,.2);-webkit-transition:all .1s ease;transition:all .1s ease}.aplayer .aplayer-pic .aplayer-button path{fill:#fff}.aplayer .aplayer-pic .aplayer-hide{display:none}.aplayer .aplayer-pic .aplayer-play{width:26px;height:26px;border:2px solid #fff;bottom:50%;right:50%;margin:0 -15px -15px 0}.aplayer .aplayer-pic .aplayer-play svg{position:absolute;top:3px;left:4px;height:20px;width:20px}.aplayer .aplayer-pic .aplayer-pause{width:16px;height:16px;border:2px solid #fff;bottom:4px;right:4px}.aplayer .aplayer-pic .aplayer-pause svg{position:absolute;top:2px;left:2px;height:12px;width:12px}.aplayer .aplayer-info{margin-left:66px;padding:14px 7px 0 10px;height:66px;-webkit-box-sizing:border-box;box-sizing:border-box}.aplayer .aplayer-info .aplayer-music{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;margin:0 0 13px 5px;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;cursor:default;padding-bottom:2px;height:20px}.aplayer .aplayer-info .aplayer-music .aplayer-title{font-size:14px}.aplayer .aplayer-info .aplayer-music .aplayer-author{font-size:12px;color:#666}.aplayer .aplayer-info .aplayer-controller{position:relative;display:-webkit-box;display:-ms-flexbox;display:flex}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap{margin:0 0 0 5px;padding:4px 0;cursor:pointer!important;-webkit-box-flex:1;-ms-flex:1;flex:1}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap:hover .aplayer-bar .aplayer-played .aplayer-thumb{-webkit-transform:scale(1);transform:scale(1)}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar{position:relative;height:2px;width:100%;background:#cdcdcd}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-loaded{position:absolute;left:0;top:0;bottom:0;background:#aaa;height:2px;-webkit-transition:all .5s ease;transition:all .5s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played{position:absolute;left:0;top:0;bottom:0;height:2px;-webkit-transition:background-color .3s ease;transition:background-color .3s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-bar-wrap .aplayer-bar .aplayer-played .aplayer-thumb{position:absolute;top:0;right:5px;margin-top:-4px;margin-right:-10px;height:10px;width:10px;border-radius:50%;cursor:pointer;-webkit-transition:all .3s ease-in-out;transition:all .3s ease-in-out;-webkit-transform:scale(0);transform:scale(0)}.aplayer .aplayer-info .aplayer-controller .aplayer-time{position:relative;right:0;bottom:4px;height:17px;color:#999;font-size:11px;padding-left:7px}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-time-inner{vertical-align:middle}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon{cursor:pointer;-webkit-transition:all .2s ease;transition:all .2s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon path{fill:#666}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-loop{margin-right:2px}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon:hover path{fill:#000}.aplayer .aplayer-info .aplayer-controller .aplayer-time .aplayer-icon.aplayer-icon-menu,.aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-menu,.aplayer .aplayer-info .aplayer-controller .aplayer-time.aplayer-time-narrow .aplayer-icon-mode{display:none}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap{position:relative;display:inline-block;margin-left:3px;cursor:pointer!important}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap:hover .aplayer-volume-bar-wrap{height:40px}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap{position:absolute;bottom:15px;right:-3px;width:25px;height:0;z-index:99;overflow:hidden;-webkit-transition:all .2s ease-in-out;transition:all .2s ease-in-out}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap.aplayer-volume-bar-wrap-active{height:40px}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar{position:absolute;bottom:0;right:10px;width:5px;height:35px;background:#aaa;border-radius:2.5px;overflow:hidden}.aplayer .aplayer-info .aplayer-controller .aplayer-volume-wrap .aplayer-volume-bar-wrap .aplayer-volume-bar .aplayer-volume{position:absolute;bottom:0;right:0;width:5px;-webkit-transition:all .1s ease;transition:all .1s ease}.aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon{display:none}.aplayer .aplayer-info .aplayer-controller .aplayer-loading-icon svg{position:absolute;-webkit-animation:rotate 1s linear infinite;animation:rotate 1s linear infinite}.aplayer .aplayer-lrc{display:none;position:relative;height:30px;text-align:center;overflow:hidden;margin:-10px 0 7px}.aplayer .aplayer-lrc:before{top:0;height:10%;background:-webkit-gradient(linear,left top,left bottom,from(#fff),to(hsla(0,0%,100%,0)));background:linear-gradient(180deg,#fff 0,hsla(0,0%,100%,0));filter:progid:DXImageTransform.Microsoft.gradient(startColorstr="#ffffff",endColorstr="#00ffffff",GradientType=0)}.aplayer .aplayer-lrc:after,.aplayer .aplayer-lrc:before{position:absolute;z-index:1;display:block;overflow:hidden;width:100%;content:" "}.aplayer .aplayer-lrc:after{bottom:0;height:33%;background:-webkit-gradient(linear,left top,left bottom,from(hsla(0,0%,100%,0)),to(hsla(0,0%,100%,.8)));background:linear-gradient(180deg,hsla(0,0%,100%,0) 0,hsla(0,0%,100%,.8));filter:progid:DXImageTransform.Microsoft.gradient(startColorstr="#00ffffff",endColorstr="#ccffffff",GradientType=0)}.aplayer .aplayer-lrc p{font-size:12px;color:#666;line-height:16px!important;height:16px!important;padding:0!important;margin:0!important;-webkit-transition-property:font-size,color,opacity;transition-property:font-size,color,opacity;-webkit-transition-timing-function:ease-out;transition-timing-function:ease-out;-webkit-transition-duration:.5s;transition-duration:.5s;opacity:.4;overflow:hidden}.aplayer .aplayer-lrc p.aplayer-lrc-current{opacity:1;overflow:visible;height:auto!important;min-height:16px}.aplayer .aplayer-lrc.aplayer-lrc-hide{display:none}.aplayer .aplayer-lrc .aplayer-lrc-contents{width:100%;-webkit-transition:all .5s ease-out;transition:all .5s ease-out;-webkit-user-select:text;-moz-user-select:text;-ms-user-select:text;user-select:text;cursor:default}.aplayer .aplayer-list{overflow:auto;-webkit-transition:all .5s ease;transition:all .5s ease;will-change:height;display:none;overflow:hidden;list-style-type:none;margin:0;padding:0;overflow-y:auto}.aplayer .aplayer-list::-webkit-scrollbar{width:5px}.aplayer .aplayer-list::-webkit-scrollbar-thumb{border-radius:3px;background-color:#eee}.aplayer .aplayer-list::-webkit-scrollbar-thumb:hover{background-color:#ccc}.aplayer .aplayer-list li{position:relative;height:32px;line-height:32px;padding:0 15px;font-size:12px;border-top:1px solid #e9e9e9;cursor:pointer;-webkit-transition:all .2s ease;transition:all .2s ease;overflow:hidden;margin:0}.aplayer .aplayer-list li:first-child{border-top:none}.aplayer .aplayer-list li:hover{background:#efefef}.aplayer .aplayer-list li.aplayer-list-light{background:#e9e9e9}.aplayer .aplayer-list li.aplayer-list-light .aplayer-list-cur{display:inline-block}.aplayer .aplayer-list li .aplayer-list-cur{display:none;width:3px;height:22px;position:absolute;left:0;top:5px;-webkit-transition:background-color .3s ease;transition:background-color .3s ease;cursor:pointer}.aplayer .aplayer-list li .aplayer-list-index{color:#666;margin-right:12px;cursor:pointer}.aplayer .aplayer-list li .aplayer-list-author{color:#666;float:right;cursor:pointer}.aplayer .aplayer-notice{opacity:0;position:absolute;z-index:1;top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);font-size:12px;border-radius:4px;padding:5px 10px;-webkit-transition:all .3s ease-in-out;transition:all .3s ease-in-out;overflow:hidden;color:#fff;pointer-events:none;background-color:#f4f4f5;color:#909399}.aplayer .aplayer-miniswitcher{display:none;position:absolute;top:0;right:0;bottom:0;height:100%;background:#e6e6e6;width:18px;border-radius:0 2px 2px 0}.aplayer .aplayer-miniswitcher .aplayer-icon{height:100%;width:100%;-webkit-transform:rotateY(180deg);transform:rotateY(180deg);-webkit-transition:all .3s ease;transition:all .3s ease}.aplayer .aplayer-miniswitcher .aplayer-icon path{fill:#666}.aplayer .aplayer-miniswitcher .aplayer-icon:hover path{fill:#000}@-webkit-keyframes aplayer-roll{0%{left:0}to{left:-100%}}@keyframes aplayer-roll{0%{left:0}to{left:-100%}}@-webkit-keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}@keyframes rotate{0%{-webkit-transform:rotate(0);transform:rotate(0)}to{-webkit-transform:rotate(1turn);transform:rotate(1turn)}}',""])},ac6a:function(n,e,t){for(var r=t("cadf"),a=t("0d58"),i=t("2aba"),o=t("7726"),s=t("32e9"),l=t("84f2"),c=t("2b4c"),u=c("iterator"),d=c("toStringTag"),p=l.Array,h={CSSRuleList:!0,CSSStyleDeclaration:!1,CSSValueList:!1,ClientRectList:!1,DOMRectList:!1,DOMStringList:!1,DOMTokenList:!0,DataTransferItemList:!1,FileList:!1,HTMLAllCollection:!1,HTMLCollection:!1,HTMLFormElement:!1,HTMLSelectElement:!1,MediaList:!0,MimeTypeArray:!1,NamedNodeMap:!1,NodeList:!0,PaintRequestList:!1,Plugin:!1,PluginArray:!1,SVGLengthList:!1,SVGNumberList:!1,SVGPathSegList:!1,SVGPointList:!1,SVGStringList:!1,SVGTransformList:!1,SourceBufferList:!1,StyleSheetList:!0,TextTrackCueList:!1,TextTrackList:!1,TouchList:!1},f=a(h),v=0;v<f.length;v++){var m,g=f[v],y=h[g],b=o[g],w=b&&b.prototype;if(w&&(w[u]||s(w,u,p),w[d]||s(w,d,g),l[g]=p,y))for(m in r)w[m]||i(w,m,r[m],!0)}},adec:function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 28 32"}},[t("path",{attrs:{d:"M13.728 6.272v19.456q0 .448-.352.8t-.8.32-.8-.32l-5.952-5.952H1.152q-.48 0-.8-.352t-.352-.8v-6.848q0-.48.352-.8t.8-.352h4.672l5.952-5.952q.32-.32.8-.32t.8.32.352.8z"}})])}}},b349:function(n,e,t){"use strict";var r,a=this&&this.__extends||(r=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(n,e){n.__proto__=e}||function(n,e){for(var t in e)e.hasOwnProperty(t)&&(n[t]=e[t])},function(n,e){function t(){this.constructor=n}r(n,e),n.prototype=null===e?Object.create(e):(t.prototype=e.prototype,new t)}),i=this&&this.__assign||Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++)for(var a in e=arguments[t])Object.prototype.hasOwnProperty.call(e,a)&&(n[a]=e[a]);return n},o=this&&this.__importDefault||function(n){return n&&n.__esModule?n:{default:n}};Object.defineProperty(e,"__esModule",{value:!0});var s=o(t("8bbf")),l=function(n){function e(){var e=null!==n&&n.apply(this,arguments)||this;return e._tsxattrs=void 0,e.$scopedSlots=void 0,e}return a(e,n),e}(s.default);e.Component=l,e.createComponent=function(n){return s.default.extend(n)};var c={convert:function(n){return n},extendFrom:function(n){return n}};function u(n,e){return{create:function(t){var r=t.mixins?t.mixins.concat(e):e;return n.extend(i({},t,{mixins:r}))},mixin:function(t){return u(n,e.concat([t]))}}}e.ofType=function(){return c},e.withNativeOn=function(n){return n},e.withHtmlAttrs=function(n){return n},e.withUnknownProps=function(n){return n},e.componentFactory={create:function(n){return s.default.extend(n)},extendFrom:function(n){return u(n,[])},mixin:function(n){return u(s.default,[n])}},e.componentFactoryOf=function(){return e.componentFactory},e.component=e.componentFactory.create,e.extendFrom=e.componentFactory.extendFrom},bcaa:function(n,e,t){var r=t("cb7c"),a=t("d3f4"),i=t("a5b8");n.exports=function(n,e){if(r(n),a(e)&&e.constructor===n)return e;var t=i.f(n);return(0,t.resolve)(e),t.promise}},bdba:function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 28 32"}},[t("path",{attrs:{d:"M13.728 6.272v19.456q0 .448-.352.8t-.8.32-.8-.32l-5.952-5.952H1.152q-.48 0-.8-.352t-.352-.8v-6.848q0-.48.352-.8t.8-.352h4.672l5.952-5.952q.32-.32.8-.32t.8.32.352.8zM20.576 16q0 1.344-.768 2.528t-2.016 1.664q-.16.096-.448.096-.448 0-.8-.32t-.32-.832q0-.384.192-.64t.544-.448.608-.384.512-.64.192-1.024-.192-1.024-.512-.64-.608-.384-.544-.448-.192-.64q0-.48.32-.832t.8-.32q.288 0 .448.096 1.248.48 2.016 1.664T20.576 16z"}})])}}},be13:function(n,e){n.exports=function(n){if(null==n)throw TypeError("Can't call method on  "+n);return n}},bf5c:function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 32 32"}},[t("path",{attrs:{d:"M22 16L11.895 5.4 10 7.387 18.211 16 10 24.612l1.895 1.988 8.211-8.613z"}})])}}},c366:function(n,e,t){var r=t("6821"),a=t("9def"),i=t("77f1");n.exports=function(n){return function(e,t,o){var s,l=r(e),c=a(l.length),u=i(o,c);if(n&&t!=t){for(;c>u;)if((s=l[u++])!=s)return!0}else for(;c>u;u++)if((n||u in l)&&l[u]===t)return n||u||0;return!n&&-1}}},c3ab:function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 29 32"}},[t("path",{attrs:{d:"M2.667 7.027l1.707-1.693 22.293 22.293-1.693 1.707-4-4H9.334v4l-5.333-5.333 5.333-5.333v4h8.973l-8.973-8.973v.973H6.667v-3.64l-4-4zm20 10.306h2.667v5.573l-2.667-2.667v-2.907zm0-10.666v-4L28 8l-5.333 5.333v-4H11.76L9.093 6.666h13.573z"}})])}}},c5f6:function(n,e,t){"use strict";var r=t("7726"),a=t("69a8"),i=t("2d95"),o=t("5dbc"),s=t("6a99"),l=t("79e5"),c=t("9093").f,u=t("11e9").f,d=t("86cc").f,p=t("aa77").trim,h=r.Number,f=h,v=h.prototype,m="Number"==i(t("2aeb")(v)),g="trim"in String.prototype,y=function(n){var e=s(n,!1);if("string"==typeof e&&e.length>2){var t,r,a,i=(e=g?e.trim():p(e,3)).charCodeAt(0);if(43===i||45===i){if(88===(t=e.charCodeAt(2))||120===t)return NaN}else if(48===i){switch(e.charCodeAt(1)){case 66:case 98:r=2,a=49;break;case 79:case 111:r=8,a=55;break;default:return+e}for(var o,l=e.slice(2),c=0,u=l.length;c<u;c++)if((o=l.charCodeAt(c))<48||o>a)return NaN;return parseInt(l,r)}}return+e};if(!h(" 0o1")||!h("0b1")||h("+0x1")){h=function(n){var e=arguments.length<1?0:n,t=this;return t instanceof h&&(m?l((function(){v.valueOf.call(t)})):"Number"!=i(t))?o(new f(y(e)),t,h):y(e)};for(var b,w=t("9e1e")?c(f):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),k=0;w.length>k;k++)a(f,b=w[k])&&!a(h,b)&&d(h,b,u(f,b));h.prototype=v,v.constructor=h,t("2aba")(r,"Number",h)}},c69a:function(n,e,t){n.exports=!t("9e1e")&&!t("79e5")((function(){return 7!=Object.defineProperty(t("230e")("div"),"a",{get:function(){return 7}}).a}))},ca5a:function(n,e){var t=0,r=Math.random();n.exports=function(n){return"Symbol(".concat(void 0===n?"":n,")_",(++t+r).toString(36))}},cadf:function(n,e,t){"use strict";var r=t("9c6c"),a=t("d53b"),i=t("84f2"),o=t("6821");n.exports=t("01f9")(Array,"Array",(function(n,e){this._t=o(n),this._i=0,this._k=e}),(function(){var n=this._t,e=this._k,t=this._i++;return!n||t>=n.length?(this._t=void 0,a(1)):a(0,"keys"==e?t:"values"==e?n[t]:[t,n[t]])}),"values"),i.Arguments=i.Array,r("keys"),r("values"),r("entries")},cb7c:function(n,e,t){var r=t("d3f4");n.exports=function(n){if(!r(n))throw TypeError(n+" is not an object!");return n}},cd1c:function(n,e,t){var r=t("e853");n.exports=function(n,e){return new(r(n))(e)}},ce10:function(n,e,t){var r=t("69a8"),a=t("6821"),i=t("c366")(!1),o=t("613b")("IE_PROTO");n.exports=function(n,e){var t,s=a(n),l=0,c=[];for(t in s)t!=o&&r(s,t)&&c.push(t);for(;e.length>l;)r(s,t=e[l++])&&(~i(c,t)||c.push(t));return c}},d263:function(n,e,t){"use strict";t("386b")("fixed",(function(n){return function(){return n(this,"tt","","")}}))},d2c8:function(n,e,t){var r=t("aae3"),a=t("be13");n.exports=function(n,e,t){if(r(e))throw TypeError("String#"+t+" doesn't accept regex!");return String(a(n))}},d3f4:function(n,e){n.exports=function(n){return"object"==typeof n?null!==n:"function"==typeof n}},d53b:function(n,e){n.exports=function(n,e){return{value:e,done:!!n}}},d8e8:function(n,e){n.exports=function(n){if("function"!=typeof n)throw TypeError(n+" is not a function!");return n}},daf8:function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 17 32"}},[t("path",{attrs:{d:"M14.08 4.8q2.88 0 2.88 2.048v18.24q0 2.112-2.88 2.112t-2.88-2.112V6.848q0-2.048 2.88-2.048zm-11.2 0q2.88 0 2.88 2.048v18.24q0 2.112-2.88 2.112T0 25.088V6.848Q0 4.8 2.88 4.8z"}})])}}},dcbc:function(n,e,t){var r=t("2aba");n.exports=function(n,e,t){for(var a in e)r(n,a,e[a],t);return n}},e11e:function(n,e){n.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},e853:function(n,e,t){var r=t("d3f4"),a=t("1169"),i=t("2b4c")("species");n.exports=function(n){var e;return a(n)&&("function"!=typeof(e=n.constructor)||e!==Array&&!a(e.prototype)||(e=void 0),r(e)&&null===(e=e[i])&&(e=void 0)),void 0===e?Array:e}},ebd6:function(n,e,t){var r=t("cb7c"),a=t("d8e8"),i=t("2b4c")("species");n.exports=function(n,e){var t,o=r(n).constructor;return void 0===o||null==(t=r(o)[i])?e:a(t)}},f559:function(n,e,t){"use strict";var r=t("5ca1"),a=t("9def"),i=t("d2c8"),o="".startsWith;r(r.P+r.F*t("5147")("startsWith"),"String",{startsWith:function(n){var e=i(this,n,"startsWith"),t=a(Math.min(arguments.length>1?arguments[1]:void 0,e.length)),r=String(n);return o?o.call(e,r,t):e.slice(t,t+r.length)===r}})},f576:function(n,e,t){"use strict";var r=t("5ca1"),a=t("2e08"),i=t("a25f");r(r.P+r.F*/Version\/10\.\d+(\.\d+)? Safari\//.test(i),"String",{padStart:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0,!0)}})},f605:function(n,e){n.exports=function(n,e,t,r){if(!(n instanceof e)||void 0!==r&&r in n)throw TypeError(t+": incorrect invocation!");return n}},f751:function(n,e,t){var r=t("5ca1");r(r.S+r.F,"Object",{assign:t("7333")})},f866:function(n,e,t){"use strict";t.r(e),e.default={functional:!0,render:function(n,e){var t=e._c;return t("svg",{class:[e.data.class,e.data.staticClass],style:[e.data.style,e.data.staticStyle],attrs:{xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 29 32"}},[t("path",{attrs:{d:"M9.333 9.333h13.333v4L27.999 8l-5.333-5.333v4h-16v8h2.667V9.334zm13.334 13.334H9.334v-4L4.001 24l5.333 5.333v-4h16v-8h-2.667v5.333z"}})])}}},fab2:function(n,e,t){var r=t("7726").document;n.exports=r&&r.documentElement},fb15:function(n,e,t){"use strict";var r;(t.r(e),"undefined"!=typeof window)&&((r=window.document.currentScript)&&(r=r.src.match(/(.+\/)[^/]+\.js(\?.*)?$/))&&(t.p=r[1]));t("f751");function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{},r=Object.keys(t);"function"==typeof Object.getOwnPropertySymbols&&(r=r.concat(Object.getOwnPropertySymbols(t).filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable})))),r.forEach((function(e){a(n,e,t[e])}))}return n}t("c5f6");function o(n,e){if(null==n)return{};var t,r,a=function(n,e){if(null==n)return{};var t,r,a={},i=Object.keys(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}function s(n){return function(n){if(Array.isArray(n)){for(var e=0,t=new Array(n.length);e<n.length;e++)t[e]=n[e];return t}}(n)||function(n){if(Symbol.iterator in Object(n)||"[object Arguments]"===Object.prototype.toString.call(n))return Array.from(n)}(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}t("ac6a"),t("551c"),t("6762"),t("2fdb"),t("7f7f"),t("7514"),t("6b54");function l(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=[],r=!0,a=!1,i=void 0;try{for(var o,s=n[Symbol.iterator]();!(r=(o=s.next()).done)&&(t.push(o.value),!e||t.length!==e);r=!0);}catch(n){a=!0,i=n}finally{try{r||null==s.return||s.return()}finally{if(a)throw i}}return t}(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}()}t("20d6"),t("96cf");function c(n,e,t,r,a,i,o){try{var s=n[i](o),l=s.value}catch(n){return void t(n)}s.done?e(l):Promise.resolve(l).then(r,a)}function u(n){return function(){var e=this,t=arguments;return new Promise((function(r,a){var i=n.apply(e,t);function o(n){c(i,r,a,o,s,"next",n)}function s(n){c(i,r,a,o,s,"throw",n)}o(void 0)}))}}t("d263");function d(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function p(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function h(n,e,t){return e&&p(n.prototype,e),t&&p(n,t),n}function f(n){return(f="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function v(n){return(v="function"==typeof Symbol&&"symbol"===f(Symbol.iterator)?function(n){return f(n)}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":f(n)})(n)}function m(n,e){return!e||"object"!==v(e)&&"function"!=typeof e?function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n):e}function g(n){return(g=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function y(n,e){return(y=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}function b(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&y(n,e)}var w=t("48d3"),k=t("65d9"),x=t.n(k),E=t("8bbf"),A=t.n(E);function _(n){return Object(k.createDecorator)((function(e,t){void 0===e.inject&&(e.inject={}),Array.isArray(e.inject)||(e.inject[t]=n||t)}))}function S(n){return Object(k.createDecorator)((function(e,t){var r=e.provide;if("function"!=typeof r||!r.managed){var a=e.provide;(r=e.provide=function(){var n=Object.create(("function"==typeof a?a.call(this):a)||null);for(var e in r.managed)n[r.managed[e]]=this[e];return n}).managed={}}r.managed[t]=n||t}))}function C(n){return void 0===n&&(n={}),Object(k.createDecorator)((function(e,t){(e.props||(e.props={}))[t]=n}))}function T(n,e){void 0===e&&(e={});var t=e.deep,r=void 0!==t&&t,a=e.immediate,i=void 0!==a&&a;return Object(k.createDecorator)((function(e,t){"object"!=typeof e.watch&&(e.watch=Object.create(null)),e.watch[n]={handler:t,deep:r,immediate:i}}))}var O=t("4d26"),j=t.n(O);t("cadf"),t("456d");function B(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3e3;return new Promise((function(t,r){var a=(new Date).getTime(),i=setInterval((function(){n()?(t(),clearInterval(i)):e>0&&(new Date).getTime()-a>e&&(r(),clearInterval(i))}),100)}))}var I,L=["abort","canplay","canplaythrough","durationchange","emptied","ended","error","loadeddata","loadedmetadata","loadstart","pause","play","playing","progress","ratechange","readystatechange","seeked","seeking","stalled","suspend","timeupdate","volumechange","waiting"],N=function(n,e,t,r){var a,i=arguments.length,o=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(o=(i<3?a(o):i>3?a(e,t,o):a(e,t))||o);return i>3&&o&&Object.defineProperty(e,t,o),o},P=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)};!function(n){n[n.HAVE_NOTHING=0]="HAVE_NOTHING",n[n.HAVE_METADATA=1]="HAVE_METADATA",n[n.HAVE_CURRENT_DATA=2]="HAVE_CURRENT_DATA",n[n.HAVE_FUTURE_DATA=3]="HAVE_FUTURE_DATA",n[n.HAVE_ENOUGH_DATA=4]="HAVE_ENOUGH_DATA"}(I||(I={}));var q=function(n){function e(){var n;return d(this,e),(n=m(this,g(e).call(this))).audio=new Audio,n.audioTracks=n.audio.audioTracks,n.autoplay=n.audio.autoplay,n.buffered=n.audio.buffered,n.controls=n.audio.controls,n.crossOrigin=n.audio.crossOrigin,n.currentSrc=n.audio.currentSrc,n.currentTime=n.audio.currentTime,n.defaultMuted=n.audio.defaultMuted,n.defaultPlaybackRate=n.audio.defaultPlaybackRate,n.duration=n.audio.duration,n.ended=n.audio.ended,n.error=n.audio.error,n.loop=n.audio.loop,n.mediaKeys=n.audio.mediaKeys,n.muted=n.audio.muted,n.networkState=n.audio.networkState,n.paused=n.audio.paused,n.playbackRate=n.audio.playbackRate,n.played=n.audio.played,n.preload=n.audio.preload,n.readyState=n.audio.readyState,n.seekable=n.audio.seekable,n.seeking=n.audio.seeking,n.src=n.audio.src,n.textTracks=n.audio.textTracks,n.volume=n.audio.volume,L.forEach((function(e){n.audio.addEventListener(e,(function(e){n.sync()}))})),n}return b(e,n),h(e,[{key:"sync",value:function(){var n=this;Object.keys(this.$data).forEach((function(e){"audio"!==e&&(n[e]=n.audio[e])}))}},{key:"loaded",value:function(){var n=this;return B((function(){return n.readyState>=I.HAVE_FUTURE_DATA}),0)}},{key:"srcLoaded",value:function(){var n=this;return B((function(){return n.src}),0)}},{key:"render",value:function(){return null}}]),e}(A.a),R=q=N([x.a,P("design:paramtypes",[])],q),F=function(n,e,t,r){var a,i=arguments.length,o=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(o=(i<3?a(o):i>3?a(e,t,o):a(e,t))||o);return i>3&&o&&Object.defineProperty(e,t,o),o},M=function(n){function e(){var n;return d(this,e),(n=m(this,g(e).apply(this,arguments))).key="aplayer-setting",n.store=n.get(n.key),n}return b(e,n),h(e,[{key:"get",value:function(n){return JSON.parse(localStorage.getItem(n)||"[]")}},{key:"set",value:function(n){this.store=n,localStorage.setItem(this.key,JSON.stringify(n))}},{key:"render",value:function(){return null}}]),e}(A.a),z=M=F([x.a],M),D=function(n,e,t,r){var a,i=arguments.length,o=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(o=(i<3?a(o):i>3?a(e,t,o):a(e,t))||o);return i>3&&o&&Object.defineProperty(e,t,o),o},U=function(n){function e(){return d(this,e),m(this,g(e).apply(this,arguments))}return b(e,n),h(e,[{key:"isMobile",get:function(){var n=this.$ssrContext?this.$ssrContext.userAgent:window.navigator.userAgent;return/mobile/i.test(n)}}]),e}(A.a),$=U=D([x.a],U),J=function(n,e,t,r){var a,i=arguments.length,o=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(o=(i<3?a(o):i>3?a(e,t,o):a(e,t))||o);return i>3&&o&&Object.defineProperty(e,t,o),o},W=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},Q=function(n){function e(){return d(this,e),m(this,g(e).apply(this,arguments))}return b(e,n),h(e,[{key:"handleClick",value:function(n){this.$emit("click",n)}},{key:"render",value:function(){var n=arguments[0];return n("div",{class:"aplayer-pic",style:this.style,on:{click:this.handleClick}},[this.$slots.default])}},{key:"style",get:function(){var n=this.aplayer,e=n.options,t=n.currentTheme,r=n.currentMusic.cover||e.defaultCover;return{backgroundImage:r&&'url("'.concat(r,'")'),backgroundColor:t}}}]),e}(w.Component);J([_(),W("design:type",Object)],Q.prototype,"aplayer",void 0);var V=Q=J([x.a],Q),H=function(n,e,t,r){var a,i=arguments.length,o=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(o=(i<3?a(o):i>3?a(e,t,o):a(e,t))||o);return i>3&&o&&Object.defineProperty(e,t,o),o},G=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},K=function(n){return t("52f0")("./".concat(n,".svg")).default},Y=function(n){function e(){return d(this,e),m(this,g(e).apply(this,arguments))}return b(e,n),h(e,[{key:"render",value:function(){var n=arguments[0],e=K(this.type);return n(e)}}]),e}(w.Component);H([C({type:String,required:!0}),G("design:type",String)],Y.prototype,"type",void 0);var X=Y=H([x.a],Y);t("55dd"),t("28a5"),t("a481"),t("4917");var Z=function(){function n(){d(this,n),this.xhr=new XMLHttpRequest}return h(n,[{key:"download",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"";return new Promise((function(r,a){e.xhr.open("get",n),e.xhr.responseType=t,e.xhr.onload=function(){var n=e.xhr.status;(n>=200&&n<300||304===n)&&r(e.xhr.response)},e.xhr.onabort=a,e.xhr.onerror=a,e.xhr.ontimeout=a,e.xhr.send()}))}}]),n}(),nn=function(n,e,t,r){var a,i=arguments.length,o=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(o=(i<3?a(o):i>3?a(e,t,o):a(e,t))||o);return i>3&&o&&Object.defineProperty(e,t,o),o},en=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},tn=function(n){function e(){var n;return d(this,e),(n=m(this,g(e).apply(this,arguments))).lrc="",n.xhr=new Z,n.isLoading=!1,n}var t;return b(e,n),h(e,[{key:"getLyricFromCurrentMusic",value:function(){var n=this;return new Promise((function(e,t){var r=n.aplayer,a=r.lrcType,i=r.currentMusic;switch(a){case 0:e("");break;case 1:e(i.lrc);break;case 3:e(i.lrc?n.xhr.download(i.lrc):"");break;default:t(new Error("Illegal lrcType: ".concat(a)))}}))}},{key:"parseLRC",value:function(n){var e=/\[(\d+):(\d+)[.|:](\d+)\](.+)/,t=/\[(\d+):(\d+)[.|:](\d+)\]/g,r=/\[(\d+):(\d+)]()(.+)/,a=/\[(\d+):(\d+)]/g,i=this.lrc.match(/\[offset:\s*(-?\d+)\]/),o=i?Number(i[1]):0,s=[];return n.replace(/\\n/g,"\n").split("\n").forEach((function(n){return function n(i){var l=i.match(e)||i.match(r);if(l&&5===l.length){var c=60*(Number(l[1])||0)*1e3+1e3*(Number(l[2])||0)+(Number(l[3])||0)+o,u=l[4].replace(t,"").replace(a,"");u&&(s.push({time:c,text:u}),n(l[4]))}}(n)})),s.length>0&&s.sort((function(n,e){return n.time-e.time})),s}},{key:"handleChange",value:(t=u(regeneratorRuntime.mark((function n(){return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.prev=0,this.isLoading=!0,this.lrc="",n.next=5,this.getLyricFromCurrentMusic();case 5:this.lrc=n.sent;case 6:return n.prev=6,this.isLoading=!1,n.finish(6);case 9:case"end":return n.stop()}}),n,this,[[0,,6,9]])}))),function(){return t.apply(this,arguments)})},{key:"render",value:function(){var n=arguments[0],e=this.visible,t=this.style,r=this.parsed,a=this.current,i=this.noLyric;return n("div",{class:j()({"aplayer-lrc":!0,"aplayer-lrc-hide":!e})},[n("div",{class:"aplayer-lrc-contents",style:t},[r.length>0?r.map((function(e,t){return n("p",{key:e.time,class:j()({"aplayer-lrc-current":a.time===e.time})},[e.text])})):n("p",{class:"aplayer-lrc-current"},[i])])])}},{key:"noLyric",get:function(){return this.aplayer.currentMusic.id?this.isLoading?"(*ゝω・) 少女祈祷中..":this.lrc?"(・∀・*) 抱歉，该歌词格式不支持":"(,,•́ . •̀,,) 抱歉，当前歌曲暂无歌词":"(ಗ ‸ ಗ ) 未加载音频"}},{key:"parsed",get:function(){return this.parseLRC(this.lrc)}},{key:"current",get:function(){var n=this.aplayer,e=n.media,t=n.currentPlayed,r=this.parsed.filter((function(n){return n.time<t*e.duration*1e3}));return r&&r.length>0?r[r.length-1]:this.parsed[0]}},{key:"transitionDuration",get:function(){return this.parsed.length>1?500:0}},{key:"translateY",get:function(){var n=this.current,e=this.parsed;if(e.length<=0)return 0;var t=e.indexOf(n);return-1*(t===e.length-1?16*(t-1):16*t)}},{key:"style",get:function(){return{transitionDuration:"".concat(this.transitionDuration,"ms"),transform:"translate3d(0, ".concat(this.translateY,"px, 0)")}}}]),e}(w.Component);nn([C({type:Boolean,required:!1,default:!0}),en("design:type",Boolean)],tn.prototype,"visible",void 0),nn([_(),en("design:type",Object)],tn.prototype,"aplayer",void 0),nn([T("aplayer.lrcType",{immediate:!0}),T("aplayer.currentMusic.lrc",{immediate:!0}),en("design:type",Function),en("design:paramtypes",[]),en("design:returntype",Promise)],tn.prototype,"handleChange",null);var rn=tn=nn([x.a],tn),an=function(n,e,t,r){var a,i=arguments.length,o=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(o=(i<3?a(o):i>3?a(e,t,o):a(e,t))||o);return i>3&&o&&Object.defineProperty(e,t,o),o},on=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},sn=function(n){function e(){return d(this,e),m(this,g(e).apply(this,arguments))}return b(e,n),h(e,[{key:"render",value:function(){var n=arguments[0],e=this.music,t=this.aplayer.fixed;return n("div",{class:"aplayer-info"},[n("div",{class:"aplayer-music"},[n("span",{class:"aplayer-title"},[e.name]),n("span",{class:"aplayer-author"},[e.artist])]),t?null:n(rn),this.$slots.default])}},{key:"music",get:function(){var n=this.aplayer.currentMusic;return{name:n.name,artist:n.artist?" - ".concat(n.artist):""}}}]),e}(w.Component);an([_(),on("design:type",Object)],sn.prototype,"aplayer",void 0);var ln=sn=an([x.a],sn),cn=(t("f559"),t("f576"),function(n,e,t,r){var a,i=arguments.length,o=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(o=(i<3?a(o):i>3?a(e,t,o):a(e,t))||o);return i>3&&o&&Object.defineProperty(e,t,o),o}),un=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},dn=function(n){function e(){var n;return d(this,e),(n=m(this,g(e).apply(this,arguments))).isDragMove=!1,n}return b(e,n),h(e,[{key:"thumbMove",value:function(n){this.isDragMove=!0,this.$emit("panMove",n)}},{key:"thumbUp",value:function(n){document.removeEventListener(this.dragMove,this.thumbMove),document.removeEventListener(this.dragEnd,this.thumbUp),this.isDragMove=!1,this.$emit("panEnd",n)}},{key:"mounted",value:function(){var n=this;this.$el.addEventListener(this.dragStart,(function(e){n.$emit("panStart",e),document.addEventListener(n.dragMove,n.thumbMove),document.addEventListener(n.dragEnd,n.thumbUp)}))}},{key:"render",value:function(){var n=arguments[0];return n("div",{class:this.classNames,style:{touchAction:"none",userSelect:"none",webkitUserDrag:"none",webkitTapHighlightColor:"rgba(0, 0, 0, 0)"}},[this.$slots.default])}},{key:"classNames",get:function(){return a({},this.panMoveClass,this.isDragMove)}},{key:"dragStart",get:function(){return this.isMobile?"touchstart":"mousedown"}},{key:"dragMove",get:function(){return this.isMobile?"touchmove":"mousemove"}},{key:"dragEnd",get:function(){return this.isMobile?"touchend":"mouseup"}}]),e}(w.Component);cn([C({type:String,required:!1}),un("design:type",String)],dn.prototype,"panMoveClass",void 0);var pn=dn=cn([x()({mixins:[$]})],dn),hn=function(n,e,t,r){var a,i=arguments.length,o=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(o=(i<3?a(o):i>3?a(e,t,o):a(e,t))||o);return i>3&&o&&Object.defineProperty(e,t,o),o},fn=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},vn=function(n){function e(){return d(this,e),m(this,g(e).apply(this,arguments))}return b(e,n),h(e,[{key:"handleClick",value:function(){this.$emit("click")}},{key:"render",value:function(){var n=arguments[0];return n("button",{attrs:{type:"button"},class:"aplayer-icon aplayer-icon-".concat(this.type),on:{click:this.handleClick}},[n(X,{attrs:{type:this.icon}})])}}]),e}(w.Component);hn([C({type:String,required:!0}),fn("design:type",String)],vn.prototype,"type",void 0),hn([C({type:String,required:!0}),fn("design:type",String)],vn.prototype,"icon",void 0);var mn=vn=hn([x.a],vn),gn=function(n,e,t,r){var a,i=arguments.length,o=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(o=(i<3?a(o):i>3?a(e,t,o):a(e,t))||o);return i>3&&o&&Object.defineProperty(e,t,o),o},yn=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},bn=function(n){function e(){return d(this,e),m(this,g(e).apply(this,arguments))}return b(e,n),h(e,[{key:"handleChange",value:function(n){var e=this.$refs.progressBar,t=e.getBoundingClientRect().left,r=((n.type.startsWith("touch")?n.changedTouches[0].clientX:n.clientX)-t)/e.offsetWidth;r=Math.min(r,1),r=Math.max(r,0),this.handleChangeProgress(n,r)}},{key:"render",value:function(){var n=arguments[0],e=this.aplayer,t=e.currentTheme,r=e.currentLoaded,a=e.currentPlayed;return n(pn,{class:"aplayer-bar-wrap",on:{panMove:this.handleChange,panEnd:this.handleChange}},[n("div",{ref:"progressBar",class:"aplayer-bar"},[n("div",{class:"aplayer-loaded",style:{width:"".concat(100*r,"%")}}),n("div",{class:"aplayer-played",style:{width:"".concat(100*a,"%"),backgroundColor:t}},[n("span",{class:"aplayer-thumb",style:{backgroundColor:t}},[n("span",{class:"aplayer-loading-icon"},[n(X,{attrs:{type:"loading"}})])])])])])}}]),e}(w.Component);gn([_(),yn("design:type",Object)],bn.prototype,"aplayer",void 0),gn([_(),yn("design:type",Function)],bn.prototype,"handleChangeProgress",void 0);var wn=bn=gn([x.a],bn),kn=function(n,e,t,r){var a,i=arguments.length,o=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(o=(i<3?a(o):i>3?a(e,t,o):a(e,t))||o);return i>3&&o&&Object.defineProperty(e,t,o),o},xn=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},En=function(n){function e(){return d(this,e),m(this,g(e).apply(this,arguments))}return b(e,n),h(e,[{key:"timeSecondsFormat",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=Math.floor(n/60)||0,t=Math.floor(n%60)||0;return"".concat(e.toString().padStart(2,"0"),":").concat(t.toString().padStart(2,"0"))}},{key:"handleToggleVolume",value:function(){var n=this.aplayer,e=n.currentVolume,t=n.currentSettings;this.handleChangeVolume(e>0?0:t.volume)}},{key:"handleClickVolumeBar",value:function(n){this.handlePanMove(n)}},{key:"handlePanMove",value:function(n){var e=this.$refs.volumeBar,t=e.getBoundingClientRect().bottom;if(!(t<=0)){var r=n.type.startsWith("touch")?n.changedTouches[0].clientY:n.clientY,a=Math.round(t-r)/e.offsetHeight;a=Math.min(a,1),a=Math.max(a,0),this.handleChangeVolume(a)}}},{key:"render",value:function(){var n=arguments[0],e=this.ptime,t=this.dtime,r=this.volumeIcon,a=this.aplayer,i=a.lrcType,o=a.currentTheme,s=a.currentVolume,l=a.currentOrder,c=a.currentLoop;return n("div",{class:"aplayer-controller"},[n(wn),n("div",{class:"aplayer-time"},[n("span",{class:"aplayer-time-inner"},[n("span",{class:"aplayer-ptime"},[e])," /"," ",n("span",{class:"aplayer-dtime"},[t])," "]),n("span",{class:"aplayer-icon aplayer-icon-back",on:{click:this.handleSkipBack}},[n(X,{attrs:{type:"skip"}})]),n("span",{class:"aplayer-icon aplayer-icon-play",on:{click:this.handleTogglePlay}},[n(X,{attrs:{type:this.playIcon}})]),n("span",{class:"aplayer-icon aplayer-icon-forward",on:{click:this.handleSkipForward}},[n(X,{attrs:{type:"skip"}})]),n("div",{class:"aplayer-volume-wrap"},[n(mn,{attrs:{type:"volume-".concat(r),icon:"volume-".concat(r)},on:{click:this.handleToggleVolume}}),n(pn,{class:"aplayer-volume-bar-wrap",attrs:{panMoveClass:"aplayer-volume-bar-wrap-active"},on:{panMove:this.handlePanMove}},[n("div",{ref:"volumeBar",class:"aplayer-volume-bar",on:{click:this.handleClickVolumeBar}},[n("div",{class:"aplayer-volume",style:{height:"".concat(100*s,"%"),backgroundColor:o}})])])])," ",n(mn,{attrs:{type:"order",icon:"order-".concat(l)},on:{click:this.handleToggleOrderMode}})," ",n(mn,{attrs:{type:"loop",icon:"loop-".concat(c)},on:{click:this.handleToggleLoopMode}})," ",n(mn,{attrs:{type:"menu",icon:"menu"},on:{click:this.handleTogglePlaylist}}),0!==i?n(mn,{attrs:{type:"lrc",icon:"lrc"},on:{click:this.handleToggleLyric}}):null])])}},{key:"playIcon",get:function(){return this.aplayer.media.paused?"play":"pause"}},{key:"volumeIcon",get:function(){var n=this.aplayer.currentVolume;return n<=0?"off":n>=.95?"up":"down"}},{key:"ptime",get:function(){var n=this.aplayer,e=n.media,t=n.currentPlayed;return this.timeSecondsFormat(t*e.duration)}},{key:"dtime",get:function(){return this.timeSecondsFormat(this.aplayer.media.duration)}}]),e}(w.Component);kn([_(),xn("design:type",Object)],En.prototype,"aplayer",void 0),kn([_(),xn("design:type",Function)],En.prototype,"handleSkipBack",void 0),kn([_(),xn("design:type",Function)],En.prototype,"handleSkipForward",void 0),kn([_(),xn("design:type",Function)],En.prototype,"handleTogglePlay",void 0),kn([_(),xn("design:type",Function)],En.prototype,"handleToggleOrderMode",void 0),kn([_(),xn("design:type",Function)],En.prototype,"handleToggleLoopMode",void 0),kn([_(),xn("design:type",Function)],En.prototype,"handleTogglePlaylist",void 0),kn([_(),xn("design:type",Function)],En.prototype,"handleToggleLyric",void 0),kn([_(),xn("design:type",Function)],En.prototype,"handleChangeVolume",void 0);var An=En=kn([x.a],En),_n=function(n,e,t,r){var a,i=arguments.length,o=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(o=(i<3?a(o):i>3?a(e,t,o):a(e,t))||o);return i>3&&o&&Object.defineProperty(e,t,o),o},Sn=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},Cn=function(n){function e(){return d(this,e),m(this,g(e).apply(this,arguments))}return b(e,n),h(e,[{key:"handleTogglePlay",value:function(){this.$emit("togglePlay")}},{key:"handleSkipBack",value:function(){this.$emit("skipBack")}},{key:"handleSkipForward",value:function(){this.$emit("skipForward")}},{key:"handleToggleOrderMode",value:function(){this.$emit("toggleOrderMode")}},{key:"handleToggleLoopMode",value:function(){this.$emit("toggleLoopMode")}},{key:"handleTogglePlaylist",value:function(){this.$emit("togglePlaylist")}},{key:"handleToggleLyric",value:function(){this.$emit("toggleLyric")}},{key:"handleChangeVolume",value:function(n){this.$emit("changeVolume",n)}},{key:"handleChangeProgress",value:function(n,e){this.$emit("changeProgress",n,e)}},{key:"handleMiniSwitcher",value:function(){this.$emit("miniSwitcher")}},{key:"render",value:function(){var n=arguments[0],e=this.playIcon,t=this.notice;return n("div",{class:"aplayer-body"},[n(V,{on:{click:this.handleTogglePlay}},[n("div",{class:"aplayer-button aplayer-".concat(e)},[n(X,{attrs:{type:e}})])]),n(ln,[n(An,{on:{skipBack:this.handleSkipBack,skipForward:this.handleSkipForward,togglePlay:this.handleTogglePlay,toggleOrderMode:this.handleToggleOrderMode,toggleLoopMode:this.handleToggleLoopMode,togglePlaylist:this.handleTogglePlaylist,toggleLyric:this.handleToggleLyric,changeVolume:this.handleChangeVolume,changeProgress:this.handleChangeProgress}})]),n("div",{class:"aplayer-notice",style:{opacity:t.opacity}},[t.text]),n("div",{class:"aplayer-miniswitcher",on:{click:this.handleMiniSwitcher}},[n(mn,{attrs:{type:"miniswitcher",icon:"right"}})])])}},{key:"playIcon",get:function(){return this.aplayer.media.paused?"play":"pause"}}]),e}(w.Component);_n([C({type:Object,required:!0}),Sn("design:type",Object)],Cn.prototype,"notice",void 0),_n([_(),Sn("design:type",Object)],Cn.prototype,"aplayer",void 0),_n([S(),Sn("design:type",Function),Sn("design:paramtypes",[]),Sn("design:returntype",void 0)],Cn.prototype,"handleTogglePlay",null),_n([S(),Sn("design:type",Function),Sn("design:paramtypes",[]),Sn("design:returntype",void 0)],Cn.prototype,"handleSkipBack",null),_n([S(),Sn("design:type",Function),Sn("design:paramtypes",[]),Sn("design:returntype",void 0)],Cn.prototype,"handleSkipForward",null),_n([S(),Sn("design:type",Function),Sn("design:paramtypes",[]),Sn("design:returntype",void 0)],Cn.prototype,"handleToggleOrderMode",null),_n([S(),Sn("design:type",Function),Sn("design:paramtypes",[]),Sn("design:returntype",void 0)],Cn.prototype,"handleToggleLoopMode",null),_n([S(),Sn("design:type",Function),Sn("design:paramtypes",[]),Sn("design:returntype",void 0)],Cn.prototype,"handleTogglePlaylist",null),_n([S(),Sn("design:type",Function),Sn("design:paramtypes",[]),Sn("design:returntype",void 0)],Cn.prototype,"handleToggleLyric",null),_n([S(),Sn("design:type",Function),Sn("design:paramtypes",[Number]),Sn("design:returntype",void 0)],Cn.prototype,"handleChangeVolume",null),_n([S(),Sn("design:type",Function),Sn("design:paramtypes",[Object,Number]),Sn("design:returntype",void 0)],Cn.prototype,"handleChangeProgress",null);var Tn,On,jn=Cn=_n([x.a],Cn),Bn=function(n,e,t,r){var a,i=arguments.length,o=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(o=(i<3?a(o):i>3?a(e,t,o):a(e,t))||o);return i>3&&o&&Object.defineProperty(e,t,o),o},In=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},Ln=function(n){function e(){return d(this,e),m(this,g(e).apply(this,arguments))}var t;return b(e,n),h(e,[{key:"handleChangeScrollTop",value:(t=u(regeneratorRuntime.mark((function n(){return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this.$nextTick();case 2:this.visible&&(this.$refs.list.scrollTop=this.scrollTop);case 3:case"end":return n.stop()}}),n,this)}))),function(){return t.apply(this,arguments)})},{key:"render",value:function(){var n=this,e=arguments[0],t=this.listHeight,r=this.dataSource,a=this.currentMusic,i=this.aplayer.currentTheme;return e("ol",{ref:"list",class:"aplayer-list",style:{height:"".concat(t,"px")}},[r.map((function(t,r){return e("li",{key:t.id,class:j()({"aplayer-list-light":t.id===a.id}),on:{click:function(){return n.$emit("change",t,r)}}},[e("span",{class:"aplayer-list-cur",style:{backgroundColor:i}}),e("span",{class:"aplayer-list-index"},[r+1])," ",e("span",{class:"aplayer-list-title"},[t.name]),e("span",{class:"aplayer-list-author"},[t.artist])])}))])}},{key:"listHeight",get:function(){var n=this.visible,e=this.dataSource;return n?Math.min(33*e.length,Number(this.aplayer.listMaxHeight)):0}}]),e}(w.Component);Bn([C({type:Boolean,required:!1,default:!0}),In("design:type",Boolean)],Ln.prototype,"visible",void 0),Bn([C({type:Object,required:!0}),In("design:type","function"==typeof(Tn="undefined"!=typeof APlayer&&APlayer.Audio)?Tn:Object)],Ln.prototype,"currentMusic",void 0),Bn([C({type:Array,required:!0}),In("design:type","function"==typeof(On="undefined"!=typeof Array&&Array)?On:Object)],Ln.prototype,"dataSource",void 0),Bn([C({type:Number,required:!0}),In("design:type",Number)],Ln.prototype,"scrollTop",void 0),Bn([_(),In("design:type",Object)],Ln.prototype,"aplayer",void 0),Bn([T("scrollTop",{immediate:!0}),T("dataSource",{immediate:!0,deep:!0}),T("visible"),In("design:type",Function),In("design:paramtypes",[]),In("design:returntype",Promise)],Ln.prototype,"handleChangeScrollTop",null);var Nn,Pn,qn,Rn,Fn,Mn,zn=Ln=Bn([x.a],Ln),Dn=(t("610a"),function(n,e,t,r){var a,i=arguments.length,o=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(o=(i<3?a(o):i>3?a(e,t,o):a(e,t))||o);return i>3&&o&&Object.defineProperty(e,t,o),o}),Un=function(n,e){if("object"===("undefined"==typeof Reflect?"undefined":v(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(n,e)},$n=[],Jn=new z,Wn=null;"undefined"!=typeof BroadcastChannel&&(Wn=new BroadcastChannel("aplayer"));var Qn=function(n){function e(){var n;return d(this,e),(n=m(this,g(e).apply(this,arguments))).isDraggingProgressBar=!1,n.isAwaitChangeProgressBar=!1,n.isMini=null!==n.mini?n.mini:n.fixed,n.isArrow=!1,n.canPlay=!n.isMobile&&n.autoplay,n.listVisible=!n.listFolded,n.lyricVisible=!0,n.img=new Image,n.xhr=new Z,n.media=new R,n.player=n.media.audio,n.store=Jn,n.currentMusic={id:NaN,name:"未加载音频",artist:"(ಗ ‸ ಗ )",url:""},n.currentPlayed=0,n.currentVolume=n.volume,n.currentLoop=n.loop,n.currentOrder=n.order,n.currentTheme=n.currentMusic.theme||n.theme,n.notice={text:"",time:2e3,opacity:0},n}var t,r,a,c,p;return b(e,n),h(e,[{key:"handleChangePlayList",value:(p=u(regeneratorRuntime.mark((function n(e,t){var r,a,i,o,s,c,u,d;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(t&&(r=e.length,a=t.length,r!==a&&(r<=0?this.$emit("listClear"):r>a?this.$emit("listAdd"):(this.currentOrderIndex<0&&(i=this.currentMusic,o=i.id,s=i.url,c=t.findIndex((function(n){return n.id===o||n.url===s})),Object.assign(this.currentMusic,t[c-1])),this.canPlay=!this.player.paused,this.$emit("listRemove")))),!(this.orderList.length>0)){n.next=6;break}return this.currentMusic.id?(this.canPlay=!this.player.paused,d=this.orderList[this.currentOrderIndex]||this.orderList[0],Object.assign(this.currentMusic,d)):(u=l(this.currentList,1),this.currentMusic=u[0]),n.next=5,this.$nextTick();case 5:this.canPlay=!0;case 6:case"end":return n.stop()}}),n,this)}))),function(n,e){return p.apply(this,arguments)})},{key:"handleChangeCurrentMusic",value:(c=u(regeneratorRuntime.mark((function n(e,t){var r,a,i=this;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(e.theme?this.currentTheme=e.theme:(r=e.cover||this.options.defaultCover)&&setTimeout(u(regeneratorRuntime.mark((function n(){return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.prev=0,n.next=3,i.getThemeColorFromCover(r);case 3:i.currentTheme=n.sent,n.next=9;break;case 6:n.prev=6,n.t0=n.catch(0),i.currentTheme=e.theme||i.theme;case 9:case"end":return n.stop()}}),n,this,[[0,6]])})))),!e.url){n.next=15;break}if((void 0!==t&&t.url)===e.url&&this.player.src===e.url){n.next=14;break}return this.currentPlayed=0,t&&t.id&&(this.handleChangeSettings(),this.$emit("listSwitch",e)),n.next=7,this.getAudioUrl(e);case 7:(a=n.sent)&&(this.player.src=a),this.player.playbackRate=e.speed||1,this.player.preload=this.preload,this.player.volume=this.currentVolume,this.player.currentTime=0,this.player.onerror=function(n){i.showNotice(n.toString())};case 14:this.canPlay&&this.play();case 15:case"end":return n.stop()}}),n,this)}))),function(n,e){return c.apply(this,arguments)})},{key:"handleChangeVolume",value:function(n){this.currentVolume=n}},{key:"handleChangeCurrentVolume",value:function(){this.player.volume=this.currentVolume,this.$emit("update:volume",this.currentVolume)}},{key:"handleChangeCurrentTime",value:function(){this.isDraggingProgressBar||this.isAwaitChangeProgressBar||(this.currentPlayed=this.media.currentTime/this.media.duration||0)}},{key:"handleChangeSettings",value:function(){var n={currentTime:this.media.currentTime,duration:this.media.duration,paused:this.media.paused,mini:this.isMini,lrc:this.lyricVisible,list:this.listVisible,volume:this.currentVolume,loop:this.currentLoop,order:this.currentOrder,music:this.currentMusic};n.volume<=0&&(n.volume=this.currentSettings.volume),this.saveSettings(n)}},{key:"handleChangeEnded",value:function(){if(this.media.ended)switch(this.currentPlayed=0,this.currentLoop){default:case"all":this.handleSkipForward();break;case"one":this.play();break;case"none":if(this.currentIndex===this.currentList.length-1){var n=l(this.currentList,1);this.currentMusic=n[0],this.pause(),this.canPlay=!1}else this.handleSkipForward()}}},{key:"handleChangeMini",value:function(){this.isMini=this.mini}},{key:"handleChangeCurrentMini",value:(a=u(regeneratorRuntime.mark((function n(e,t){var r;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.next=2,this.$nextTick();case 2:r=this.$refs.container,this.isArrow=r&&r.offsetWidth<=300,void 0!==t&&(this.$emit("update:mini",this.isMini),this.handleChangeSettings());case 5:case"end":return n.stop()}}),n,this)}))),function(n,e){return a.apply(this,arguments)})},{key:"handleChangeLoop",value:function(){this.currentLoop=this.loop}},{key:"handleChangeCurrentLoop",value:function(){this.$emit("update:loop",this.currentLoop),this.handleChangeSettings()}},{key:"handleChangeOrder",value:function(){this.currentOrder=this.order}},{key:"handleChangeCurrentOrder",value:function(){this.$emit("update:order",this.currentOrder),this.handleChangeSettings()}},{key:"handleChangeListVisible",value:function(){this.$emit(this.listVisible?"listShow":"listHide"),this.$emit("update:listFolded",this.listVisible),this.handleChangeSettings()}},{key:"handleChangeLyricVisible",value:function(){this.$emit(this.lyricVisible?"lrcShow":"lrcHide"),this.handleChangeSettings()}},{key:"play",value:(r=u(regeneratorRuntime.mark((function n(){return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return n.prev=0,this.mutex&&this.pauseOtherInstances(),n.next=4,this.player.play();case 4:n.next=10;break;case 6:n.prev=6,n.t0=n.catch(0),this.showNotice(n.t0.message),this.player.pause();case 10:case"end":return n.stop()}}),n,this,[[0,6]])}))),function(){return r.apply(this,arguments)})},{key:"pause",value:function(){this.player.pause()}},{key:"toggle",value:function(){this.media.paused?this.play():this.pause()}},{key:"seeking",value:(t=u(regeneratorRuntime.mark((function n(e){var t,r,a=arguments;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(t=!(a.length>1&&void 0!==a[1])||a[1],n.prev=1,this.isAwaitChangeProgressBar=!0,"none"!==this.preload){n.next=11;break}if(this.player.src){n.next=7;break}return n.next=7,this.media.srcLoaded();case 7:return r=this.player.paused,n.next=10,this.play();case 10:t&&r&&this.pause();case 11:return t&&this.pause(),n.next=14,this.media.loaded();case 14:this.player.currentTime=e*this.media.duration,t||(this.play(),Wn&&this.mutex&&Wn.postMessage("mutex")),n.next=21;break;case 18:n.prev=18,n.t0=n.catch(1),this.showNotice(n.t0.message);case 21:return n.prev=21,this.isAwaitChangeProgressBar=!1,n.finish(21);case 24:case"end":return n.stop()}}),n,this,[[1,18,21,24]])}))),function(n){return t.apply(this,arguments)})},{key:"seek",value:function(n){this.seeking(n/this.media.duration,this.media.paused)}},{key:"switch",value:function(n){switch(v(n)){case"number":this.currentMusic=this.orderList[Math.min(Math.max(0,n),this.orderList.length-1)];break;default:var e=this.orderList.find((function(e){return"string"==typeof e.name&&e.name.includes(n)}));e&&(this.currentMusic=e)}}},{key:"skipBack",value:function(){var n=this.getPlayIndexByMode("skipBack");this.currentMusic=i({},this.currentList[n])}},{key:"skipForward",value:function(){var n=this.getPlayIndexByMode("skipForward");this.currentMusic=i({},this.currentList[n])}},{key:"showLrc",value:function(){this.lyricVisible=!0}},{key:"hideLrc",value:function(){this.lyricVisible=!1}},{key:"toggleLrc",value:function(){this.lyricVisible=!this.lyricVisible}},{key:"showList",value:function(){this.listVisible=!0}},{key:"hideList",value:function(){this.listVisible=!1}},{key:"toggleList",value:function(){this.listVisible=!this.listVisible}},{key:"showNotice",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2e3,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:.8;return new Promise((function(a){e.isMini?(console.warn("aplayer notice:",n),a()):(e.notice={text:n,time:t,opacity:r},e.$emit("noticeShow"),t>0&&setTimeout((function(){e.notice.opacity=0,e.$emit("noticeHide"),a()}),t))}))}},{key:"getThemeColorFromCover",value:function(n){var e=this;return new Promise(function(){var t=u(regeneratorRuntime.mark((function t(r,a){var i,o;return regeneratorRuntime.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(t.prev=0,"undefined"==typeof ColorThief){t.next=12;break}return t.next=4,e.xhr.download(n,"blob");case 4:i=t.sent,(o=new FileReader).onload=function(){e.img.src=o.result,e.img.onload=function(){var n=l((new ColorThief).getColor(e.img),3),t=n[0],a=n[1],i=n[2],o="rgb(".concat(t,", ").concat(a,", ").concat(i,")");r(o||e.currentMusic.theme||e.theme)},e.img.onabort=a,e.img.onerror=a},o.onabort=a,o.onerror=a,o.readAsDataURL(i),t.next=13;break;case 12:r(e.currentMusic.theme||e.theme);case 13:t.next=18;break;case 15:t.prev=15,t.t0=t.catch(0),r(e.currentMusic.theme||e.theme);case 18:case"end":return t.stop()}}),t,this,[[0,15]])})));return function(n,e){return t.apply(this,arguments)}}())}},{key:"getAudioUrl",value:function(n){var e=this;return new Promise((function(t,r){var a=n.type;if(a&&e.customAudioType&&e.customAudioType[a])"function"==typeof e.customAudioType[a]?e.customAudioType[a](e.player,n,e):console.error("Illegal customType: ".concat(a)),t();else if(a&&"auto"!==a||(a=/m3u8(#|\?|$)/i.test(n.url)?"hls":"normal"),"hls"===a)try{if(Hls.isSupported()){var i=new Hls;i.loadSource(n.url),i.attachMedia(e.player),t()}else e.player.canPlayType("application/x-mpegURL")||e.player.canPlayType("application/vnd.apple.mpegURL")?t(n.url):r(new Error("HLS is not supported."))}catch(n){r(new Error("HLS is not supported."))}else t(n.url)}))}},{key:"getPlayIndexByMode",value:function(n){var e=this.currentList.length,t=this.currentIndex;return("skipBack"===n?e+(t-1):t+1)%e}},{key:"pauseOtherInstances",value:function(){var n=this;$n.filter((function(e){return e!==n})).forEach((function(n){return n.pause()}))}},{key:"saveSettings",value:function(n){var e=$n.indexOf(this);null===n&&delete $n[e],this.store.set(void 0!==this.settings[e]?this.settings.map((function(t,r){return r===e?n:t})):s(this.settings).concat([n]))}},{key:"handleSkipBack",value:function(){this.skipBack()}},{key:"handleSkipForward",value:function(){this.skipForward()}},{key:"handleTogglePlay",value:function(){this.toggle()}},{key:"handleToggleOrderMode",value:function(){this.currentOrder="list"===this.currentOrder?"random":"list"}},{key:"handleToggleLoopMode",value:function(){this.currentLoop="all"===this.currentLoop?"one":"one"===this.currentLoop?"none":"all"}},{key:"handleTogglePlaylist",value:function(){this.toggleList()}},{key:"handleToggleLyric",value:function(){this.toggleLrc()}},{key:"handleChangeProgress",value:function(n,e){this.currentPlayed=e,this.isDraggingProgressBar=n.type.includes("move"),["touchend","mouseup"].includes(n.type)&&this.seeking(e,this.media.paused)}},{key:"handleMiniSwitcher",value:function(){this.isMini=!this.isMini}},{key:"handleChangePlaylist",value:function(n,e){n.id===this.currentMusic.id?this.handleTogglePlay():this.currentMusic=this.orderList[e]}},{key:"beforeMount",value:function(){var n=this;this.store.key=this.storageName;var e=$n.findIndex((function(n){return!n}));if(e>-1?$n[e]=this:$n.push(this),this.currentSettings){var t=this.currentSettings,r=t.mini,a=t.lrc,i=t.list,o=t.volume,s=t.loop,l=t.order,c=t.music,u=t.currentTime,d=t.duration,p=t.paused;this.isMini=r,this.lyricVisible=a,this.listVisible=i,this.currentVolume=o,this.currentLoop=s,this.currentOrder=l,c&&(this.currentMusic=c,!this.isMobile&&d&&this.seeking(u/d,p))}Wn&&this.mutex&&Wn.addEventListener("message",(function(e){"mutex"===e.data&&n.pause()})),L.forEach((function(e){n.player.addEventListener(e,(function(t){return n.$emit(e,t)}))}))}},{key:"beforeDestroy",value:function(){this.pause(),this.saveSettings(null),this.$emit("destroy"),this.$el.remove()}},{key:"render",value:function(){var n=arguments[0],e=this.dataSource,t=this.fixed,r=this.lrcType,a=this.isMini,i=this.isMobile,o=this.isArrow,s=this.isLoading,l=this.notice,c=this.listVisible,u=this.listScrollTop,d=this.currentMusic,p=this.lyricVisible;return n("div",{ref:"container",class:j()({aplayer:!0,"aplayer-withlist":e.length>1,"aplayer-withlrc":!t&&0!==r&&p,"aplayer-narrow":a,"aplayer-fixed":t,"aplayer-mobile":i,"aplayer-arrow":o,"aplayer-loading":s})},[n(jn,{attrs:{notice:l},on:{skipBack:this.handleSkipBack,skipForward:this.handleSkipForward,togglePlay:this.handleTogglePlay,toggleOrderMode:this.handleToggleOrderMode,toggleLoopMode:this.handleToggleLoopMode,togglePlaylist:this.handleTogglePlaylist,toggleLyric:this.handleToggleLyric,changeVolume:this.handleChangeVolume,changeProgress:this.handleChangeProgress,miniSwitcher:this.handleMiniSwitcher}}),n(zn,{attrs:{visible:c,scrollTop:u,currentMusic:d,dataSource:e},on:{change:this.handleChangePlaylist}}),t&&0!==r?n(rn,{attrs:{visible:p}}):null])}},{key:"aplayer",get:function(){return this}},{key:"settings",get:function(){return this.store.store}},{key:"currentSettings",get:function(){return this.settings[$n.indexOf(this)]}},{key:"currentList",get:function(){return"list"===this.currentOrder?this.orderList:this.randomList}},{key:"dataSource",get:function(){return(Array.isArray(this.audio)?this.audio:[this.audio]).filter((function(n){return n})).map((function(n,e){return i({id:e+1},n)}))}},{key:"orderList",get:function(){var n=function(n,e){return"string"==typeof n?n:n.data&&n.data.attrs&&n.data.attrs["data-".concat(e)]};return this.dataSource.map((function(e){var t=e.name,r=e.artist;return i({},o(e,["name","artist"]),{name:n(t,"name"),artist:n(r,"artist")})}))}},{key:"randomList",get:function(){return function(n){for(var e=n.length-1;e>=0;e--){var t=Math.floor(Math.random()*(e+1)),r=n[t];n[t]=n[e],n[e]=r}return n}(s(this.orderList))}},{key:"isLoading",get:function(){var n=this.preload,e=this.currentPlayed,t=this.currentLoaded,r=this.media,a=r.src,i=r.paused,o=r.duration,s=!!a&&(e>t||!o);return"none"===n?!i&&s:s}},{key:"listScrollTop",get:function(){return 33*this.currentOrderIndex}},{key:"currentIndex",get:function(){return"list"===this.currentOrder?this.currentOrderIndex:this.currentRandomIndex}},{key:"currentOrderIndex",get:function(){var n=this.currentMusic,e=n.id,t=n.url;return this.orderList.findIndex((function(n){return n.id===e||n.url===t}))}},{key:"currentRandomIndex",get:function(){var n=this.currentMusic,e=n.id,t=n.url;return this.randomList.findIndex((function(n){return n.id===e||n.url===t}))}},{key:"currentLoaded",get:function(){if(this.media.readyState<I.HAVE_FUTURE_DATA)return 0;var n=this.media.buffered.length;return n>0?this.media.buffered.end(n-1)/this.media.duration:1}}]),e}(w.Component);Qn.version="2.0.0-beta.5",Dn([C({type:Boolean,required:!1,default:!1}),Un("design:type",Boolean)],Qn.prototype,"fixed",void 0),Dn([C({type:Boolean,required:!1,default:null}),Un("design:type",Boolean)],Qn.prototype,"mini",void 0),Dn([C({type:Boolean,required:!1,default:!1}),Un("design:type",Boolean)],Qn.prototype,"autoplay",void 0),Dn([C({type:String,required:!1,default:"#b7daff"}),Un("design:type",String)],Qn.prototype,"theme",void 0),Dn([C({type:String,required:!1,default:"all"}),Un("design:type","function"==typeof(Nn=void 0!==Qn&&Qn.LoopMode)?Nn:Object)],Qn.prototype,"loop",void 0),Dn([C({type:String,required:!1,default:"list"}),Un("design:type","function"==typeof(Pn=void 0!==Qn&&Qn.OrderMode)?Pn:Object)],Qn.prototype,"order",void 0),Dn([C({type:String,required:!1,default:"auto"}),Un("design:type","function"==typeof(qn=void 0!==Qn&&Qn.Preload)?qn:Object)],Qn.prototype,"preload",void 0),Dn([C({type:Number,required:!1,default:.7}),Un("design:type",Number)],Qn.prototype,"volume",void 0),Dn([C({type:[Object,Array],required:!0}),Un("design:type",Object)],Qn.prototype,"audio",void 0),Dn([C({type:Object,required:!1}),Un("design:type",Object)],Qn.prototype,"customAudioType",void 0),Dn([C({type:Boolean,required:!1,default:!0}),Un("design:type",Boolean)],Qn.prototype,"mutex",void 0),Dn([C({type:Number,required:!1,default:0}),Un("design:type","function"==typeof(Rn=void 0!==Qn&&Qn.LrcType)?Rn:Object)],Qn.prototype,"lrcType",void 0),Dn([C({type:Boolean,required:!1,default:!1}),Un("design:type",Boolean)],Qn.prototype,"listFolded",void 0),Dn([C({type:Number,required:!1,default:250}),Un("design:type",Number)],Qn.prototype,"listMaxHeight",void 0),Dn([C({type:String,required:!1,default:"aplayer-setting"}),Un("design:type",String)],Qn.prototype,"storageName",void 0),Dn([S(),Un("design:type",Object),Un("design:paramtypes",[])],Qn.prototype,"aplayer",null),Dn([T("orderList",{immediate:!0,deep:!0}),Un("design:type",Function),Un("design:paramtypes",[Array,Array]),Un("design:returntype",Promise)],Qn.prototype,"handleChangePlayList",null),Dn([T("currentMusic",{immediate:!0,deep:!0}),Un("design:type",Function),Un("design:paramtypes",["function"==typeof(Fn=void 0!==Qn&&Qn.Audio)?Fn:Object,"function"==typeof(Mn=void 0!==Qn&&Qn.Audio)?Mn:Object]),Un("design:returntype",Promise)],Qn.prototype,"handleChangeCurrentMusic",null),Dn([T("volume"),Un("design:type",Function),Un("design:paramtypes",[Number]),Un("design:returntype",void 0)],Qn.prototype,"handleChangeVolume",null),Dn([T("currentVolume"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Qn.prototype,"handleChangeCurrentVolume",null),Dn([T("media.currentTime"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Qn.prototype,"handleChangeCurrentTime",null),Dn([T("media.$data",{deep:!0}),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Qn.prototype,"handleChangeSettings",null),Dn([T("media.ended"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Qn.prototype,"handleChangeEnded",null),Dn([T("mini"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Qn.prototype,"handleChangeMini",null),Dn([T("isMini",{immediate:!0}),Un("design:type",Function),Un("design:paramtypes",[Boolean,Boolean]),Un("design:returntype",Promise)],Qn.prototype,"handleChangeCurrentMini",null),Dn([T("loop"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Qn.prototype,"handleChangeLoop",null),Dn([T("currentLoop"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Qn.prototype,"handleChangeCurrentLoop",null),Dn([T("order"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Qn.prototype,"handleChangeOrder",null),Dn([T("currentOrder"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Qn.prototype,"handleChangeCurrentOrder",null),Dn([T("listVisible"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Qn.prototype,"handleChangeListVisible",null),Dn([T("lyricVisible"),Un("design:type",Function),Un("design:paramtypes",[]),Un("design:returntype",void 0)],Qn.prototype,"handleChangeLyricVisible",null);var Vn=Qn=Dn([x()({mixins:[$]})],Qn);t.d(e,"APlayer",(function(){return Vn}));e.default=function(n,e){var t=i({},{productionTip:!0,defaultCover:"https://avatars2.githubusercontent.com/u/20062482?s=270"},e);Object.assign(Vn.prototype,{options:t}),n.component("aplayer",Vn),n.component("APlayer",Vn),t.productionTip&&console.log("%c vue-aplayer %c v".concat("2.0.0-beta.5"," ").concat("dd10c50"," %c"),"background: #35495e; padding: 1px; border-radius: 3px 0 0 3px; color: #fff","background: #41b883; padding: 1px; border-radius: 0 3px 3px 0; color: #fff","background: transparent")}},fdef:function(n,e){n.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"}})},function(n,e,t){"use strict";var r=t(1),a=t(5),i=t(29),o=t(15),s=t(12),l=t(86),c=t(80),u=r.Function,d=a([].concat),p=a([].join),h={},f=function(n,e,t){if(!s(h,e)){for(var r=[],a=0;a<e;a++)r[a]="a["+a+"]";h[e]=u("C,a","return new C("+p(r,",")+")")}return h[e](n,t)};n.exports=c?u.bind:function(n){var e=i(this),t=e.prototype,r=l(arguments,1),a=function(){var t=d(r,l(arguments));return this instanceof a?f(e,t.length,t):e.apply(n,t)};return o(t)&&(a.prototype=t),a}},function(n,e,t){"use strict";t(263)},function(n,e,t){"use strict";t(264)},function(n,e,t){"use strict";t.r(e);t(173),t(287),t(300),t(302);var r=t(72),a=t(115),i=(t(41),t(7),t(25),t(26),t(55),t(34),t(2));function o(n,e){for(var t in e)n[t]=e[t];return n}var s=/[!'()*]/g,l=function(n){return"%"+n.charCodeAt(0).toString(16)},c=/%2C/g,u=function(n){return encodeURIComponent(n).replace(s,l).replace(c,",")};function d(n){try{return decodeURIComponent(n)}catch(n){0}return n}var p=function(n){return null==n||"object"==typeof n?n:String(n)};function h(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=d(t.shift()),a=t.length>0?d(t.join("=")):null;void 0===e[r]?e[r]=a:Array.isArray(e[r])?e[r].push(a):e[r]=[e[r],a]})),e):e}function f(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return u(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(u(e)):r.push(u(e)+"="+u(n)))})),r.join("&")}return u(e)+"="+u(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var v=/\/?$/;function m(n,e,t,r){var a=r&&r.options.stringifyQuery,i=e.query||{};try{i=g(i)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:w(e,a),matched:n?b(n):[]};return t&&(o.redirectedFrom=w(t,a)),Object.freeze(o)}function g(n){if(Array.isArray(n))return n.map(g);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=g(n[t]);return e}return n}var y=m(null,{path:"/"});function b(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function w(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||f)(r)+a}function k(n,e,t){return e===y?n===e:!!e&&(n.path&&e.path?n.path.replace(v,"")===e.path.replace(v,"")&&(t||n.hash===e.hash&&x(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&x(n.query,e.query)&&x(n.params,e.params))))}function x(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,a){var i=n[t];if(r[a]!==t)return!1;var o=e[t];return null==i||null==o?i===o:"object"==typeof i&&"object"==typeof o?x(i,o):String(i)===String(o)}))}function E(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var a=t.instances[r],i=t.enteredCbs[r];if(a&&i){delete t.enteredCbs[r];for(var o=0;o<i.length;o++)a._isBeingDestroyed||i[o](a)}}}}var A={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,a=e.parent,i=e.data;i.routerView=!0;for(var s=a.$createElement,l=t.name,c=a.$route,u=a._routerViewCache||(a._routerViewCache={}),d=0,p=!1;a&&a._routerRoot!==a;){var h=a.$vnode?a.$vnode.data:{};h.routerView&&d++,h.keepAlive&&a._directInactive&&a._inactive&&(p=!0),a=a.$parent}if(i.routerViewDepth=d,p){var f=u[l],v=f&&f.component;return v?(f.configProps&&_(v,i,f.route,f.configProps),s(v,i,r)):s()}var m=c.matched[d],g=m&&m.components[l];if(!m||!g)return u[l]=null,s();u[l]={component:g},i.registerRouteInstance=function(n,e){var t=m.instances[l];(e&&t!==n||!e&&t===n)&&(m.instances[l]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){m.instances[l]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==m.instances[l]&&(m.instances[l]=n.componentInstance),E(c)};var y=m.props&&m.props[l];return y&&(o(u[l],{route:c,configProps:y}),_(g,i,c,y)),s(g,i,r)}};function _(n,e,t,r){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(a){a=e.props=o({},a);var i=e.attrs=e.attrs||{};for(var s in a)n.props&&s in n.props||(i[s]=a[s],delete a[s])}}function S(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var s=i[o];".."===s?a.pop():"."!==s&&a.push(s)}return""!==a[0]&&a.unshift(""),a.join("/")}function C(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var T=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},O=$,j=P,B=function(n,e){return R(P(n,e),e)},I=R,L=U,N=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function P(n,e){for(var t,r=[],a=0,i=0,o="",s=e&&e.delimiter||"/";null!=(t=N.exec(n));){var l=t[0],c=t[1],u=t.index;if(o+=n.slice(i,u),i=u+l.length,c)o+=c[1];else{var d=n[i],p=t[2],h=t[3],f=t[4],v=t[5],m=t[6],g=t[7];o&&(r.push(o),o="");var y=null!=p&&null!=d&&d!==p,b="+"===m||"*"===m,w="?"===m||"*"===m,k=t[2]||s,x=f||v;r.push({name:h||a++,prefix:p||"",delimiter:k,optional:w,repeat:b,partial:y,asterisk:!!g,pattern:x?M(x):g?".*":"[^"+F(k)+"]+?"})}}return i<n.length&&(o+=n.substr(i)),o&&r.push(o),r}function q(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function R(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"==typeof n[r]&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",D(e)));return function(e,r){for(var a="",i=e||{},o=(r||{}).pretty?q:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,u=i[l.name];if(null==u){if(l.optional){l.partial&&(a+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(T(u)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<u.length;d++){if(c=o(u[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");a+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(u).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(u),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');a+=l.prefix+c}}else a+=l}return a}}function F(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function M(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function z(n,e){return n.keys=e,n}function D(n){return n&&n.sensitive?"":"i"}function U(n,e,t){T(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,a=!1!==t.end,i="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)i+=F(s);else{var l=F(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),i+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var u=F(t.delimiter||"/"),d=i.slice(-u.length)===u;return r||(i=(d?i.slice(0,-u.length):i)+"(?:"+u+"(?=$))?"),i+=a?"$":r&&d?"":"(?="+u+"|$)",z(new RegExp("^"+i,D(t)),e)}function $(n,e,t){return T(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return z(n,e)}(n,e):T(n)?function(n,e,t){for(var r=[],a=0;a<n.length;a++)r.push($(n[a],e,t).source);return z(new RegExp("(?:"+r.join("|")+")",D(t)),e)}(n,e,t):function(n,e,t){return U(P(n,t),e,t)}(n,e,t)}O.parse=j,O.compile=B,O.tokensToFunction=I,O.tokensToRegExp=L;var J=Object.create(null);function W(n,e,t){e=e||{};try{var r=J[n]||(J[n]=O.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Q(n,e,t,r){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var i=(a=o({},n)).params;return i&&"object"==typeof i&&(a.params=o({},i)),a}if(!a.path&&a.params&&e){(a=o({},a))._normalized=!0;var s=o(o({},e.params),a.params);if(e.name)a.name=e.name,a.params=s;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;a.path=W(l,s,e.path)}else 0;return a}var c=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(a.path||""),u=e&&e.path||"/",d=c.path?S(c.path,u,t||a.append):u,f=function(n,e,t){void 0===e&&(e={});var r,a=t||h;try{r=a(n||"")}catch(n){r={}}for(var i in e){var o=e[i];r[i]=Array.isArray(o)?o.map(p):p(o)}return r}(c.query,a.query,r&&r.options.parseQuery),v=a.hash||c.hash;return v&&"#"!==v.charAt(0)&&(v="#"+v),{_normalized:!0,path:d,query:f,hash:v}}var V,H=function(){},G={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,a=t.resolve(this.to,r,this.append),i=a.location,s=a.route,l=a.href,c={},u=t.options.linkActiveClass,d=t.options.linkExactActiveClass,p=null==u?"router-link-active":u,h=null==d?"router-link-exact-active":d,f=null==this.activeClass?p:this.activeClass,g=null==this.exactActiveClass?h:this.exactActiveClass,y=s.redirectedFrom?m(null,Q(s.redirectedFrom),null,t):s;c[g]=k(r,y,this.exactPath),c[f]=this.exact||this.exactPath?c[g]:function(n,e){return 0===n.path.replace(v,"/").indexOf(e.path.replace(v,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,y);var b=c[g]?this.ariaCurrentValue:null,w=function(n){K(n)&&(e.replace?t.replace(i,H):t.push(i,H))},x={click:K};Array.isArray(this.event)?this.event.forEach((function(n){x[n]=w})):x[this.event]=w;var E={class:c},A=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:s,navigate:w,isActive:c[f],isExactActive:c[g]});if(A){if(1===A.length)return A[0];if(A.length>1||!A.length)return 0===A.length?n():n("span",{},A)}if("a"===this.tag)E.on=x,E.attrs={href:l,"aria-current":b};else{var _=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(_){_.isStatic=!1;var S=_.data=o({},_.data);for(var C in S.on=S.on||{},S.on){var T=S.on[C];C in x&&(S.on[C]=Array.isArray(T)?T:[T])}for(var O in x)O in S.on?S.on[O].push(x[O]):S.on[O]=w;var j=_.data.attrs=o({},_.data.attrs);j.href=l,j["aria-current"]=b}else E.on=x}return n(this.tag,E,this.$slots.default)}};function K(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Y="undefined"!=typeof window;function X(n,e,t,r,a){var i=e||[],o=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,a,i,o){var s=a.path,l=a.name;0;var c=a.pathToRegexpOptions||{},u=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return C(e.path+"/"+n)}(s,i,c.strict);"boolean"==typeof a.caseSensitive&&(c.sensitive=a.caseSensitive);var d={path:u,regex:Z(u,c),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:l,parent:i,matchAs:o,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var i=o?C(o+"/"+a.path):void 0;n(e,t,r,a,d,i)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==a.alias)for(var p=Array.isArray(a.alias)?a.alias:[a.alias],h=0;h<p.length;++h){0;var f={path:p[h],children:a.children};n(e,t,r,f,i,d.path||"/")}l&&(r[l]||(r[l]=d))}(i,o,s,n,a)}));for(var l=0,c=i.length;l<c;l++)"*"===i[l]&&(i.push(i.splice(l,1)[0]),c--,l--);return{pathList:i,pathMap:o,nameMap:s}}function Z(n,e){return O(n,[],e)}function nn(n,e){var t=X(n),r=t.pathList,a=t.pathMap,i=t.nameMap;function o(n,t,o){var s=Q(n,t,!1,e),c=s.name;if(c){var u=i[c];if(!u)return l(null,s);var d=u.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var p in t.params)!(p in s.params)&&d.indexOf(p)>-1&&(s.params[p]=t.params[p]);return s.path=W(u.path,s.params),l(u,s,o)}if(s.path){s.params={};for(var h=0;h<r.length;h++){var f=r[h],v=a[f];if(en(v.regex,s.path,s.params))return l(v,s,o)}}return l(null,s)}function s(n,t){var r=n.redirect,a="function"==typeof r?r(m(n,t,null,e)):r;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return l(null,t);var s=a,c=s.name,u=s.path,d=t.query,p=t.hash,h=t.params;if(d=s.hasOwnProperty("query")?s.query:d,p=s.hasOwnProperty("hash")?s.hash:p,h=s.hasOwnProperty("params")?s.params:h,c){i[c];return o({_normalized:!0,name:c,query:d,hash:p,params:h},void 0,t)}if(u){var f=function(n,e){return S(n,e.parent?e.parent.path:"/",!0)}(u,n);return o({_normalized:!0,path:W(f,h),query:d,hash:p},void 0,t)}return l(null,t)}function l(n,t,r){return n&&n.redirect?s(n,r||t):n&&n.matchAs?function(n,e,t){var r=o({_normalized:!0,path:W(t,e.params)});if(r){var a=r.matched,i=a[a.length-1];return e.params=r.params,l(i,e)}return l(null,e)}(0,t,n.matchAs):m(n,t,r,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;X([e||n],r,a,i,t),t&&t.alias.length&&X(t.alias.map((function(n){return{path:n,children:[e]}})),r,a,i,t)},getRoutes:function(){return r.map((function(n){return a[n]}))},addRoutes:function(n){X(n,r,a,i)}}}function en(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var a=1,i=r.length;a<i;++a){var o=n.keys[a-1];o&&(t[o.name||"pathMatch"]="string"==typeof r[a]?d(r[a]):r[a])}return!0}var tn=Y&&window.performance&&window.performance.now?window.performance:Date;function rn(){return tn.now().toFixed(3)}var an=rn();function on(){return an}function sn(n){return an=n}var ln=Object.create(null);function cn(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=o({},window.history.state);return t.key=on(),window.history.replaceState(t,"",e),window.addEventListener("popstate",pn),function(){window.removeEventListener("popstate",pn)}}function un(n,e,t,r){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var i=function(){var n=on();if(n)return ln[n]}(),o=a.call(n,e,t,r?i:null);o&&("function"==typeof o.then?o.then((function(n){gn(n,i)})).catch((function(n){0})):gn(o,i))}))}}function dn(){var n=on();n&&(ln[n]={x:window.pageXOffset,y:window.pageYOffset})}function pn(n){dn(),n.state&&n.state.key&&sn(n.state.key)}function hn(n){return vn(n.x)||vn(n.y)}function fn(n){return{x:vn(n.x)?n.x:window.pageXOffset,y:vn(n.y)?n.y:window.pageYOffset}}function vn(n){return"number"==typeof n}var mn=/^#\d/;function gn(n,e){var t,r="object"==typeof n;if(r&&"string"==typeof n.selector){var a=mn.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(a,i={x:vn((t=i).x)?t.x:0,y:vn(t.y)?t.y:0})}else hn(n)&&(e=fn(n))}else r&&hn(n)&&(e=fn(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var yn,bn=Y&&((-1===(yn=window.navigator.userAgent).indexOf("Android 2.")&&-1===yn.indexOf("Android 4.0")||-1===yn.indexOf("Mobile Safari")||-1!==yn.indexOf("Chrome")||-1!==yn.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function wn(n,e){dn();var t=window.history;try{if(e){var r=o({},t.state);r.key=on(),t.replaceState(r,"",n)}else t.pushState({key:sn(rn())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function kn(n){wn(n,!0)}function xn(n,e,t){var r=function(a){a>=n.length?t():n[a]?e(n[a],(function(){r(a+1)})):r(a+1)};r(0)}var En={redirected:2,aborted:4,cancelled:8,duplicated:16};function An(n,e){return Sn(n,e,En.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return Cn.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function _n(n,e){return Sn(n,e,En.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function Sn(n,e,t,r){var a=new Error(r);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var Cn=["params","query","hash"];function Tn(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function On(n,e){return Tn(n)&&n._isRouter&&(null==e||n.type===e)}function jn(n){return function(e,t,r){var a=!1,i=0,o=null;Bn(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){a=!0,i++;var l,c=Nn((function(e){var a;((a=e).__esModule||Ln&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:V.extend(e),t.components[s]=e,--i<=0&&r()})),u=Nn((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=Tn(n)?n:new Error(e),r(o))}));try{l=n(c,u)}catch(n){u(n)}if(l)if("function"==typeof l.then)l.then(c,u);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,u)}}})),a||r()}}function Bn(n,e){return In(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function In(n){return Array.prototype.concat.apply([],n)}var Ln="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Nn(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var Pn=function(n,e){this.router=n,this.base=function(n){if(!n)if(Y){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=y,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function qn(n,e,t,r){var a=Bn(n,(function(n,r,a,i){var o=function(n,e){"function"!=typeof n&&(n=V.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,r,a,i)})):t(o,r,a,i)}));return In(r?a.reverse():a)}function Rn(n,e){if(e)return function(){return n.apply(e,arguments)}}Pn.prototype.listen=function(n){this.cb=n},Pn.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Pn.prototype.onError=function(n){this.errorCbs.push(n)},Pn.prototype.transitionTo=function(n,e,t){var r,a=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(r,(function(){a.updateRoute(r),e&&e(r),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(r,i)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!a.ready&&(On(n,En.redirected)&&i===y||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},Pn.prototype.confirmTransition=function(n,e,t){var r=this,a=this.current;this.pending=n;var i,o,s=function(n){!On(n)&&Tn(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=a.matched.length-1;if(k(n,a)&&l===c&&n.matched[l]===a.matched[c])return this.ensureURL(),n.hash&&un(this.router,a,n,!1),s(((o=Sn(i=a,n,En.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",o));var u=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=u.updated,p=u.deactivated,h=u.activated,f=[].concat(function(n){return qn(n,"beforeRouteLeave",Rn,!0)}(p),this.router.beforeHooks,function(n){return qn(n,"beforeRouteUpdate",Rn)}(d),h.map((function(n){return n.beforeEnter})),jn(h)),v=function(e,t){if(r.pending!==n)return s(_n(a,n));try{e(n,a,(function(e){!1===e?(r.ensureURL(!0),s(function(n,e){return Sn(n,e,En.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):Tn(e)?(r.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(An(a,n)),"object"==typeof e&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){s(n)}};xn(f,v,(function(){xn(function(n){return qn(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,a,i){return n(r,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,r)}))}(h).concat(r.router.resolveHooks),v,(function(){if(r.pending!==n)return s(_n(a,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){E(n)}))}))}))},Pn.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Pn.prototype.setupListeners=function(){},Pn.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=y,this.pending=null};var Fn=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Mn(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=bn&&t;r&&this.listeners.push(cn());var a=function(){var t=n.current,a=Mn(n.base);n.current===y&&a===n._startLocation||n.transitionTo(a,(function(n){r&&un(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){wn(C(r.base+n.fullPath)),un(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){kn(C(r.base+n.fullPath)),un(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Mn(this.base)!==this.current.fullPath){var e=C(this.base+this.current.fullPath);n?wn(e):kn(e)}},e.prototype.getCurrentLocation=function(){return Mn(this.base)},e}(Pn);function Mn(n){var e=window.location.pathname,t=e.toLowerCase(),r=n.toLowerCase();return!n||t!==r&&0!==t.indexOf(C(r+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var zn=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=Mn(n);if(!/^\/#/.test(e))return window.location.replace(C(n+"/#"+e)),!0}(this.base)||Dn()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=bn&&e;t&&this.listeners.push(cn());var r=function(){var e=n.current;Dn()&&n.transitionTo(Un(),(function(r){t&&un(n.router,r,e,!0),bn||Wn(r.fullPath)}))},a=bn?"popstate":"hashchange";window.addEventListener(a,r),this.listeners.push((function(){window.removeEventListener(a,r)}))}},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Jn(n.fullPath),un(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Wn(n.fullPath),un(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Un()!==e&&(n?Jn(e):Wn(e))},e.prototype.getCurrentLocation=function(){return Un()},e}(Pn);function Dn(){var n=Un();return"/"===n.charAt(0)||(Wn("/"+n),!1)}function Un(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function $n(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function Jn(n){bn?wn($n(n)):window.location.hash=n}function Wn(n){bn?kn($n(n)):window.location.replace($n(n))}var Qn=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){On(n,En.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Pn),Vn=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=nn(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!bn&&!1!==n.fallback,this.fallback&&(e="hash"),Y||(e="abstract"),this.mode=e,e){case"history":this.history=new Fn(this,n.base);break;case"hash":this.history=new zn(this,n.base,this.fallback);break;case"abstract":this.history=new Qn(this,n.base);break;default:0}},Hn={currentRoute:{configurable:!0}};function Gn(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Vn.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Hn.currentRoute.get=function(){return this.history&&this.history.current},Vn.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Fn||t instanceof zn){var r=function(n){t.setupListeners(),function(n){var r=t.current,a=e.options.scrollBehavior;bn&&a&&"fullPath"in n&&un(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Vn.prototype.beforeEach=function(n){return Gn(this.beforeHooks,n)},Vn.prototype.beforeResolve=function(n){return Gn(this.resolveHooks,n)},Vn.prototype.afterEach=function(n){return Gn(this.afterHooks,n)},Vn.prototype.onReady=function(n,e){this.history.onReady(n,e)},Vn.prototype.onError=function(n){this.history.onError(n)},Vn.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Vn.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Vn.prototype.go=function(n){this.history.go(n)},Vn.prototype.back=function(){this.go(-1)},Vn.prototype.forward=function(){this.go(1)},Vn.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Vn.prototype.resolve=function(n,e,t){var r=Q(n,e=e||this.history.current,t,this),a=this.match(r,e),i=a.redirectedFrom||a.fullPath;return{location:r,route:a,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?C(n+"/"+r):r}(this.history.base,i,this.mode),normalizedTo:r,resolved:a}},Vn.prototype.getRoutes=function(){return this.matcher.getRoutes()},Vn.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==y&&this.history.transitionTo(this.history.getCurrentLocation())},Vn.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==y&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Vn.prototype,Hn),Vn.install=function n(e){if(!n.installed||V!==e){n.installed=!0,V=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",A),e.component("RouterLink",G);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},Vn.version="3.5.4",Vn.isNavigationFailure=On,Vn.NavigationFailureType=En,Vn.START_LOCATION=y,Y&&window.Vue&&window.Vue.use(Vn);var Kn=Vn;t(210),t(148),t(150),t(77),t(322),t(37),t(38),t(323);function Yn(n){n.locales&&Object.keys(n.locales).forEach((function(e){n.locales[e].path=e})),Object.freeze(n)}var Xn=t(0),Zn=t(48),ne=t(54),ee=(t(168),t(131),t(75),t(265)),te=t.n(ee),re=t(266),ae=t.n(re),ie={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Object(ne.a)(n,1)[0]})).map((function(n){var e=Object(ne.a)(n,2);e[0];return e[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map((function(n){var e="<meta";return Object.keys(n).forEach((function(t){e+=" ".concat(t,'="').concat(ae()(n[t]),'"')})),e+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=se(this.$canonicalUrl)}var e},mounted:function(){this.currentMetaTags=Object(Zn.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=le(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return te()([{name:"description",content:this.$description}],n,this.siteMeta,ce)},updateCanonicalLink:function(){oe(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",se(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){le(null,this.currentMetaTags),oe()}};function oe(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function se(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function le(n,e){if(e&&Object(Zn.a)(e).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var e=document.createElement("meta");return Object.keys(n).forEach((function(t){e.setAttribute(t,n[t])})),document.head.appendChild(e),e}))}function ce(n){for(var e=0,t=["name","property","itemprop"];e<t.length;e++){var r=t[e];if(n.hasOwnProperty(r))return n[r]+r}return JSON.stringify(n)}t(125),t(19),t(50);var ue=t(267),de={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ue)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return e.some((function(e){return e.hash===n.hash}))})),r=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+r,o=0;o<t.length;o++){var s=t[o],l=t[o+1],c=0===o&&0===r||r>=s.parentElement.offsetTop+10&&(!l||r<l.parentElement.offsetTop-10),u=decodeURIComponent(this.$route.hash);if(c&&u!==decodeURIComponent(s.hash)){var d=s;if(i===a)for(var p=o+1;p<t.length;p++)if(u===decodeURIComponent(t[p].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(d.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},pe=t(49),he=t(268),fe=!0,ve=!1,me=!1,ge=100,ye="",be={props:{html:String,lang:String},created:function(){this.authorName="string"==typeof ye?ye:this.getI18nValue(ye),this.text=this.getI18nValue(he),this.location=String(location).replace(/#.+$/,"")},methods:{getI18nValue:function(n){return this.lang in n?n[this.lang]:n["en-US"]}}},we=t(6),ke=Object(we.a)(be,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("p",[n._v(n._s(n.text.beforeAuthor)+n._s(n.authorName||n.text.author)+n._s(n.text.afterAuthor)),t("a",{attrs:{href:n.location}},[n._v(n._s(decodeURIComponent(n.location)))])]),n._v("\n\n"),t("div",{domProps:{innerHTML:n._s(n.html)}})])}),[],!1,null,null,null).exports,xe={data:function(){return{isElement:!1}},created:function(){var n=this;this.onCopy=function(e){var t=getSelection().getRangeAt(0);if(!(String(t).length<n.minLength||(e.preventDefault(),n.noCopy))){var r=document.createElement("div");r.appendChild(getSelection().getRangeAt(0).cloneContents());var a=n.$lang,o=new i.default({render:function(n){return n(ke,{props:{html:r.innerHTML,lang:a}})}}).$mount().$el,s=o.innerHTML,l=o.innerText;e.clipboardData?(e.clipboardData.setData("text/html",s),e.clipboardData.setData("text/plain",l)):window.clipboardData&&window.clipboardData.setData("text",l)}}},watch:{isElement:function(n){if(n){var e=this.$frontmatter.copyright,t=void 0===e?!me:e;if(t){"object"!==Object(pe.a)(t)&&(t={});var r=t.noSelect||ve;this.minLength=t.minLength||ge,this.noCopy=t.noCopy||fe,r?this.$el.style.userSelect="none":this.$el.addEventListener("copy",this.onCopy)}}}},updated:function(){this.isElement="#comment"!==this.$el.nodeName},beforeDestory:function(){this.$el.removeEventListener("copy",this.onCopy)}},Ee=(t(32),t(427),Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n}),Ae=function(n){return"IMG"===n.tagName},_e=function(n){return n&&1===n.nodeType},Se=function(n){return".svg"===(n.currentSrc||n.src).substr(-4).toLowerCase()},Ce=function(n){try{return Array.isArray(n)?n.filter(Ae):function(n){return NodeList.prototype.isPrototypeOf(n)}(n)?[].slice.call(n).filter(Ae):_e(n)?[n].filter(Ae):"string"==typeof n?[].slice.call(document.querySelectorAll(n)).filter(Ae):[]}catch(n){throw new TypeError("The provided selector is invalid.\nExpects a CSS selector, a Node element, a NodeList or an array.\nSee: https://github.com/francoischalifour/medium-zoom")}},Te=function(n){var e=document.createElement("div");return e.classList.add("medium-zoom-overlay"),e.style.background=n,e},Oe=function(n){var e=n.getBoundingClientRect(),t=e.top,r=e.left,a=e.width,i=e.height,o=n.cloneNode(),s=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,l=window.pageXOffset||document.documentElement.scrollLeft||document.body.scrollLeft||0;return o.removeAttribute("id"),o.style.position="absolute",o.style.top=t+s+"px",o.style.left=r+l+"px",o.style.width=a+"px",o.style.height=i+"px",o.style.transform="",o},je=function(n,e){var t=Ee({bubbles:!1,cancelable:!1,detail:void 0},e);if("function"==typeof window.CustomEvent)return new CustomEvent(n,t);var r=document.createEvent("CustomEvent");return r.initCustomEvent(n,t.bubbles,t.cancelable,t.detail),r};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===t&&r.firstChild?r.insertBefore(a,r.firstChild):r.appendChild(a),a.styleSheet?a.styleSheet.cssText=n:a.appendChild(document.createTextNode(n))}}(".medium-zoom-overlay{position:fixed;top:0;right:0;bottom:0;left:0;opacity:0;transition:opacity .3s;will-change:opacity}.medium-zoom--opened .medium-zoom-overlay{cursor:pointer;cursor:zoom-out;opacity:1}.medium-zoom-image{cursor:pointer;cursor:zoom-in;transition:transform .3s cubic-bezier(.2,0,.2,1)!important}.medium-zoom-image--hidden{visibility:hidden}.medium-zoom-image--opened{position:relative;cursor:pointer;cursor:zoom-out;will-change:transform}");var Be=function n(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=window.Promise||function(n){function e(){}n(e,e)},a=function(n){var e=n.target;e!==_?-1!==b.indexOf(e)&&v({target:e}):f()},i=function(){if(!k&&A.original){var n=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0;Math.abs(x-n)>E.scrollOffset&&setTimeout(f,150)}},o=function(n){var e=n.key||n.keyCode;"Escape"!==e&&"Esc"!==e&&27!==e||f()},s=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n;if(n.background&&(_.style.background=n.background),n.container&&n.container instanceof Object&&(e.container=Ee({},E.container,n.container)),n.template){var t=_e(n.template)?n.template:document.querySelector(n.template);e.template=t}return E=Ee({},E,e),b.forEach((function(n){n.dispatchEvent(je("medium-zoom:update",{detail:{zoom:S}}))})),S},l=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return n(Ee({},E,e))},c=function(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];var r=e.reduce((function(n,e){return[].concat(n,Ce(e))}),[]);return r.filter((function(n){return-1===b.indexOf(n)})).forEach((function(n){b.push(n),n.classList.add("medium-zoom-image")})),w.forEach((function(n){var e=n.type,t=n.listener,a=n.options;r.forEach((function(n){n.addEventListener(e,t,a)}))})),S},u=function(){for(var n=arguments.length,e=Array(n),t=0;t<n;t++)e[t]=arguments[t];A.zoomed&&f();var r=e.length>0?e.reduce((function(n,e){return[].concat(n,Ce(e))}),[]):b;return r.forEach((function(n){n.classList.remove("medium-zoom-image"),n.dispatchEvent(je("medium-zoom:detach",{detail:{zoom:S}}))})),b=b.filter((function(n){return-1===r.indexOf(n)})),S},d=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return b.forEach((function(r){r.addEventListener("medium-zoom:"+n,e,t)})),w.push({type:"medium-zoom:"+n,listener:e,options:t}),S},p=function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return b.forEach((function(r){r.removeEventListener("medium-zoom:"+n,e,t)})),w=w.filter((function(t){return!(t.type==="medium-zoom:"+n&&t.listener.toString()===e.toString())})),S},h=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.target,t=function(){var n={width:document.documentElement.clientWidth,height:document.documentElement.clientHeight,left:0,top:0,right:0,bottom:0},e=void 0,t=void 0;if(E.container)if(E.container instanceof Object)e=(n=Ee({},n,E.container)).width-n.left-n.right-2*E.margin,t=n.height-n.top-n.bottom-2*E.margin;else{var r=(_e(E.container)?E.container:document.querySelector(E.container)).getBoundingClientRect(),a=r.width,i=r.height,o=r.left,s=r.top;n=Ee({},n,{width:a,height:i,left:o,top:s})}e=e||n.width-2*E.margin,t=t||n.height-2*E.margin;var l=A.zoomedHd||A.original,c=Se(l)?e:l.naturalWidth||e,u=Se(l)?t:l.naturalHeight||t,d=l.getBoundingClientRect(),p=d.top,h=d.left,f=d.width,v=d.height,m=Math.min(c,e)/f,g=Math.min(u,t)/v,y=Math.min(m,g),b="scale("+y+") translate3d("+((e-f)/2-h+E.margin+n.left)/y+"px, "+((t-v)/2-p+E.margin+n.top)/y+"px, 0)";A.zoomed.style.transform=b,A.zoomedHd&&(A.zoomedHd.style.transform=b)};return new r((function(n){if(e&&-1===b.indexOf(e))n(S);else{if(A.zoomed)n(S);else{if(e)A.original=e;else{if(!(b.length>0))return void n(S);var r=b;A.original=r[0]}if(A.original.dispatchEvent(je("medium-zoom:open",{detail:{zoom:S}})),x=window.pageYOffset||document.documentElement.scrollTop||document.body.scrollTop||0,k=!0,A.zoomed=Oe(A.original),document.body.appendChild(_),E.template){var a=_e(E.template)?E.template:document.querySelector(E.template);A.template=document.createElement("div"),A.template.appendChild(a.content.cloneNode(!0)),document.body.appendChild(A.template)}if(document.body.appendChild(A.zoomed),window.requestAnimationFrame((function(){document.body.classList.add("medium-zoom--opened")})),A.original.classList.add("medium-zoom-image--hidden"),A.zoomed.classList.add("medium-zoom-image--opened"),A.zoomed.addEventListener("click",f),A.zoomed.addEventListener("transitionend",(function e(){k=!1,A.zoomed.removeEventListener("transitionend",e),A.original.dispatchEvent(je("medium-zoom:opened",{detail:{zoom:S}})),n(S)})),A.original.getAttribute("data-zoom-src")){A.zoomedHd=A.zoomed.cloneNode(),A.zoomedHd.removeAttribute("srcset"),A.zoomedHd.removeAttribute("sizes"),A.zoomedHd.src=A.zoomed.getAttribute("data-zoom-src"),A.zoomedHd.onerror=function(){clearInterval(i),console.warn("Unable to reach the zoom image target "+A.zoomedHd.src),A.zoomedHd=null,t()};var i=setInterval((function(){A.zoomedHd.complete&&(clearInterval(i),A.zoomedHd.classList.add("medium-zoom-image--opened"),A.zoomedHd.addEventListener("click",f),document.body.appendChild(A.zoomedHd),t())}),10)}else if(A.original.hasAttribute("srcset")){A.zoomedHd=A.zoomed.cloneNode(),A.zoomedHd.removeAttribute("sizes"),A.zoomedHd.removeAttribute("loading");var o=A.zoomedHd.addEventListener("load",(function(){A.zoomedHd.removeEventListener("load",o),A.zoomedHd.classList.add("medium-zoom-image--opened"),A.zoomedHd.addEventListener("click",f),document.body.appendChild(A.zoomedHd),t()}))}else t()}}}))},f=function(){return new r((function(n){if(!k&&A.original){k=!0,document.body.classList.remove("medium-zoom--opened"),A.zoomed.style.transform="",A.zoomedHd&&(A.zoomedHd.style.transform=""),A.template&&(A.template.style.transition="opacity 150ms",A.template.style.opacity=0),A.original.dispatchEvent(je("medium-zoom:close",{detail:{zoom:S}})),A.zoomed.addEventListener("transitionend",(function e(){A.original.classList.remove("medium-zoom-image--hidden"),document.body.removeChild(A.zoomed),A.zoomedHd&&document.body.removeChild(A.zoomedHd),document.body.removeChild(_),A.zoomed.classList.remove("medium-zoom-image--opened"),A.template&&document.body.removeChild(A.template),k=!1,A.zoomed.removeEventListener("transitionend",e),A.original.dispatchEvent(je("medium-zoom:closed",{detail:{zoom:S}})),A.original=null,A.zoomed=null,A.zoomedHd=null,A.template=null,n(S)}))}else n(S)}))},v=function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},e=n.target;return A.original?f():h({target:e})},m=function(){return E},g=function(){return b},y=function(){return A.original},b=[],w=[],k=!1,x=0,E=t,A={original:null,zoomed:null,zoomedHd:null,template:null};"[object Object]"===Object.prototype.toString.call(e)?E=e:(e||"string"==typeof e)&&c(e),E=Ee({margin:0,background:"#fff",scrollOffset:40,container:null,template:null},E);var _=Te(E.background);document.addEventListener("click",a),document.addEventListener("keyup",o),document.addEventListener("scroll",i),window.addEventListener("resize",f);var S={open:h,close:f,toggle:v,update:s,clone:l,attach:c,detach:u,on:d,off:p,getOptions:m,getImages:g,getZoomedImage:y};return S},Ie={data:function(){return{zoom:null}},mounted:function(){this.updateZoom()},updated:function(){this.updateZoom()},methods:{updateZoom:function(){var n=this;setTimeout((function(){n.zoom&&n.zoom.detach(),n.zoom=Be("img",{})}),1e3)}}},Le=(t(62),t(124)),Ne=t.n(Le),Pe={mounted:function(){var n=this;Ne.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,e,t){n.path===e.path||i.default.component(n.name)||Ne.a.start(),t()})),this.$router.afterEach((function(){Ne.a.done(),n.isSidebarOpen=!1}))}},qe=t(269),Re=t.n(qe),Fe=(t(428),{mounted:function(){Re.a.polyfill()}}),Me=t(22),ze=(t(167),{props:{parent:Object,code:String,options:{align:String,color:String,backgroundTransition:Boolean,backgroundColor:String,successText:String,staticIcon:Boolean}},data:function(){return{success:!1,originalBackground:null,originalTransition:null}},computed:{alignStyle:function(){var n={};return n[this.options.align]="7.5px",n},iconClass:function(){return this.options.staticIcon?"":"hover"}},mounted:function(){this.originalTransition=this.parent.style.transition,this.originalBackground=this.parent.style.background},beforeDestroy:function(){this.parent.style.transition=this.originalTransition,this.parent.style.background=this.originalBackground},methods:{hexToRgb:function(n){var e=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(n);return e?{r:parseInt(e[1],16),g:parseInt(e[2],16),b:parseInt(e[3],16)}:null},copyToClipboard:function(n){var e=this;if(navigator.clipboard)navigator.clipboard.writeText(this.code).then((function(){e.setSuccessTransitions()}),(function(){}));else{var t=document.createElement("textarea");document.body.appendChild(t),t.value=this.code,t.select(),document.execCommand("Copy"),t.remove(),this.setSuccessTransitions()}},setSuccessTransitions:function(){var n=this;if(clearTimeout(this.successTimeout),this.options.backgroundTransition){this.parent.style.transition="background 350ms";var e=this.hexToRgb(this.options.backgroundColor);this.parent.style.background="rgba(".concat(e.r,", ").concat(e.g,", ").concat(e.b,", 0.1)")}this.success=!0,this.successTimeout=setTimeout((function(){n.options.backgroundTransition&&(n.parent.style.background=n.originalBackground,n.parent.style.transition=n.originalTransition),n.success=!1}),500)}}}),De=(t(432),Object(we.a)(ze,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"code-copy"},[t("svg",{class:n.iconClass,style:n.alignStyle,attrs:{xmlns:"http://www.w3.org/2000/svg",width:"24",height:"24",viewBox:"0 0 24 24"},on:{click:n.copyToClipboard}},[t("path",{attrs:{fill:"none",d:"M0 0h24v24H0z"}}),n._v(" "),t("path",{attrs:{fill:n.options.color,d:"M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm-1 4l6 6v10c0 1.1-.9 2-2 2H7.99C6.89 23 6 22.1 6 21l.01-14c0-1.1.89-2 1.99-2h7zm-1 7h5.5L14 6.5V12z"}})]),n._v(" "),t("span",{class:n.success?"success":"",style:n.alignStyle},[n._v("\n        "+n._s(n.options.successText)+"\n    ")])])}),[],!1,null,"49140617",null).exports),Ue=(t(433),[ie,de,xe,Ie,Pe,Fe,{updated:function(){this.update()},methods:{update:function(){setTimeout((function(){document.querySelectorAll('div[class*="language-"] pre').forEach((function(n){if(!n.classList.contains("code-copy-added")){var e=new(i.default.extend(De));e.options=Object(Me.a)({},{align:"bottom",color:"#27b1ff",backgroundTransition:!0,backgroundColor:"#0075b8",successText:"Copied!",staticIcon:!1}),e.code=n.innerText,e.parent=n,e.$mount(),n.classList.add("code-copy-added"),n.appendChild(e.$el)}}))}),100)}}}]),$e={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return Object(Xn.i)("layout",n),i.default.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},Je=Object(we.a)($e,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;Object(Xn.g)(Je,"mixins",Ue);var We=[{name:"v-073380e6",path:"/Idea/01%E3%80%81%E7%88%B1%E6%83%85.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-073380e6").then(t)}},{path:"/Idea/01、爱情.html",redirect:"/Idea/01%E3%80%81%E7%88%B1%E6%83%85.html"},{path:"/Idea/01、爱情.html",redirect:"/Idea/01%E3%80%81%E7%88%B1%E6%83%85.html"},{name:"v-1be91c9a",path:"/Idea/03%E3%80%81%E9%9D%92%E5%B9%B4%E8%8A%82%E5%89%8D%E5%A4%95....html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-1be91c9a").then(t)}},{path:"/Idea/03、青年节前夕....html",redirect:"/Idea/03%E3%80%81%E9%9D%92%E5%B9%B4%E8%8A%82%E5%89%8D%E5%A4%95....html"},{path:"/Idea/03、青年节前夕....html",redirect:"/Idea/03%E3%80%81%E9%9D%92%E5%B9%B4%E8%8A%82%E5%89%8D%E5%A4%95....html"},{name:"v-f7f26542",path:"/Idea/02%E3%80%81%E4%BA%BA%E7%94%9F%E5%A2%83%E7%95%8C%E7%A9%B6%E7%AB%9F%E6%8C%87%E4%BB%80%E4%B9%88.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-f7f26542").then(t)}},{path:"/Idea/02、人生境界究竟指什么.html",redirect:"/Idea/02%E3%80%81%E4%BA%BA%E7%94%9F%E5%A2%83%E7%95%8C%E7%A9%B6%E7%AB%9F%E6%8C%87%E4%BB%80%E4%B9%88.html"},{path:"/Idea/02、人生境界究竟指什么.html",redirect:"/Idea/02%E3%80%81%E4%BA%BA%E7%94%9F%E5%A2%83%E7%95%8C%E7%A9%B6%E7%AB%9F%E6%8C%87%E4%BB%80%E4%B9%88.html"},{name:"v-a67c1470",path:"/Idea/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-a67c1470").then(t)}},{path:"/Idea/index.html",redirect:"/Idea/"},{name:"v-3dc3c778",path:"/Idea/%E7%8E%8B%E5%B0%8F%E6%B3%A2/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-3dc3c778").then(t)}},{path:"/Idea/王小波/",redirect:"/Idea/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"},{path:"/Idea/%E7%8E%8B%E5%B0%8F%E6%B3%A2/index.html",redirect:"/Idea/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"},{path:"/Idea/王小波/",redirect:"/Idea/%E7%8E%8B%E5%B0%8F%E6%B3%A2/"},{name:"v-bdcf9946",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/01%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-bdcf9946").then(t)}},{path:"/Java/Java并发编程的艺术/01、并发编程面临的挑战.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/01%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98.html"},{path:"/Java/Java并发编程的艺术/01、并发编程面临的挑战.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/01%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98.html"},{name:"v-e8410f2c",path:"/Idea/%E7%8E%8B%E5%B0%8F%E6%B3%A2/%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-e8410f2c").then(t)}},{path:"/Idea/王小波/黄金时代.html",redirect:"/Idea/%E7%8E%8B%E5%B0%8F%E6%B3%A2/%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3.html"},{path:"/Idea/王小波/黄金时代.html",redirect:"/Idea/%E7%8E%8B%E5%B0%8F%E6%B3%A2/%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3.html"},{name:"v-d0b6117a",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/02%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-d0b6117a").then(t)}},{path:"/Java/Java并发编程的艺术/02、线程的状态转换以及基本操作.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/02%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html"},{path:"/Java/Java并发编程的艺术/02、线程的状态转换以及基本操作.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/02%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html"},{name:"v-0f4f0be8",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/04%E3%80%81%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3synchronized.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-0f4f0be8").then(t)}},{path:"/Java/Java并发编程的艺术/04、彻底理解synchronized.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/04%E3%80%81%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3synchronized.html"},{path:"/Java/Java并发编程的艺术/04、彻底理解synchronized.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/04%E3%80%81%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3synchronized.html"},{name:"v-312a14d9",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/03%E3%80%81Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8Ahappens-before.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-312a14d9").then(t)}},{path:"/Java/Java并发编程的艺术/03、Java内存模型以及happens-before.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/03%E3%80%81Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8Ahappens-before.html"},{path:"/Java/Java并发编程的艺术/03、Java内存模型以及happens-before.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/03%E3%80%81Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8Ahappens-before.html"},{name:"v-383aa104",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/05%E3%80%81%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3volatile.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-383aa104").then(t)}},{path:"/Java/Java并发编程的艺术/05、彻底理解volatile.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/05%E3%80%81%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3volatile.html"},{path:"/Java/Java并发编程的艺术/05、彻底理解volatile.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/05%E3%80%81%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3volatile.html"},{name:"v-05a7ba0f",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/06%E3%80%81%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3final%E5%90%97%EF%BC%9F.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-05a7ba0f").then(t)}},{path:"/Java/Java并发编程的艺术/06、你真的了解final吗？.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/06%E3%80%81%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3final%E5%90%97%EF%BC%9F.html"},{path:"/Java/Java并发编程的艺术/06、你真的了解final吗？.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/06%E3%80%81%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3final%E5%90%97%EF%BC%9F.html"},{name:"v-5f3f8622",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/10%E3%80%81ReentrantLock%E7%9A%84%E9%87%8D%E5%85%A5%E6%80%A7%E4%B8%8E%E5%85%AC%E5%B9%B3%E6%80%A7.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-5f3f8622").then(t)}},{path:"/Java/Java并发编程的艺术/10、ReentrantLock的重入性与公平性.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/10%E3%80%81ReentrantLock%E7%9A%84%E9%87%8D%E5%85%A5%E6%80%A7%E4%B8%8E%E5%85%AC%E5%B9%B3%E6%80%A7.html"},{path:"/Java/Java并发编程的艺术/10、ReentrantLock的重入性与公平性.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/10%E3%80%81ReentrantLock%E7%9A%84%E9%87%8D%E5%85%A5%E6%80%A7%E4%B8%8E%E5%85%AC%E5%B9%B3%E6%80%A7.html"},{name:"v-22a22e56",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/07%E3%80%81%E4%B8%89%E5%A4%A7%E6%80%A7%E8%B4%A8%E6%80%BB%E7%BB%93%EF%BC%9A%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%9C%89%E5%BA%8F%E6%80%A7.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-22a22e56").then(t)}},{path:"/Java/Java并发编程的艺术/07、三大性质总结：原子性、可见性以及有序性.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/07%E3%80%81%E4%B8%89%E5%A4%A7%E6%80%A7%E8%B4%A8%E6%80%BB%E7%BB%93%EF%BC%9A%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%9C%89%E5%BA%8F%E6%80%A7.html"},{path:"/Java/Java并发编程的艺术/07、三大性质总结：原子性、可见性以及有序性.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/07%E3%80%81%E4%B8%89%E5%A4%A7%E6%80%A7%E8%B4%A8%E6%80%BB%E7%BB%93%EF%BC%9A%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%9C%89%E5%BA%8F%E6%80%A7.html"},{name:"v-5ae78972",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/08%E3%80%81%E5%88%9D%E8%AF%86Lock%E4%B8%8EAbstractQueuedSynchronizer-AQS.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-5ae78972").then(t)}},{path:"/Java/Java并发编程的艺术/08、初识Lock与AbstractQueuedSynchronizer-AQS.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/08%E3%80%81%E5%88%9D%E8%AF%86Lock%E4%B8%8EAbstractQueuedSynchronizer-AQS.html"},{path:"/Java/Java并发编程的艺术/08、初识Lock与AbstractQueuedSynchronizer-AQS.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/08%E3%80%81%E5%88%9D%E8%AF%86Lock%E4%B8%8EAbstractQueuedSynchronizer-AQS.html"},{name:"v-6266d266",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/11%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-6266d266").then(t)}},{path:"/Java/Java并发编程的艺术/11、深入理解读写锁ReentrantReadWriteLock.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/11%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html"},{path:"/Java/Java并发编程的艺术/11、深入理解读写锁ReentrantReadWriteLock.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/11%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html"},{name:"v-f65945d6",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/15%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentLinkedQueue.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-f65945d6").then(t)}},{path:"/Java/Java并发编程的艺术/15、并发容器之ConcurrentLinkedQueue.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/15%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentLinkedQueue.html"},{path:"/Java/Java并发编程的艺术/15、并发容器之ConcurrentLinkedQueue.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/15%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentLinkedQueue.html"},{name:"v-e1ec06b4",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/12%E3%80%81%E8%AF%A6%E8%A7%A3Condition%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-e1ec06b4").then(t)}},{path:"/Java/Java并发编程的艺术/12、详解Condition的线程通信机制.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/12%E3%80%81%E8%AF%A6%E8%A7%A3Condition%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6.html"},{path:"/Java/Java并发编程的艺术/12、详解Condition的线程通信机制.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/12%E3%80%81%E8%AF%A6%E8%A7%A3Condition%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6.html"},{name:"v-58e095d5",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/13%E3%80%81LockSupport%E5%B7%A5%E5%85%B7.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-58e095d5").then(t)}},{path:"/Java/Java并发编程的艺术/13、LockSupport工具.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/13%E3%80%81LockSupport%E5%B7%A5%E5%85%B7.html"},{path:"/Java/Java并发编程的艺术/13、LockSupport工具.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/13%E3%80%81LockSupport%E5%B7%A5%E5%85%B7.html"},{name:"v-66485df2",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/16%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BCopyOnWriteArrayList.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-66485df2").then(t)}},{path:"/Java/Java并发编程的艺术/16、并发容器之CopyOnWriteArrayList.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/16%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BCopyOnWriteArrayList.html"},{path:"/Java/Java并发编程的艺术/16、并发容器之CopyOnWriteArrayList.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/16%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BCopyOnWriteArrayList.html"},{name:"v-7771c16d",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/09%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer-AQS.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-7771c16d").then(t)}},{path:"/Java/Java并发编程的艺术/09、深入理解AbstractQueuedSynchronizer-AQS.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/09%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer-AQS.html"},{path:"/Java/Java并发编程的艺术/09、深入理解AbstractQueuedSynchronizer-AQS.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/09%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer-AQS.html"},{name:"v-5c491b59",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/17%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BThreadLocal.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-5c491b59").then(t)}},{path:"/Java/Java并发编程的艺术/17、并发容器之ThreadLocal.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/17%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BThreadLocal.html"},{path:"/Java/Java并发编程的艺术/17、并发容器之ThreadLocal.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/17%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BThreadLocal.html"},{name:"v-64a9c608",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/21%E3%80%81FutureTask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-64a9c608").then(t)}},{path:"/Java/Java并发编程的艺术/21、FutureTask源码解析.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/21%E3%80%81FutureTask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html"},{path:"/Java/Java并发编程的艺术/21、FutureTask源码解析.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/21%E3%80%81FutureTask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html"},{name:"v-5af16972",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/14%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap-JDK1.8.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-5af16972").then(t)}},{path:"/Java/Java并发编程的艺术/14、并发容器之ConcurrentHashMap-JDK1.8.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/14%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap-JDK1.8.html"},{path:"/Java/Java并发编程的艺术/14、并发容器之ConcurrentHashMap-JDK1.8.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/14%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap-JDK1.8.html"},{name:"v-a9c98eb6",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/18%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BBlockingQueue.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-a9c98eb6").then(t)}},{path:"/Java/Java并发编程的艺术/18、并发容器之BlockingQueue.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/18%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BBlockingQueue.html"},{path:"/Java/Java并发编程的艺术/18、并发容器之BlockingQueue.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/18%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BBlockingQueue.html"},{name:"v-54d6b646",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/19%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-54d6b646").then(t)}},{path:"/Java/Java并发编程的艺术/19、线程池ThreadPoolExecutor实现原理.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/19%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"},{path:"/Java/Java并发编程的艺术/19、线程池ThreadPoolExecutor实现原理.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/19%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"},{name:"v-0de9a35d",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/22%E3%80%81Java%E4%B8%ADatomic%E5%8C%85%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%E6%80%BB%E7%BB%93.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-0de9a35d").then(t)}},{path:"/Java/Java并发编程的艺术/22、Java中atomic包中的原子操作类总结.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/22%E3%80%81Java%E4%B8%ADatomic%E5%8C%85%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%E6%80%BB%E7%BB%93.html"},{path:"/Java/Java并发编程的艺术/22、Java中atomic包中的原子操作类总结.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/22%E3%80%81Java%E4%B8%ADatomic%E5%8C%85%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%E6%80%BB%E7%BB%93.html"},{name:"v-464f68c4",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/20%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BScheduledThreadPoolExecutor.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-464f68c4").then(t)}},{path:"/Java/Java并发编程的艺术/20、线程池之ScheduledThreadPoolExecutor.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/20%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BScheduledThreadPoolExecutor.html"},{path:"/Java/Java并发编程的艺术/20、线程池之ScheduledThreadPoolExecutor.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/20%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BScheduledThreadPoolExecutor.html"},{name:"v-6edd8a2c",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/24%E3%80%81java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-Semaphore%EF%BC%8CExchanger.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-6edd8a2c").then(t)}},{path:"/Java/Java并发编程的艺术/24、java并发工具类-Semaphore，Exchanger.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/24%E3%80%81java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-Semaphore%EF%BC%8CExchanger.html"},{path:"/Java/Java并发编程的艺术/24、java并发工具类-Semaphore，Exchanger.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/24%E3%80%81java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-Semaphore%EF%BC%8CExchanger.html"},{name:"v-36962f7c",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-36962f7c").then(t)}},{path:"/Java/Java并发编程的艺术/",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/"},{path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/index.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/"},{path:"/Java/Java并发编程的艺术/",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/"},{name:"v-008512f6",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/25%E3%80%81%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%E7%94%9F%E4%BA%A7%E8%80%85--%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-008512f6").then(t)}},{path:"/Java/Java并发编程的艺术/25、彻底弄懂生产者--消费者问题.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/25%E3%80%81%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%E7%94%9F%E4%BA%A7%E8%80%85--%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98.html"},{path:"/Java/Java并发编程的艺术/25、彻底弄懂生产者--消费者问题.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/25%E3%80%81%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%E7%94%9F%E4%BA%A7%E8%80%85--%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98.html"},{name:"v-1252c4e0",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/23%E3%80%81CountDownLatch%E4%B8%8ECyclicBarrier%E8%AE%A1%E6%95%B0%E5%99%A8.html",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-1252c4e0").then(t)}},{path:"/Java/Java并发编程的艺术/23、CountDownLatch与CyclicBarrier计数器.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/23%E3%80%81CountDownLatch%E4%B8%8ECyclicBarrier%E8%AE%A1%E6%95%B0%E5%99%A8.html"},{path:"/Java/Java并发编程的艺术/23、CountDownLatch与CyclicBarrier计数器.html",redirect:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/23%E3%80%81CountDownLatch%E4%B8%8ECyclicBarrier%E8%AE%A1%E6%95%B0%E5%99%A8.html"},{name:"v-399c8f76",path:"/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-399c8f76").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-30eb6750",path:"/guide/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-30eb6750").then(t)}},{path:"/guide/index.html",redirect:"/guide/"},{name:"v-6319eb4e",path:"/timeline/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("TimeLines","v-6319eb4e").then(t)},meta:{pid:"timeline",id:"timeline"}},{path:"/timeline/index.html",redirect:"/timeline/"},{name:"v-b1564aac",path:"/tag/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Tags","v-b1564aac").then(t)},meta:{pid:"tags",id:"tags"}},{path:"/tag/index.html",redirect:"/tag/"},{name:"v-ef9325c4",path:"/categories/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("FrontmatterKey","v-ef9325c4").then(t)},meta:{pid:"categories",id:"categories"}},{path:"/categories/index.html",redirect:"/categories/"},{name:"v-693be597",path:"/tags/Idea/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Tag","v-693be597").then(t)},meta:{pid:"tags",id:"Idea"}},{path:"/tags/Idea/index.html",redirect:"/tags/Idea/"},{name:"v-121f755c",path:"/tags/爱情/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Tag","v-121f755c").then(t)},meta:{pid:"tags",id:"爱情"}},{path:"/tags/爱情/index.html",redirect:"/tags/爱情/"},{name:"v-e2cdd360",path:"/tags/青年节/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Tag","v-e2cdd360").then(t)},meta:{pid:"tags",id:"青年节"}},{path:"/tags/青年节/index.html",redirect:"/tags/青年节/"},{name:"v-caf7c19c",path:"/tags/人生境界/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Tag","v-caf7c19c").then(t)},meta:{pid:"tags",id:"人生境界"}},{path:"/tags/人生境界/index.html",redirect:"/tags/人生境界/"},{name:"v-7d08354a",path:"/tags/王小波/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Tag","v-7d08354a").then(t)},meta:{pid:"tags",id:"王小波"}},{path:"/tags/王小波/index.html",redirect:"/tags/王小波/"},{name:"v-6948dfcc",path:"/tags/Java/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Tag","v-6948dfcc").then(t)},meta:{pid:"tags",id:"Java"}},{path:"/tags/Java/index.html",redirect:"/tags/Java/"},{name:"v-e6ef0f30",path:"/tags/Java并发编程/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Tag","v-e6ef0f30").then(t)},meta:{pid:"tags",id:"Java并发编程"}},{path:"/tags/Java并发编程/index.html",redirect:"/tags/Java并发编程/"},{name:"v-667e0558",path:"/tags/JUC/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Tag","v-667e0558").then(t)},meta:{pid:"tags",id:"JUC"}},{path:"/tags/JUC/index.html",redirect:"/tags/JUC/"},{name:"v-8b58e252",path:"/tags/黄金时代/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Tag","v-8b58e252").then(t)},meta:{pid:"tags",id:"黄金时代"}},{path:"/tags/黄金时代/index.html",redirect:"/tags/黄金时代/"},{name:"v-612ac59a",path:"/categories/Idea/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Category","v-612ac59a").then(t)},meta:{pid:"categories",id:"Idea"}},{path:"/categories/Idea/index.html",redirect:"/categories/Idea/"},{name:"v-5cfc18c5",path:"/categories/技术/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Category","v-5cfc18c5").then(t)},meta:{pid:"categories",id:"技术"}},{path:"/categories/技术/index.html",redirect:"/categories/技术/"},{name:"v-594fcf1e",path:"/tags/Java/page/2/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-594fcf1e").then(t)},meta:{pid:"tags",id:"Java"}},{path:"/tags/Java/page/2/index.html",redirect:"/tags/Java/page/2/"},{name:"v-594fcee0",path:"/tags/Java/page/3/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-594fcee0").then(t)},meta:{pid:"tags",id:"Java"}},{path:"/tags/Java/page/3/index.html",redirect:"/tags/Java/page/3/"},{name:"v-5b14d855",path:"/tags/Java并发编程/page/2/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-5b14d855").then(t)},meta:{pid:"tags",id:"Java并发编程"}},{path:"/tags/Java并发编程/page/2/index.html",redirect:"/tags/Java并发编程/page/2/"},{name:"v-5b14d874",path:"/tags/Java并发编程/page/3/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-5b14d874").then(t)},meta:{pid:"tags",id:"Java并发编程"}},{path:"/tags/Java并发编程/page/3/index.html",redirect:"/tags/Java并发编程/page/3/"},{name:"v-49b84536",path:"/tags/JUC/page/2/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-49b84536").then(t)},meta:{pid:"tags",id:"JUC"}},{path:"/tags/JUC/page/2/index.html",redirect:"/tags/JUC/page/2/"},{name:"v-49b844f8",path:"/tags/JUC/page/3/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-49b844f8").then(t)},meta:{pid:"tags",id:"JUC"}},{path:"/tags/JUC/page/3/index.html",redirect:"/tags/JUC/page/3/"},{name:"v-2c1a8558",path:"/categories/技术/page/2/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-2c1a8558").then(t)},meta:{pid:"categories",id:"技术"}},{path:"/categories/技术/page/2/index.html",redirect:"/categories/技术/page/2/"},{name:"v-2c1a8577",path:"/categories/技术/page/3/",component:Je,beforeEnter:function(n,e,t){Object(Xn.a)("Layout","v-2c1a8577").then(t)},meta:{pid:"categories",id:"技术"}},{path:"/categories/技术/page/3/index.html",redirect:"/categories/技术/page/3/"},{path:"*",component:Je}],Qe={title:"MyGoldenAge",description:"那是我的黄金时代",base:"/vuepress/",headTags:[["link",{rel:"icon",href:"/vuepress/img/favicon.ico"}],["meta",{name:"keywords",content:"全栈,黄金时代"}],["meta",{name:"description",content:"全栈,黄金时代"}],["meta",{name:"viewport",content:"width=device-width,initial-scale=1,user-scalable=no"}],["meta",{name:"robots",content:"all"}],["meta",{name:"author",content:"萧瑟"}],["link",{rel:"stylesheet",href:"/vuepress/css/style.css"}],["script",{charset:"utf-8",src:"/vuepress/js/custom.js"}]],pages:[{title:"爱情",frontmatter:{title:"爱情",date:"2022-04-25T13:44:15.000Z",tags:["Idea","爱情"],categories:["Idea"],readingShow:"top"},regularPath:"/Idea/01%E3%80%81%E7%88%B1%E6%83%85.html",relativePath:"Idea/01、爱情.md",key:"v-073380e6",path:"/Idea/01%E3%80%81%E7%88%B1%E6%83%85.html",lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:null,content:"虽然也许我们现在的找女朋友策略都只是停留在肤浅的外貌层面，但随着人生阅历的增加，慢慢变成一个成熟的男人。你会发现再美丽的容颜也都只是昙花一现，而只有懂你的灵魂才能值得你一生所爱。能带给你幸福的也许并不是一个穿裙子比你好看的女生，而是一个在撞见你穿裙子这么有冲击力的画面后不会尖叫着夺门而出的女生。相反，她会轻轻抱住无地自容眼圈泛红你，邪魅一笑说道：“呦，怎么穿着品如的衣服呢？”。我的天，那一瞬间她如剃刀般锋利的温柔与情商终究还是将你在眼角打转的泪水收割了下来，随着你豆大的泪珠滴落在已经被你撑到变形的裙摆上，她突然轻轻的替你擦去眼泪，一弯腰，捡起掉在地上的小灯泡，在你耳边说：“I got your Bro，在我面前你应该是最能放心做自己的，不行就穿红色哦！“。直到那一天你才理解了什么是亲密关系中的沟通与包容；才终于体会到原来卸下防备赤裸相待还能被爱是何等幸福；才终于知道了原来另一半的情商比外貌重要这么多；也终于明白了什么样的聪明女孩才是真正适合你的！\n\n说明\n\n上文的“穿裙子”代表的当然不只是狭义的女装，而是每人个人心中最柔软，最自卑，最奇怪，甚至是最见不得人的一部分自己。从而想表达的是真正的爱情也许并不应只停留在外貌，而更多的是两个人内心深处的沟通，包容，与尊重。",normalizedContent:"虽然也许我们现在的找女朋友策略都只是停留在肤浅的外貌层面，但随着人生阅历的增加，慢慢变成一个成熟的男人。你会发现再美丽的容颜也都只是昙花一现，而只有懂你的灵魂才能值得你一生所爱。能带给你幸福的也许并不是一个穿裙子比你好看的女生，而是一个在撞见你穿裙子这么有冲击力的画面后不会尖叫着夺门而出的女生。相反，她会轻轻抱住无地自容眼圈泛红你，邪魅一笑说道：“呦，怎么穿着品如的衣服呢？”。我的天，那一瞬间她如剃刀般锋利的温柔与情商终究还是将你在眼角打转的泪水收割了下来，随着你豆大的泪珠滴落在已经被你撑到变形的裙摆上，她突然轻轻的替你擦去眼泪，一弯腰，捡起掉在地上的小灯泡，在你耳边说：“i got your bro，在我面前你应该是最能放心做自己的，不行就穿红色哦！“。直到那一天你才理解了什么是亲密关系中的沟通与包容；才终于体会到原来卸下防备赤裸相待还能被爱是何等幸福；才终于知道了原来另一半的情商比外貌重要这么多；也终于明白了什么样的聪明女孩才是真正适合你的！\n\n说明\n\n上文的“穿裙子”代表的当然不只是狭义的女装，而是每人个人心中最柔软，最自卑，最奇怪，甚至是最见不得人的一部分自己。从而想表达的是真正的爱情也许并不应只停留在外貌，而更多的是两个人内心深处的沟通，包容，与尊重。",charsets:{cjk:!0},createdTime:1655628697e3},{title:"青年节前夕——有幸我仍是青年",frontmatter:{title:"青年节前夕——有幸我仍是青年",date:"2022-05-03T17:03:03.000Z",next:!1,tags:["Idea","青年节"],categories:["Idea"],readingShow:"top"},regularPath:"/Idea/03%E3%80%81%E9%9D%92%E5%B9%B4%E8%8A%82%E5%89%8D%E5%A4%95....html",relativePath:"Idea/03、青年节前夕....md",key:"v-1be91c9a",path:"/Idea/03%E3%80%81%E9%9D%92%E5%B9%B4%E8%8A%82%E5%89%8D%E5%A4%95....html",lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:null,content:"今天是5月3日，明天就是青年节，最近的事总是很多，忙活起来就是好几天...\n\n有时候会想：天天忙活是为了什么，其实我也不知道，或许只是想为将来保留一些可能性...；又或在想：该怎么规划人生方向，自己又何尝明白呢...\n\n现在信息时代，年轻人的机会好像是很多，可是，像我这样的年轻人又哪来的能力去发现、鉴别并把握呢？只能像个孩子一样，拼尽全力去接从天上掉下来的糖果，不知哪一颗是真的，哪一颗是假的。不过是趁热血未凉之时，尽可能的多抓住一些。可能将来哪一天就会发现，自己拼尽全力攥住了这一把，全是石子。到时候也只能无奈的自嘲一句：“tmd，爷躺平了”。\n\n我们现在说反内卷，就被别人指责说懒散。其实，我们不过是不想被同质化的成功观绑架，而是想努力得值得。我们现在说要躺平，那也不是真的就无所事事，只不过是无奈地在梦想和现实之间达成了和解。\n\n小时候，我总是看到一些文章说，90后是垮掉的一代（我是00年，所以还是颇有90后的感想），虽然那时候我根本就理解不了，为什么小学还没毕业，就垮掉了。但总是不由得惶恐和自卑了起来。现在想起，不禁哑然失笑。那不过是某些有发言权的人，觉得我们和他们的意志不同罢了。但是，不同，就是错的吗？不可否认，你们是成功的，但这不代表我们就是失败的。\n\n近些年的各项前线，我们逐渐成为队伍的主力，线上线下，台前幕后，我们这一代人的身影，已然无处不见。我们不甘着，但也热爱着；我们迷茫着，但也探寻着。所以，没必要去在意那些虚妄的指指点点。我们虽然年轻，但也绝对有理由是自信的。草木知春不久归，百般红紫斗芳菲。草木尚且如此，站在人生的五月，我又当如何。\n\n现在已是五月，可现在还只是五月，明天就是青年节，有幸，我仍是青年！",normalizedContent:"今天是5月3日，明天就是青年节，最近的事总是很多，忙活起来就是好几天...\n\n有时候会想：天天忙活是为了什么，其实我也不知道，或许只是想为将来保留一些可能性...；又或在想：该怎么规划人生方向，自己又何尝明白呢...\n\n现在信息时代，年轻人的机会好像是很多，可是，像我这样的年轻人又哪来的能力去发现、鉴别并把握呢？只能像个孩子一样，拼尽全力去接从天上掉下来的糖果，不知哪一颗是真的，哪一颗是假的。不过是趁热血未凉之时，尽可能的多抓住一些。可能将来哪一天就会发现，自己拼尽全力攥住了这一把，全是石子。到时候也只能无奈的自嘲一句：“tmd，爷躺平了”。\n\n我们现在说反内卷，就被别人指责说懒散。其实，我们不过是不想被同质化的成功观绑架，而是想努力得值得。我们现在说要躺平，那也不是真的就无所事事，只不过是无奈地在梦想和现实之间达成了和解。\n\n小时候，我总是看到一些文章说，90后是垮掉的一代（我是00年，所以还是颇有90后的感想），虽然那时候我根本就理解不了，为什么小学还没毕业，就垮掉了。但总是不由得惶恐和自卑了起来。现在想起，不禁哑然失笑。那不过是某些有发言权的人，觉得我们和他们的意志不同罢了。但是，不同，就是错的吗？不可否认，你们是成功的，但这不代表我们就是失败的。\n\n近些年的各项前线，我们逐渐成为队伍的主力，线上线下，台前幕后，我们这一代人的身影，已然无处不见。我们不甘着，但也热爱着；我们迷茫着，但也探寻着。所以，没必要去在意那些虚妄的指指点点。我们虽然年轻，但也绝对有理由是自信的。草木知春不久归，百般红紫斗芳菲。草木尚且如此，站在人生的五月，我又当如何。\n\n现在已是五月，可现在还只是五月，明天就是青年节，有幸，我仍是青年！",charsets:{cjk:!0},createdTime:1655628697e3},{title:"人生境界究竟指什么?",frontmatter:{title:"人生境界究竟指什么?",date:"2022-05-01T17:03:03.000Z",tags:["Idea","人生境界"],categories:["Idea"],readingShow:"top"},regularPath:"/Idea/02%E3%80%81%E4%BA%BA%E7%94%9F%E5%A2%83%E7%95%8C%E7%A9%B6%E7%AB%9F%E6%8C%87%E4%BB%80%E4%B9%88.html",relativePath:"Idea/02、人生境界究竟指什么.md",key:"v-f7f26542",path:"/Idea/02%E3%80%81%E4%BA%BA%E7%94%9F%E5%A2%83%E7%95%8C%E7%A9%B6%E7%AB%9F%E6%8C%87%E4%BB%80%E4%B9%88.html",headers:[{level:2,title:"自然境界",slug:"自然境界",normalizedTitle:"自然境界",charIndex:643},{level:2,title:"功利境界",slug:"功利境界",normalizedTitle:"功利境界",charIndex:936},{level:2,title:"道德境界",slug:"道德境界",normalizedTitle:"道德境界",charIndex:1617}],lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"自然境界 功利境界 道德境界",content:"我们常常指责人说这个人境界很低，这个人很俗，境界太低。那么一个人的境界，它和一个人的胸襟、格调、气度、他的修养修为都连在一起的。那么什么是人生境界？汉语中间的境界，大概有这么几种意思：境界的本意是指疆界、边疆，后来指范围，后来又指情景。今天说的这个境界是指人生境界，人生境界就是一个人的精神、品格、觉解（觉悟的觉，理解的解）所达到的程度。而且要把自己的精神境界和觉解达到的这种程度在自己的人生，在自己的生命中间把它呈现出来，那个呈现出来的状态，就是境界。\n\n境界，是属于本体论，或者说存在论的范畴，它不是能力学的范畴，它也不是认识论的范畴。境界是“体”，修为（修养）是“用”。在中国古代哲学中间有体有用，境界就是属于体，修养、实践就是用。还有境界和功夫，功夫也是用，就是我们在达到某种境界的过程中间，那种努功这种过程我们就叫功夫，达到的结果，那个状态就是境界。\n\n在中国古代，人生境界分为很多种，比方说有人把人生境界分为九种，分的很繁琐，有人分为七种，有人分为八种。著名哲学家，新儒学的代表人物之一，冯友兰先生的“贞元六书”中有一本书叫《新原人》，这本书中有一篇文章叫《境界》，再这篇文章中，冯友兰先生把人生境界分为四种：第一种是自然的境界、第二种是功利的境界、第三种是道德的境界、第四种是天地的境界。就有点像马斯洛的人生有四（五）个内在的需要，马斯洛先生说在这五种境界中最高的是人生自我价值实现的需要。但冯友兰先生我认为他说的更好，他则说境界分四种：自然、功利、道德、天地。\n\n\n# 自然境界\n\n自然境界其实就是人的本能的境界，吃喝拉撒。说白了就是人的动物的这种境界。其实有很多人，哪怕已经几十岁了，他的人生需求、他的追求，求还没有超越穿衣吃饭的这个层次，基本上还是限制在自然的境界。像最小的孩子，他可能就是自然的境界，饿了就哭，想喝奶了手就一勾一勾地骚动。其实就是动物的本能反应，也就是自然的境界。小孩子嘛，就是丰衣足食，没有焦虑。那么什么时候会脱离自然境界呢？\n\n大概大家都有这样的经历，就是上小学时，考砸了，回去爸妈问起来直接进行一个谎报，39说成93。其实这时候，我们已经是“成了人了”，已经脱离了自然境界，因为这个世界上只有人才骗人，猪就从来不骗人。\n\n\n# 功利境界\n\n第二种境界其实是大多数人的境界，从自然的境界提升到功利的境界。可以说，功利境界是这个世界上至少90%以上的人的境界。所谓功利境界，就是我们所有的行为，所有的努力都是为了获得报酬的一种境界，要有结果，而且是对我有利的结果的那种境界。比如好好学习是为了考研，或者便于将来搞研究，总之要有好处，没有好处是不会努力的。\n\n那这么看功利的境界是不是有点自私是吧？首先功利境界是绝大多数人的境界，虽然有点自私，但也同样可以干出很多伟大的事业。就不说曹操，比如唐太宗，他都不是说很高的道德，他都把他的兄弟都杀了，为了自己当皇帝。但他也干出很多了不起的、惊天动地的大事业。即使像民族英雄岳飞，他在词中间表现出来的也是功利的境界，比如说他有首小词叫《小重山》：\n\n> 昨夜寒蛩不住鸣。 惊回千里梦，已三更。 起来独自绕阶行。 人悄悄，帘外月胧明。\n> \n> 白首为功名。 旧山松竹老，阻归程。 欲将心事付瑶琴。 知音少，弦断有谁听？\n\n还有辛弃疾的《破阵子》：\n\n> 醉里挑灯看剑，梦回吹角连营。八百里分麾下炙，五十弦翻塞外声，沙场秋点兵。\n> \n> 马作的卢飞快，弓如霹雳弦惊。了却君王天下事，赢得生前身后名。可怜白发生！\n\n他为什么要统一国家，为什么要金戈铁马？“赢得生前身后名”。要么为了名，要么为了利，这就是功利的境界。功利的境界可以做出许多伟大的事业，是自私，但黑格尔说过：“推动历史前进的内在的动功，不是人类的仁慈善良，而是人类的贪婪、恶，人类的自私，它才具有强大的动力推动历史的前进”。所以，功利的境界只要用得好，可以干出惊天动地的伟大的事业。\n\n\n# 道德境界\n\n道德的境界，就是比较高尚的境界了。道德境界里，个人的行为不是为了对自己有利，而是为了他人有利，是为了爱。仁慈善良，爱他人、爱民族、爱祖国，这些就是道德的境界。\n\n那有谁达到了这个境界呢？中国历史上比如屈原、杜甫、苏东坡，他们都达到了道德的境界。以杜甫为例，他总是把自己的命运跟自己的名族和国家紧紧地连在一起。就和白居易不一样，就说写的新乐府比如：《卖炭翁》、《上阳白发人》，白居易表现出来的是爱国、同情劳动人民的疾苦，但在同情劳动人民的疾苦里没有自己的影子。后来白居易被贬官，在消沉、苦闷的时候，像《琵琶行》这类的代表作，就感叹自己的不幸：“同是天涯沦落人，相逢何必曾相识”。杜甫不一样，他在自己的诗歌中总是把自己的国家、民族和个人的命运紧紧的连在一起。就像他的《春望》，除了他写得好之外，这首诗确实崇高：\n\n> 国破山河在，城春草木深。\n> \n> 感时花溅泪，恨别鸟惊心。\n> \n> 烽火连三月，家书抵万金。\n> \n> 白头搔更短，浑欲不胜簪。",normalizedContent:"我们常常指责人说这个人境界很低，这个人很俗，境界太低。那么一个人的境界，它和一个人的胸襟、格调、气度、他的修养修为都连在一起的。那么什么是人生境界？汉语中间的境界，大概有这么几种意思：境界的本意是指疆界、边疆，后来指范围，后来又指情景。今天说的这个境界是指人生境界，人生境界就是一个人的精神、品格、觉解（觉悟的觉，理解的解）所达到的程度。而且要把自己的精神境界和觉解达到的这种程度在自己的人生，在自己的生命中间把它呈现出来，那个呈现出来的状态，就是境界。\n\n境界，是属于本体论，或者说存在论的范畴，它不是能力学的范畴，它也不是认识论的范畴。境界是“体”，修为（修养）是“用”。在中国古代哲学中间有体有用，境界就是属于体，修养、实践就是用。还有境界和功夫，功夫也是用，就是我们在达到某种境界的过程中间，那种努功这种过程我们就叫功夫，达到的结果，那个状态就是境界。\n\n在中国古代，人生境界分为很多种，比方说有人把人生境界分为九种，分的很繁琐，有人分为七种，有人分为八种。著名哲学家，新儒学的代表人物之一，冯友兰先生的“贞元六书”中有一本书叫《新原人》，这本书中有一篇文章叫《境界》，再这篇文章中，冯友兰先生把人生境界分为四种：第一种是自然的境界、第二种是功利的境界、第三种是道德的境界、第四种是天地的境界。就有点像马斯洛的人生有四（五）个内在的需要，马斯洛先生说在这五种境界中最高的是人生自我价值实现的需要。但冯友兰先生我认为他说的更好，他则说境界分四种：自然、功利、道德、天地。\n\n\n# 自然境界\n\n自然境界其实就是人的本能的境界，吃喝拉撒。说白了就是人的动物的这种境界。其实有很多人，哪怕已经几十岁了，他的人生需求、他的追求，求还没有超越穿衣吃饭的这个层次，基本上还是限制在自然的境界。像最小的孩子，他可能就是自然的境界，饿了就哭，想喝奶了手就一勾一勾地骚动。其实就是动物的本能反应，也就是自然的境界。小孩子嘛，就是丰衣足食，没有焦虑。那么什么时候会脱离自然境界呢？\n\n大概大家都有这样的经历，就是上小学时，考砸了，回去爸妈问起来直接进行一个谎报，39说成93。其实这时候，我们已经是“成了人了”，已经脱离了自然境界，因为这个世界上只有人才骗人，猪就从来不骗人。\n\n\n# 功利境界\n\n第二种境界其实是大多数人的境界，从自然的境界提升到功利的境界。可以说，功利境界是这个世界上至少90%以上的人的境界。所谓功利境界，就是我们所有的行为，所有的努力都是为了获得报酬的一种境界，要有结果，而且是对我有利的结果的那种境界。比如好好学习是为了考研，或者便于将来搞研究，总之要有好处，没有好处是不会努力的。\n\n那这么看功利的境界是不是有点自私是吧？首先功利境界是绝大多数人的境界，虽然有点自私，但也同样可以干出很多伟大的事业。就不说曹操，比如唐太宗，他都不是说很高的道德，他都把他的兄弟都杀了，为了自己当皇帝。但他也干出很多了不起的、惊天动地的大事业。即使像民族英雄岳飞，他在词中间表现出来的也是功利的境界，比如说他有首小词叫《小重山》：\n\n> 昨夜寒蛩不住鸣。 惊回千里梦，已三更。 起来独自绕阶行。 人悄悄，帘外月胧明。\n> \n> 白首为功名。 旧山松竹老，阻归程。 欲将心事付瑶琴。 知音少，弦断有谁听？\n\n还有辛弃疾的《破阵子》：\n\n> 醉里挑灯看剑，梦回吹角连营。八百里分麾下炙，五十弦翻塞外声，沙场秋点兵。\n> \n> 马作的卢飞快，弓如霹雳弦惊。了却君王天下事，赢得生前身后名。可怜白发生！\n\n他为什么要统一国家，为什么要金戈铁马？“赢得生前身后名”。要么为了名，要么为了利，这就是功利的境界。功利的境界可以做出许多伟大的事业，是自私，但黑格尔说过：“推动历史前进的内在的动功，不是人类的仁慈善良，而是人类的贪婪、恶，人类的自私，它才具有强大的动力推动历史的前进”。所以，功利的境界只要用得好，可以干出惊天动地的伟大的事业。\n\n\n# 道德境界\n\n道德的境界，就是比较高尚的境界了。道德境界里，个人的行为不是为了对自己有利，而是为了他人有利，是为了爱。仁慈善良，爱他人、爱民族、爱祖国，这些就是道德的境界。\n\n那有谁达到了这个境界呢？中国历史上比如屈原、杜甫、苏东坡，他们都达到了道德的境界。以杜甫为例，他总是把自己的命运跟自己的名族和国家紧紧地连在一起。就和白居易不一样，就说写的新乐府比如：《卖炭翁》、《上阳白发人》，白居易表现出来的是爱国、同情劳动人民的疾苦，但在同情劳动人民的疾苦里没有自己的影子。后来白居易被贬官，在消沉、苦闷的时候，像《琵琶行》这类的代表作，就感叹自己的不幸：“同是天涯沦落人，相逢何必曾相识”。杜甫不一样，他在自己的诗歌中总是把自己的国家、民族和个人的命运紧紧的连在一起。就像他的《春望》，除了他写得好之外，这首诗确实崇高：\n\n> 国破山河在，城春草木深。\n> \n> 感时花溅泪，恨别鸟惊心。\n> \n> 烽火连三月，家书抵万金。\n> \n> 白头搔更短，浑欲不胜簪。",charsets:{cjk:!0},createdTime:1655628697e3},{title:"Idea",frontmatter:{title:"Idea",date:"2022-03-27T13:44:15.000Z",tags:["Idea"],categories:["Idea"],publish:!1,readingShow:"top"},regularPath:"/Idea/",relativePath:"Idea/README.md",key:"v-a67c1470",path:"/Idea/",lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:null,content:" * 爱情\n * 人生境界究竟指什么\n * 青年节前夕...",normalizedContent:" * 爱情\n * 人生境界究竟指什么\n * 青年节前夕...",charsets:{cjk:!0},createdTime:1655628697e3},{title:"王小波",frontmatter:{title:"王小波",date:"2022-05-23T13:44:15.000Z",tags:["Idea","王小波"],categories:["Idea"],publish:!1,readingShow:"top"},regularPath:"/Idea/%E7%8E%8B%E5%B0%8F%E6%B3%A2/",relativePath:"Idea/王小波/README.md",key:"v-3dc3c778",path:"/Idea/%E7%8E%8B%E5%B0%8F%E6%B3%A2/",lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:null,content:" * 《黄金时代》\n   \n   > 那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。 后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。\n\n",normalizedContent:" * 《黄金时代》\n   \n   > 那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。 后来我才知道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。\n\n",charsets:{cjk:!0},createdTime:1655628697e3},{title:"并发编程面临的挑战",frontmatter:{title:"并发编程面临的挑战",description:"并发编程面临的挑战",date:"2022-03-27T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/01%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98.html",relativePath:"Java/Java并发编程的艺术/01、并发编程面临的挑战.md",key:"v-bdcf9946",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/01%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E9%9D%A2%E4%B8%B4%E7%9A%84%E6%8C%91%E6%88%98.html",headers:[{level:2,title:"并发编程面临的挑战",slug:"并发编程面临的挑战",normalizedTitle:"并发编程面临的挑战",charIndex:4},{level:2,title:"1. 应该了解的概念",slug:"_1-应该了解的概念",normalizedTitle:"1. 应该了解的概念",charIndex:33},{level:3,title:"1.1 同步VS异步",slug:"_1-1-同步vs异步",normalizedTitle:"1.1 同步vs异步",charIndex:49},{level:3,title:"1.2 并发与并行",slug:"_1-2-并发与并行",normalizedTitle:"1.2 并发与并行",charIndex:65},{level:3,title:"1.3 阻塞和非阻塞",slug:"_1-3-阻塞和非阻塞",normalizedTitle:"1.3 阻塞和非阻塞",charIndex:80},{level:3,title:"1.4 临界区",slug:"_1-4-临界区",normalizedTitle:"1.4 临界区",charIndex:96},{level:2,title:"2. 为什么要用到并发",slug:"_2-为什么要用到并发",normalizedTitle:"2. 为什么要用到并发",charIndex:107},{level:2,title:"3. 并发编程有哪些缺点（面临的挑战）",slug:"_3-并发编程有哪些缺点-面临的挑战",normalizedTitle:"3. 并发编程有哪些缺点（面临的挑战）",charIndex:122},{level:3,title:"3.1 频繁的上下文切换",slug:"_3-1-频繁的上下文切换",normalizedTitle:"3.1 频繁的上下文切换",charIndex:147},{level:3,title:"3.2 线程安全",slug:"_3-2-线程安全",normalizedTitle:"3.2 线程安全",charIndex:165},{level:3,title:"3.3 资源限制的挑战",slug:"_3-3-资源限制的挑战",normalizedTitle:"3.3 资源限制的挑战",charIndex:179}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>并发编程面临的挑战</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"并发编程面临的挑战 1. 应该了解的概念 1.1 同步VS异步 1.2 并发与并行 1.3 阻塞和非阻塞 1.4 临界区 2. 为什么要用到并发 3. 并发编程有哪些缺点（面临的挑战） 3.1 频繁的上下文切换 3.2 线程安全 3.3 资源限制的挑战",content:'说明\n\n并发编程面临的挑战\n\n\n\n * 并发编程面临的挑战\n * 1. 应该了解的概念\n   * 1.1 同步VS异步\n   * 1.2 并发与并行\n   * 1.3 阻塞和非阻塞\n   * 1.4 临界区\n * 2. 为什么要用到并发\n * 3. 并发编程有哪些缺点（面临的挑战）\n   * 3.1 频繁的上下文切换\n   * 3.2 线程安全\n   * 3.3 资源限制的挑战\n\n\n\n\n# 并发编程面临的挑战\n\n\n# 1. 应该了解的概念\n\n一直以来并发编程对于刚入行的小白来说总是觉得高深莫测，于是乎，就诞生了想写点东西记录下，以提升理解和堆并发编程的认知。为什么需要用的并发？凡事总有好坏两面，之间的trade-off是什么，也就是说并发编程具有哪些缺点？以及在进行并发编程时应该了解和掌握的概念是什么？这篇文章主要以这三个问题来谈一谈。\n\n\n# 1.1 同步VS异步\n\n同步和异步通常用来形容一次方法调用。同步方法调用一开始，调用者必须等待被调用的方法结束后，调用者后面的代码才能执行。而异步调用，指的是，调用者不用管被调用方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者。比如，在超时购物，如果一件物品没了，你得等仓库人员跟你调货，直到仓库人员跟你把货物送过来，你才能继续去收银台付款，这就类似同步调用。而异步调用了，就像网购，你在网上付款下单后，什么事就不用管了，该干嘛就干嘛去了，当货物到达后你收到通知去取就好。\n\n\n# 1.2 并发与并行\n\n并发和并行是十分容易混淆的概念。并发指的是多个任务交替进行，而并行则是指真正意义上的“同时进行”。实际上，如果系统内只有一个CPU，而使用多线程时，那么真实系统环境下不能并行，只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个CPU的系统中。\n\n\n# 1.3 阻塞和非阻塞\n\n阻塞和非阻塞通常用来形容多线程间的相互影响，比如一个线程占有了临界区资源，那么其他线程需要这个资源就必须进行等待该资源的释放，会导致等待的线程挂起，这种情况就是阻塞，而非阻塞就恰好相反，它强调没有一个线程可以阻塞其他线程，所有的线程都会尝试地往前运行。\n\n\n# 1.4 临界区\n\n临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待。\n\n\n# 2. 为什么要用到并发\n\n一直以来，硬件的发展极其迅速，也有一个很著名的"摩尔定律"，可能会奇怪明明讨论的是并发编程为什么会扯到了硬件的发展，这其中的关系应该是多核CPU的发展为并发编程提供的硬件基础。摩尔定律并不是一种自然法则或者是物理定律，它只是基于认为观测数据后，对未来的一种预测。按照所预测的速度，我们的计算能力会按照指数级别的速度增长，不久以后会拥有超强的计算能力，正是在畅想未来的时候，2004年，Intel宣布4GHz芯片的计划推迟到2005年，然后在2004年秋季，Intel宣布彻底取消4GHz的计划，也就是说摩尔定律的有效性超过了半个世纪戛然而止。但是，聪明的硬件工程师并没有停止研发的脚步，他们为了进一步提升计算速度，而不是再追求单独的计算单元，而是将多个计算单元整合到了一起，也就是形成了多核CPU。短短十几年的时间，家用型CPU,比如Intel i7就可以达到4核心甚至8核心。而专业服务器则通常可以达到几个独立的CPU，每一个CPU甚至拥有多达8个以上的内核。因此，摩尔定律似乎在CPU核心扩展上继续得到体验。因此，多核的CPU的背景下，催生了并发编程的趋势，通过并发编程的形式可以将多核CPU的计算能力发挥到极致，性能得到提升。\n\n顶级计算机科学家Donald Ervin Knuth如此评价这种情况：在我看来，这种现象（并发）或多或少是由于硬件设计者无计可施了导致的，他们将摩尔定律的责任推给了软件开发者。\n\n另外，在特殊的业务场景下先天的就适合于并发编程。比如在图像处理领域，一张1024X768像素的图片，包含达到78万6千多个像素。即时将所有的像素遍历一边都需要很长的时间，面对如此复杂的计算量就需要充分利用多核的计算的能力。又比如当我们在网上购物时，为了提升响应速度，需要拆分，减库存，生成订单等等这些操作，就可以进行拆分利用多线程的技术完成。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。正是因为这些优点，使得多线程技术能够得到重视，也是一名CS学习者应该掌握的：\n\n * 充分利用多核CPU的计算能力；\n * 方便进行业务拆分，提升应用性能\n\n\n# 3. 并发编程有哪些缺点（面临的挑战）\n\n多线程技术有这么多的好处，难道就没有一点缺点么，就在任何场景下就一定适用么？很显然不是。\n\n\n# 3.1 频繁的上下文切换\n\n时间片是 CPU 分配给各个线程的时间，因为时间非常短，所以CPU不断通过切换线程，即使是单核 CPU ，也会让我们觉得多个线程是同时执行的，时间片一般是几十毫秒。而每次切换时，需要保存当前的状态起来，以便能够进行恢复先前状态，而这个切换时非常损耗性能，过于频繁反而无法发挥出多线程编程的优势。通常减少上下文切换可以采用无锁并发编程，CAS 算法，使用最少的线程和使用协程。\n\n * 无锁并发编程：可以参照 concurrentHashMap 锁分段的思想，不同的线程处理不同段的数据，这样在多线程竞争的条件下，可以减少上下文切换的时间。\n * CAS 算法，利用 Atomic 下使用 CAS 算法来更新数据，使用了乐观锁，可以有效的减少一部分不必要的锁竞争带来的上下文切换\n * 使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多的线程，这样会造成大量的线程都处于等待状态\n * 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换\n\n由于上下文切换也是个相对比较耗时的操作，所以在《java并发编程的艺术》一书中有过一个实验，并发累加未必会比串行累加速度要快。 可以使用Lmbench3测量上下文切换的时长 vmstat测量上下文切换次数\n\n\n# 3.2 线程安全\n\n多线程编程中最难以把握的就是临界区线程安全问题，稍微不注意就会出现死锁的情况，一旦产生死锁就会造成系统功能不可用。\n\npublic class DeadLockDemo {\n    private static String resource_a = "A";\n    private static String resource_b = "B";\n\n    public static void main(String[] args) {\n        deadLock();\n    }\n\n    public static void deadLock() {\n        Thread threadA = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                synchronized (resource_a) {\n                    System.out.println("get resource a");\n                    try {\n                        Thread.sleep(3000);\n                        synchronized (resource_b) {\n                            System.out.println("get resource b");\n                        }\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n        Thread threadB = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                synchronized (resource_b) {\n                    System.out.println("get resource b");\n                    synchronized (resource_a) {\n                        System.out.println("get resource a");\n                    }\n                }\n            }\n        });\n        threadA.start();\n        threadB.start();\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n在上面的这个demo中，开启了两个线程threadA, threadB,其中threadA占用了resource_a, 并等待被threadB释放的resource _b。threadB占用了resource _b正在等待被threadA释放的resource _a。因此threadA,threadB出现线程安全的问题，形成死锁。同样可以通过jps，jstack证明这种推论：\n\n"Thread-1":\n  waiting to lock monitor 0x000000000b695360 (object 0x00000007d5ff53a8, a java.lang.String),\n  which is held by "Thread-0"\n"Thread-0":\n  waiting to lock monitor 0x000000000b697c10 (object 0x00000007d5ff53d8, a java.lang.String),\n  which is held by "Thread-1"\n\nJava stack information for the threads listed above:\n===================================================\n"Thread-1":\n        at learn.DeadLockDemo$2.run(DeadLockDemo.java:34)\n        - waiting to lock <0x00000007d5ff53a8(a java.lang.String)\n        - locked <0x00000007d5ff53d8(a java.lang.String)\n        at java.lang.Thread.run(Thread.java:722)\n"Thread-0":\n        at learn.DeadLockDemo$1.run(DeadLockDemo.java:20)\n        - waiting to lock <0x00000007d5ff53d8(a java.lang.String)\n        - locked <0x00000007d5ff53a8(a java.lang.String)\n        at java.lang.Thread.run(Thread.java:722)\n\nFound 1 deadlock.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n如上所述，完全可以看出当前死锁的情况。\n\n那么，通常可以用如下方式避免死锁的情况：\n\n 1. 避免一个线程同时获得多个锁；\n 2. 避免一个线程在锁内部占有多个资源，尽量保证每个锁只占用一个资源；\n 3. 尝试使用定时锁，使用lock.tryLock(timeOut)，当超时等待时当前线程不会阻塞；\n 4. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况\n\n所以，如何正确的使用多线程编程技术有很大的学问，比如如何保证线程安全，如何正确理解由于JMM内存模型在原子性，有序性，可见性带来的问题，比如数据脏读，DCL等这些问题（在后续篇幅会讲述）。而在学习多线程编程技术的过程中也会让你收获颇丰。\n\n\n# 3.3 资源限制的挑战\n\n（1）什么是资源限制\n\n资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。例如，服务器的带宽只有2Mb/s，某个资源的下载速度是1Mb/s每秒，系统启动10个线程下载资源，下载速度不会变成10Mb/s，所以在进行并发编程时，要考虑这些资源的限制。硬件资源限制有带宽的上传/下载速度、硬盘读写速度和CPU的处理速度。软件资源限制有数据库的连接数和socket连接数等。\n\n（2）资源限制引发的问题\n\n在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。例如，之前看到一段程序使用多线程在办公网并发地下载和处理数据时，导致CPU利用率达到100%，几个小时都不能运行完成任务，后来修改成单线程，一个小时就执行完成了。\n\n（3）如何解决资源限制的问题\n\n对于硬件资源限制，可以考虑使用集群并行执行程序。既然单机的资源有限制，那么就让程序在多机上运行。比如使用ODPS、Hadoop或者自己搭建服务器集群，不同的机器处理不同的数据。可以通过“数据ID%机器数”，计算得到一个机器编号，然后由对应编号的机器处理这笔数据。\n\n对于软件资源限制，可以考虑使用资源池将资源复用。比如使用连接池将数据库和Socket连接复用，或者在调用对方webservice接口获取数据时，只建立一个连接。\n\n（4）在资源限制情况下进行并发编程\n\n如何在资源限制的情况下，让程序执行得更快呢？方法就是，根据不同的资源限制调整程序的并发度，比如下载文件程序依赖于两个资源——带宽和硬盘读写速度。有数据库操作时，涉及数据库连接数，如果SQL语句执行非常快，而线程的数量比数据库连接数大很多，则某些线程会被阻塞，等待数据库连接。\n\n> 参考文献\n\n《java并发编程的艺术》',normalizedContent:'说明\n\n并发编程面临的挑战\n\n\n\n * 并发编程面临的挑战\n * 1. 应该了解的概念\n   * 1.1 同步vs异步\n   * 1.2 并发与并行\n   * 1.3 阻塞和非阻塞\n   * 1.4 临界区\n * 2. 为什么要用到并发\n * 3. 并发编程有哪些缺点（面临的挑战）\n   * 3.1 频繁的上下文切换\n   * 3.2 线程安全\n   * 3.3 资源限制的挑战\n\n\n\n\n# 并发编程面临的挑战\n\n\n# 1. 应该了解的概念\n\n一直以来并发编程对于刚入行的小白来说总是觉得高深莫测，于是乎，就诞生了想写点东西记录下，以提升理解和堆并发编程的认知。为什么需要用的并发？凡事总有好坏两面，之间的trade-off是什么，也就是说并发编程具有哪些缺点？以及在进行并发编程时应该了解和掌握的概念是什么？这篇文章主要以这三个问题来谈一谈。\n\n\n# 1.1 同步vs异步\n\n同步和异步通常用来形容一次方法调用。同步方法调用一开始，调用者必须等待被调用的方法结束后，调用者后面的代码才能执行。而异步调用，指的是，调用者不用管被调用方法是否完成，都会继续执行后面的代码，当被调用的方法完成后会通知调用者。比如，在超时购物，如果一件物品没了，你得等仓库人员跟你调货，直到仓库人员跟你把货物送过来，你才能继续去收银台付款，这就类似同步调用。而异步调用了，就像网购，你在网上付款下单后，什么事就不用管了，该干嘛就干嘛去了，当货物到达后你收到通知去取就好。\n\n\n# 1.2 并发与并行\n\n并发和并行是十分容易混淆的概念。并发指的是多个任务交替进行，而并行则是指真正意义上的“同时进行”。实际上，如果系统内只有一个cpu，而使用多线程时，那么真实系统环境下不能并行，只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个cpu的系统中。\n\n\n# 1.3 阻塞和非阻塞\n\n阻塞和非阻塞通常用来形容多线程间的相互影响，比如一个线程占有了临界区资源，那么其他线程需要这个资源就必须进行等待该资源的释放，会导致等待的线程挂起，这种情况就是阻塞，而非阻塞就恰好相反，它强调没有一个线程可以阻塞其他线程，所有的线程都会尝试地往前运行。\n\n\n# 1.4 临界区\n\n临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。但是每个线程使用时，一旦临界区资源被一个线程占有，那么其他线程必须等待。\n\n\n# 2. 为什么要用到并发\n\n一直以来，硬件的发展极其迅速，也有一个很著名的"摩尔定律"，可能会奇怪明明讨论的是并发编程为什么会扯到了硬件的发展，这其中的关系应该是多核cpu的发展为并发编程提供的硬件基础。摩尔定律并不是一种自然法则或者是物理定律，它只是基于认为观测数据后，对未来的一种预测。按照所预测的速度，我们的计算能力会按照指数级别的速度增长，不久以后会拥有超强的计算能力，正是在畅想未来的时候，2004年，intel宣布4ghz芯片的计划推迟到2005年，然后在2004年秋季，intel宣布彻底取消4ghz的计划，也就是说摩尔定律的有效性超过了半个世纪戛然而止。但是，聪明的硬件工程师并没有停止研发的脚步，他们为了进一步提升计算速度，而不是再追求单独的计算单元，而是将多个计算单元整合到了一起，也就是形成了多核cpu。短短十几年的时间，家用型cpu,比如intel i7就可以达到4核心甚至8核心。而专业服务器则通常可以达到几个独立的cpu，每一个cpu甚至拥有多达8个以上的内核。因此，摩尔定律似乎在cpu核心扩展上继续得到体验。因此，多核的cpu的背景下，催生了并发编程的趋势，通过并发编程的形式可以将多核cpu的计算能力发挥到极致，性能得到提升。\n\n顶级计算机科学家donald ervin knuth如此评价这种情况：在我看来，这种现象（并发）或多或少是由于硬件设计者无计可施了导致的，他们将摩尔定律的责任推给了软件开发者。\n\n另外，在特殊的业务场景下先天的就适合于并发编程。比如在图像处理领域，一张1024x768像素的图片，包含达到78万6千多个像素。即时将所有的像素遍历一边都需要很长的时间，面对如此复杂的计算量就需要充分利用多核的计算的能力。又比如当我们在网上购物时，为了提升响应速度，需要拆分，减库存，生成订单等等这些操作，就可以进行拆分利用多线程的技术完成。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。正是因为这些优点，使得多线程技术能够得到重视，也是一名cs学习者应该掌握的：\n\n * 充分利用多核cpu的计算能力；\n * 方便进行业务拆分，提升应用性能\n\n\n# 3. 并发编程有哪些缺点（面临的挑战）\n\n多线程技术有这么多的好处，难道就没有一点缺点么，就在任何场景下就一定适用么？很显然不是。\n\n\n# 3.1 频繁的上下文切换\n\n时间片是 cpu 分配给各个线程的时间，因为时间非常短，所以cpu不断通过切换线程，即使是单核 cpu ，也会让我们觉得多个线程是同时执行的，时间片一般是几十毫秒。而每次切换时，需要保存当前的状态起来，以便能够进行恢复先前状态，而这个切换时非常损耗性能，过于频繁反而无法发挥出多线程编程的优势。通常减少上下文切换可以采用无锁并发编程，cas 算法，使用最少的线程和使用协程。\n\n * 无锁并发编程：可以参照 concurrenthashmap 锁分段的思想，不同的线程处理不同段的数据，这样在多线程竞争的条件下，可以减少上下文切换的时间。\n * cas 算法，利用 atomic 下使用 cas 算法来更新数据，使用了乐观锁，可以有效的减少一部分不必要的锁竞争带来的上下文切换\n * 使用最少线程：避免创建不需要的线程，比如任务很少，但是创建了很多的线程，这样会造成大量的线程都处于等待状态\n * 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换\n\n由于上下文切换也是个相对比较耗时的操作，所以在《java并发编程的艺术》一书中有过一个实验，并发累加未必会比串行累加速度要快。 可以使用lmbench3测量上下文切换的时长 vmstat测量上下文切换次数\n\n\n# 3.2 线程安全\n\n多线程编程中最难以把握的就是临界区线程安全问题，稍微不注意就会出现死锁的情况，一旦产生死锁就会造成系统功能不可用。\n\npublic class deadlockdemo {\n    private static string resource_a = "a";\n    private static string resource_b = "b";\n\n    public static void main(string[] args) {\n        deadlock();\n    }\n\n    public static void deadlock() {\n        thread threada = new thread(new runnable() {\n            @override\n            public void run() {\n                synchronized (resource_a) {\n                    system.out.println("get resource a");\n                    try {\n                        thread.sleep(3000);\n                        synchronized (resource_b) {\n                            system.out.println("get resource b");\n                        }\n                    } catch (interruptedexception e) {\n                        e.printstacktrace();\n                    }\n                }\n            }\n        });\n        thread threadb = new thread(new runnable() {\n            @override\n            public void run() {\n                synchronized (resource_b) {\n                    system.out.println("get resource b");\n                    synchronized (resource_a) {\n                        system.out.println("get resource a");\n                    }\n                }\n            }\n        });\n        threada.start();\n        threadb.start();\n\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n在上面的这个demo中，开启了两个线程threada, threadb,其中threada占用了resource_a, 并等待被threadb释放的resource _b。threadb占用了resource _b正在等待被threada释放的resource _a。因此threada,threadb出现线程安全的问题，形成死锁。同样可以通过jps，jstack证明这种推论：\n\n"thread-1":\n  waiting to lock monitor 0x000000000b695360 (object 0x00000007d5ff53a8, a java.lang.string),\n  which is held by "thread-0"\n"thread-0":\n  waiting to lock monitor 0x000000000b697c10 (object 0x00000007d5ff53d8, a java.lang.string),\n  which is held by "thread-1"\n\njava stack information for the threads listed above:\n===================================================\n"thread-1":\n        at learn.deadlockdemo$2.run(deadlockdemo.java:34)\n        - waiting to lock <0x00000007d5ff53a8(a java.lang.string)\n        - locked <0x00000007d5ff53d8(a java.lang.string)\n        at java.lang.thread.run(thread.java:722)\n"thread-0":\n        at learn.deadlockdemo$1.run(deadlockdemo.java:20)\n        - waiting to lock <0x00000007d5ff53d8(a java.lang.string)\n        - locked <0x00000007d5ff53a8(a java.lang.string)\n        at java.lang.thread.run(thread.java:722)\n\nfound 1 deadlock.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n如上所述，完全可以看出当前死锁的情况。\n\n那么，通常可以用如下方式避免死锁的情况：\n\n 1. 避免一个线程同时获得多个锁；\n 2. 避免一个线程在锁内部占有多个资源，尽量保证每个锁只占用一个资源；\n 3. 尝试使用定时锁，使用lock.trylock(timeout)，当超时等待时当前线程不会阻塞；\n 4. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况\n\n所以，如何正确的使用多线程编程技术有很大的学问，比如如何保证线程安全，如何正确理解由于jmm内存模型在原子性，有序性，可见性带来的问题，比如数据脏读，dcl等这些问题（在后续篇幅会讲述）。而在学习多线程编程技术的过程中也会让你收获颇丰。\n\n\n# 3.3 资源限制的挑战\n\n（1）什么是资源限制\n\n资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。例如，服务器的带宽只有2mb/s，某个资源的下载速度是1mb/s每秒，系统启动10个线程下载资源，下载速度不会变成10mb/s，所以在进行并发编程时，要考虑这些资源的限制。硬件资源限制有带宽的上传/下载速度、硬盘读写速度和cpu的处理速度。软件资源限制有数据库的连接数和socket连接数等。\n\n（2）资源限制引发的问题\n\n在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。例如，之前看到一段程序使用多线程在办公网并发地下载和处理数据时，导致cpu利用率达到100%，几个小时都不能运行完成任务，后来修改成单线程，一个小时就执行完成了。\n\n（3）如何解决资源限制的问题\n\n对于硬件资源限制，可以考虑使用集群并行执行程序。既然单机的资源有限制，那么就让程序在多机上运行。比如使用odps、hadoop或者自己搭建服务器集群，不同的机器处理不同的数据。可以通过“数据id%机器数”，计算得到一个机器编号，然后由对应编号的机器处理这笔数据。\n\n对于软件资源限制，可以考虑使用资源池将资源复用。比如使用连接池将数据库和socket连接复用，或者在调用对方webservice接口获取数据时，只建立一个连接。\n\n（4）在资源限制情况下进行并发编程\n\n如何在资源限制的情况下，让程序执行得更快呢？方法就是，根据不同的资源限制调整程序的并发度，比如下载文件程序依赖于两个资源——带宽和硬盘读写速度。有数据库操作时，涉及数据库连接数，如果sql语句执行非常快，而线程的数量比数据库连接数大很多，则某些线程会被阻塞，等待数据库连接。\n\n> 参考文献\n\n《java并发编程的艺术》',charsets:{cjk:!0},createdTime:1655628697e3},{title:"《黄金时代》",frontmatter:{title:"《黄金时代》",date:"2022-05-25T13:44:15.000Z",tags:["Idea","黄金时代","王小波"],categories:["Idea"],readingShow:"top"},regularPath:"/Idea/%E7%8E%8B%E5%B0%8F%E6%B3%A2/%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3.html",relativePath:"Idea/王小波/黄金时代.md",key:"v-e8410f2c",path:"/Idea/%E7%8E%8B%E5%B0%8F%E6%B3%A2/%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3.html",headers:[{level:2,title:"性倒错和权力——追逐游戏",slug:"性倒错和权力-追逐游戏",normalizedTitle:"性倒错和权力——追逐游戏",charIndex:164},{level:2,title:"极限体验——非性化快感(SM)",slug:"极限体验-非性化快感-sm",normalizedTitle:"极限体验——非性化快感(sm)",charIndex:666},{level:2,title:"黄金时代——凝视深渊的思想者",slug:"黄金时代-凝视深渊的思想者",normalizedTitle:"黄金时代——凝视深渊的思想者",charIndex:1996}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">经典语录</p>\n<p>那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知 道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"性倒错和权力——追逐游戏 极限体验——非性化快感(SM) 黄金时代——凝视深渊的思想者",content:"经典语录\n\n那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知 道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。\n\n\n# 王小波x福柯\n\n\n# 性倒错和权力——追逐游戏\n\n福柯通过对性压抑假说和性话语爆炸的分析得出结论：现代社会的性与权力并不是二元对立的，性也不脱离于权力之外而存在，权力对性不是完全否定的、禁忌的、压制的，因为现代社会的性这个东西处于肉体和人口的交汇点，不是自然的，而是一种人为的把生理、情感、欲望、行为聚合在一起，通过语言、经验、知识、规则聚拢起来，组合到了一个叫做 “性” 的整体范畴之内，是一个缝合怪，是权力的产物，性在被构建的同时，它的本质功能就是调动人的欲望，谈论它、接近它、触发它、阐释它、解放它。\n\n所谓的性解放，就是那种把性视为一种自然的东西，并且通过性去发掘人的本质去彰显反抗，只不过都是幻影，任何围绕着性的努力都是徒劳的，性是权力的创造物。人们谈论得越多，话语越丰富，权力的约束机制就越强，控制的就越多。我们总以为性在话语之外，唯有解除障碍、消除秘密才能打通直达性的道路，但恰恰相反，这种机制让谈论性既是困难的又是必须的，既是危险的又是重要的。\n\n那权力为什么要这么做，目的就是掩盖，掩盖它的无处不在。权力创造出了这样一个看上去它无能为力的漏洞，就是为了要表示它的能力有限，但其实权力存在于每一个角落\n\n\n# 极限体验——非性化快感(SM)\n\n这个人类寻找真实自己的可能性，就是王小波《黄金时代》故事中陈清扬爱上王二的原因，也是《革命时期的爱情》中海鹰的快乐源泉，更是福柯这位思想家哲学家的生死爱欲——SM，施虐与受虐。\n\n到这里可能有疑惑：前面不是刚说性是徒劳的吗？为什么又说施虐受虐是摆脱权力控制的可能呢？其实不矛盾，《福柯的生死爱欲》有段话是这么说的：\n\n> 人们的目标不应定在生殖器官欲望的解放上，而应定在某种不以性规范为基础的一般的快感系统上，使自己的肉体成为一个产生极其多样的快感的场所，同时又使它摆脱对生殖器官的依赖。\n\n其实福柯这里说的就是“快感的非性化”，而福柯在这里的大前提并没有变，他是说人如果想抵抗权力的规训，想去寻找所谓的“真实”，不能通过思维也不能通过实验去获得，必须要回归到肉体本身。因为权力可以改造人的思想、语言、文化，可以改造社会结构，但是人的这个身体是最真实的，由身体所带来的体验是最真实的，所以通过肉体的体验人才能够最接近真实。\n\n但肉体当中性那一部分已经被规训了，已经是一个社会产物，它不是自然的属于人的东西，所以这里福柯主张非性的肉体体验。也就是不再通过人的生殖器官，而是利用人身体的其他部位去体验一种极限感受，而这种最极限的感受，就是SM施虐与受虐。福柯说：\n\n> 这一活动，人们可以通过有益的探索，快感-痛苦的缓慢运动来进行，来来回回的摇摆。从痛苦的感觉滑向快乐的感觉然后再滑回来，任由种种陌生的知觉一浪一浪的冲击自己，肉体的所有习惯倾向似乎都陷于崩溃。\n\n其实到这里相信大多数人也只能在思维层面上想象一下上面福柯说的话，毕竟没有多少人能真正达到福柯这种地步吧，当然即便想去了解福柯也不推荐大家去模仿。（福柯死于艾滋病）\n\n话说回来，这种由痛苦产生的愉悦的体验，相信大家也应该都知道，酸甜苦辣，辣其实是痛觉，之所以人们乐于吃辣，因为吃辣会骗取我们大脑分泌一种叫内啡肽的止痛物质，也正是这个，辣才如此上头。但吃辣可能只是一种低阶的（受虐）感受。不过还有科学证明，人们在性高潮的时候，大脑中也会分泌内源性鸦片物质内啡肽。\n\n福柯在这里暗含的意思是，我们的性器官所带来的性欲的调动其实也是一种社会产物。也就是权力不单塑造了人的语言和思维，它更可以影响人的生理功能，我们的性器官不过是权力作用于人体的一个点而已（其实也不无道理，人为什么偏偏就莫名其妙对那两个器官产生兴趣，有没有可能是成长进化过程中潜移默化的结果，就和审美一样受环境影响，只是这种影响在很长一段时间里都没有变化）。\n\n> 在谈论SM时，人们会感到一种词汇的贫乏，可以用来形容那种痛苦感觉的词太少了，这种感受能够成功的勾销千百年历史在人身体内留下的印记。\n\n权力是潜藏在话语当中的，而上面这段话里，这种极限的施虐受虐体验，语言会感到贫乏，也就是这种感受到达了一种语言的荒芜之地，如果语言没有，那是不是意味着权力也就无法到场呢？所以上面说“能够成功的勾销千百年历史在人身体内留下的印记”。到这里我们发现了一条线索，就是这种极限的肉体体验，它超越了语言的形容范围，它超越了权力的解释能力，这种状态下权力就缺席了。这个时刻权力会很茫然，表现出一种刚愎与执拗的窘态。\n\n\n# 黄金时代——凝视深渊的思想者\n\n通过对福柯的了解以及前面对性和权力的两层关系的解读，我们知道第一层：性-反抗-权力，是虚幻的、徒劳的，而到了第二层：性-象征-权力，也可以解释，这就是规训的结果，权力把人塑造成了一个个驯顺且实用的人，人自愿的受到控制。可是在《黄金时代》这个故事的结尾有一个情节又超越了这一层，就是陈清扬写的那篇交待材料。\n\n借助福柯我们再去回看王小波的小说，会发现王小波的小说当中有非常多的很典型的权力关系场域：警察与犯人、老师与学生、医生与病人、审讯者与被审者，尤其是审讯与供认出现得最多。在《黄金时代》这个故事中，几乎所有的故事情节都是由王二和陈清扬写交待材料呈现出来的，这就是一个很典型的权力关系场域。福柯在《性经验史》中考察欧洲的基督教历史，他说忏悔是一个非常 典型和重要的权力关系场域。而在《黄金时代》中，王二和陈清扬写交待材料支撑了故事的主线。福柯在《性经验史》中说：\n\n> 忏悔者被要求以种前所未闻的全面和独特的方式来审查自己的良心，仅仅说我和妻子以外的女人睡觉了，这还不够，你得说睡过多少次、采取了什么样的性行为、这个女人自己是否已婚，仅仅报告外在的行为还不够，思想和欲望也同等重要，即使没有实施出来。但是这种情况下，光说我想和妻子以外的女人睡觉也不够，你还得确定你是否老想着这事，是不是因此觉得愉悦，而不是立即打消了这个想法。如果你有此想法，是无意为之，还是得到了意志的完全批准。\n\n这简直和《黄金时代》中王二和陈清扬写交代材料的情节惊人的相似。在《黄金时代》故事的最后，陈清扬在交待材料里写她因为王二打了她屁股而爱上了王二。陈清扬这样说就表明这不是她无意为之，不是她一时糊涂，而是得到了意志的完全批准，因此陈清扬说这是她最真实的罪孽。注意王小波在这里的用词，他用的是“罪孽”，而不是“罪行”或者“犯罪”。“罪孽”是一个在忏悔的语境中才用的词。\n\n其实在《黄金时代》故事中，交待问题就是一种忏悔。在这个典型的权力场域里面，权力构建出了一套话语范畴：搞破鞋、偷汉子、色胆包天，忏悔者需要进入到这一套话语当中，按照这一套话语去自我反思去忏悔。所以王二说他以为军代表当上了土司而逃走，上面并不接受，上面说你们得写你们色胆包天，因为色胆包天的人什么都干得出来，这就是权力要求忏悔者进入它所构建的那一套话语范畴。可是这个权力所构建的话语范畴并不包括被人在屁股上打了一巴掌之后火烧火燎的感受，并不包括被人打了屁股而爱上了对方。受虐者的快感SM超越了当时权力所构建的话语范畴，超出了当时“由规定的自我审查所构建出的范畴”，所以上面一次又一次让陈清扬重写，还告诉她谁都不这样写材料。因为这一篇交代材料，虽然发生在“忏悔”这样一个权力关系场域，但是在那一时刻权力并不在场，权力缺席了。因为权力无法去捕捉那样的快感，权力也就无法用语言去解释，一旦失去了语言的范畴，权力也就无法潜藏其中无法实施对人的操控。而陈清扬说交待材料一个字都不能改，在这一时刻就是福柯所描述的权力出现了一种刚愎与执拗的窘态，对应在小说中就是所有看交待材料的人一个个都面红耳赤什么话都说不出来，这个时候在小说里权力第一次出现了一种真正意义上的无能为力，完全进入到了所谓知识的盲区，话语显得贫乏，监视也不再有用，陈清扬已经承认这是她最真实的罪孽，所以规训不再起作用，在那一时刻陈清扬是一个真正的站在 权力-知识-规训 这个体系之外的一个人。陈清扬的快乐，她的爱情，她所做的一切都来自于权力无法解释语言无法到达无法规训的东西，那这个时候权力还能把她怎么样呢？所以小说最后上面只好把他们给放了。\n\n用福柯的理论去尝试解读王小波的小说，并不是说王小波一定受到了福柯多大的影响，也不是说王小波的小说一定是按照福柯的理论来写的。只是觉得这两位：一个伟大的思想家、哲学家，一个当代中国非常重要且特殊的作家。他俩在思想的深处一定有那么一个交汇点，这个交汇点就是性爱与权力的关系、控制与被控制、施虐与受虐，一个相互追逐的权力游戏。\n\n王小波对特定时代的凝视与思考最终穿透了特定时代的限定，进入到了历史与权力自身。王小波他凝视的当然是文革那个特殊的时期，但是他确实也穿透了那个时期，他看到了权力的运作机制，这种追逐与控制的机制不光存在于那个特定的历史时期，还贯穿于整个人类的历史社会与文明当中，这就是王小波小说文字迷宫最深处摆放着的那个永恒旋转着的轮盘，这是一个权力的追逐游戏。",normalizedContent:"经典语录\n\n那一天我二十一岁，在我一生的黄金时代。我有好多奢望。我想爱，想吃，还想在一瞬间变成天上半明半暗的云。后来我才知 道，生活就是个缓慢受锤的过程，人一天天老下去，奢望也一天天消失，最后变得像挨了锤的牛一样。可是我过二十一岁生日时没有预见到这一点。我觉得自己会永远生猛下去，什么也锤不了我。\n\n\n# 王小波x福柯\n\n\n# 性倒错和权力——追逐游戏\n\n福柯通过对性压抑假说和性话语爆炸的分析得出结论：现代社会的性与权力并不是二元对立的，性也不脱离于权力之外而存在，权力对性不是完全否定的、禁忌的、压制的，因为现代社会的性这个东西处于肉体和人口的交汇点，不是自然的，而是一种人为的把生理、情感、欲望、行为聚合在一起，通过语言、经验、知识、规则聚拢起来，组合到了一个叫做 “性” 的整体范畴之内，是一个缝合怪，是权力的产物，性在被构建的同时，它的本质功能就是调动人的欲望，谈论它、接近它、触发它、阐释它、解放它。\n\n所谓的性解放，就是那种把性视为一种自然的东西，并且通过性去发掘人的本质去彰显反抗，只不过都是幻影，任何围绕着性的努力都是徒劳的，性是权力的创造物。人们谈论得越多，话语越丰富，权力的约束机制就越强，控制的就越多。我们总以为性在话语之外，唯有解除障碍、消除秘密才能打通直达性的道路，但恰恰相反，这种机制让谈论性既是困难的又是必须的，既是危险的又是重要的。\n\n那权力为什么要这么做，目的就是掩盖，掩盖它的无处不在。权力创造出了这样一个看上去它无能为力的漏洞，就是为了要表示它的能力有限，但其实权力存在于每一个角落\n\n\n# 极限体验——非性化快感(sm)\n\n这个人类寻找真实自己的可能性，就是王小波《黄金时代》故事中陈清扬爱上王二的原因，也是《革命时期的爱情》中海鹰的快乐源泉，更是福柯这位思想家哲学家的生死爱欲——sm，施虐与受虐。\n\n到这里可能有疑惑：前面不是刚说性是徒劳的吗？为什么又说施虐受虐是摆脱权力控制的可能呢？其实不矛盾，《福柯的生死爱欲》有段话是这么说的：\n\n> 人们的目标不应定在生殖器官欲望的解放上，而应定在某种不以性规范为基础的一般的快感系统上，使自己的肉体成为一个产生极其多样的快感的场所，同时又使它摆脱对生殖器官的依赖。\n\n其实福柯这里说的就是“快感的非性化”，而福柯在这里的大前提并没有变，他是说人如果想抵抗权力的规训，想去寻找所谓的“真实”，不能通过思维也不能通过实验去获得，必须要回归到肉体本身。因为权力可以改造人的思想、语言、文化，可以改造社会结构，但是人的这个身体是最真实的，由身体所带来的体验是最真实的，所以通过肉体的体验人才能够最接近真实。\n\n但肉体当中性那一部分已经被规训了，已经是一个社会产物，它不是自然的属于人的东西，所以这里福柯主张非性的肉体体验。也就是不再通过人的生殖器官，而是利用人身体的其他部位去体验一种极限感受，而这种最极限的感受，就是sm施虐与受虐。福柯说：\n\n> 这一活动，人们可以通过有益的探索，快感-痛苦的缓慢运动来进行，来来回回的摇摆。从痛苦的感觉滑向快乐的感觉然后再滑回来，任由种种陌生的知觉一浪一浪的冲击自己，肉体的所有习惯倾向似乎都陷于崩溃。\n\n其实到这里相信大多数人也只能在思维层面上想象一下上面福柯说的话，毕竟没有多少人能真正达到福柯这种地步吧，当然即便想去了解福柯也不推荐大家去模仿。（福柯死于艾滋病）\n\n话说回来，这种由痛苦产生的愉悦的体验，相信大家也应该都知道，酸甜苦辣，辣其实是痛觉，之所以人们乐于吃辣，因为吃辣会骗取我们大脑分泌一种叫内啡肽的止痛物质，也正是这个，辣才如此上头。但吃辣可能只是一种低阶的（受虐）感受。不过还有科学证明，人们在性高潮的时候，大脑中也会分泌内源性鸦片物质内啡肽。\n\n福柯在这里暗含的意思是，我们的性器官所带来的性欲的调动其实也是一种社会产物。也就是权力不单塑造了人的语言和思维，它更可以影响人的生理功能，我们的性器官不过是权力作用于人体的一个点而已（其实也不无道理，人为什么偏偏就莫名其妙对那两个器官产生兴趣，有没有可能是成长进化过程中潜移默化的结果，就和审美一样受环境影响，只是这种影响在很长一段时间里都没有变化）。\n\n> 在谈论sm时，人们会感到一种词汇的贫乏，可以用来形容那种痛苦感觉的词太少了，这种感受能够成功的勾销千百年历史在人身体内留下的印记。\n\n权力是潜藏在话语当中的，而上面这段话里，这种极限的施虐受虐体验，语言会感到贫乏，也就是这种感受到达了一种语言的荒芜之地，如果语言没有，那是不是意味着权力也就无法到场呢？所以上面说“能够成功的勾销千百年历史在人身体内留下的印记”。到这里我们发现了一条线索，就是这种极限的肉体体验，它超越了语言的形容范围，它超越了权力的解释能力，这种状态下权力就缺席了。这个时刻权力会很茫然，表现出一种刚愎与执拗的窘态。\n\n\n# 黄金时代——凝视深渊的思想者\n\n通过对福柯的了解以及前面对性和权力的两层关系的解读，我们知道第一层：性-反抗-权力，是虚幻的、徒劳的，而到了第二层：性-象征-权力，也可以解释，这就是规训的结果，权力把人塑造成了一个个驯顺且实用的人，人自愿的受到控制。可是在《黄金时代》这个故事的结尾有一个情节又超越了这一层，就是陈清扬写的那篇交待材料。\n\n借助福柯我们再去回看王小波的小说，会发现王小波的小说当中有非常多的很典型的权力关系场域：警察与犯人、老师与学生、医生与病人、审讯者与被审者，尤其是审讯与供认出现得最多。在《黄金时代》这个故事中，几乎所有的故事情节都是由王二和陈清扬写交待材料呈现出来的，这就是一个很典型的权力关系场域。福柯在《性经验史》中考察欧洲的基督教历史，他说忏悔是一个非常 典型和重要的权力关系场域。而在《黄金时代》中，王二和陈清扬写交待材料支撑了故事的主线。福柯在《性经验史》中说：\n\n> 忏悔者被要求以种前所未闻的全面和独特的方式来审查自己的良心，仅仅说我和妻子以外的女人睡觉了，这还不够，你得说睡过多少次、采取了什么样的性行为、这个女人自己是否已婚，仅仅报告外在的行为还不够，思想和欲望也同等重要，即使没有实施出来。但是这种情况下，光说我想和妻子以外的女人睡觉也不够，你还得确定你是否老想着这事，是不是因此觉得愉悦，而不是立即打消了这个想法。如果你有此想法，是无意为之，还是得到了意志的完全批准。\n\n这简直和《黄金时代》中王二和陈清扬写交代材料的情节惊人的相似。在《黄金时代》故事的最后，陈清扬在交待材料里写她因为王二打了她屁股而爱上了王二。陈清扬这样说就表明这不是她无意为之，不是她一时糊涂，而是得到了意志的完全批准，因此陈清扬说这是她最真实的罪孽。注意王小波在这里的用词，他用的是“罪孽”，而不是“罪行”或者“犯罪”。“罪孽”是一个在忏悔的语境中才用的词。\n\n其实在《黄金时代》故事中，交待问题就是一种忏悔。在这个典型的权力场域里面，权力构建出了一套话语范畴：搞破鞋、偷汉子、色胆包天，忏悔者需要进入到这一套话语当中，按照这一套话语去自我反思去忏悔。所以王二说他以为军代表当上了土司而逃走，上面并不接受，上面说你们得写你们色胆包天，因为色胆包天的人什么都干得出来，这就是权力要求忏悔者进入它所构建的那一套话语范畴。可是这个权力所构建的话语范畴并不包括被人在屁股上打了一巴掌之后火烧火燎的感受，并不包括被人打了屁股而爱上了对方。受虐者的快感sm超越了当时权力所构建的话语范畴，超出了当时“由规定的自我审查所构建出的范畴”，所以上面一次又一次让陈清扬重写，还告诉她谁都不这样写材料。因为这一篇交代材料，虽然发生在“忏悔”这样一个权力关系场域，但是在那一时刻权力并不在场，权力缺席了。因为权力无法去捕捉那样的快感，权力也就无法用语言去解释，一旦失去了语言的范畴，权力也就无法潜藏其中无法实施对人的操控。而陈清扬说交待材料一个字都不能改，在这一时刻就是福柯所描述的权力出现了一种刚愎与执拗的窘态，对应在小说中就是所有看交待材料的人一个个都面红耳赤什么话都说不出来，这个时候在小说里权力第一次出现了一种真正意义上的无能为力，完全进入到了所谓知识的盲区，话语显得贫乏，监视也不再有用，陈清扬已经承认这是她最真实的罪孽，所以规训不再起作用，在那一时刻陈清扬是一个真正的站在 权力-知识-规训 这个体系之外的一个人。陈清扬的快乐，她的爱情，她所做的一切都来自于权力无法解释语言无法到达无法规训的东西，那这个时候权力还能把她怎么样呢？所以小说最后上面只好把他们给放了。\n\n用福柯的理论去尝试解读王小波的小说，并不是说王小波一定受到了福柯多大的影响，也不是说王小波的小说一定是按照福柯的理论来写的。只是觉得这两位：一个伟大的思想家、哲学家，一个当代中国非常重要且特殊的作家。他俩在思想的深处一定有那么一个交汇点，这个交汇点就是性爱与权力的关系、控制与被控制、施虐与受虐，一个相互追逐的权力游戏。\n\n王小波对特定时代的凝视与思考最终穿透了特定时代的限定，进入到了历史与权力自身。王小波他凝视的当然是文革那个特殊的时期，但是他确实也穿透了那个时期，他看到了权力的运作机制，这种追逐与控制的机制不光存在于那个特定的历史时期，还贯穿于整个人类的历史社会与文明当中，这就是王小波小说文字迷宫最深处摆放着的那个永恒旋转着的轮盘，这是一个权力的追逐游戏。",charsets:{cjk:!0},createdTime:1655628697e3},{title:"线程的状态转换以及基本操作",frontmatter:{title:"线程的状态转换以及基本操作",description:"线程的状态转换以及基本操作《Java并发编程的艺术》",date:"2022-03-27T14:45:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/02%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html",relativePath:"Java/Java并发编程的艺术/02、线程的状态转换以及基本操作.md",key:"v-d0b6117a",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/02%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E4%BB%A5%E5%8F%8A%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html",headers:[{level:2,title:"线程的状态转换以及基本操作",slug:"线程的状态转换以及基本操作",normalizedTitle:"线程的状态转换以及基本操作",charIndex:4},{level:2,title:"1. 新建线程",slug:"_1-新建线程",normalizedTitle:"1. 新建线程",charIndex:41},{level:2,title:"2. 线程状态转换",slug:"_2-线程状态转换",normalizedTitle:"2. 线程状态转换",charIndex:52},{level:2,title:"3. 线程状态的基本操作",slug:"_3-线程状态的基本操作",normalizedTitle:"3. 线程状态的基本操作",charIndex:65},{level:3,title:"3.1. interrupted",slug:"_3-1-interrupted",normalizedTitle:"3.1. interrupted",charIndex:83},{level:3,title:"3.2. join",slug:"_3-2-join",normalizedTitle:"3.2. join",charIndex:105},{level:3,title:"3.3 sleep",slug:"_3-3-sleep",normalizedTitle:"3.3 sleep",charIndex:120},{level:3,title:"3.4 yield",slug:"_3-4-yield",normalizedTitle:"3.4 yield",charIndex:135},{level:2,title:"4.守护线程Daemon",slug:"_4-守护线程daemon",normalizedTitle:"4.守护线程daemon",charIndex:148}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>线程的状态转换以及基本操作</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"线程的状态转换以及基本操作 1. 新建线程 2. 线程状态转换 3. 线程状态的基本操作 3.1. interrupted 3.2. join 3.3 sleep 3.4 yield 4.守护线程Daemon",content:'说明\n\n线程的状态转换以及基本操作\n\n\n\n * 线程的状态转换以及基本操作\n * 1. 新建线程\n * 2. 线程状态转换\n * 3. 线程状态的基本操作\n   * 3.1. interrupted\n   * 3.2. join\n   * 3.3 sleep\n   * 3.4 yield\n * 4.守护线程Daemon\n\n\n\n\n# 线程的状态转换以及基本操作\n\n在上一篇文章并发编程面临的挑战中谈到了为什么花功夫去学习并发编程的技术，也就是说我们必须了解到并发编程的优缺点，我们在什么情况下可以去考虑开启多个线程去实现我们的业务，当然使用多线程我们应该着重注意一些什么，在上一篇文章中会有一些讨论。那么，说了这么多，无论是针对面试还是实际工作中作为一名软件开发人员都应该具备这样的技能。万事开头难，接下来就应该了解如何新建一个线程？线程状态是怎样转换的？关于线程状态的操作是怎样的？这篇文章就主要围绕这三个方面来聊一聊。\n\n\n# 1. 新建线程\n\n一个java程序从main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上java程序天生就是一个多线程程序，包含了：（1）分发处理发送给给JVM信号的线程；（2）调用对象的finalize方法的线程；（3）清除Reference的线程；（4）main线程，用户程序的入口。那么，如何在用户程序中新建一个线程了，只要有三种方式：\n\n 1. 通过继承Thread类，重写run方法；\n\n 2. 通过实现runable接口；\n\n 3. 通过实现callable接口这三种方式，下面看具体demo。\n    \n     public class CreateThreadDemo {\n    \n         public static void main(String[] args) {\n             //1.继承Thread\n             Thread thread = new Thread() {\n                 @Override\n                 public void run() {\n                     System.out.println("继承Thread");\n                     super.run();\n                 }\n             };\n             thread.start();\n             //2.实现runable接口\n             Thread thread1 = new Thread(new Runnable() {\n                 @Override\n                 public void run() {\n                     System.out.println("实现runable接口");\n                 }\n             });\n             thread1.start();\n             //3.实现callable接口\n             ExecutorService service = Executors.newSingleThreadExecutor();\n             Future<String> future = service.submit(new Callable() {\n                 @Override\n                 public String call() throws Exception {\n                     return "通过实现Callable接口";\n                 }\n             });\n             try {\n                 String result = future.get();\n                 System.out.println(result);\n             } catch (InterruptedException e) {\n                 e.printStackTrace();\n             } catch (ExecutionException e) {\n                 e.printStackTrace();\n             }\n         }\n    \n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    \n\n三种新建线程的方式具体看以上注释，需要主要的是：\n\n * 由于java不能多继承可以实现多个接口，因此，在创建线程的时候尽量多考虑采用实现接口的形式；\n\n * 实现callable接口，提交给ExecutorService返回的是异步执行的结果，另外，通常也可以利用FutureTask(Callable callable)将callable进行包装然后FeatureTask提交给ExecutorsService。如图，\n   \n   \n\n另外由于FeatureTask也实现了Runable接口也可以利用上面第二种方式（实现Runable接口）来新建线程；\n\n * 可以通过Executors将Runable转换成Callable，具体方法是：Callable callable(Runnable task, T result)， Callable callable(Runnable task)。\n\n\n# 2. 线程状态转换\n\n\n\n此图来源于《JAVA并发编程的艺术》一书中，线程是会在不同的状态间进行转换的，java线程线程转换图如上图所示。线程创建之后调用start()方法开始运行，当调用 wait(),join(),LockSupport.lock() 方法线程会进入到WAITING状态，而同样的 wait(long timeout)，sleep(long),join(long),LockSupport.parkNanos(),LockSupport.parkUtil() 增加了超时等待的功能，也就是调用这些方法后线程会进入TIMED_WAITING状态，当超时等待时间到达后，线程会切换到Runable的状态，另外当WAITING和TIMED _WAITING状态时可以通过 Object.notify(),Object.notifyAll() 方法使线程转换到Runable状态。当线程出现资源竞争时，即等待获取锁的时候，线程会进入到BLOCKED阻塞状态，当线程获取锁时，线程进入到Runable状态。线程运行结束后，线程进入到TERMINATED状态，状态转换可以说是线程的生命周期。另外需要注意的是：\n\n * 当线程进入到synchronized方法或者synchronized代码块时，线程切换到的是BLOCKED状态，而使用java.util.concurrent.locks下lock进行加锁的时候线程切换的是WAITING或者TIMED_WAITING状态，因为lock会调用LockSupport的方法。\n\n用一个表格将上面六种状态进行一个总结归纳。\n\n\n\n\n# 3. 线程状态的基本操作\n\n除了新建一个线程外，线程在生命周期内还有需要基本操作，而这些操作会成为线程间一种通信方式，比如使用中断（interrupted）方式通知实现线程间的交互等等，下面就将具体说说这些操作。\n\n\n# 3.1. interrupted\n\n中断可以理解为线程的一个标志位，它表示了一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了一个招呼。其他线程可以调用该线程的 interrupt() 方法对其进行中断操作，同时该线程可以调用 isInterrupted() 来感知其他线程对其自身的中断操作，从而做出响应。另外，同样可以调用Thread的静态方法 interrupted() 对当前线程进行中断操作，该方法会清除中断标志位。需要注意的是，当抛出InterruptedException时候，会清除中断标志位，也就是说在调用isInterrupted会返回false。\n\n\n\n下面结合具体的实例来看一看\n\npublic class InterruptDemo {\n    public static void main(String[] args) throws InterruptedException {\n        //sleepThread睡眠1000ms\n        final Thread sleepThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                super.run();\n            }\n        };\n        //busyThread一直执行死循环\n        Thread busyThread = new Thread() {\n            @Override\n            public void run() {\n                while (true) ;\n            }\n        };\n        sleepThread.start();\n        busyThread.start();\n        sleepThread.interrupt();\n        busyThread.interrupt();\n        while (sleepThread.isInterrupted()) ;\n        System.out.println("sleepThread isInterrupted: " + sleepThread.isInterrupted());\n        System.out.println("busyThread isInterrupted: " + busyThread.isInterrupted());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n输出结果\n\n> sleepThread isInterrupted: false\n> \n> busyThread isInterrupted: true\n\n开启了两个线程分别为sleepThread和BusyThread, sleepThread睡眠1s，BusyThread执行死循环。然后分别对着两个线程进行中断操作，可以看出sleepThread抛出InterruptedException后清除标志位，而busyThread就不会清除标志位。\n\n另外，同样可以通过中断的方式实现线程间的简单交互， while (sleepThread.isInterrupted()) 表示在Main中会持续监测sleepThread，一旦sleepThread的中断标志位清零，即 sleepThread.isInterrupted() 返回为false时才会继续Main线程才会继续往下执行。因此，中断操作可以看做线程间一种简便的交互方式。一般在结束线程时通过中断标志位或者标志位的方式可以有机会去清理资源，相对于武断而直接的结束线程，这种方式要优雅和安全。\n\n\n# 3.2. join\n\njoin方法可以看做是线程间协作的一种方式，很多时候，一个线程的输入可能非常依赖于另一个线程的输出，这就像两个好基友，一个基友先走在前面突然看见另一个基友落在后面了，这个时候他就会在原处等一等这个基友，等基友赶上来后，就两人携手并进。其实线程间的这种协作方式也符合现实生活。在软件开发的过程中，从客户那里获取需求后，需要经过需求分析师进行需求分解后，这个时候产品，开发才会继续跟进。如果一个线程实例A执行了 threadB.join() ，其含义是：当前线程A会等待threadB线程终止后threadA才会继续执行。关于join方法一共提供如下这些方法:\n\n> public final synchronized void join(long millis)\n> \n> public final synchronized void join(long millis, int nanos)\n> \n> public final void join() throws InterruptedException\n\nThread类除了提供join()方法外，另外还提供了超时等待的方法，如果线程threadB在等待的时间内还没有结束的话，threadA会在超时之后继续执行。join方法源码关键是：\n\n while (isAlive()) {\n    wait(0);\n }\n\n\n1\n2\n3\n\n\n可以看出来当前等待对象threadA会一直阻塞，直到被等待对象threadB结束后即 isAlive() 返回false的时候才会结束while循环，当threadB退出时会调用 notifyAll() 方法通知所有的等待线程。下面用一个具体的例子来说说join方法的使用：\n\npublic class JoinDemo {\n    public static void main(String[] args) {\n        Thread previousThread = Thread.currentThread();\n        for (int i = 1; i <= 10; i++) {\n            Thread curThread = new JoinThread(previousThread);\n            curThread.start();\n            previousThread = curThread;\n        }\n    }\n\n    static class JoinThread extends Thread {\n        private Thread thread;\n\n        public JoinThread(Thread thread) {\n            this.thread = thread;\n        }\n\n        @Override\n        public void run() {\n            try {\n                thread.join();\n                System.out.println(thread.getName() + " terminated.");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n输出结果为：\n\n> main terminated.\n> \n> Thread-0 terminated.\n> \n> Thread-1 terminated.\n> \n> Thread-2 terminated.\n> \n> Thread-3 terminated.\n> \n> Thread-4 terminated.\n> \n> Thread-5 terminated.\n> \n> Thread-6 terminated.\n> \n> Thread-7 terminated.\n> \n> Thread-8 terminated.\n\n在上面的例子中一个创建了10个线程，每个线程都会等待前一个线程结束才会继续运行。可以通俗的理解成接力，前一个线程将接力棒传给下一个线程，然后又传给下一个线程......\n\n\n# 3.3 sleep\n\npublic static native void sleep(long millis) 方法显然是Thread的静态方法，很显然它是让当前线程按照指定的时间休眠，其休眠时间的精度取决于处理器的计时器和调度器。需要注意的是如果当前线程获得了锁，sleep方法并不会失去锁。sleep方法经常拿来与Object.wait() 方法进行比价，这也是面试经常被问的地方。\n\n> sleep() VS wait()\n\n两者主要的区别：\n\n 1. sleep() 方法是Thread的静态方法，而wait是Object实例方法\n 2. wait() 方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而 sleep() 方法没有这个限制可以在任何地方种使用。另外，wait() 方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出CPU并不会释放掉对象锁；\n 3. sleep() 方法在休眠时间达到后如果再次获得CPU时间片就会继续执行，而 wait() 方法必须等待Object.notifty/Object.notifyAll通知后，才会离开等待池，并且再次获得CPU时间片才会继续执行。\n\n\n# 3.4 yield\n\npublic static native void yield() ；这是一个静态方法，一旦执行，它会是当前线程让出CPU，但是，需要注意的是，让出的CPU并不是代表当前线程不再运行了，如果在下一次竞争中，又获得了CPU时间片当前线程依然会继续运行。另外，让出的时间片只会分配给当前线程相同优先级的线程。什么是线程优先级了？下面就来具体聊一聊。\n\n现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会被分配到若干时间片，当前时间片用完后就会发生线程调度，并等待着下次分配。线程分配到的时间多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要或多或少分配一些处理器资源的线程属性。\n\n在Java程序中，通过一个整型成员变量Priority来控制优先级，优先级的范围从1~10。在构建线程的时候可以通过 setPriority(int) 方法进行设置，默认优先级为5，优先级高的线程相较于优先级低的线程优先获得处理器时间片。需要注意的是在不同JVM以及操作系统上，线程规划存在差异，有些操作系统甚至会忽略线程优先级的设定。\n\n> sleep() VS yield()\n\n需要注意的是，sleep() 和 yield() 方法，同样都是当前线程会交出处理器资源，而它们不同的是，sleep() 交出来的时间片其他线程都可以去竞争，也就是说都有机会获得当前线程让出的时间片。而 yield() 方法只允许与当前线程具有相同优先级的线程能够获得释放出来的CPU时间片。\n\n\n# 4.守护线程Daemon\n\n守护线程是一种特殊的线程，就和它的名字一样，它是系统的守护者，在后台默默地守护一些系统服务，比如垃圾回收线程，JIT线程就可以理解守护线程。与之对应的就是用户线程，用户线程就可以认为是系统的工作线程，它会完成整个系统的业务操作。用户线程完全结束后就意味着整个系统的业务任务全部结束了，因此系统就没有对象需要守护的了，守护线程自然而然就会退。当一个Java应用，只有守护线程的时候，虚拟机就会自然退出。下面以一个简单的例子来表述Daemon线程的使用。\n\npublic class DaemonDemo {\n    public static void main(String[] args) {\n        Thread daemonThread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                while (true) {\n                    try {\n                        System.out.println("i am alive");\n                        Thread.sleep(500);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    } finally {\n                        System.out.println("finally block");\n                    }\n                }\n            }\n        });\n        daemonThread.setDaemon(true);\n        daemonThread.start();\n        //确保main线程结束前能给daemonThread能够分到时间片\n        try {\n            Thread.sleep(800);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n输出结果为：\n\n> i am alive\n> \n> finally block\n> \n> i am alive\n\n上面的例子中daemodThread run方法中是一个while死循环，会一直打印，但是当main线程结束后daemonThread就会退出所以不会出现死循环的情况。main线程先睡眠800ms保证daemonThread能够拥有一次时间片的机会，也就是说可以正常执行一次打印“i am alive”操作和一次finally块中"finally block"操作。紧接着main 线程结束后，daemonThread退出，这个时候只打印了"i am alive"并没有打印finnal块中的“finally block ”。因此，这里需要注意的是守护线程在退出的时候并不会执行finnaly块中的代码，所以将释放资源等操作不要放在finnaly块中执行，这种操作是不安全的（毕竟是虚拟机直接结束退出）\n\n线程可以通过 setDaemon(true) 的方法将线程设置为守护线程。并且需要注意的是设置守护线程要先于 start() 方法，否则会报\n\n> Exception in thread "main" java.lang.IllegalThreadStateException at java.lang.Thread.setDaemon(Thread.java:1365) at learn.DaemonDemo.main(DaemonDemo.java:19)\n\n这样的异常，但是该线程还是会执行，只不过会当做正常的用户线程执行。\n\n> 参考文献：\n> \n> 线程的状态转换以及基本操作',normalizedContent:'说明\n\n线程的状态转换以及基本操作\n\n\n\n * 线程的状态转换以及基本操作\n * 1. 新建线程\n * 2. 线程状态转换\n * 3. 线程状态的基本操作\n   * 3.1. interrupted\n   * 3.2. join\n   * 3.3 sleep\n   * 3.4 yield\n * 4.守护线程daemon\n\n\n\n\n# 线程的状态转换以及基本操作\n\n在上一篇文章并发编程面临的挑战中谈到了为什么花功夫去学习并发编程的技术，也就是说我们必须了解到并发编程的优缺点，我们在什么情况下可以去考虑开启多个线程去实现我们的业务，当然使用多线程我们应该着重注意一些什么，在上一篇文章中会有一些讨论。那么，说了这么多，无论是针对面试还是实际工作中作为一名软件开发人员都应该具备这样的技能。万事开头难，接下来就应该了解如何新建一个线程？线程状态是怎样转换的？关于线程状态的操作是怎样的？这篇文章就主要围绕这三个方面来聊一聊。\n\n\n# 1. 新建线程\n\n一个java程序从main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上java程序天生就是一个多线程程序，包含了：（1）分发处理发送给给jvm信号的线程；（2）调用对象的finalize方法的线程；（3）清除reference的线程；（4）main线程，用户程序的入口。那么，如何在用户程序中新建一个线程了，只要有三种方式：\n\n 1. 通过继承thread类，重写run方法；\n\n 2. 通过实现runable接口；\n\n 3. 通过实现callable接口这三种方式，下面看具体demo。\n    \n     public class createthreaddemo {\n    \n         public static void main(string[] args) {\n             //1.继承thread\n             thread thread = new thread() {\n                 @override\n                 public void run() {\n                     system.out.println("继承thread");\n                     super.run();\n                 }\n             };\n             thread.start();\n             //2.实现runable接口\n             thread thread1 = new thread(new runnable() {\n                 @override\n                 public void run() {\n                     system.out.println("实现runable接口");\n                 }\n             });\n             thread1.start();\n             //3.实现callable接口\n             executorservice service = executors.newsinglethreadexecutor();\n             future<string> future = service.submit(new callable() {\n                 @override\n                 public string call() throws exception {\n                     return "通过实现callable接口";\n                 }\n             });\n             try {\n                 string result = future.get();\n                 system.out.println(result);\n             } catch (interruptedexception e) {\n                 e.printstacktrace();\n             } catch (executionexception e) {\n                 e.printstacktrace();\n             }\n         }\n    \n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    \n\n三种新建线程的方式具体看以上注释，需要主要的是：\n\n * 由于java不能多继承可以实现多个接口，因此，在创建线程的时候尽量多考虑采用实现接口的形式；\n\n * 实现callable接口，提交给executorservice返回的是异步执行的结果，另外，通常也可以利用futuretask(callable callable)将callable进行包装然后featuretask提交给executorsservice。如图，\n   \n   \n\n另外由于featuretask也实现了runable接口也可以利用上面第二种方式（实现runable接口）来新建线程；\n\n * 可以通过executors将runable转换成callable，具体方法是：callable callable(runnable task, t result)， callable callable(runnable task)。\n\n\n# 2. 线程状态转换\n\n\n\n此图来源于《java并发编程的艺术》一书中，线程是会在不同的状态间进行转换的，java线程线程转换图如上图所示。线程创建之后调用start()方法开始运行，当调用 wait(),join(),locksupport.lock() 方法线程会进入到waiting状态，而同样的 wait(long timeout)，sleep(long),join(long),locksupport.parknanos(),locksupport.parkutil() 增加了超时等待的功能，也就是调用这些方法后线程会进入timed_waiting状态，当超时等待时间到达后，线程会切换到runable的状态，另外当waiting和timed _waiting状态时可以通过 object.notify(),object.notifyall() 方法使线程转换到runable状态。当线程出现资源竞争时，即等待获取锁的时候，线程会进入到blocked阻塞状态，当线程获取锁时，线程进入到runable状态。线程运行结束后，线程进入到terminated状态，状态转换可以说是线程的生命周期。另外需要注意的是：\n\n * 当线程进入到synchronized方法或者synchronized代码块时，线程切换到的是blocked状态，而使用java.util.concurrent.locks下lock进行加锁的时候线程切换的是waiting或者timed_waiting状态，因为lock会调用locksupport的方法。\n\n用一个表格将上面六种状态进行一个总结归纳。\n\n\n\n\n# 3. 线程状态的基本操作\n\n除了新建一个线程外，线程在生命周期内还有需要基本操作，而这些操作会成为线程间一种通信方式，比如使用中断（interrupted）方式通知实现线程间的交互等等，下面就将具体说说这些操作。\n\n\n# 3.1. interrupted\n\n中断可以理解为线程的一个标志位，它表示了一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了一个招呼。其他线程可以调用该线程的 interrupt() 方法对其进行中断操作，同时该线程可以调用 isinterrupted() 来感知其他线程对其自身的中断操作，从而做出响应。另外，同样可以调用thread的静态方法 interrupted() 对当前线程进行中断操作，该方法会清除中断标志位。需要注意的是，当抛出interruptedexception时候，会清除中断标志位，也就是说在调用isinterrupted会返回false。\n\n\n\n下面结合具体的实例来看一看\n\npublic class interruptdemo {\n    public static void main(string[] args) throws interruptedexception {\n        //sleepthread睡眠1000ms\n        final thread sleepthread = new thread() {\n            @override\n            public void run() {\n                try {\n                    thread.sleep(1000);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n                super.run();\n            }\n        };\n        //busythread一直执行死循环\n        thread busythread = new thread() {\n            @override\n            public void run() {\n                while (true) ;\n            }\n        };\n        sleepthread.start();\n        busythread.start();\n        sleepthread.interrupt();\n        busythread.interrupt();\n        while (sleepthread.isinterrupted()) ;\n        system.out.println("sleepthread isinterrupted: " + sleepthread.isinterrupted());\n        system.out.println("busythread isinterrupted: " + busythread.isinterrupted());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n输出结果\n\n> sleepthread isinterrupted: false\n> \n> busythread isinterrupted: true\n\n开启了两个线程分别为sleepthread和busythread, sleepthread睡眠1s，busythread执行死循环。然后分别对着两个线程进行中断操作，可以看出sleepthread抛出interruptedexception后清除标志位，而busythread就不会清除标志位。\n\n另外，同样可以通过中断的方式实现线程间的简单交互， while (sleepthread.isinterrupted()) 表示在main中会持续监测sleepthread，一旦sleepthread的中断标志位清零，即 sleepthread.isinterrupted() 返回为false时才会继续main线程才会继续往下执行。因此，中断操作可以看做线程间一种简便的交互方式。一般在结束线程时通过中断标志位或者标志位的方式可以有机会去清理资源，相对于武断而直接的结束线程，这种方式要优雅和安全。\n\n\n# 3.2. join\n\njoin方法可以看做是线程间协作的一种方式，很多时候，一个线程的输入可能非常依赖于另一个线程的输出，这就像两个好基友，一个基友先走在前面突然看见另一个基友落在后面了，这个时候他就会在原处等一等这个基友，等基友赶上来后，就两人携手并进。其实线程间的这种协作方式也符合现实生活。在软件开发的过程中，从客户那里获取需求后，需要经过需求分析师进行需求分解后，这个时候产品，开发才会继续跟进。如果一个线程实例a执行了 threadb.join() ，其含义是：当前线程a会等待threadb线程终止后threada才会继续执行。关于join方法一共提供如下这些方法:\n\n> public final synchronized void join(long millis)\n> \n> public final synchronized void join(long millis, int nanos)\n> \n> public final void join() throws interruptedexception\n\nthread类除了提供join()方法外，另外还提供了超时等待的方法，如果线程threadb在等待的时间内还没有结束的话，threada会在超时之后继续执行。join方法源码关键是：\n\n while (isalive()) {\n    wait(0);\n }\n\n\n1\n2\n3\n\n\n可以看出来当前等待对象threada会一直阻塞，直到被等待对象threadb结束后即 isalive() 返回false的时候才会结束while循环，当threadb退出时会调用 notifyall() 方法通知所有的等待线程。下面用一个具体的例子来说说join方法的使用：\n\npublic class joindemo {\n    public static void main(string[] args) {\n        thread previousthread = thread.currentthread();\n        for (int i = 1; i <= 10; i++) {\n            thread curthread = new jointhread(previousthread);\n            curthread.start();\n            previousthread = curthread;\n        }\n    }\n\n    static class jointhread extends thread {\n        private thread thread;\n\n        public jointhread(thread thread) {\n            this.thread = thread;\n        }\n\n        @override\n        public void run() {\n            try {\n                thread.join();\n                system.out.println(thread.getname() + " terminated.");\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n输出结果为：\n\n> main terminated.\n> \n> thread-0 terminated.\n> \n> thread-1 terminated.\n> \n> thread-2 terminated.\n> \n> thread-3 terminated.\n> \n> thread-4 terminated.\n> \n> thread-5 terminated.\n> \n> thread-6 terminated.\n> \n> thread-7 terminated.\n> \n> thread-8 terminated.\n\n在上面的例子中一个创建了10个线程，每个线程都会等待前一个线程结束才会继续运行。可以通俗的理解成接力，前一个线程将接力棒传给下一个线程，然后又传给下一个线程......\n\n\n# 3.3 sleep\n\npublic static native void sleep(long millis) 方法显然是thread的静态方法，很显然它是让当前线程按照指定的时间休眠，其休眠时间的精度取决于处理器的计时器和调度器。需要注意的是如果当前线程获得了锁，sleep方法并不会失去锁。sleep方法经常拿来与object.wait() 方法进行比价，这也是面试经常被问的地方。\n\n> sleep() vs wait()\n\n两者主要的区别：\n\n 1. sleep() 方法是thread的静态方法，而wait是object实例方法\n 2. wait() 方法必须要在同步方法或者同步块中调用，也就是必须已经获得对象锁。而 sleep() 方法没有这个限制可以在任何地方种使用。另外，wait() 方法会释放占有的对象锁，使得该线程进入等待池中，等待下一次获取资源。而sleep()方法只是会让出cpu并不会释放掉对象锁；\n 3. sleep() 方法在休眠时间达到后如果再次获得cpu时间片就会继续执行，而 wait() 方法必须等待object.notifty/object.notifyall通知后，才会离开等待池，并且再次获得cpu时间片才会继续执行。\n\n\n# 3.4 yield\n\npublic static native void yield() ；这是一个静态方法，一旦执行，它会是当前线程让出cpu，但是，需要注意的是，让出的cpu并不是代表当前线程不再运行了，如果在下一次竞争中，又获得了cpu时间片当前线程依然会继续运行。另外，让出的时间片只会分配给当前线程相同优先级的线程。什么是线程优先级了？下面就来具体聊一聊。\n\n现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会被分配到若干时间片，当前时间片用完后就会发生线程调度，并等待着下次分配。线程分配到的时间多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要或多或少分配一些处理器资源的线程属性。\n\n在java程序中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10。在构建线程的时候可以通过 setpriority(int) 方法进行设置，默认优先级为5，优先级高的线程相较于优先级低的线程优先获得处理器时间片。需要注意的是在不同jvm以及操作系统上，线程规划存在差异，有些操作系统甚至会忽略线程优先级的设定。\n\n> sleep() vs yield()\n\n需要注意的是，sleep() 和 yield() 方法，同样都是当前线程会交出处理器资源，而它们不同的是，sleep() 交出来的时间片其他线程都可以去竞争，也就是说都有机会获得当前线程让出的时间片。而 yield() 方法只允许与当前线程具有相同优先级的线程能够获得释放出来的cpu时间片。\n\n\n# 4.守护线程daemon\n\n守护线程是一种特殊的线程，就和它的名字一样，它是系统的守护者，在后台默默地守护一些系统服务，比如垃圾回收线程，jit线程就可以理解守护线程。与之对应的就是用户线程，用户线程就可以认为是系统的工作线程，它会完成整个系统的业务操作。用户线程完全结束后就意味着整个系统的业务任务全部结束了，因此系统就没有对象需要守护的了，守护线程自然而然就会退。当一个java应用，只有守护线程的时候，虚拟机就会自然退出。下面以一个简单的例子来表述daemon线程的使用。\n\npublic class daemondemo {\n    public static void main(string[] args) {\n        thread daemonthread = new thread(new runnable() {\n            @override\n            public void run() {\n                while (true) {\n                    try {\n                        system.out.println("i am alive");\n                        thread.sleep(500);\n                    } catch (interruptedexception e) {\n                        e.printstacktrace();\n                    } finally {\n                        system.out.println("finally block");\n                    }\n                }\n            }\n        });\n        daemonthread.setdaemon(true);\n        daemonthread.start();\n        //确保main线程结束前能给daemonthread能够分到时间片\n        try {\n            thread.sleep(800);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n输出结果为：\n\n> i am alive\n> \n> finally block\n> \n> i am alive\n\n上面的例子中daemodthread run方法中是一个while死循环，会一直打印，但是当main线程结束后daemonthread就会退出所以不会出现死循环的情况。main线程先睡眠800ms保证daemonthread能够拥有一次时间片的机会，也就是说可以正常执行一次打印“i am alive”操作和一次finally块中"finally block"操作。紧接着main 线程结束后，daemonthread退出，这个时候只打印了"i am alive"并没有打印finnal块中的“finally block ”。因此，这里需要注意的是守护线程在退出的时候并不会执行finnaly块中的代码，所以将释放资源等操作不要放在finnaly块中执行，这种操作是不安全的（毕竟是虚拟机直接结束退出）\n\n线程可以通过 setdaemon(true) 的方法将线程设置为守护线程。并且需要注意的是设置守护线程要先于 start() 方法，否则会报\n\n> exception in thread "main" java.lang.illegalthreadstateexception at java.lang.thread.setdaemon(thread.java:1365) at learn.daemondemo.main(daemondemo.java:19)\n\n这样的异常，但是该线程还是会执行，只不过会当做正常的用户线程执行。\n\n> 参考文献：\n> \n> 线程的状态转换以及基本操作',charsets:{cjk:!0},createdTime:1655628697e3},{title:"彻底理解synchronized",frontmatter:{title:"彻底理解synchronized",description:"彻底理解synchronized",date:"2022-03-28T15:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/04%E3%80%81%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3synchronized.html",relativePath:"Java/Java并发编程的艺术/04、彻底理解synchronized.md",key:"v-0f4f0be8",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/04%E3%80%81%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3synchronized.html",headers:[{level:2,title:"1、CAS操作",slug:"_1、cas操作",normalizedTitle:"1、cas操作",charIndex:27},{level:3,title:"什么是 CAS ?",slug:"什么是-cas",normalizedTitle:"什么是 cas ?",charIndex:40},{level:3,title:"CAS的操作过程",slug:"cas的操作过程",normalizedTitle:"cas的操作过程",charIndex:55},{level:3,title:"CAS的应用场景",slug:"cas的应用场景",normalizedTitle:"cas的应用场景",charIndex:69},{level:3,title:"CAS的问题",slug:"cas的问题",normalizedTitle:"cas的问题",charIndex:83},{level:2,title:"2、synchronized实现原理",slug:"_2、synchronized实现原理",normalizedTitle:"2、synchronized实现原理",charIndex:93},{level:3,title:"监视器（monitor）机制",slug:"监视器-monitor-机制",normalizedTitle:"监视器（monitor）机制",charIndex:117},{level:3,title:"synchronized的happens-before关系",slug:"synchronized的happens-before关系",normalizedTitle:"synchronized的happens-before关系",charIndex:137},{level:3,title:"锁的释放和获取的内存语义",slug:"锁的释放和获取的内存语义",normalizedTitle:"锁的释放和获取的内存语义",charIndex:172},{level:3,title:"锁内存语义的实现",slug:"锁内存语义的实现",normalizedTitle:"锁内存语义的实现",charIndex:190},{level:3,title:"Java 对象头",slug:"java-对象头",normalizedTitle:"java 对象头",charIndex:204},{level:2,title:"3、锁的状态的对比与升级",slug:"_3、锁的状态的对比与升级",normalizedTitle:"3、锁的状态的对比与升级",charIndex:216},{level:3,title:"偏向锁",slug:"偏向锁",normalizedTitle:"偏向锁",charIndex:234},{level:3,title:"轻量级锁",slug:"轻量级锁",normalizedTitle:"轻量级锁",charIndex:243},{level:3,title:"各种锁的比较",slug:"各种锁的比较",normalizedTitle:"各种锁的比较",charIndex:253}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>彻底理解synchronized</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"1、CAS操作 什么是 CAS ? CAS的操作过程 CAS的应用场景 CAS的问题 2、synchronized实现原理 监视器（monitor）机制 synchronized的happens-before关系 锁的释放和获取的内存语义 锁内存语义的实现 Java 对象头 3、锁的状态的对比与升级 偏向锁 轻量级锁 各种锁的比较",content:'说明\n\n彻底理解synchronized\n\n\n\n * 1、CAS操作\n   * 什么是 CAS ?\n   * CAS的操作过程\n   * CAS的应用场景\n   * CAS的问题\n * 2、synchronized实现原理\n   * 监视器（monitor）机制\n   * synchronized的happens-before关系\n   * 锁的释放和获取的内存语义\n   * 锁内存语义的实现\n   * Java 对象头\n * 3、锁的状态的对比与升级\n   * 偏向锁\n   * 轻量级锁\n   * 各种锁的比较\n\n\n\n\n# 彻底理解synchronized\n\n\n# 1、CAS操作\n\n\n# 什么是 CAS ?\n\n使用锁时，线程获取锁是一种悲观锁策略，即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。而 CAS 操作（又称为无锁操作）是一种乐观锁策略，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。因此，线程就不会出现阻塞停顿的状态。那么，如果出现冲突了怎么办？无锁操作是使用CAS(compare and swap)又叫做比较交换来鉴别线程是否出现冲突，出现冲突就重试当前操作直到没有冲突为止。\n\n\n# CAS的操作过程\n\nCAS比较交换的过程可以通俗的理解为CAS(V,O,N)，包含三个值分别为：\n\n> V：内存地址存放的实际值\n> \n> O：预期的值（旧值）\n> \n> N：更新的新值\n\n当 V 和 O 相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值 O 就是目前来说最新的值了，自然而然可以将新值 N 赋值给 V 。反之，V 和 O 不相同，表明该值已经被其他线程改过了则该旧值 O 不是最新版本的值了，所以不能将新值 N赋给 V，返回 V 即可。当多个线程使用 CAS 操作一个变量是，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试，当然也可以选择挂起线程。\n\nCAS 的实现需要硬件指令集的支撑，在 JDK1.5 后虚拟机才可以使用处理器提供的 CMPXCHG 指令实现。\n\n> Synchronized VS CAS\n\n元老级的 Synchronized (未优化前)最主要的问题是：在存在线程竞争的情况下会出现线程阻塞和唤醒锁带来的性能问题，因为这是一种互斥同步（阻塞同步）。而 CAS 并不是武断的将线程挂起，当 CAS 操作失败后会进行一定的尝试，而非进行耗时的挂起唤醒的操作，因此也叫做非阻塞同步。这是两者主要的区别。\n\n\n# CAS的应用场景\n\n在 J.U.C 包中利用 CAS 实现类有很多，可以说是支撑起整个 concurrency 包的实现，在 Lock 实现中会有 CAS 改变 state 变量，在atomic 包中的实现类也几乎都是用 CAS 实现，关于这些具体的实现场景在之后会详细聊聊。\n\n\n# CAS的问题\n\n1. ABA问题\n\n因为 CAS 会检查旧值有没有变化，这里存在这样一个有意思的问题。比如一个旧值 A 变为了成 B，然后再变成 A，刚好在做 CAS 时检查发现旧值并没有变化依然为 A，但是实际上的确发生了变化。解决方案可以沿袭数据库中常用的乐观锁方式，添加一个版本号可以解决。原来的变化路径 A->B->A 就变成了 1A->2B->3C 。java 这么优秀的语言，当然在 java 1.5 后的 atomic 包中提供了AtomicStampedReference 来解决 ABA 问题，解决思路就是这样的。\n\n2. 自旋时间过长\n\n使用 CAS 时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。如果 JVM 能支持处理器提供的 pause 指令，那么在效率上会有一定的提升。\n\n3. 只能保证一个共享变量的原子操作\n\n当对一个共享变量执行操作时 CAS 能保证其原子性，如果对多个共享变量进行操作，CAS 就不能保证其原子性。有一个解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。然后将这个对象做 CAS 操作就可以保证其原子性。atomic 中提供了 AtomicReference 来保证引用对象之间的原子性。\n\n\n# 2、synchronized实现原理\n\n在多线程并发编程中 synchronized 一直是元老级角色，很多人都会称呼它为重量级锁。但是，随着 Java SE 1.6 对 synchronized 进行了各种优化之后，有些情况下它就并不那么重了。本文详细介绍 Java SE 1.6 中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。\n\n先来看下利用 synchronized 实现同步的基础：Java 中的每一个对象都可以作为锁。具体表现为以下3种形式：\n\n * 对于普通同步方法，锁是当前实例对象。\n * 对于静态同步方法，锁是当前类的 Class 对象。\n * 对于同步方法块，锁是 Synchonized 括号里配置的对象。\n\n\n# 监视器（monitor）机制\n\n现在我们来看看 synchronized 的具体底层实现。先写一个简单的 demo :\n\npublic class SynchronizedDemo {\n    public static void main(String[] args) {\n        synchronized (SynchronizedDemo.class) {\n        }\n        method();\n    }\n\n    private static void method() {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面的代码中有一个同步代码块，锁住的是类对象，并且还有一个同步静态方法，锁住的依然是该类的类对象。编译之后，切换到SynchronizedDemo.class 的同级目录之后，然后用 javap -v SynchronizedDemo.class 查看字节码文件：\n\n\n\n如图，上面用黄色高亮的部分就是需要注意的部分了，这也是添 Synchronized 关键字之后独有的。执行同步代码块后首先要先执行monitorenter 指令，退出的时候 monitorexit 指令。通过分析之后可以看出，使用 Synchronized 进行同步，其关键就是必须要对对象的监视器 monitor 进行获取，当线程获取 monitor 后才能继续往下执行，否则就只能等待。而这个获取的过程是互斥的，即同一时刻只有一个线程能够获取到 monitor。上面的 demo 中在执行完同步代码块之后紧接着再会去执行一个静态同步方法，而这个方法锁的对象依然就这个类对象，那么这个正在执行的线程还需要获取该锁吗？答案是不必的，从上图中就可以看出来，执行静态同步方法的时候就只有一条 monitorexit 指令，并没有 monitorenter 获取锁的指令。这就是锁的重入性，即在同一锁程中，线程不需要再次获取同一把锁。Synchronized 先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。\n\n任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取该对象的监视器才能进入同步块和同步方法，如果没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入到BLOCKED状态。\n\n下图表现了对象，对象监视器，同步队列以及执行线程状态之间的关系：\n\n\n\n该图可以看出，任意线程对 Object 的访问，首先要获得 Object 的监视器，如果获取失败，该线程就进入同步状态，线程状态变为BLOCKED，当 Object 的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。\n\n\n# synchronized的happens-before关系\n\n在上一篇文章中讨论过happens-before规则，抱着学以致用的原则我们现在来看一看Synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。继续来看代码：\n\npublic class MonitorDemo {\n    private int a = 0;\n\n    public synchronized void writer() {     // 1\n        a++;                                // 2\n    }                                       // 3\n\n    public synchronized void reader() {    // 4\n        int i = a;                         // 5\n    }                                      // 6\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n该代码的happens-before关系如图所示：\n\n\n\n在图3-24中，每一个箭头链接的两个节点，代表了一个happens-before关系。黑色箭头表示程序顺序规则；橙色箭头表示监视器锁规则；蓝色箭头表示组合这些规则后提供的happens-before保证。\n\n图3-24表示在线程A释放了锁之后，随后线程B获取同一个锁。在上图中，2 happens-before 5。因此，线程A在释放锁之前所有可见的共享变量，在线程B获取同一个锁之后，将立刻变得对B线程可见。\n\n\n# 锁的释放和获取的内存语义\n\n当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。以上面的MonitorExample程序为例，A线程释放锁后，共享数据的状态示意图如下图所示：\n\n\n\n当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。下图是锁获取的状态示意图：\n\n\n\n对比锁释放-获取的内存语义与volatile写-读的内存语义可以看出：锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。\n\n下面对锁释放和锁获取的内存语义做个总结：\n\n * 线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。\n * 线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。\n * 线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。\n\n\n# 锁内存语义的实现\n\n这里将借助ReentrantLock的源代码，来分析锁内存语义的具体实现机制。\n\n请看下面的示例代码。\n\nclass ReentrantLockExample {\n    int a = 0;\n    ReentrantLock lock = new ReentrantLock();\n    public void writer() {\n        lock.lock(); // 获取锁\n        try {\n            a++;\n        } finally {\n            lock.unlock(); // 释放锁\n        }\n    }\n    public void reader () {\n        lock.lock(); // 获取锁\n        try {\n            int i = a;\n            ……\n        } finally {\n            lock.unlock(); // 释放锁\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在ReentrantLock中，调用lock()方法获取锁；调用unlock()方法释放锁。\n\nReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronizer（本文简称之为AQS）。AQS使用一个整型的volatile变量（命名为state）来维护同步状态，马上我们会看到，这个volatile变量是ReentrantLock内存语义实现的关键。\n\n下图是ReentrantLock的类图（仅画出与本文相关的部分）：\n\n\n\nReentrantLock分为公平锁和非公平锁，我们首先分析公平锁。\n\n使用公平锁时，加锁方法lock()调用轨迹如下。\n\n1）ReentrantLock : lock()。\n\n2）FairSync : lock()。\n\n3）AbstractQueuedSynchronizer : acquire(int arg)。\n\n4）ReentrantLock : tryAcquire(int acquires)。\n\n在第4）步真正开始加锁，下面是该方法的源代码：\n\nprotected final boolean tryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState(); // 获取锁的开始，首先读volatile变量state\n    if (c == 0) {\n        if (isFirst(current) &&\n            compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error("Maximum lock count exceeded");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n从上面源代码中我们可以看出，加锁方法首先读volatile变量state。\n\n在使用公平锁时，解锁方法unlock()调用轨迹如下。\n\n1）ReentrantLock : unlock()。\n\n2）AbstractQueuedSynchronizer : release(int arg)。\n\n3）Sync : tryRelease(int releases)。\n\n在第3步真正开始释放锁，下面是该方法的源代码：\n\nprotected final boolean tryRelease(int releases) {\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    setState(c); // 释放锁的最后，写volatile变量state\n    return free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n从上面的源代码可以看出，在释放锁的最后写volatile变量state。\n\n公平锁在释放锁的最后写volatile变量state，在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。\n\n现在我们来分析非公平锁的内存语义的实现。非公平锁的释放和公平锁完全一样，所以这里仅仅分析非公平锁的获取。使用非公平锁时，加锁方法lock()调用轨迹如下。\n\n1）ReentrantLock : lock()。\n\n2）NonfairSync : lock()。\n\n3）AbstractQueuedSynchronizer : compareAndSetState(int expect,int update)。\n\n在第3步真正开始加锁，下面是该方法的源代码：\n\nprotected final boolean compareAndSetState(int expect, int update) {\n    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);\n}\n\n\n1\n2\n3\n\n\n可以看到这里是以CAS的方法来更新state变量，要知道，此操作具有volatile读和写的内存语义。由此可知，其实非公平锁上锁的内存语义也是通过volatile实现。\n\n现在对公平锁和非公平锁的内存语义做个总结：\n\n * 公平锁和非公平锁释放时，最后都要写一个volatile变量state。\n * 公平锁获取时，首先会去读volatile变量。\n * 非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。\n\n从本文对ReentrantLock的分析可以看出，锁释放-获取的内存语义的实现至少有下面两种方式：\n\n 1. 利用volatile变量的写-读所具有的内存语义。\n 2. 利用CAS所附带的volatile读和volatile写的内存语义。\n\n\n# Java 对象头\n\n在同步的时候是获取对象的 monitor ，即获取到对象的锁。那么对象的锁怎么理解？无非就是类似对对象的一个标志，那么这个标志就是存放在 Java 对象的对象头。Java 对象头里的 Mark Word 里默认的存放的对象的 Hashcode ，分代年龄和锁标记位。32位 JVM Mark Word默认存储结构为：\n\n\n\n如图在Mark Word会默认存放hasdcode，年龄值以及锁标志位等信息。\n\nJava SE 1.6 中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。对象的MarkWord变化为下图：\n\n\n\n\n# 3、锁的状态的对比与升级\n\n\n# 偏向锁\n\nHotSpot 的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。\n\n> 偏向锁的获取\n\n当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁，只需简单地测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下 Mark Word 中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用 CAS 竞争锁；如果设置了，则尝试使用 CAS 将对象头的偏向锁指向当前线程。\n\n> 偏向锁的撤销\n\n偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。\n\n\n\n如图，偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的 Mark Word 要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。\n\n下图线程1展示了偏向锁获取的过程，线程2展示了偏向锁撤销的过程。\n\n\n\n> 如何关闭偏向锁\n\n偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。\n\n\n# 轻量级锁\n\n> 加锁\n\n线程在执行同步块之前，JVM 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 Mark Word 复制到锁记录中，官方称为 Displaced Mark Word 。然后线程尝试使用 CAS 将对象头中的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。\n\n> 解锁\n\n轻量级解锁时，会使用原子的 CAS 操作将 Displaced Mark Word 替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。\n\n\n\n因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。\n\n\n# 各种锁的比较\n\n\n\n> 参考文献\n\n《java并发编程的艺术》',normalizedContent:'说明\n\n彻底理解synchronized\n\n\n\n * 1、cas操作\n   * 什么是 cas ?\n   * cas的操作过程\n   * cas的应用场景\n   * cas的问题\n * 2、synchronized实现原理\n   * 监视器（monitor）机制\n   * synchronized的happens-before关系\n   * 锁的释放和获取的内存语义\n   * 锁内存语义的实现\n   * java 对象头\n * 3、锁的状态的对比与升级\n   * 偏向锁\n   * 轻量级锁\n   * 各种锁的比较\n\n\n\n\n# 彻底理解synchronized\n\n\n# 1、cas操作\n\n\n# 什么是 cas ?\n\n使用锁时，线程获取锁是一种悲观锁策略，即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。而 cas 操作（又称为无锁操作）是一种乐观锁策略，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。因此，线程就不会出现阻塞停顿的状态。那么，如果出现冲突了怎么办？无锁操作是使用cas(compare and swap)又叫做比较交换来鉴别线程是否出现冲突，出现冲突就重试当前操作直到没有冲突为止。\n\n\n# cas的操作过程\n\ncas比较交换的过程可以通俗的理解为cas(v,o,n)，包含三个值分别为：\n\n> v：内存地址存放的实际值\n> \n> o：预期的值（旧值）\n> \n> n：更新的新值\n\n当 v 和 o 相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值 o 就是目前来说最新的值了，自然而然可以将新值 n 赋值给 v 。反之，v 和 o 不相同，表明该值已经被其他线程改过了则该旧值 o 不是最新版本的值了，所以不能将新值 n赋给 v，返回 v 即可。当多个线程使用 cas 操作一个变量是，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试，当然也可以选择挂起线程。\n\ncas 的实现需要硬件指令集的支撑，在 jdk1.5 后虚拟机才可以使用处理器提供的 cmpxchg 指令实现。\n\n> synchronized vs cas\n\n元老级的 synchronized (未优化前)最主要的问题是：在存在线程竞争的情况下会出现线程阻塞和唤醒锁带来的性能问题，因为这是一种互斥同步（阻塞同步）。而 cas 并不是武断的将线程挂起，当 cas 操作失败后会进行一定的尝试，而非进行耗时的挂起唤醒的操作，因此也叫做非阻塞同步。这是两者主要的区别。\n\n\n# cas的应用场景\n\n在 j.u.c 包中利用 cas 实现类有很多，可以说是支撑起整个 concurrency 包的实现，在 lock 实现中会有 cas 改变 state 变量，在atomic 包中的实现类也几乎都是用 cas 实现，关于这些具体的实现场景在之后会详细聊聊。\n\n\n# cas的问题\n\n1. aba问题\n\n因为 cas 会检查旧值有没有变化，这里存在这样一个有意思的问题。比如一个旧值 a 变为了成 b，然后再变成 a，刚好在做 cas 时检查发现旧值并没有变化依然为 a，但是实际上的确发生了变化。解决方案可以沿袭数据库中常用的乐观锁方式，添加一个版本号可以解决。原来的变化路径 a->b->a 就变成了 1a->2b->3c 。java 这么优秀的语言，当然在 java 1.5 后的 atomic 包中提供了atomicstampedreference 来解决 aba 问题，解决思路就是这样的。\n\n2. 自旋时间过长\n\n使用 cas 时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。如果 jvm 能支持处理器提供的 pause 指令，那么在效率上会有一定的提升。\n\n3. 只能保证一个共享变量的原子操作\n\n当对一个共享变量执行操作时 cas 能保证其原子性，如果对多个共享变量进行操作，cas 就不能保证其原子性。有一个解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。然后将这个对象做 cas 操作就可以保证其原子性。atomic 中提供了 atomicreference 来保证引用对象之间的原子性。\n\n\n# 2、synchronized实现原理\n\n在多线程并发编程中 synchronized 一直是元老级角色，很多人都会称呼它为重量级锁。但是，随着 java se 1.6 对 synchronized 进行了各种优化之后，有些情况下它就并不那么重了。本文详细介绍 java se 1.6 中为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁，以及锁的存储结构和升级过程。\n\n先来看下利用 synchronized 实现同步的基础：java 中的每一个对象都可以作为锁。具体表现为以下3种形式：\n\n * 对于普通同步方法，锁是当前实例对象。\n * 对于静态同步方法，锁是当前类的 class 对象。\n * 对于同步方法块，锁是 synchonized 括号里配置的对象。\n\n\n# 监视器（monitor）机制\n\n现在我们来看看 synchronized 的具体底层实现。先写一个简单的 demo :\n\npublic class synchronizeddemo {\n    public static void main(string[] args) {\n        synchronized (synchronizeddemo.class) {\n        }\n        method();\n    }\n\n    private static void method() {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上面的代码中有一个同步代码块，锁住的是类对象，并且还有一个同步静态方法，锁住的依然是该类的类对象。编译之后，切换到synchronizeddemo.class 的同级目录之后，然后用 javap -v synchronizeddemo.class 查看字节码文件：\n\n\n\n如图，上面用黄色高亮的部分就是需要注意的部分了，这也是添 synchronized 关键字之后独有的。执行同步代码块后首先要先执行monitorenter 指令，退出的时候 monitorexit 指令。通过分析之后可以看出，使用 synchronized 进行同步，其关键就是必须要对对象的监视器 monitor 进行获取，当线程获取 monitor 后才能继续往下执行，否则就只能等待。而这个获取的过程是互斥的，即同一时刻只有一个线程能够获取到 monitor。上面的 demo 中在执行完同步代码块之后紧接着再会去执行一个静态同步方法，而这个方法锁的对象依然就这个类对象，那么这个正在执行的线程还需要获取该锁吗？答案是不必的，从上图中就可以看出来，执行静态同步方法的时候就只有一条 monitorexit 指令，并没有 monitorenter 获取锁的指令。这就是锁的重入性，即在同一锁程中，线程不需要再次获取同一把锁。synchronized 先天具有重入性。每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。\n\n任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取该对象的监视器才能进入同步块和同步方法，如果没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入到blocked状态。\n\n下图表现了对象，对象监视器，同步队列以及执行线程状态之间的关系：\n\n\n\n该图可以看出，任意线程对 object 的访问，首先要获得 object 的监视器，如果获取失败，该线程就进入同步状态，线程状态变为blocked，当 object 的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。\n\n\n# synchronized的happens-before关系\n\n在上一篇文章中讨论过happens-before规则，抱着学以致用的原则我们现在来看一看synchronized的happens-before规则，即监视器锁规则：对同一个监视器的解锁，happens-before于对该监视器的加锁。继续来看代码：\n\npublic class monitordemo {\n    private int a = 0;\n\n    public synchronized void writer() {     // 1\n        a++;                                // 2\n    }                                       // 3\n\n    public synchronized void reader() {    // 4\n        int i = a;                         // 5\n    }                                      // 6\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n该代码的happens-before关系如图所示：\n\n\n\n在图3-24中，每一个箭头链接的两个节点，代表了一个happens-before关系。黑色箭头表示程序顺序规则；橙色箭头表示监视器锁规则；蓝色箭头表示组合这些规则后提供的happens-before保证。\n\n图3-24表示在线程a释放了锁之后，随后线程b获取同一个锁。在上图中，2 happens-before 5。因此，线程a在释放锁之前所有可见的共享变量，在线程b获取同一个锁之后，将立刻变得对b线程可见。\n\n\n# 锁的释放和获取的内存语义\n\n当线程释放锁时，jmm会把该线程对应的本地内存中的共享变量刷新到主内存中。以上面的monitorexample程序为例，a线程释放锁后，共享数据的状态示意图如下图所示：\n\n\n\n当线程获取锁时，jmm会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。下图是锁获取的状态示意图：\n\n\n\n对比锁释放-获取的内存语义与volatile写-读的内存语义可以看出：锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。\n\n下面对锁释放和锁获取的内存语义做个总结：\n\n * 线程a释放一个锁，实质上是线程a向接下来将要获取这个锁的某个线程发出了（线程a对共享变量所做修改的）消息。\n * 线程b获取一个锁，实质上是线程b接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。\n * 线程a释放锁，随后线程b获取这个锁，这个过程实质上是线程a通过主内存向线程b发送消息。\n\n\n# 锁内存语义的实现\n\n这里将借助reentrantlock的源代码，来分析锁内存语义的具体实现机制。\n\n请看下面的示例代码。\n\nclass reentrantlockexample {\n    int a = 0;\n    reentrantlock lock = new reentrantlock();\n    public void writer() {\n        lock.lock(); // 获取锁\n        try {\n            a++;\n        } finally {\n            lock.unlock(); // 释放锁\n        }\n    }\n    public void reader () {\n        lock.lock(); // 获取锁\n        try {\n            int i = a;\n            ……\n        } finally {\n            lock.unlock(); // 释放锁\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n在reentrantlock中，调用lock()方法获取锁；调用unlock()方法释放锁。\n\nreentrantlock的实现依赖于java同步器框架abstractqueuedsynchronizer（本文简称之为aqs）。aqs使用一个整型的volatile变量（命名为state）来维护同步状态，马上我们会看到，这个volatile变量是reentrantlock内存语义实现的关键。\n\n下图是reentrantlock的类图（仅画出与本文相关的部分）：\n\n\n\nreentrantlock分为公平锁和非公平锁，我们首先分析公平锁。\n\n使用公平锁时，加锁方法lock()调用轨迹如下。\n\n1）reentrantlock : lock()。\n\n2）fairsync : lock()。\n\n3）abstractqueuedsynchronizer : acquire(int arg)。\n\n4）reentrantlock : tryacquire(int acquires)。\n\n在第4）步真正开始加锁，下面是该方法的源代码：\n\nprotected final boolean tryacquire(int acquires) {\n    final thread current = thread.currentthread();\n    int c = getstate(); // 获取锁的开始，首先读volatile变量state\n    if (c == 0) {\n        if (isfirst(current) &&\n            compareandsetstate(0, acquires)) {\n            setexclusiveownerthread(current);\n            return true;\n        }\n    }else if (current == getexclusiveownerthread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new error("maximum lock count exceeded");\n        setstate(nextc);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n从上面源代码中我们可以看出，加锁方法首先读volatile变量state。\n\n在使用公平锁时，解锁方法unlock()调用轨迹如下。\n\n1）reentrantlock : unlock()。\n\n2）abstractqueuedsynchronizer : release(int arg)。\n\n3）sync : tryrelease(int releases)。\n\n在第3步真正开始释放锁，下面是该方法的源代码：\n\nprotected final boolean tryrelease(int releases) {\n    int c = getstate() - releases;\n    if (thread.currentthread() != getexclusiveownerthread())\n        throw new illegalmonitorstateexception();\n    boolean free = false;\n    if (c == 0) {\n        free = true;\n        setexclusiveownerthread(null);\n    }\n    setstate(c); // 释放锁的最后，写volatile变量state\n    return free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n从上面的源代码可以看出，在释放锁的最后写volatile变量state。\n\n公平锁在释放锁的最后写volatile变量state，在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。\n\n现在我们来分析非公平锁的内存语义的实现。非公平锁的释放和公平锁完全一样，所以这里仅仅分析非公平锁的获取。使用非公平锁时，加锁方法lock()调用轨迹如下。\n\n1）reentrantlock : lock()。\n\n2）nonfairsync : lock()。\n\n3）abstractqueuedsynchronizer : compareandsetstate(int expect,int update)。\n\n在第3步真正开始加锁，下面是该方法的源代码：\n\nprotected final boolean compareandsetstate(int expect, int update) {\n    return unsafe.compareandswapint(this, stateoffset, expect, update);\n}\n\n\n1\n2\n3\n\n\n可以看到这里是以cas的方法来更新state变量，要知道，此操作具有volatile读和写的内存语义。由此可知，其实非公平锁上锁的内存语义也是通过volatile实现。\n\n现在对公平锁和非公平锁的内存语义做个总结：\n\n * 公平锁和非公平锁释放时，最后都要写一个volatile变量state。\n * 公平锁获取时，首先会去读volatile变量。\n * 非公平锁获取时，首先会用cas更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。\n\n从本文对reentrantlock的分析可以看出，锁释放-获取的内存语义的实现至少有下面两种方式：\n\n 1. 利用volatile变量的写-读所具有的内存语义。\n 2. 利用cas所附带的volatile读和volatile写的内存语义。\n\n\n# java 对象头\n\n在同步的时候是获取对象的 monitor ，即获取到对象的锁。那么对象的锁怎么理解？无非就是类似对对象的一个标志，那么这个标志就是存放在 java 对象的对象头。java 对象头里的 mark word 里默认的存放的对象的 hashcode ，分代年龄和锁标记位。32位 jvm mark word默认存储结构为：\n\n\n\n如图在mark word会默认存放hasdcode，年龄值以及锁标志位等信息。\n\njava se 1.6 中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。对象的markword变化为下图：\n\n\n\n\n# 3、锁的状态的对比与升级\n\n\n# 偏向锁\n\nhotspot 的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。\n\n> 偏向锁的获取\n\n当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 id，以后该线程在进入和退出同步块时不需要进行 cas 操作来加锁和解锁，只需简单地测试一下对象头的 mark word 里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下 mark word 中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用 cas 竞争锁；如果设置了，则尝试使用 cas 将对象头的偏向锁指向当前线程。\n\n> 偏向锁的撤销\n\n偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。\n\n\n\n如图，偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的 mark word 要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。\n\n下图线程1展示了偏向锁获取的过程，线程2展示了偏向锁撤销的过程。\n\n\n\n> 如何关闭偏向锁\n\n偏向锁在java 6和java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用jvm参数来关闭延迟：-xx:biasedlockingstartupdelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过jvm参数关闭偏向锁：-xx:-usebiasedlocking=false，那么程序默认会进入轻量级锁状态。\n\n\n# 轻量级锁\n\n> 加锁\n\n线程在执行同步块之前，jvm 会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的 mark word 复制到锁记录中，官方称为 displaced mark word 。然后线程尝试使用 cas 将对象头中的 mark word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。\n\n> 解锁\n\n轻量级解锁时，会使用原子的 cas 操作将 displaced mark word 替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。\n\n\n\n因为自旋会消耗cpu，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。\n\n\n# 各种锁的比较\n\n\n\n> 参考文献\n\n《java并发编程的艺术》',charsets:{cjk:!0},createdTime:1655628697e3},{title:"Java内存模型以及happens-before",frontmatter:{title:"Java内存模型以及happens-before",description:"Java内存模型以及happens-before",date:"2022-03-28T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/03%E3%80%81Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8Ahappens-before.html",relativePath:"Java/Java并发编程的艺术/03、Java内存模型以及happens-before.md",key:"v-312a14d9",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/03%E3%80%81Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%BB%A5%E5%8F%8Ahappens-before.html",headers:[{level:2,title:"Java内存模型以及happens-before",slug:"java内存模型以及happens-before",normalizedTitle:"java内存模型以及happens-before",charIndex:4},{level:2,title:"1、JMM的介绍",slug:"_1、jmm的介绍",normalizedTitle:"1、jmm的介绍",charIndex:63},{level:2,title:"2、重排序",slug:"_2、重排序",normalizedTitle:"2、重排序",charIndex:75},{level:2,title:"3、happens-before 规则",slug:"_3、happens-before-规则",normalizedTitle:"3、happens-before 规则",charIndex:84},{level:3,title:"3.1 happens-before定义",slug:"_3-1-happens-before定义",normalizedTitle:"3.1 happens-before定义",charIndex:109},{level:3,title:"3.2 具体规则",slug:"_3-2-具体规则",normalizedTitle:"3.2 具体规则",charIndex:135},{level:2,title:"4、总结",slug:"_4、总结",normalizedTitle:"4、总结",charIndex:147},{level:3,title:"4.1 JMM的设计",slug:"_4-1-jmm的设计",normalizedTitle:"4.1 jmm的设计",charIndex:157},{level:3,title:"4.2 happens-before与JMM的关系",slug:"_4-2-happens-before与jmm的关系",normalizedTitle:"4.2 happens-before与jmm的关系",charIndex:173},{level:3,title:"4.3 今后可能需要关注的问题",slug:"_4-3-今后可能需要关注的问题",normalizedTitle:"4.3 今后可能需要关注的问题",charIndex:204}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>Java内存模型以及happens-before</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"Java内存模型以及happens-before 1、JMM的介绍 2、重排序 3、happens-before 规则 3.1 happens-before定义 3.2 具体规则 4、总结 4.1 JMM的设计 4.2 happens-before与JMM的关系 4.3 今后可能需要关注的问题",content:"说明\n\nJava内存模型以及happens-before\n\n\n\n * Java内存模型以及happens-before\n * 1、JMM的介绍\n * 2、重排序\n * 3、happens-before 规则\n   * 3.1 happens-before定义\n   * 3.2 具体规则\n * 4、总结\n   * 4.1 JMM的设计\n   * 4.2 happens-before与JMM的关系\n   * 4.3 今后可能需要关注的问题\n\n\n\n\n# Java内存模型以及happens-before\n\n在上一篇文章中总结了线程的状态转换和一些基本操作，对多线程已经有一点基本的认识了，如果多线程编程只有这么简单，那我们就不必费劲周折的去学习它了。在多线程中稍微不注意就会出现线程安全问题，那么什么是线程安全问题？我的认识是，在多线程下代码执行的结果与预期正确的结果不一致，该代码就是线程不安全的，否则则是线程安全的。虽然这种回答似乎不能获取什么内容，可以google下。在《深入理解Java虚拟机》中看到的定义。原文如下： 当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。\n\n\n# 1、JMM的介绍\n\n关于定义的理解这是一个仁者见仁智者见智的事情。出现线程安全的问题一般是因为主内存和工作内存数据不一致性和重排序导致的，而解决线程安全的问题最重要的就是理解这两种问题是怎么来的，那么，理解它们的核心在于理解java内存模型（JMM）。\n\n在多线程条件下，多个线程肯定会相互协作完成一件事情，一般来说就会涉及到多个线程间相互通信告知彼此的状态以及当前的执行结果等，另外，为了性能优化，还会涉及到编译器指令重排序和处理器指令重排序。下面会一一来聊聊这些知识。\n\n线程间协作通信机制可以类比人与人之间的协作的方式，在现实生活中，之前网上有个流行语“你妈喊你回家吃饭了”，就以这个生活场景为例，小明在外面玩耍，小明妈妈在家里做饭，做晚饭后准备叫小明回家吃饭，那么就存在两种方式：\n\n 1. 小明妈妈要去上班了十分紧急这个时候手机又没有电了，于是就在桌子上贴了一张纸条“饭做好了，放在...”小明回家后看到纸条如愿吃到妈妈做的饭菜，那么，如果将小明妈妈和小明作为两个线程，那么这张纸条就是这两个线程间通信的共享变量，通过读写共享变量实现两个线程间协作；（共享内存）\n 2. 还有一种方式就是，妈妈的手机还有电，妈妈在赶去坐公交的路上给小明打了个电话，这种方式就是通知机制来完成协作。同样，可以引申到线程间通信机制。（消息传递）\n\n通过上面这个例子，应该有些认识。在并发编程中主要需要解决两个问题：1. 线程之间如何通信；2. 线程之间如何完成同步（这里的线程指的是并发执行的活动实体）。通信是指线程之间以何种机制来交换信息，主要有两种：共享内存和消息传递。\n\n而 java 内存模型是共享内存的并发模型，线程之间主要通过读 - 写共享变量来完成隐式通信。如果程序员不能理解 Java 的共享内存模型在编写并发程序时一定会遇到各种各样关于内存可见性的问题。\n\n> 1、哪些是共享变量\n\n在 java 程序中所有实例域，静态域和数组元素都是放在堆内存中（所有线程均可访问到，是可以共享的），而局部变量，方法定义参数和异常处理器参数不会在线程间共享。共享数据会出现线程安全的问题，而非共享数据不会出现线程安全的问题。关于 JVM 运行时内存区域在后面的文章会讲到。\n\n> 2、JMM抽象结构模型\n\nJava 线程之间的通信由 Java 内存模型（本文简称为 JMM ）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存（我们知道 CPU 的处理速度和主存的读写速度不是一个量级的，为了平衡这种巨大的差距，每个CPU 都会有缓存，也就可以是主内存）之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。\n\n\n\n如图为JMM抽象示意图，线程A和线程B之间要完成通信的话，要经历如下两步：\n\n 1. 线程A从主内存中将共享变量读入线程A的工作内存后并进行操作，之后将数据重新写回到主内存中；\n 2. 线程B从主存中读取最新的共享变量。\n\n从横向去看看，线程 A 和线程 B 就好像通过共享变量在进行隐式通信。这其中有很有意思的问题，如果线程 A 更新后数据并没有及时写回到主存，而此时线程 B 读到的是过期的数据，这就出现了“脏读”现象。可以通过同步机制（控制不同线程间操作发生的相对顺序）来解决或者通过 volatile 关键字使得每次 volatile 变量都能够强制刷新到主存，从而对每个线程都是可见的。\n\n\n# 2、重排序\n\n一个好的内存模型实际上会放松对处理器和编译器规则的束缚，也就是说软件技术和硬件技术都为同一个目标而进行奋斗：在不改变程序执行结果的前提下，尽可能提高并行度。JMM对底层尽量减少约束，使其能够发挥自身优势。因此，在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序。一般重排序可以分为如下三种：\n\n\n\n 1. 编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；\n 2. 指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；\n 3. 内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。\n\n如图，1属于编译器重排序，而2和3统称为处理器重排序。这些重排序会导致线程安全的问题，一个很经典的例子就是DCL问题，这个在以后的文章中会具体去聊。\n\n * 针对编译器重排序，JMM的编译器重排序规则会禁止一些特定类型的编译器重排序；\n * 针对处理器重排序，编译器在生成指令序列的时候会通过插入内存屏障指令来禁止某些特殊的处理器重排序。\n\n> 数据依赖性\n\n那么什么情况下，不能进行重排序了？下面就来说说数据依赖性。有如下代码：\n\ndouble pi = 3.14 //A\ndouble r = 1.0 //B\ndouble area = pi * r * r //C\n\n\n1\n2\n3\n\n\n这是一个计算圆面积的代码，由于 A , B 之间没有任何关系，对最终结果也不会存在关系，它们之间执行顺序可以重排序。因此可以执行顺序可以是 A->B->C 或者 B->A->C 执行最终结果都是3.14，即A和B之间没有数据依赖性。\n\n具体的定义为：如果两个操作访问同一个变量，且这两个操作有一个为写操作，此时这两个操作就存在数据依赖性。这里就存在三种情况：1. 读后写；2. 写后写；3. 写后读，这三种操作都是存在数据依赖性的，如果重排序会对最终执行结果会存在影响。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序\n\n另外，还有一个比较有意思的就是as-if-serial语义。\n\n> as-if-serial\n\nas-if-serial 语义的意思是：不管怎么重排序（编译器和处理器为了提供并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器，runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。\n\n\n\n比如上面计算圆面积的代码，在单线程中，会让人感觉代码是一行一行顺序执行上，实际上 A , B 两行不存在数据依赖性可能会进行重排序，即 A , B 不是顺序执行的。as-if-serial 语义使程序员不必担心单线程中重排序的问题干扰他们，也无需担心内存可见性问题。\n\n\n# 3、happens-before 规则\n\n上面的内容讲述了重排序原则，一会是编译器重排序一会是处理器重排序，如果让程序员再去了解这些底层的实现以及具体规则，那么程序员的负担就太重了，严重影响了并发编程的效率。因此，JMM为程序员在上层提供了六条规则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则。\n\n\n# 3.1 happens-before定义\n\nhappens-before 的概念最初由 Leslie Lamport 在其一篇影响深远的论文（《Time，Clocks and the Ordering of Events in a Distributed System》）中提出，有兴趣的可以 google 一下。\n\nJSR-133（JMM Java内存模型的具体名称）使用 happens-before 的概念来指定两个操作之间的执行顺序。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。因此，JMM 可以通过 happens-before 关系向程序员提供跨线程的内存可见性保证（如果 A 线程的写操作 a 与 B 线程的读操作 b 之间存在 happens-before 关系，尽管 a 操作和 b 操作在不同的线程中执行，但 JMM 向程序员保证 a 操作将对 b 操作可见）。\n\n《JSR-133:Java Memory Model and Thread Specification》对 happens-before 关系的定义如下：\n\n1）如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。\n\n2）两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM 允许这种重排序）。\n\n * 上面的1）是 JMM 对程序员的承诺。从程序员的角度来说，可以这样理解 happens-before 关系：如果A happens-before B，那么 Java 内存模型将向程序员保证—— A 操作的结果将对 B 可见，且 A 的执行顺序排在 B 之前。注意，这只是 Java 内存模型向程序员做出的保证！\n * 上面的2）是 JMM 对编译器和处理器重排序的约束原则。正如前面所言，JMM 其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM 这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before 关系本质上和as-if-serial 语义是一回事。\n\n下面来比较一下 as-if-serial 和 happens-before ：\n\n> as-if-serial VS happens-before\n\n 1. as-if-serial 语义保证单线程内程序的执行结果不被改变，happens-before 关系保证正确同步的多线程程序的执行结果不被改变。\n 2. as-if-serial 语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before 关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按 happens-before 指定的顺序来执行的。\n 3. as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。\n\n\n# 3.2 具体规则\n\n《JSR-133:Java Memory Model and Thread Specification》定义了如下 happens-before 规则：\n\n 1. 程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。\n 2. 监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。\n 3. volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。\n 4. 传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。\n 5. start() 规则：如果线程 A 执行操作 ThreadB.start()（启动线程B），那么 A 线程的 ThreadB.start() 操作 happens-before 于线程 B 中的任意操作。\n 6. join() 规则：如果线程 A 执行操作 ThreadB.join() 并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join() 操作成功返回。\n 7. 程序中断规则：对线程 interrupted() 方法的调用先行于被中断线程的代码检测到中断时间的发生。\n 8. 对象 finalize 规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的 finalize() 方法的开始。\n\n下面以一个具体的例子来讲下如何使用这些规则进行推论：\n\n下图是 volatile 写-读建立的 happens-before 关系图并做出分析。\n\n\n\n * 1 happens-before 2和3 happens-before 4由程序顺序规则产生。由于编译器和处理器都要遵守 as-if-serial 语义，也就是说，as-if-serial 语义保证了程序顺序规则。因此，可以把程序顺序规则看成是对as-if-serial语义的“封装”。\n * 2 happens-before 3是由 volatile 规则产生。前面提到过，对一个 volatile 变量的读，总是能看到（任意线程）之前对这个 volatile 变量最后的写入。因此，volatile 的这个特性可以保证实现 volatile 规则。\n * 1 happens-before 4是由传递性规则产生的。这里的传递性是由 volatile 的内存屏障插入策略和 volatile 的编译器重排序规则共同来保证的。\n\n下面我们来看 start() 规则。假设线程 A 在执行的过程中，通过执行 ThreadB.start() 来启动线程 B；同时，假设线程 A 在执行 ThreadB.start() 之前修改了一些共享变量，线程 B 在开始执行后会读这些共享变量。下图是该程序对应的 happens-before 关系图。\n\n\n\n上图中，1 happens-before 2由程序顺序规则产生。2 happens-before 4由 start() 规则产生。根据传递性，将有1 happens-before 4。这实意味着，线程 A 在执行 ThreadB.start() 之前对共享变量所做的修改，接下来在线程B开始执行后都将确保对线程B可见。\n\n下面我们来看 join() 规则。假设线程 A 在执行的过程中，通过执行 ThreadB.join() 来等待线程 B 终止；同时，假设线程 B 在终止之前修改了一些共享变量，线程 A 从 ThreadB.join() 返回后会读这些共享变量。下图是该程序对应的 happens-before 关系图。\n\n\n\n上图中，2 happens-before 4由 join() 规则产生；4 happens-before 5由程序顺序规则产生。根据传递性规则，将有2 happens-before 5。这意味着，线程 A 执行操作 ThreadB.join() 并成功返回后，线程 B 中的任意操作都将对线程 A 可见。\n\n\n# 4、总结\n\n上面已经聊了关于JMM的两个方面：1. JMM的抽象结构（主内存和线程工作内存）；2. 重排序以及 happens-before 规则。接下来，我们来做一个总结。\n\n从两个方面进行考虑。\n\n 1. 如果让我们设计 JMM 应该从哪些方面考虑，也就是说 JMM 承担哪些功能；\n\n 2. happens-before 与 JMM 的关系；\n\n 3. 由于 JMM，多线程情况下可能会出现哪些问题？\n\n\n# 4.1 JMM的设计\n\n\n\nJMM 是语言级的内存模型，在我的理解中 JMM 处于中间层，包含了两个方面：（1）内存模型；（2）重排序以及 happens-before 规则。同时，为了禁止特定类型的重排序会对编译器和处理器指令序列加以控制。而上层会有基于 JMM 的关键字和 J.U.C 包下的一些具体类用来方便程序员能够迅速高效率的进行并发编程。站在 JMM 设计者的角度，在设计 JMM 时需要考虑两个关键因素:\n\n 1. 程序员对内存模型的使用 程序员希望内存模型易于理解、易于编程。程序员希望基于一个强内存模型来编写代码。\n 2. 编译器和处理器对内存模型的实现 编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。\n\n另外还要一个特别有意思的事情就是关于重排序问题，更简单的说，重排序可以分为两类：\n\n 1. 会改变程序执行结果的重排序。\n 2. 不会改变程序执行结果的重排序。\n\nJMM对这两种不同性质的重排序，采取了不同的策略，如下。\n\n 1. 对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。\n 2. 对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种 重排序）\n\nJMM的设计图为：\n\n\n\n从图可以看出：\n\n 1. JMM 向程序员提供的 happens-before 规则能满足程序员的需求。JMM 的 happens-before 规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的A happens-before B）。\n 2. JMM 对编译器和处理器的束缚已经尽可能少。从上面的分析可以看出，JMM 其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。例如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个 volatile 变量只会被单个线程访问，那么编译器可以把这个 volatile 变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。\n\n\n# 4.2 happens-before与JMM的关系\n\n\n\n一个 happens-before 规则对应于一个或多个编译器和处理器重排序规则。对于 Java 程序员来说，happens-before 规则简单易懂，它避免 Java 程序员为了理解 JMM 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法\n\n\n# 4.3 今后可能需要关注的问题\n\n从上面内存抽象结构来说，可能出在数据“脏读”的现象，这就是数据可见性的问题，另外，重排序在多线程中不注意的话也容易存在一些问题，比如一个很经典的问题就是DCL（双重检验锁），这就是需要禁止重排序，另外，在多线程下原子操作例如 i++ 不加以注意的也容易出现线程安全的问题。但总的来说，在多线程开发时需要从原子性，有序性，可见性三个方面进行考虑。J.U.C 包下的并发工具类和并发容器也是需要花时间去掌握的，这些东西在以后得文章中多会一一进行讨论。\n\n> 参考文献\n\n《java并发编程的艺术》",normalizedContent:"说明\n\njava内存模型以及happens-before\n\n\n\n * java内存模型以及happens-before\n * 1、jmm的介绍\n * 2、重排序\n * 3、happens-before 规则\n   * 3.1 happens-before定义\n   * 3.2 具体规则\n * 4、总结\n   * 4.1 jmm的设计\n   * 4.2 happens-before与jmm的关系\n   * 4.3 今后可能需要关注的问题\n\n\n\n\n# java内存模型以及happens-before\n\n在上一篇文章中总结了线程的状态转换和一些基本操作，对多线程已经有一点基本的认识了，如果多线程编程只有这么简单，那我们就不必费劲周折的去学习它了。在多线程中稍微不注意就会出现线程安全问题，那么什么是线程安全问题？我的认识是，在多线程下代码执行的结果与预期正确的结果不一致，该代码就是线程不安全的，否则则是线程安全的。虽然这种回答似乎不能获取什么内容，可以google下。在《深入理解java虚拟机》中看到的定义。原文如下： 当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是线程安全的。\n\n\n# 1、jmm的介绍\n\n关于定义的理解这是一个仁者见仁智者见智的事情。出现线程安全的问题一般是因为主内存和工作内存数据不一致性和重排序导致的，而解决线程安全的问题最重要的就是理解这两种问题是怎么来的，那么，理解它们的核心在于理解java内存模型（jmm）。\n\n在多线程条件下，多个线程肯定会相互协作完成一件事情，一般来说就会涉及到多个线程间相互通信告知彼此的状态以及当前的执行结果等，另外，为了性能优化，还会涉及到编译器指令重排序和处理器指令重排序。下面会一一来聊聊这些知识。\n\n线程间协作通信机制可以类比人与人之间的协作的方式，在现实生活中，之前网上有个流行语“你妈喊你回家吃饭了”，就以这个生活场景为例，小明在外面玩耍，小明妈妈在家里做饭，做晚饭后准备叫小明回家吃饭，那么就存在两种方式：\n\n 1. 小明妈妈要去上班了十分紧急这个时候手机又没有电了，于是就在桌子上贴了一张纸条“饭做好了，放在...”小明回家后看到纸条如愿吃到妈妈做的饭菜，那么，如果将小明妈妈和小明作为两个线程，那么这张纸条就是这两个线程间通信的共享变量，通过读写共享变量实现两个线程间协作；（共享内存）\n 2. 还有一种方式就是，妈妈的手机还有电，妈妈在赶去坐公交的路上给小明打了个电话，这种方式就是通知机制来完成协作。同样，可以引申到线程间通信机制。（消息传递）\n\n通过上面这个例子，应该有些认识。在并发编程中主要需要解决两个问题：1. 线程之间如何通信；2. 线程之间如何完成同步（这里的线程指的是并发执行的活动实体）。通信是指线程之间以何种机制来交换信息，主要有两种：共享内存和消息传递。\n\n而 java 内存模型是共享内存的并发模型，线程之间主要通过读 - 写共享变量来完成隐式通信。如果程序员不能理解 java 的共享内存模型在编写并发程序时一定会遇到各种各样关于内存可见性的问题。\n\n> 1、哪些是共享变量\n\n在 java 程序中所有实例域，静态域和数组元素都是放在堆内存中（所有线程均可访问到，是可以共享的），而局部变量，方法定义参数和异常处理器参数不会在线程间共享。共享数据会出现线程安全的问题，而非共享数据不会出现线程安全的问题。关于 jvm 运行时内存区域在后面的文章会讲到。\n\n> 2、jmm抽象结构模型\n\njava 线程之间的通信由 java 内存模型（本文简称为 jmm ）控制，jmm 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，jmm 定义了线程和主内存（我们知道 cpu 的处理速度和主存的读写速度不是一个量级的，为了平衡这种巨大的差距，每个cpu 都会有缓存，也就可以是主内存）之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是 jmm 的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。\n\n\n\n如图为jmm抽象示意图，线程a和线程b之间要完成通信的话，要经历如下两步：\n\n 1. 线程a从主内存中将共享变量读入线程a的工作内存后并进行操作，之后将数据重新写回到主内存中；\n 2. 线程b从主存中读取最新的共享变量。\n\n从横向去看看，线程 a 和线程 b 就好像通过共享变量在进行隐式通信。这其中有很有意思的问题，如果线程 a 更新后数据并没有及时写回到主存，而此时线程 b 读到的是过期的数据，这就出现了“脏读”现象。可以通过同步机制（控制不同线程间操作发生的相对顺序）来解决或者通过 volatile 关键字使得每次 volatile 变量都能够强制刷新到主存，从而对每个线程都是可见的。\n\n\n# 2、重排序\n\n一个好的内存模型实际上会放松对处理器和编译器规则的束缚，也就是说软件技术和硬件技术都为同一个目标而进行奋斗：在不改变程序执行结果的前提下，尽可能提高并行度。jmm对底层尽量减少约束，使其能够发挥自身优势。因此，在执行程序时，为了提高性能，编译器和处理器常常会对指令进行重排序。一般重排序可以分为如下三种：\n\n\n\n 1. 编译器优化的重排序：编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；\n 2. 指令级并行的重排序：现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；\n 3. 内存系统的重排序：由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。\n\n如图，1属于编译器重排序，而2和3统称为处理器重排序。这些重排序会导致线程安全的问题，一个很经典的例子就是dcl问题，这个在以后的文章中会具体去聊。\n\n * 针对编译器重排序，jmm的编译器重排序规则会禁止一些特定类型的编译器重排序；\n * 针对处理器重排序，编译器在生成指令序列的时候会通过插入内存屏障指令来禁止某些特殊的处理器重排序。\n\n> 数据依赖性\n\n那么什么情况下，不能进行重排序了？下面就来说说数据依赖性。有如下代码：\n\ndouble pi = 3.14 //a\ndouble r = 1.0 //b\ndouble area = pi * r * r //c\n\n\n1\n2\n3\n\n\n这是一个计算圆面积的代码，由于 a , b 之间没有任何关系，对最终结果也不会存在关系，它们之间执行顺序可以重排序。因此可以执行顺序可以是 a->b->c 或者 b->a->c 执行最终结果都是3.14，即a和b之间没有数据依赖性。\n\n具体的定义为：如果两个操作访问同一个变量，且这两个操作有一个为写操作，此时这两个操作就存在数据依赖性。这里就存在三种情况：1. 读后写；2. 写后写；3. 写后读，这三种操作都是存在数据依赖性的，如果重排序会对最终执行结果会存在影响。编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖性关系的两个操作的执行顺序\n\n另外，还有一个比较有意思的就是as-if-serial语义。\n\n> as-if-serial\n\nas-if-serial 语义的意思是：不管怎么重排序（编译器和处理器为了提供并行度），（单线程）程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守 as-if-serial 语义。as-if-serial 语义把单线程程序保护了起来，遵守 as-if-serial 语义的编译器，runtime和处理器共同为编写单线程程序的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的。\n\n\n\n比如上面计算圆面积的代码，在单线程中，会让人感觉代码是一行一行顺序执行上，实际上 a , b 两行不存在数据依赖性可能会进行重排序，即 a , b 不是顺序执行的。as-if-serial 语义使程序员不必担心单线程中重排序的问题干扰他们，也无需担心内存可见性问题。\n\n\n# 3、happens-before 规则\n\n上面的内容讲述了重排序原则，一会是编译器重排序一会是处理器重排序，如果让程序员再去了解这些底层的实现以及具体规则，那么程序员的负担就太重了，严重影响了并发编程的效率。因此，jmm为程序员在上层提供了六条规则，这样我们就可以根据规则去推论跨线程的内存可见性问题，而不用再去理解底层重排序的规则。\n\n\n# 3.1 happens-before定义\n\nhappens-before 的概念最初由 leslie lamport 在其一篇影响深远的论文（《time，clocks and the ordering of events in a distributed system》）中提出，有兴趣的可以 google 一下。\n\njsr-133（jmm java内存模型的具体名称）使用 happens-before 的概念来指定两个操作之间的执行顺序。由于这两个操作可以在一个线程之内，也可以是在不同线程之间。因此，jmm 可以通过 happens-before 关系向程序员提供跨线程的内存可见性保证（如果 a 线程的写操作 a 与 b 线程的读操作 b 之间存在 happens-before 关系，尽管 a 操作和 b 操作在不同的线程中执行，但 jmm 向程序员保证 a 操作将对 b 操作可见）。\n\n《jsr-133:java memory model and thread specification》对 happens-before 关系的定义如下：\n\n1）如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。\n\n2）两个操作之间存在 happens-before 关系，并不意味着 java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么这种重排序并不非法（也就是说，jmm 允许这种重排序）。\n\n * 上面的1）是 jmm 对程序员的承诺。从程序员的角度来说，可以这样理解 happens-before 关系：如果a happens-before b，那么 java 内存模型将向程序员保证—— a 操作的结果将对 b 可见，且 a 的执行顺序排在 b 之前。注意，这只是 java 内存模型向程序员做出的保证！\n * 上面的2）是 jmm 对编译器和处理器重排序的约束原则。正如前面所言，jmm 其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。jmm 这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。因此，happens-before 关系本质上和as-if-serial 语义是一回事。\n\n下面来比较一下 as-if-serial 和 happens-before ：\n\n> as-if-serial vs happens-before\n\n 1. as-if-serial 语义保证单线程内程序的执行结果不被改变，happens-before 关系保证正确同步的多线程程序的执行结果不被改变。\n 2. as-if-serial 语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before 关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按 happens-before 指定的顺序来执行的。\n 3. as-if-serial 语义和 happens-before 这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。\n\n\n# 3.2 具体规则\n\n《jsr-133:java memory model and thread specification》定义了如下 happens-before 规则：\n\n 1. 程序顺序规则：一个线程中的每个操作，happens-before 于该线程中的任意后续操作。\n 2. 监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。\n 3. volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。\n 4. 传递性：如果 a happens-before b，且 b happens-before c，那么 a happens-before c。\n 5. start() 规则：如果线程 a 执行操作 threadb.start()（启动线程b），那么 a 线程的 threadb.start() 操作 happens-before 于线程 b 中的任意操作。\n 6. join() 规则：如果线程 a 执行操作 threadb.join() 并成功返回，那么线程 b 中的任意操作 happens-before 于线程 a 从 threadb.join() 操作成功返回。\n 7. 程序中断规则：对线程 interrupted() 方法的调用先行于被中断线程的代码检测到中断时间的发生。\n 8. 对象 finalize 规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的 finalize() 方法的开始。\n\n下面以一个具体的例子来讲下如何使用这些规则进行推论：\n\n下图是 volatile 写-读建立的 happens-before 关系图并做出分析。\n\n\n\n * 1 happens-before 2和3 happens-before 4由程序顺序规则产生。由于编译器和处理器都要遵守 as-if-serial 语义，也就是说，as-if-serial 语义保证了程序顺序规则。因此，可以把程序顺序规则看成是对as-if-serial语义的“封装”。\n * 2 happens-before 3是由 volatile 规则产生。前面提到过，对一个 volatile 变量的读，总是能看到（任意线程）之前对这个 volatile 变量最后的写入。因此，volatile 的这个特性可以保证实现 volatile 规则。\n * 1 happens-before 4是由传递性规则产生的。这里的传递性是由 volatile 的内存屏障插入策略和 volatile 的编译器重排序规则共同来保证的。\n\n下面我们来看 start() 规则。假设线程 a 在执行的过程中，通过执行 threadb.start() 来启动线程 b；同时，假设线程 a 在执行 threadb.start() 之前修改了一些共享变量，线程 b 在开始执行后会读这些共享变量。下图是该程序对应的 happens-before 关系图。\n\n\n\n上图中，1 happens-before 2由程序顺序规则产生。2 happens-before 4由 start() 规则产生。根据传递性，将有1 happens-before 4。这实意味着，线程 a 在执行 threadb.start() 之前对共享变量所做的修改，接下来在线程b开始执行后都将确保对线程b可见。\n\n下面我们来看 join() 规则。假设线程 a 在执行的过程中，通过执行 threadb.join() 来等待线程 b 终止；同时，假设线程 b 在终止之前修改了一些共享变量，线程 a 从 threadb.join() 返回后会读这些共享变量。下图是该程序对应的 happens-before 关系图。\n\n\n\n上图中，2 happens-before 4由 join() 规则产生；4 happens-before 5由程序顺序规则产生。根据传递性规则，将有2 happens-before 5。这意味着，线程 a 执行操作 threadb.join() 并成功返回后，线程 b 中的任意操作都将对线程 a 可见。\n\n\n# 4、总结\n\n上面已经聊了关于jmm的两个方面：1. jmm的抽象结构（主内存和线程工作内存）；2. 重排序以及 happens-before 规则。接下来，我们来做一个总结。\n\n从两个方面进行考虑。\n\n 1. 如果让我们设计 jmm 应该从哪些方面考虑，也就是说 jmm 承担哪些功能；\n\n 2. happens-before 与 jmm 的关系；\n\n 3. 由于 jmm，多线程情况下可能会出现哪些问题？\n\n\n# 4.1 jmm的设计\n\n\n\njmm 是语言级的内存模型，在我的理解中 jmm 处于中间层，包含了两个方面：（1）内存模型；（2）重排序以及 happens-before 规则。同时，为了禁止特定类型的重排序会对编译器和处理器指令序列加以控制。而上层会有基于 jmm 的关键字和 j.u.c 包下的一些具体类用来方便程序员能够迅速高效率的进行并发编程。站在 jmm 设计者的角度，在设计 jmm 时需要考虑两个关键因素:\n\n 1. 程序员对内存模型的使用 程序员希望内存模型易于理解、易于编程。程序员希望基于一个强内存模型来编写代码。\n 2. 编译器和处理器对内存模型的实现 编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。\n\n另外还要一个特别有意思的事情就是关于重排序问题，更简单的说，重排序可以分为两类：\n\n 1. 会改变程序执行结果的重排序。\n 2. 不会改变程序执行结果的重排序。\n\njmm对这两种不同性质的重排序，采取了不同的策略，如下。\n\n 1. 对于会改变程序执行结果的重排序，jmm要求编译器和处理器必须禁止这种重排序。\n 2. 对于不会改变程序执行结果的重排序，jmm对编译器和处理器不做要求（jmm允许这种 重排序）\n\njmm的设计图为：\n\n\n\n从图可以看出：\n\n 1. jmm 向程序员提供的 happens-before 规则能满足程序员的需求。jmm 的 happens-before 规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证（有些内存可见性保证其实并不一定真实存在，比如上面的a happens-before b）。\n 2. jmm 对编译器和处理器的束缚已经尽可能少。从上面的分析可以看出，jmm 其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。例如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再如，如果编译器经过细致的分析后，认定一个 volatile 变量只会被单个线程访问，那么编译器可以把这个 volatile 变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率。\n\n\n# 4.2 happens-before与jmm的关系\n\n\n\n一个 happens-before 规则对应于一个或多个编译器和处理器重排序规则。对于 java 程序员来说，happens-before 规则简单易懂，它避免 java 程序员为了理解 jmm 提供的内存可见性保证而去学习复杂的重排序规则以及这些规则的具体实现方法\n\n\n# 4.3 今后可能需要关注的问题\n\n从上面内存抽象结构来说，可能出在数据“脏读”的现象，这就是数据可见性的问题，另外，重排序在多线程中不注意的话也容易存在一些问题，比如一个很经典的问题就是dcl（双重检验锁），这就是需要禁止重排序，另外，在多线程下原子操作例如 i++ 不加以注意的也容易出现线程安全的问题。但总的来说，在多线程开发时需要从原子性，有序性，可见性三个方面进行考虑。j.u.c 包下的并发工具类和并发容器也是需要花时间去掌握的，这些东西在以后得文章中多会一一进行讨论。\n\n> 参考文献\n\n《java并发编程的艺术》",charsets:{cjk:!0},createdTime:1655628697e3},{title:"彻底理解volatile",frontmatter:{title:"彻底理解volatile",description:"彻底理解volatile",date:"2022-03-28T15:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/05%E3%80%81%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3volatile.html",relativePath:"Java/Java并发编程的艺术/05、彻底理解volatile.md",key:"v-383aa104",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/05%E3%80%81%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3volatile.html",headers:[{level:2,title:"1、volatile 的特性",slug:"_1、volatile-的特性",normalizedTitle:"1、volatile 的特性",charIndex:23},{level:2,title:"2、volatile 的实现原理",slug:"_2、volatile-的实现原理",normalizedTitle:"2、volatile 的实现原理",charIndex:41},{level:2,title:"3、volatile 的 happens-before 关系",slug:"_3、volatile-的-happens-before-关系",normalizedTitle:"3、volatile 的 happens-before 关系",charIndex:61},{level:2,title:"4、volatile的内存语义",slug:"_4、volatile的内存语义",normalizedTitle:"4、volatile的内存语义",charIndex:95},{level:2,title:"5、volatile内存语义的实现",slug:"_5、volatile内存语义的实现",normalizedTitle:"5、volatile内存语义的实现",charIndex:114},{level:2,title:"6、一个例子",slug:"_6、一个例子",normalizedTitle:"6、一个例子",charIndex:135}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>彻底理解volatile</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"1、volatile 的特性 2、volatile 的实现原理 3、volatile 的 happens-before 关系 4、volatile的内存语义 5、volatile内存语义的实现 6、一个例子",content:"说明\n\n彻底理解volatile\n\n\n\n * 1、volatile 的特性\n * 2、volatile 的实现原理\n * 3、volatile 的 happens-before 关系\n * 4、volatile的内存语义\n * 5、volatile内存语义的实现\n * 6、一个例子\n\n\n\n\n# 彻底理解volatile\n\nsynchronized是阻塞式同步，在线程竞争激烈的情况下会升级为重量级锁。而volatile就可以说是java虚拟机提供的最轻量级的同步机制。但它同时不容易被正确理解，也至于在并发编程中很多程序员遇到线程安全的问题就会使用synchronized。Java内存模型告诉我们，各个线程会将共享变量从主内存中拷贝到工作内存，然后执行引擎会基于工作内存中的数据进行操作处理。线程在工作内存进行操作后何时会写到主内存中？这个时机对普通变量是没有规定的，而针对volatile修饰的变量给java虚拟机特殊的约定，线程对volatile变量的修改会立刻被其他线程所感知，即不会出现数据脏读的现象，从而保证数据的“可见性”。\n\n现在我们有了一个大概的印象就是：被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。\n\n\n# 1、volatile 的特性\n\n理解volatile特性的一个好方法是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。下面通过具体的示例来说明，示例代码如下。\n\nclass VolatileFeaturesExample {\n    volatile long vl = 0L; // 使用volatile声明64位的long型变量\n\n    public void set(long l) {\n        vl = l; // 单个volatile变量的写\n    }\n    public void getAndIncrement () {\n        vl++; // 复合（多个）volatile变量的读/写\n    }\n    public long get() {\n        return vl; // 单个volatile变量的读\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n假设有多个线程分别调用上面程序的3个方法，这个程序在语义上和下面程序等价。\n\nclass VolatileFeaturesExample {\n    long vl = 0L; // 64位的long型普通变量\n\n    public synchronized void set(long l) { // 对单个的普通变量的写用同一个锁同步\n        vl = l;\n    }\n    public void getAndIncrement () { // 普通方法调用\n        long temp = get(); // 调用已同步的读方法\n        temp += 1L; // 普通写操作\n        set(temp); // 调用已同步的写方法\n    }\n    public synchronized long get() { // 对单个的普通变量的读用同一个锁同步\n        return vl;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如上面示例程序所示，一个volatile变量的单个读/写操作，与一个普通变量的读/写操作都是使用同一个锁来同步，它们之间的执行效果相同。\n\n简而言之，volatile变量自身具有下列特性：\n\n * 可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。\n * 原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。\n\n\n# 2、volatile 的实现原理\n\nJava 语言规范第3版中对 volatile 的定义如下：\n\n> Java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。\n\nJava语言 提供了 volatile，在某些情况下比锁要更加方便。如果一个字段被声明成 volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。\n\n在了解 volatile 实现原理之前，我们先来看下与其实现原理相关的 CPU 术语与说明。\n\n\n\nvolatile 是如何来保证可见性的呢？让我们在 X86 处理器下通过工具获取JIT编译器生成的汇编指令来查看对 volatile 进行写操作时，CPU会做什么事情。\n\nJava 代码：\n\ninstance = new Instancce() //instance是volatile变量\n\n\n1\n\n\n转变成汇编代码如下：\n\n0x01a3de1d: movb $0×0,0×1104800(%esi);0x01a3de24: lock addl $0×0,(%esp);\n\n\n1\n\n\n在生成汇编代码时会在 volatile 修饰的共享变量进行写操作的时候会多出 Lock 前缀的指令（具体的大家可以使用一些工具去看一下，这里我就只把结果说出来）。我们想这个Lock 指令肯定有神奇的地方，那么 Lock 前缀的指令在多核处理器下会发现什么事情了？主要有这两个方面的影响：\n\n 1. 将当前处理器缓存行的数据写回系统内存；\n 2. 这个写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效\n\n为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。\n\n因此，经过分析，volatile 的实现原则如下：\n\n 1. Lock前缀的指令会引起处理器缓存写回内存；\n 2. 一个处理器的缓存回写到内存会导致其他处理器的缓存失效；\n 3. 当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。\n\n这样针对 volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。\n\n\n# 3、volatile 的 happens-before 关系\n\n经过上面的分析，我们已经知道了volatile变量可以通过缓存一致性协议保证每个线程都能获得最新值，即满足数据的“可见性”。我们继续延续上一篇分析问题的方式（我一直认为思考问题的方式是属于自己，也才是最重要的，也在不断培养这方面的能力），我一直将并发分析的切入点分为两个核心，三大性质。两大核心：JMM内存模型（主内存和工作内存）以及happens-before；三条性质：原子性，可见性，有序性（关于三大性质的总结在以后得文章会和大家共同探讨）。废话不多说，先来看两个核心之一：volatile的happens-before关系。\n\n在六条happens-before规则中有一条是：**volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。**下面我们结合具体的代码，我们利用这条规则推导下：\n\npublic class VolatileExample {\n    private int a = 0;\n    private volatile boolean flag = false;\n    public void writer(){\n        a = 1;          //1\n        flag = true;   //2\n    }\n    public void reader(){\n        if(flag){      //3\n            int i = a; //4\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n假设线程A执行writer()方法之后，线程B执行reader()方法。\n\n上述happens-before关系的图形化表现形式如下：\n\n\n\n在上图中，每一个箭头链接的两个节点，代表了一个happens-before关系。黑色箭头表示程序顺序规则；橙色箭头表示volatile规则；蓝色箭头表示组合这些规则后提供的happens-before保证。\n\n这里A线程写一个volatile变量后，B线程读同一个volatile变量。A线程在写volatile变量之前所有可见的共享变量，在B线程读同一个volatile变量后，将立即变得对B线程可见。\n\n\n# 4、volatile的内存语义\n\n还是按照两个核心的分析方式，分析完happens-before关系后我们现在就来进一步分析volatile的内存语义。\n\nvolatile写的内存语义如下：\n\n> 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。\n\n以上面示例程序VolatileExample为例，假设线程A首先执行writer()方法，随后线程B执行reader()方法，初始时两个线程的本地内存中的flag和a都是初始状态。图3-17是线程A执行volatile写后，共享变量的状态示意图。\n\n\n\n如图，线程A在写flag变量后，本地内存A中被线程A更新过的两个共享变量的值被刷新到主内存中。此时，本地内存A和主内存中的共享变量的值是一致的。\n\nvolatile读的内存语义如下：\n\n> 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。\n\n图3-18为线程B读同一个volatile变量后，共享变量的状态示意图。\n\n\n\n如图所示，在读flag变量后，本地内存B包含的值已经被置为无效。此时，线程B必须从主内存中读取共享变量。线程B的读取操作将导致本地内存B与主内存中的共享变量的值变成一致。\n\n如果我们把volatile写和volatile读两个步骤综合起来看的话，在读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都将立即变得对读线程B可见。\n\n下面对volatile写和volatile读的内存语义做个总结：\n\n * 线程A写一个volatile变量，实质上是线程A向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所做修改的）消息。\n * 线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。\n * 线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息。\n\n\n# 5、volatile内存语义的实现\n\n我们都知道，为了性能优化，JMM在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序，那如果想阻止重排序要怎么办了？答案是可以添加内存屏障。\n\n> 内存屏障\n\nJMM内存屏障分为四类见下图\n\n\n\njava编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。为了实现volatile的内存语义，JMM会限制特定类型的编译器和处理器重排序，JMM会针对编译器制定volatile重排序规则表：\n\n\n\n举例来说，第三行最后一个单元格的意思是：在程序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。 从上图可以看出：\n\n * 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。\n * 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。\n * 当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。\n\n为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：\n\n * 在每个volatile写操作的前面插入一个StoreStore屏障。\n * 在每个volatile写操作的后面插入一个StoreLoad屏障。\n * 在每个volatile读操作的后面插入一个LoadLoad屏障。\n * 在每个volatile读操作的后面插入一个LoadStore屏障。\n\n需要注意的是：volatile写是在前面和后面分别插入内存屏障，而volatile读操作是在后面插入两个内存屏障。上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。\n\n内存屏障在这里的语义可以理解为：\n\n * StoreStore屏障：禁止上面的普通写和下面的volatile写重排序；\n * StoreLoad屏障：防止上面的volatile写与下面可能有的volatile读/写重排序\n * LoadLoad屏障：禁止下面所有的普通读操作和上面的volatile读重排序\n * LoadStore屏障：禁止下面所有的普通写操作和上面的volatile读重排序\n\n如下图：\n\n\n\n\n\n上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。\n\n\n# 6、一个例子\n\n我们现在已经理解volatile的精华了，再重新认识一下以下代码：\n\npublic class VolatileDemo {\n    private static volatile boolean isOver = false;\n\n    public static void main(String[] args) {\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                while (!isOver) ;\n            }\n        });\n        thread.start();\n        try {\n            Thread.sleep(500);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        isOver = true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n现在已经将isOver设置成了volatile变量，这样在main线程中将isOver改为了true后，thread的工作内存该变量值就会失效，从而需要再次从主内存中读取该值，现在能够读出isOver最新值为true从而能够结束在thread里的死循环，从而能够顺利停止掉thread线程。",normalizedContent:"说明\n\n彻底理解volatile\n\n\n\n * 1、volatile 的特性\n * 2、volatile 的实现原理\n * 3、volatile 的 happens-before 关系\n * 4、volatile的内存语义\n * 5、volatile内存语义的实现\n * 6、一个例子\n\n\n\n\n# 彻底理解volatile\n\nsynchronized是阻塞式同步，在线程竞争激烈的情况下会升级为重量级锁。而volatile就可以说是java虚拟机提供的最轻量级的同步机制。但它同时不容易被正确理解，也至于在并发编程中很多程序员遇到线程安全的问题就会使用synchronized。java内存模型告诉我们，各个线程会将共享变量从主内存中拷贝到工作内存，然后执行引擎会基于工作内存中的数据进行操作处理。线程在工作内存进行操作后何时会写到主内存中？这个时机对普通变量是没有规定的，而针对volatile修饰的变量给java虚拟机特殊的约定，线程对volatile变量的修改会立刻被其他线程所感知，即不会出现数据脏读的现象，从而保证数据的“可见性”。\n\n现在我们有了一个大概的印象就是：被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。\n\n\n# 1、volatile 的特性\n\n理解volatile特性的一个好方法是把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步。下面通过具体的示例来说明，示例代码如下。\n\nclass volatilefeaturesexample {\n    volatile long vl = 0l; // 使用volatile声明64位的long型变量\n\n    public void set(long l) {\n        vl = l; // 单个volatile变量的写\n    }\n    public void getandincrement () {\n        vl++; // 复合（多个）volatile变量的读/写\n    }\n    public long get() {\n        return vl; // 单个volatile变量的读\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n假设有多个线程分别调用上面程序的3个方法，这个程序在语义上和下面程序等价。\n\nclass volatilefeaturesexample {\n    long vl = 0l; // 64位的long型普通变量\n\n    public synchronized void set(long l) { // 对单个的普通变量的写用同一个锁同步\n        vl = l;\n    }\n    public void getandincrement () { // 普通方法调用\n        long temp = get(); // 调用已同步的读方法\n        temp += 1l; // 普通写操作\n        set(temp); // 调用已同步的写方法\n    }\n    public synchronized long get() { // 对单个的普通变量的读用同一个锁同步\n        return vl;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n如上面示例程序所示，一个volatile变量的单个读/写操作，与一个普通变量的读/写操作都是使用同一个锁来同步，它们之间的执行效果相同。\n\n简而言之，volatile变量自身具有下列特性：\n\n * 可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。\n * 原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。\n\n\n# 2、volatile 的实现原理\n\njava 语言规范第3版中对 volatile 的定义如下：\n\n> java 编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。\n\njava语言 提供了 volatile，在某些情况下比锁要更加方便。如果一个字段被声明成 volatile，java线程内存模型确保所有线程看到这个变量的值是一致的。\n\n在了解 volatile 实现原理之前，我们先来看下与其实现原理相关的 cpu 术语与说明。\n\n\n\nvolatile 是如何来保证可见性的呢？让我们在 x86 处理器下通过工具获取jit编译器生成的汇编指令来查看对 volatile 进行写操作时，cpu会做什么事情。\n\njava 代码：\n\ninstance = new instancce() //instance是volatile变量\n\n\n1\n\n\n转变成汇编代码如下：\n\n0x01a3de1d: movb $0×0,0×1104800(%esi);0x01a3de24: lock addl $0×0,(%esp);\n\n\n1\n\n\n在生成汇编代码时会在 volatile 修饰的共享变量进行写操作的时候会多出 lock 前缀的指令（具体的大家可以使用一些工具去看一下，这里我就只把结果说出来）。我们想这个lock 指令肯定有神奇的地方，那么 lock 前缀的指令在多核处理器下会发现什么事情了？主要有这两个方面的影响：\n\n 1. 将当前处理器缓存行的数据写回系统内存；\n 2. 这个写回内存的操作会使得其他cpu里缓存了该内存地址的数据无效\n\n为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（l1，l2或其他）后再进行操作，但操作完不知道何时会写到内存。如果对声明了volatile的变量进行写操作，jvm就会向处理器发送一条lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。\n\n因此，经过分析，volatile 的实现原则如下：\n\n 1. lock前缀的指令会引起处理器缓存写回内存；\n 2. 一个处理器的缓存回写到内存会导致其他处理器的缓存失效；\n 3. 当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。\n\n这样针对 volatile 变量通过这样的机制就使得每个线程都能获得该变量的最新值。\n\n\n# 3、volatile 的 happens-before 关系\n\n经过上面的分析，我们已经知道了volatile变量可以通过缓存一致性协议保证每个线程都能获得最新值，即满足数据的“可见性”。我们继续延续上一篇分析问题的方式（我一直认为思考问题的方式是属于自己，也才是最重要的，也在不断培养这方面的能力），我一直将并发分析的切入点分为两个核心，三大性质。两大核心：jmm内存模型（主内存和工作内存）以及happens-before；三条性质：原子性，可见性，有序性（关于三大性质的总结在以后得文章会和大家共同探讨）。废话不多说，先来看两个核心之一：volatile的happens-before关系。\n\n在六条happens-before规则中有一条是：**volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。**下面我们结合具体的代码，我们利用这条规则推导下：\n\npublic class volatileexample {\n    private int a = 0;\n    private volatile boolean flag = false;\n    public void writer(){\n        a = 1;          //1\n        flag = true;   //2\n    }\n    public void reader(){\n        if(flag){      //3\n            int i = a; //4\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n假设线程a执行writer()方法之后，线程b执行reader()方法。\n\n上述happens-before关系的图形化表现形式如下：\n\n\n\n在上图中，每一个箭头链接的两个节点，代表了一个happens-before关系。黑色箭头表示程序顺序规则；橙色箭头表示volatile规则；蓝色箭头表示组合这些规则后提供的happens-before保证。\n\n这里a线程写一个volatile变量后，b线程读同一个volatile变量。a线程在写volatile变量之前所有可见的共享变量，在b线程读同一个volatile变量后，将立即变得对b线程可见。\n\n\n# 4、volatile的内存语义\n\n还是按照两个核心的分析方式，分析完happens-before关系后我们现在就来进一步分析volatile的内存语义。\n\nvolatile写的内存语义如下：\n\n> 当写一个volatile变量时，jmm会把该线程对应的本地内存中的共享变量值刷新到主内存。\n\n以上面示例程序volatileexample为例，假设线程a首先执行writer()方法，随后线程b执行reader()方法，初始时两个线程的本地内存中的flag和a都是初始状态。图3-17是线程a执行volatile写后，共享变量的状态示意图。\n\n\n\n如图，线程a在写flag变量后，本地内存a中被线程a更新过的两个共享变量的值被刷新到主内存中。此时，本地内存a和主内存中的共享变量的值是一致的。\n\nvolatile读的内存语义如下：\n\n> 当读一个volatile变量时，jmm会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。\n\n图3-18为线程b读同一个volatile变量后，共享变量的状态示意图。\n\n\n\n如图所示，在读flag变量后，本地内存b包含的值已经被置为无效。此时，线程b必须从主内存中读取共享变量。线程b的读取操作将导致本地内存b与主内存中的共享变量的值变成一致。\n\n如果我们把volatile写和volatile读两个步骤综合起来看的话，在读线程b读一个volatile变量后，写线程a在写这个volatile变量之前所有可见的共享变量的值都将立即变得对读线程b可见。\n\n下面对volatile写和volatile读的内存语义做个总结：\n\n * 线程a写一个volatile变量，实质上是线程a向接下来将要读这个volatile变量的某个线程发出了（其对共享变量所做修改的）消息。\n * 线程b读一个volatile变量，实质上是线程b接收了之前某个线程发出的（在写这个volatile变量之前对共享变量所做修改的）消息。\n * 线程a写一个volatile变量，随后线程b读这个volatile变量，这个过程实质上是线程a通过主内存向线程b发送消息。\n\n\n# 5、volatile内存语义的实现\n\n我们都知道，为了性能优化，jmm在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序，那如果想阻止重排序要怎么办了？答案是可以添加内存屏障。\n\n> 内存屏障\n\njmm内存屏障分为四类见下图\n\n\n\njava编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。为了实现volatile的内存语义，jmm会限制特定类型的编译器和处理器重排序，jmm会针对编译器制定volatile重排序规则表：\n\n\n\n举例来说，第三行最后一个单元格的意思是：在程序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。 从上图可以看出：\n\n * 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。\n * 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。\n * 当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。\n\n为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。为此，jmm采取保守策略。下面是基于保守策略的jmm内存屏障插入策略：\n\n * 在每个volatile写操作的前面插入一个storestore屏障。\n * 在每个volatile写操作的后面插入一个storeload屏障。\n * 在每个volatile读操作的后面插入一个loadload屏障。\n * 在每个volatile读操作的后面插入一个loadstore屏障。\n\n需要注意的是：volatile写是在前面和后面分别插入内存屏障，而volatile读操作是在后面插入两个内存屏障。上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得到正确的volatile内存语义。\n\n内存屏障在这里的语义可以理解为：\n\n * storestore屏障：禁止上面的普通写和下面的volatile写重排序；\n * storeload屏障：防止上面的volatile写与下面可能有的volatile读/写重排序\n * loadload屏障：禁止下面所有的普通读操作和上面的volatile读重排序\n * loadstore屏障：禁止下面所有的普通写操作和上面的volatile读重排序\n\n如下图：\n\n\n\n\n\n上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。\n\n\n# 6、一个例子\n\n我们现在已经理解volatile的精华了，再重新认识一下以下代码：\n\npublic class volatiledemo {\n    private static volatile boolean isover = false;\n\n    public static void main(string[] args) {\n        thread thread = new thread(new runnable() {\n            @override\n            public void run() {\n                while (!isover) ;\n            }\n        });\n        thread.start();\n        try {\n            thread.sleep(500);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        isover = true;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n现在已经将isover设置成了volatile变量，这样在main线程中将isover改为了true后，thread的工作内存该变量值就会失效，从而需要再次从主内存中读取该值，现在能够读出isover最新值为true从而能够结束在thread里的死循环，从而能够顺利停止掉thread线程。",charsets:{cjk:!0},createdTime:1655628697e3},{title:"你真的了解final吗？",frontmatter:{title:"你真的了解final吗？",description:"你真的了解final吗？",date:"2022-03-29T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/06%E3%80%81%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3final%E5%90%97%EF%BC%9F.html",relativePath:"Java/Java并发编程的艺术/06、你真的了解final吗？.md",key:"v-05a7ba0f",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/06%E3%80%81%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3final%E5%90%97%EF%BC%9F.html",headers:[{level:2,title:"1、final的简介",slug:"_1、final的简介",normalizedTitle:"1、final的简介",charIndex:23},{level:2,title:"2、final的具体使用场景",slug:"_2、final的具体使用场景",normalizedTitle:"2、final的具体使用场景",charIndex:37},{level:3,title:"final变量",slug:"final变量",normalizedTitle:"final变量",charIndex:57},{level:3,title:"final方法",slug:"final方法",normalizedTitle:"final方法",charIndex:70},{level:3,title:"final类",slug:"final类",normalizedTitle:"final类",charIndex:83},{level:2,title:"3、final的应用",slug:"_3、final的应用",normalizedTitle:"3、final的应用",charIndex:93},{level:2,title:"4、final域的内存语义",slug:"_4、final域的内存语义",normalizedTitle:"4、final域的内存语义",charIndex:107},{level:3,title:"final域重排序规则",slug:"final域重排序规则",normalizedTitle:"final域重排序规则",charIndex:126},{level:2,title:"5、不同处理器的影响",slug:"_5、不同处理器的影响",normalizedTitle:"5、不同处理器的影响",charIndex:141},{level:2,title:"6、为什么final引用不能从构造函数中“溢出”",slug:"_6、为什么final引用不能从构造函数中-溢出",normalizedTitle:"6、为什么final引用不能从构造函数中“溢出”",charIndex:155}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>你真的了解final吗？</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"1、final的简介 2、final的具体使用场景 final变量 final方法 final类 3、final的应用 4、final域的内存语义 final域重排序规则 5、不同处理器的影响 6、为什么final引用不能从构造函数中“溢出”",content:'说明\n\n你真的了解final吗？\n\n\n\n * 1、final的简介\n * 2、final的具体使用场景\n   * final变量\n   * final方法\n   * final类\n * 3、final的应用\n * 4、final域的内存语义\n   * final域重排序规则\n * 5、不同处理器的影响\n * 6、为什么final引用不能从构造函数中“溢出”\n\n\n\n\n# 你真的了解final吗？\n\n\n# 1、final的简介\n\nfinal可以修饰变量，方法和类，用于表示所修饰的内容一旦赋值之后就不会再被改变，比如String类就是一个final类型的类。即使能够知道final具体的使用方法，我想对final在多线程中存在的重排序问题也很容易忽略，希望能够一起做下探讨。\n\n\n# 2、final的具体使用场景\n\nfinal能够修饰变量，方法和类，也就是final使用范围基本涵盖了java每个地方，下面就分别以锁修饰的位置：变量，方法和类分别来说一说。\n\n\n# final变量\n\n在java中变量，可以分为成员变量以及方法局部变量。因此也是按照这种方式依次来说，以避免漏掉任何一个死角。\n\n# final成员变量\n\n通常每个类中的成员变量可以分为类变量（static修饰的变量）以及实例变量。针对这两种类型的变量赋初值的时机是不同的。\n\n * 类变量可以在声明变量的时候直接赋初值或者在静态代码块中给类变量赋初值。\n * 而实例变量可以在声明变量的时候给实例变量赋初值，在非静态初始化块中以及构造器中赋初值。\n\n类变量有两个时机赋初值，而实例变量则可以有三个时机赋初值。当final变量未初始化时系统不会进行隐式初始化，会出现报错。这样说起来还是比较抽象，下面用具体的代码来演示。（代码涵盖了final修饰变量所有的可能情况，耐心看下去会有收获的:) ）\n\n\n\n\n\n看上面的图片已经将每种情况整理出来了，这里用截图的方式也是觉得在IDE出现红色出错的标记更能清晰的说明情况。现在我们来将这几种情况归纳整理一下：\n\n 1. 类变量：必须要在静态初始化块中指定初始值或者声明该类变量时指定初始值，而且只能在这两个地方之一进行指定；\n 2. 实例变量：必要要在非静态初始化块，声明该实例变量或者在构造器中指定初始值，而且只能在这三个地方进行指定。\n\n# final局部变量\n\nfinal局部变量由程序员进行显式初始化，如果final局部变量已经进行了初始化则后面就不能再次进行更改，如果final变量未进行初始化，可以进行赋值，当且仅有一次赋值，一旦赋值之后再次赋值就会出错。下面用具体的代码演示final局部变量的情况：\n\n\n\n现在我们来换一个角度进行考虑，final修饰的是基本数据类型和引用类型有区别吗？\n\n> final基本数据类型 VS final引用数据类型\n\n通过上面的例子我们已经看出来，如果final修饰的是一个基本数据类型的数据，一旦赋值后就不能再次更改，那么，如果final是引用数据类型了？这个引用的对象能够改变吗？我们同样来看一段代码。\n\npublic class FinalExample {\n    //在声明final实例成员变量时进行赋值\n    private final static Person person = new Person(24, 170);\n    public static void main(String[] args) {\n        //对final引用数据类型person进行更改\n        person.age = 22;\n        System.out.println(person.toString());\n    }\n    static class Person {\n        private int age;\n        private int height;\n\n        public Person(int age, int height) {\n            this.age = age;\n            this.height = height;\n        }\n        @Override\n        public String toString() {\n            return "Person{" +\n                    "age=" + age +\n                    ", height=" + height +\n                    \'}\';\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n当我们对final修饰的引用数据类型变量person的属性改成22，是可以成功操作的。通过这个实验我们就可以看出来当final修饰基本数据类型变量时，不能对基本数据类型变量重新赋值，因此基本数据类型变量不能被改变。而对于引用类型变量而言，它仅仅保存的是一个引用，final只保证这个引用类型变量所引用的地址不会发生改变，即一直引用这个对象，但这个对象属性是可以改变的。\n\n> 宏变量\n\n利用final变量的不可更改性，在满足以下三个条件时，该变量就会成为一个“宏变量”，即是一个常量。\n\n 1. 使用final修饰符修饰；\n 2. 在定义该final变量时就指定了初始值；\n 3. 该初始值在编译时就能够唯一指定。\n\n注意：当程序中其他地方使用该宏变量的地方，编译器会直接替换成该变量的值\n\n\n# final方法\n\n> 重写？\n\n当父类的方法被final修饰的时候，子类不能重写父类的该方法，比如在Object中，getClass()方法就是final的，我们就不能重写该方法，但是hashCode()方法就不是被final所修饰的，我们就可以重写hashCode()方法。我们还是来写一个例子来加深一下理解： 先定义一个父类，里面有final修饰的方法test();\n\npublic class FinalExampleParent {\n    public final void test() {\n    }\n}\n\n\n1\n2\n3\n4\n\n\n然后FinalExample继承该父类，当重写test()方法时出现报错，如下图：\n\n\n\n通过这个现象我们就可以看出来被final修饰的方法不能够被子类所重写。\n\n> 重载？\n\npublic class FinalExampleParent {\n    public final void test() {\n    }\n\n    public final void test(String str) {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看出被final修饰的方法是可以重载的，重载出来的也还是final方法。经过我们的分析可以得出如下结论：\n\n1. 父类的final方法是不能够被子类重写的\n\n2. final方法是可以被重载的\n\n\n# final类\n\n当一个类被final修饰时，表明该类是不能被子类继承的。子类继承往往可以重写父类的方法和改变父类属性，会带来一定的安全隐患，因此，当一个类不希望被继承时就可以使用final修饰。还是来写一个小例子：\n\npublic final class FinalExampleParent {\n    public final void test() {\n    }\n}\n\n\n1\n2\n3\n4\n\n\n父类会被final修饰，当子类继承该父类的时候，就会报错，如下图：\n\n\n\n\n# 3、final的应用\n\nfinal经常会被用作不变类上，利用final的不可更改性。我们先来看看什么是不变类。\n\n> 不变类\n\n不变类的意思是创建该类的实例后，该实例的实例变量是不可改变的。满足以下条件则可以成为不可变类：\n\n 1. 使用private和final修饰符来修饰该类的成员变量\n 2. 提供带参的构造器用于初始化类的成员变量；\n 3. 仅为该类的成员变量提供getter方法，不提供setter方法，因为普通方法无法修改fina修饰的成员变量；\n 4. 如果有必要就重写Object类 的hashCode()和equals()方法，应该保证用equals()判断相同的两个对象其Hashcode值也是相等的。\n\nJDK中提供的八个包装类和String类都是不可变类，我们来看看String的实现。\n\n/** The value is used for character storage. */\n private final char value[];\n\n\n1\n2\n\n\n可以看出String的value就是final修饰的，上述其他几条性质也是吻合的。\n\n\n# 4、final域的内存语义\n\n上面我们聊的final使用，应该属于Java基础层面的，当理解这些后我们就真的算是掌握了final吗？有考虑过final在多线程并发的情况吗？在java内存模型中我们知道java内存模型为了能让处理器和编译器底层发挥他们的最大优势，对底层的约束就很少，也就是说针对底层来说java内存模型就是一弱内存数据模型。同时，处理器和编译为了性能优化会对指令序列有编译器和处理器重排序。那么，在多线程情况下，final会进行怎样的重排序？会导致线程安全的问题吗？下面，就来看看final的重排序。\n\n\n# final域重排序规则\n\n# final域为基本类型\n\n先看一段示例性的代码：\n\npublic class FinalDemo {\n    private int a;  //普通域\n    private final int b; //final域\n    private static FinalDemo finalDemo;\n\n    public FinalDemo() {\n        a = 1; // 1. 写普通域\n        b = 2; // 2. 写final域\n    }\n\n    public static void writer() {\n        finalDemo = new FinalDemo();\n    }\n\n    public static void reader() {\n        FinalDemo demo = finalDemo; // 3.读对象引用\n        int a = demo.a;    //4.读普通域\n        int b = demo.b;    //5.读final域\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n假设线程A在执行writer()方法，线程B执行reader()方法。\n\n> 写final域重排序规则\n\n写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：\n\n 1. JMM禁止编译器把final域的写重排序到构造函数之外；\n 2. 编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。\n\n我们再来分析writer方法，虽然只有一行代码，但实际上做了两件事情：\n\n 1. 构造了一个FinalDemo对象；\n 2. 把这个对象赋值给成员变量finalDemo。\n\n我们来看一下一种执行时序图，如下：\n\n\n\n由于i，j之间没有数据依赖性，普通域（普通变量）i可能会被重排序到构造函数之外，线程B就有可能读到的是普通变量i初始化之前的值（零值），这样就可能出现错误。而final域变量j，根据重排序规则，会禁止final修饰的变量j重排序到构造函数之外，从而j能够正确赋值，线程B就能够读到final变量初始化后的值。\n\n因此，写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障。比如在上例，线程B有可能就是一个未正确初始化的对象finalDemo。\n\n（其实从这个写final域重排序规则就可以看出上面对final变量为什么只有那几种情况的初始化方式）\n\n> 读final域重排序规则\n\n读final域重排序规则为：在一个线程中，初次读对象引用和初次读该对象包含的final域，JMM会禁止这两个操作的重排序。（注意，这个规则仅仅是针对处理器），处理器会在读final域操作的前面插入一个LoadLoad屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序（比如alpha处理器），因此，这条禁止重排序规则就是针对这些处理器而设定的。\n\nread()方法主要包含了三个操作：\n\n 1. 初次读引用变量finalDemo;\n 2. 初次读引用变量finalDemo的普通域i;\n 3. 初次读引用变量finalDemo的final与j;\n\n假设线程A写过程没有重排序，那么线程A和线程B有一种的可能执行时序为下图：\n\n\n\n读对象的普通域被重排序到了读对象引用的前面就会出现线程B还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而final域的读操作就“限定”了在读final域变量前已经读到了该对象的引用，从而就可以避免这种情况。\n\n读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。\n\n# final域为引用类型\n\n我们已经知道了final域是基本数据类型的时候重排序规则是怎么的了？如果是引用数据类型了？我们接着继续来探讨。\n\n> 对final修饰的对象的成员域写操作\n\n针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里使用的是**“增加”**也就说前面对final基本数据类型的重排序规则在这里还是使用。这句话是比较拗口的，下面结合实例来看。\n\npublic class FinalReferenceDemo {\n    final int[] arrays;\n    private FinalReferenceDemo finalReferenceDemo;\n\n    public FinalReferenceDemo() {\n        arrays = new int[1];  //1\n        arrays[0] = 1;        //2\n    }\n\n    public void writerOne() {\n        finalReferenceDemo = new FinalReferenceDemo(); //3\n    }\n\n    public void writerTwo() {\n        arrays[0] = 2;  //4\n    }\n\n    public void reader() {\n        if (finalReferenceDemo != null) {  //5\n            int temp = finalReferenceDemo.arrays[0];  //6\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n针对上面的实例程序，线程线程A执行wirterOne方法，执行完后线程B执行writerTwo方法，然后线程C执行reader方法。下图就以这种执行时序出现的一种情况来讨论（耐心看完才有收获）。\n\n\n\n由于对final域的写禁止重排序到构造方法外，因此1和3不能被重排序。由于一个final域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此2和3不能重排序。\n\n> 对final修饰的对象的成员域读操作\n\nJMM可以确保线程C至少能看到写线程A对final引用的对象的成员域的写入，即能看下arrays[0] = 1，而写线程B对数组元素的写入可能看到可能看不到。JMM不保证线程B的写入对线程C可见，线程B和线程C之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。\n\n> 关于final重排序的总结\n\n按照final修饰的数据类型分类：\n\n基本数据类型:\n\n 1. final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。\n 2. final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。\n\n引用数据类型：\n\n额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量重排序\n\n\n# 5、不同处理器的影响\n\n上面我们提到过，写final域会要求编译器在final域写之后，构造函数返回前插入一个StoreStore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个LoadLoad屏障。\n\n很有意思的是，如果以X86处理为例，X86不会对写-写重排序，所以StoreStore屏障可以省略。由于不会对有间接依赖性的操作重排序，所以在X86处理器中，读final域需要的LoadLoad屏障也会被省略掉。也就是说，以X86为例的话，对final域的读/写的内存屏障都会被省略！具体是否插入还是得看是什么处理器。\n\n\n# 6、为什么final引用不能从构造函数中“溢出”\n\n这里还有一个比较有意思的问题：上面对final域写重排序规则可以确保我们在使用一个对象引用的时候该对象的final域已经在构造函数被初始化过了。但是这里其实是有一个前提条件的，也就是：在构造函数返回前，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中“逸出”。以下面的例子来说：\n\npublic class FinalReferenceEscapeDemo {\n    private final int a;\n    private FinalReferenceEscapeDemo referenceDemo;\n\n    public FinalReferenceEscapeDemo() {\n        a = 1;  //1\n        referenceDemo = this; //2\n    }\n\n    public void writer() {\n        new FinalReferenceEscapeDemo();\n    }\n\n    public void reader() {\n        if (referenceDemo != null) {  //3\n            int temp = referenceDemo.a; //4\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n可能的执行时序如图所示：\n\n\n\n假设一个线程A执行writer方法另一个线程执行reader方法。因为构造函数中操作1和2之间没有数据依赖性，1和2可以重排序，先执行了2，这个时候引用对象referenceDemo是个没有完全初始化的对象，而当线程B去读取该对象时就会出错。尽管依然满足了final域写重排序规则：在引用对象对所有线程可见时，其final域已经完全初始化成功。但是，引用对象“this”逸出，该代码依然存在线程安全的问题。\n\n> 参看文献\n\n《java并发编程的艺术》',normalizedContent:'说明\n\n你真的了解final吗？\n\n\n\n * 1、final的简介\n * 2、final的具体使用场景\n   * final变量\n   * final方法\n   * final类\n * 3、final的应用\n * 4、final域的内存语义\n   * final域重排序规则\n * 5、不同处理器的影响\n * 6、为什么final引用不能从构造函数中“溢出”\n\n\n\n\n# 你真的了解final吗？\n\n\n# 1、final的简介\n\nfinal可以修饰变量，方法和类，用于表示所修饰的内容一旦赋值之后就不会再被改变，比如string类就是一个final类型的类。即使能够知道final具体的使用方法，我想对final在多线程中存在的重排序问题也很容易忽略，希望能够一起做下探讨。\n\n\n# 2、final的具体使用场景\n\nfinal能够修饰变量，方法和类，也就是final使用范围基本涵盖了java每个地方，下面就分别以锁修饰的位置：变量，方法和类分别来说一说。\n\n\n# final变量\n\n在java中变量，可以分为成员变量以及方法局部变量。因此也是按照这种方式依次来说，以避免漏掉任何一个死角。\n\n# final成员变量\n\n通常每个类中的成员变量可以分为类变量（static修饰的变量）以及实例变量。针对这两种类型的变量赋初值的时机是不同的。\n\n * 类变量可以在声明变量的时候直接赋初值或者在静态代码块中给类变量赋初值。\n * 而实例变量可以在声明变量的时候给实例变量赋初值，在非静态初始化块中以及构造器中赋初值。\n\n类变量有两个时机赋初值，而实例变量则可以有三个时机赋初值。当final变量未初始化时系统不会进行隐式初始化，会出现报错。这样说起来还是比较抽象，下面用具体的代码来演示。（代码涵盖了final修饰变量所有的可能情况，耐心看下去会有收获的:) ）\n\n\n\n\n\n看上面的图片已经将每种情况整理出来了，这里用截图的方式也是觉得在ide出现红色出错的标记更能清晰的说明情况。现在我们来将这几种情况归纳整理一下：\n\n 1. 类变量：必须要在静态初始化块中指定初始值或者声明该类变量时指定初始值，而且只能在这两个地方之一进行指定；\n 2. 实例变量：必要要在非静态初始化块，声明该实例变量或者在构造器中指定初始值，而且只能在这三个地方进行指定。\n\n# final局部变量\n\nfinal局部变量由程序员进行显式初始化，如果final局部变量已经进行了初始化则后面就不能再次进行更改，如果final变量未进行初始化，可以进行赋值，当且仅有一次赋值，一旦赋值之后再次赋值就会出错。下面用具体的代码演示final局部变量的情况：\n\n\n\n现在我们来换一个角度进行考虑，final修饰的是基本数据类型和引用类型有区别吗？\n\n> final基本数据类型 vs final引用数据类型\n\n通过上面的例子我们已经看出来，如果final修饰的是一个基本数据类型的数据，一旦赋值后就不能再次更改，那么，如果final是引用数据类型了？这个引用的对象能够改变吗？我们同样来看一段代码。\n\npublic class finalexample {\n    //在声明final实例成员变量时进行赋值\n    private final static person person = new person(24, 170);\n    public static void main(string[] args) {\n        //对final引用数据类型person进行更改\n        person.age = 22;\n        system.out.println(person.tostring());\n    }\n    static class person {\n        private int age;\n        private int height;\n\n        public person(int age, int height) {\n            this.age = age;\n            this.height = height;\n        }\n        @override\n        public string tostring() {\n            return "person{" +\n                    "age=" + age +\n                    ", height=" + height +\n                    \'}\';\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n当我们对final修饰的引用数据类型变量person的属性改成22，是可以成功操作的。通过这个实验我们就可以看出来当final修饰基本数据类型变量时，不能对基本数据类型变量重新赋值，因此基本数据类型变量不能被改变。而对于引用类型变量而言，它仅仅保存的是一个引用，final只保证这个引用类型变量所引用的地址不会发生改变，即一直引用这个对象，但这个对象属性是可以改变的。\n\n> 宏变量\n\n利用final变量的不可更改性，在满足以下三个条件时，该变量就会成为一个“宏变量”，即是一个常量。\n\n 1. 使用final修饰符修饰；\n 2. 在定义该final变量时就指定了初始值；\n 3. 该初始值在编译时就能够唯一指定。\n\n注意：当程序中其他地方使用该宏变量的地方，编译器会直接替换成该变量的值\n\n\n# final方法\n\n> 重写？\n\n当父类的方法被final修饰的时候，子类不能重写父类的该方法，比如在object中，getclass()方法就是final的，我们就不能重写该方法，但是hashcode()方法就不是被final所修饰的，我们就可以重写hashcode()方法。我们还是来写一个例子来加深一下理解： 先定义一个父类，里面有final修饰的方法test();\n\npublic class finalexampleparent {\n    public final void test() {\n    }\n}\n\n\n1\n2\n3\n4\n\n\n然后finalexample继承该父类，当重写test()方法时出现报错，如下图：\n\n\n\n通过这个现象我们就可以看出来被final修饰的方法不能够被子类所重写。\n\n> 重载？\n\npublic class finalexampleparent {\n    public final void test() {\n    }\n\n    public final void test(string str) {\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看出被final修饰的方法是可以重载的，重载出来的也还是final方法。经过我们的分析可以得出如下结论：\n\n1. 父类的final方法是不能够被子类重写的\n\n2. final方法是可以被重载的\n\n\n# final类\n\n当一个类被final修饰时，表明该类是不能被子类继承的。子类继承往往可以重写父类的方法和改变父类属性，会带来一定的安全隐患，因此，当一个类不希望被继承时就可以使用final修饰。还是来写一个小例子：\n\npublic final class finalexampleparent {\n    public final void test() {\n    }\n}\n\n\n1\n2\n3\n4\n\n\n父类会被final修饰，当子类继承该父类的时候，就会报错，如下图：\n\n\n\n\n# 3、final的应用\n\nfinal经常会被用作不变类上，利用final的不可更改性。我们先来看看什么是不变类。\n\n> 不变类\n\n不变类的意思是创建该类的实例后，该实例的实例变量是不可改变的。满足以下条件则可以成为不可变类：\n\n 1. 使用private和final修饰符来修饰该类的成员变量\n 2. 提供带参的构造器用于初始化类的成员变量；\n 3. 仅为该类的成员变量提供getter方法，不提供setter方法，因为普通方法无法修改fina修饰的成员变量；\n 4. 如果有必要就重写object类 的hashcode()和equals()方法，应该保证用equals()判断相同的两个对象其hashcode值也是相等的。\n\njdk中提供的八个包装类和string类都是不可变类，我们来看看string的实现。\n\n/** the value is used for character storage. */\n private final char value[];\n\n\n1\n2\n\n\n可以看出string的value就是final修饰的，上述其他几条性质也是吻合的。\n\n\n# 4、final域的内存语义\n\n上面我们聊的final使用，应该属于java基础层面的，当理解这些后我们就真的算是掌握了final吗？有考虑过final在多线程并发的情况吗？在java内存模型中我们知道java内存模型为了能让处理器和编译器底层发挥他们的最大优势，对底层的约束就很少，也就是说针对底层来说java内存模型就是一弱内存数据模型。同时，处理器和编译为了性能优化会对指令序列有编译器和处理器重排序。那么，在多线程情况下，final会进行怎样的重排序？会导致线程安全的问题吗？下面，就来看看final的重排序。\n\n\n# final域重排序规则\n\n# final域为基本类型\n\n先看一段示例性的代码：\n\npublic class finaldemo {\n    private int a;  //普通域\n    private final int b; //final域\n    private static finaldemo finaldemo;\n\n    public finaldemo() {\n        a = 1; // 1. 写普通域\n        b = 2; // 2. 写final域\n    }\n\n    public static void writer() {\n        finaldemo = new finaldemo();\n    }\n\n    public static void reader() {\n        finaldemo demo = finaldemo; // 3.读对象引用\n        int a = demo.a;    //4.读普通域\n        int b = demo.b;    //5.读final域\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n假设线程a在执行writer()方法，线程b执行reader()方法。\n\n> 写final域重排序规则\n\n写final域的重排序规则禁止对final域的写重排序到构造函数之外，这个规则的实现主要包含了两个方面：\n\n 1. jmm禁止编译器把final域的写重排序到构造函数之外；\n 2. 编译器会在final域写之后，构造函数return之前，插入一个storestore屏障。这个屏障可以禁止处理器把final域的写重排序到构造函数之外。\n\n我们再来分析writer方法，虽然只有一行代码，但实际上做了两件事情：\n\n 1. 构造了一个finaldemo对象；\n 2. 把这个对象赋值给成员变量finaldemo。\n\n我们来看一下一种执行时序图，如下：\n\n\n\n由于i，j之间没有数据依赖性，普通域（普通变量）i可能会被重排序到构造函数之外，线程b就有可能读到的是普通变量i初始化之前的值（零值），这样就可能出现错误。而final域变量j，根据重排序规则，会禁止final修饰的变量j重排序到构造函数之外，从而j能够正确赋值，线程b就能够读到final变量初始化后的值。\n\n因此，写final域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域就不具有这个保障。比如在上例，线程b有可能就是一个未正确初始化的对象finaldemo。\n\n（其实从这个写final域重排序规则就可以看出上面对final变量为什么只有那几种情况的初始化方式）\n\n> 读final域重排序规则\n\n读final域重排序规则为：在一个线程中，初次读对象引用和初次读该对象包含的final域，jmm会禁止这两个操作的重排序。（注意，这个规则仅仅是针对处理器），处理器会在读final域操作的前面插入一个loadload屏障。实际上，读对象的引用和读该对象的final域存在间接依赖性，一般处理器不会重排序这两个操作。但是有一些处理器会重排序（比如alpha处理器），因此，这条禁止重排序规则就是针对这些处理器而设定的。\n\nread()方法主要包含了三个操作：\n\n 1. 初次读引用变量finaldemo;\n 2. 初次读引用变量finaldemo的普通域i;\n 3. 初次读引用变量finaldemo的final与j;\n\n假设线程a写过程没有重排序，那么线程a和线程b有一种的可能执行时序为下图：\n\n\n\n读对象的普通域被重排序到了读对象引用的前面就会出现线程b还未读到对象引用就在读取该对象的普通域变量，这显然是错误的操作。而final域的读操作就“限定”了在读final域变量前已经读到了该对象的引用，从而就可以避免这种情况。\n\n读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读这个包含这个final域的对象的引用。\n\n# final域为引用类型\n\n我们已经知道了final域是基本数据类型的时候重排序规则是怎么的了？如果是引用数据类型了？我们接着继续来探讨。\n\n> 对final修饰的对象的成员域写操作\n\n针对引用数据类型，final域写针对编译器和处理器重排序增加了这样的约束：在构造函数内对一个final修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。注意这里使用的是**“增加”**也就说前面对final基本数据类型的重排序规则在这里还是使用。这句话是比较拗口的，下面结合实例来看。\n\npublic class finalreferencedemo {\n    final int[] arrays;\n    private finalreferencedemo finalreferencedemo;\n\n    public finalreferencedemo() {\n        arrays = new int[1];  //1\n        arrays[0] = 1;        //2\n    }\n\n    public void writerone() {\n        finalreferencedemo = new finalreferencedemo(); //3\n    }\n\n    public void writertwo() {\n        arrays[0] = 2;  //4\n    }\n\n    public void reader() {\n        if (finalreferencedemo != null) {  //5\n            int temp = finalreferencedemo.arrays[0];  //6\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n针对上面的实例程序，线程线程a执行wirterone方法，执行完后线程b执行writertwo方法，然后线程c执行reader方法。下图就以这种执行时序出现的一种情况来讨论（耐心看完才有收获）。\n\n\n\n由于对final域的写禁止重排序到构造方法外，因此1和3不能被重排序。由于一个final域的引用对象的成员域写入不能与随后将这个被构造出来的对象赋给引用变量重排序，因此2和3不能重排序。\n\n> 对final修饰的对象的成员域读操作\n\njmm可以确保线程c至少能看到写线程a对final引用的对象的成员域的写入，即能看下arrays[0] = 1，而写线程b对数组元素的写入可能看到可能看不到。jmm不保证线程b的写入对线程c可见，线程b和线程c之间存在数据竞争，此时的结果是不可预知的。如果可见的，可使用锁或者volatile。\n\n> 关于final重排序的总结\n\n按照final修饰的数据类型分类：\n\n基本数据类型:\n\n 1. final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。\n 2. final域读：禁止初次读对象的引用与读该对象包含的final域的重排序。\n\n引用数据类型：\n\n额外增加约束：禁止在构造函数对一个final修饰的对象的成员域的写入与随后将这个被构造的对象的引用赋值给引用变量重排序\n\n\n# 5、不同处理器的影响\n\n上面我们提到过，写final域会要求编译器在final域写之后，构造函数返回前插入一个storestore屏障。读final域的重排序规则会要求编译器在读final域的操作前插入一个loadload屏障。\n\n很有意思的是，如果以x86处理为例，x86不会对写-写重排序，所以storestore屏障可以省略。由于不会对有间接依赖性的操作重排序，所以在x86处理器中，读final域需要的loadload屏障也会被省略掉。也就是说，以x86为例的话，对final域的读/写的内存屏障都会被省略！具体是否插入还是得看是什么处理器。\n\n\n# 6、为什么final引用不能从构造函数中“溢出”\n\n这里还有一个比较有意思的问题：上面对final域写重排序规则可以确保我们在使用一个对象引用的时候该对象的final域已经在构造函数被初始化过了。但是这里其实是有一个前提条件的，也就是：在构造函数返回前，不能让这个被构造的对象被其他线程可见，也就是说该对象引用不能在构造函数中“逸出”。以下面的例子来说：\n\npublic class finalreferenceescapedemo {\n    private final int a;\n    private finalreferenceescapedemo referencedemo;\n\n    public finalreferenceescapedemo() {\n        a = 1;  //1\n        referencedemo = this; //2\n    }\n\n    public void writer() {\n        new finalreferenceescapedemo();\n    }\n\n    public void reader() {\n        if (referencedemo != null) {  //3\n            int temp = referencedemo.a; //4\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n可能的执行时序如图所示：\n\n\n\n假设一个线程a执行writer方法另一个线程执行reader方法。因为构造函数中操作1和2之间没有数据依赖性，1和2可以重排序，先执行了2，这个时候引用对象referencedemo是个没有完全初始化的对象，而当线程b去读取该对象时就会出错。尽管依然满足了final域写重排序规则：在引用对象对所有线程可见时，其final域已经完全初始化成功。但是，引用对象“this”逸出，该代码依然存在线程安全的问题。\n\n> 参看文献\n\n《java并发编程的艺术》',charsets:{cjk:!0},createdTime:1655628697e3},{title:"彻底理解ReentrantLock",frontmatter:{title:"彻底理解ReentrantLock",description:"彻底理解ReentrantLock",date:"2022-04-02T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/10%E3%80%81ReentrantLock%E7%9A%84%E9%87%8D%E5%85%A5%E6%80%A7%E4%B8%8E%E5%85%AC%E5%B9%B3%E6%80%A7.html",relativePath:"Java/Java并发编程的艺术/10、ReentrantLock的重入性与公平性.md",key:"v-5f3f8622",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/10%E3%80%81ReentrantLock%E7%9A%84%E9%87%8D%E5%85%A5%E6%80%A7%E4%B8%8E%E5%85%AC%E5%B9%B3%E6%80%A7.html",headers:[{level:2,title:"1、ReentrantLock的介绍",slug:"_1、reentrantlock的介绍",normalizedTitle:"1、reentrantlock的介绍",charIndex:28},{level:2,title:"2、重入性的实现原理",slug:"_2、重入性的实现原理",normalizedTitle:"2、重入性的实现原理",charIndex:50},{level:2,title:"3、公平锁与公平锁",slug:"_3、公平锁与公平锁",normalizedTitle:"3、公平锁与公平锁",charIndex:64}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>彻底理解ReentrantLock</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"1、ReentrantLock的介绍 2、重入性的实现原理 3、公平锁与公平锁",content:'说明\n\n彻底理解ReentrantLock\n\n\n\n * 1、ReentrantLock的介绍\n * 2、重入性的实现原理\n * 3、公平锁与公平锁\n\n\n\n\n# 彻底理解ReentrantLock\n\n\n# 1、ReentrantLock的介绍\n\nReentrantLock重入锁，是实现Lock接口的一个类，也是在实际编程中使用频率很高的一个锁，支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。在java关键字synchronized隐式支持重入性，synchronized通过获取自增，释放自减的方式实现重入。与此同时，ReentrantLock还支持公平锁和非公平锁两种方式。那么，要想完完全全的弄懂ReentrantLock的话，主要也就是ReentrantLock同步语义的学习：\n\n 1. 重入性的实现原理；\n 2. 公平锁和非公平锁。\n\n\n# 2、重入性的实现原理\n\n要想支持重入性，就要解决两个问题：\n\n 1. 在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功；\n 2. 由于锁会被获取n次，那么只有锁在被释放同样的n次之后，该锁才算是完全释放成功。\n\n我们知道，同步组件主要是通过重写AQS的几个protected方法来表达自己的同步语义。针对第一个问题，我们来看看ReentrantLock是怎样实现的，以非公平锁为例，判断当前线程能否获得锁为例，核心方法为nonfairTryAcquire：\n\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    //1. 如果该锁未被任何线程占有，该锁能被当前线程获取\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    //2.若被占有，检查占有线程是否是当前线程\n    else if (current == getExclusiveOwnerThread()) {\n        // 3. 再次获取，计数加一\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error("Maximum lock count exceeded");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这段代码的逻辑也很简单，具体请看注释。为了支持重入性，在第二步增加了处理逻辑，如果该锁已经被线程所占有了，会继续检查占有线程是否为当前线程，如果是的话，同步状态加1返回true，表示可以再次获取成功。每次重新获取都会对同步状态进行加一的操作，那么释放的时候处理思路是怎样的了？（依然还是以非公平锁为例）核心方法为tryRelease：\n\nprotected final boolean tryRelease(int releases) {\n    //1. 同步状态减1\n    int c = getState() - releases;\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    if (c == 0) {\n        //2. 只有当同步状态为0时，锁成功被释放，返回true\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    // 3. 锁未被完全释放，返回false\n    setState(c);\n    return free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n代码的逻辑请看注释，需要注意的是，重入锁的释放必须得等到同步状态为0时锁才算成功释放，否则锁仍未释放。如果锁被获取n次，释放了n-1次，该锁未完全释放返回false，只有被释放n次才算成功释放，返回true。到现在我们可以理清ReentrantLock重入性的实现了，也就是理解了同步语义的第一条。\n\n\n# 3、公平锁与公平锁\n\nReentrantLock支持两种锁：公平锁和非公平锁。何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足FIFO。ReentrantLock的构造方法无参时是构造非公平锁，源码为：\n\npublic ReentrantLock() {\n    sync = new NonfairSync();\n}\n\n\n1\n2\n3\n\n\n另外还提供了另外一种方式，可传入一个boolean值，true时为公平锁，false时为非公平锁，源码为：\n\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n\n\n1\n2\n3\n\n\n在上面非公平锁获取时（nonfairTryAcquire方法）只是简单的获取了一下当前状态做了一些逻辑处理，并没有考虑到当前同步队列中线程等待的情况。我们来看看公平锁的处理逻辑是怎样的，核心方法为：\n\nprotected final boolean tryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (!hasQueuedPredecessors() &&\n            compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error("Maximum lock count exceeded");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n这段代码的逻辑与nonfairTryAcquire基本上一致，唯一的不同在于增加了hasQueuedPredecessors的逻辑判断，方法名就可知道该方法用来判断当前节点在同步队列中是否有前驱节点的判断，如果有前驱节点说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。如果当前节点没有前驱节点的话，再才有做后面的逻辑判断的必要性。公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁。\n\n> 公平锁 VS 非公平锁\n\n 1. 公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源时间上的绝对顺序，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，造成“饥饿”现象。\n 2. 公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，ReentrantLock默认选择的是非公平锁，则是为了减少一部分上下文切换，保证了系统更大的吞吐量。\n\n> 参考文献\n\n《java并发编程的艺术》',normalizedContent:'说明\n\n彻底理解reentrantlock\n\n\n\n * 1、reentrantlock的介绍\n * 2、重入性的实现原理\n * 3、公平锁与公平锁\n\n\n\n\n# 彻底理解reentrantlock\n\n\n# 1、reentrantlock的介绍\n\nreentrantlock重入锁，是实现lock接口的一个类，也是在实际编程中使用频率很高的一个锁，支持重入性，表示能够对共享资源能够重复加锁，即当前线程获取该锁再次获取不会被阻塞。在java关键字synchronized隐式支持重入性，synchronized通过获取自增，释放自减的方式实现重入。与此同时，reentrantlock还支持公平锁和非公平锁两种方式。那么，要想完完全全的弄懂reentrantlock的话，主要也就是reentrantlock同步语义的学习：\n\n 1. 重入性的实现原理；\n 2. 公平锁和非公平锁。\n\n\n# 2、重入性的实现原理\n\n要想支持重入性，就要解决两个问题：\n\n 1. 在线程获取锁的时候，如果已经获取锁的线程是当前线程的话则直接再次获取成功；\n 2. 由于锁会被获取n次，那么只有锁在被释放同样的n次之后，该锁才算是完全释放成功。\n\n我们知道，同步组件主要是通过重写aqs的几个protected方法来表达自己的同步语义。针对第一个问题，我们来看看reentrantlock是怎样实现的，以非公平锁为例，判断当前线程能否获得锁为例，核心方法为nonfairtryacquire：\n\nfinal boolean nonfairtryacquire(int acquires) {\n    final thread current = thread.currentthread();\n    int c = getstate();\n    //1. 如果该锁未被任何线程占有，该锁能被当前线程获取\n    if (c == 0) {\n        if (compareandsetstate(0, acquires)) {\n            setexclusiveownerthread(current);\n            return true;\n        }\n    }\n    //2.若被占有，检查占有线程是否是当前线程\n    else if (current == getexclusiveownerthread()) {\n        // 3. 再次获取，计数加一\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new error("maximum lock count exceeded");\n        setstate(nextc);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这段代码的逻辑也很简单，具体请看注释。为了支持重入性，在第二步增加了处理逻辑，如果该锁已经被线程所占有了，会继续检查占有线程是否为当前线程，如果是的话，同步状态加1返回true，表示可以再次获取成功。每次重新获取都会对同步状态进行加一的操作，那么释放的时候处理思路是怎样的了？（依然还是以非公平锁为例）核心方法为tryrelease：\n\nprotected final boolean tryrelease(int releases) {\n    //1. 同步状态减1\n    int c = getstate() - releases;\n    if (thread.currentthread() != getexclusiveownerthread())\n        throw new illegalmonitorstateexception();\n    boolean free = false;\n    if (c == 0) {\n        //2. 只有当同步状态为0时，锁成功被释放，返回true\n        free = true;\n        setexclusiveownerthread(null);\n    }\n    // 3. 锁未被完全释放，返回false\n    setstate(c);\n    return free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n代码的逻辑请看注释，需要注意的是，重入锁的释放必须得等到同步状态为0时锁才算成功释放，否则锁仍未释放。如果锁被获取n次，释放了n-1次，该锁未完全释放返回false，只有被释放n次才算成功释放，返回true。到现在我们可以理清reentrantlock重入性的实现了，也就是理解了同步语义的第一条。\n\n\n# 3、公平锁与公平锁\n\nreentrantlock支持两种锁：公平锁和非公平锁。何谓公平性，是针对获取锁而言的，如果一个锁是公平的，那么锁的获取顺序就应该符合请求上的绝对时间顺序，满足fifo。reentrantlock的构造方法无参时是构造非公平锁，源码为：\n\npublic reentrantlock() {\n    sync = new nonfairsync();\n}\n\n\n1\n2\n3\n\n\n另外还提供了另外一种方式，可传入一个boolean值，true时为公平锁，false时为非公平锁，源码为：\n\npublic reentrantlock(boolean fair) {\n    sync = fair ? new fairsync() : new nonfairsync();\n}\n\n\n1\n2\n3\n\n\n在上面非公平锁获取时（nonfairtryacquire方法）只是简单的获取了一下当前状态做了一些逻辑处理，并没有考虑到当前同步队列中线程等待的情况。我们来看看公平锁的处理逻辑是怎样的，核心方法为：\n\nprotected final boolean tryacquire(int acquires) {\n    final thread current = thread.currentthread();\n    int c = getstate();\n    if (c == 0) {\n        if (!hasqueuedpredecessors() &&\n            compareandsetstate(0, acquires)) {\n            setexclusiveownerthread(current);\n            return true;\n        }\n    }\n    else if (current == getexclusiveownerthread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new error("maximum lock count exceeded");\n        setstate(nextc);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n这段代码的逻辑与nonfairtryacquire基本上一致，唯一的不同在于增加了hasqueuedpredecessors的逻辑判断，方法名就可知道该方法用来判断当前节点在同步队列中是否有前驱节点的判断，如果有前驱节点说明有线程比当前线程更早的请求资源，根据公平性，当前线程请求资源失败。如果当前节点没有前驱节点的话，再才有做后面的逻辑判断的必要性。公平锁每次都是从同步队列中的第一个节点获取到锁，而非公平性锁则不一定，有可能刚释放锁的线程能再次获取到锁。\n\n> 公平锁 vs 非公平锁\n\n 1. 公平锁每次获取到锁为同步队列中的第一个节点，保证请求资源时间上的绝对顺序，而非公平锁有可能刚释放锁的线程下次继续获取该锁，则有可能导致其他线程永远无法获取到锁，造成“饥饿”现象。\n 2. 公平锁为了保证时间上的绝对顺序，需要频繁的上下文切换，而非公平锁会降低一定的上下文切换，降低性能开销。因此，reentrantlock默认选择的是非公平锁，则是为了减少一部分上下文切换，保证了系统更大的吞吐量。\n\n> 参考文献\n\n《java并发编程的艺术》',charsets:{cjk:!0},createdTime:1655628697e3},{title:"三大性质总结：原子性、可见性以及有序性",frontmatter:{title:"三大性质总结：原子性、可见性以及有序性",description:"三大性质总结：原子性、可见性以及有序性",date:"2022-03-30T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/07%E3%80%81%E4%B8%89%E5%A4%A7%E6%80%A7%E8%B4%A8%E6%80%BB%E7%BB%93%EF%BC%9A%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%9C%89%E5%BA%8F%E6%80%A7.html",relativePath:"Java/Java并发编程的艺术/07、三大性质总结：原子性、可见性以及有序性.md",key:"v-22a22e56",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/07%E3%80%81%E4%B8%89%E5%A4%A7%E6%80%A7%E8%B4%A8%E6%80%BB%E7%BB%93%EF%BC%9A%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BB%A5%E5%8F%8A%E6%9C%89%E5%BA%8F%E6%80%A7.html",headers:[{level:2,title:"1、三大性质简介",slug:"_1、三大性质简介",normalizedTitle:"1、三大性质简介",charIndex:30},{level:2,title:"2、原子性",slug:"_2、原子性",normalizedTitle:"2、原子性",charIndex:42},{level:2,title:"3、有序性",slug:"_3、有序性",normalizedTitle:"3、有序性",charIndex:51},{level:2,title:"4、可见性",slug:"_4、可见性",normalizedTitle:"4、可见性",charIndex:60},{level:2,title:"5、总结",slug:"_5、总结",normalizedTitle:"5、总结",charIndex:69}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>三大性质总结：原子性、可见性以及有序性</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"1、三大性质简介 2、原子性 3、有序性 4、可见性 5、总结",content:"说明\n\n三大性质总结：原子性、可见性以及有序性\n\n\n\n * 1、三大性质简介\n * 2、原子性\n * 3、有序性\n * 4、可见性\n * 5、总结\n\n\n\n\n# 三大性质总结：原子性、可见性以及有序性\n\n\n# 1、三大性质简介\n\n在并发编程中分析线程安全的问题时往往需要切入点，那就是两大核心：JMM抽象内存模型以及happens-before规则，三条性质：原子性，有序性和可见性。关于synchronized和volatile已经讨论过了，就想着将并发编程中这两大神器在 原子性，有序性和可见性上做一个比较，当然这也是面试中的高频考点，值得注意。\n\n\n# 2、原子性\n\n原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉。及时在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。我们先来看看哪些是原子操作，哪些不是原子操作，有一个直观的印象：\n\nint a = 10; //1\na++; //2\nint b=a; //3\na = a+1; //4\n\n\n1\n2\n3\n4\n\n\n上面这四个语句中只有第1个语句是原子操作，将10赋值给线程工作内存的变量a，而语句2（a++），实际上包含了三个操作：1. 读取变量a的值；2：对a进行加一的操作；3.将计算后的值再赋值给变量a，而这三个操作无法构成原子操作。对语句3，4的分析同理可得这两条语句不具备原子性。当然，java内存模型中定义了8种操作都是原子的，不可再分的：\n\n 1. lock(锁定)：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态；\n 2. unlock(解锁)：作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定\n 3. read(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后面的load动作使用；\n 4. load(载入)：作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存中的变量副本\n 5. use(用)：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；\n 6. assign(赋值)：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；\n 7. store(存储)：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中以便随后的write操作使用；\n 8. write(操作)：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。\n\n上面的这些指令操作是相当底层的，可以作为扩展知识面掌握下。那么如何理解这些指令了？比如，把一个变量从主内存中复制到工作内存中就需要执行read,load操作，将工作内存同步到主内存中就需要执行store,write操作。注意的是：java内存模型只是要求上述两个操作是顺序执行的并不是连续执行的。也就是说read和load之间可以插入其他指令，store和writer可以插入其他指令。比如对主内存中的a,b进行访问就可以出现这样的操作顺序：read a,read b, load b,load a。\n\n由原子性变量操作read,load,use,assign,store,write，可以大致认为基本数据类型的访问读写具备原子性（例外就是long和double的非原子性协定）\n\n> synchronized\n\n上面一共有八条原子操作，其中六条可以满足基本数据类型的访问读写具备原子性，还剩下lock和unlock两条原子操作。如果我们需要更大范围的原子性操作就可以使用lock和unlock原子操作。尽管jvm没有把lock和unlock开放给我们使用，但jvm以更高层次的指令monitorenter和monitorexit指令开放给我们使用，反应到java代码中就是---synchronized关键字，也就是说synchronized满足原子性。\n\n> volatile 我们先来看这样一个例子：\n\npublic class VolatileExample {\n    private static volatile int counter = 0;\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            Thread thread = new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    for (int i = 0; i < 10000; i++)\n                        counter++;\n                }\n            });\n            thread.start();\n        }\n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        System.out.println(counter);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n开启10个线程，每个线程都自加10000次，如果不出现线程安全的问题最终的结果应该就是：10*10000 = 100000，可是运行多次都是小于100000的结果，问题在于 volatile并不能保证原子性，在前面说过counter++这并不是一个原子操作，包含了三个步骤：1. 读取变量counter的值；2. 对counter加一；3. 将新值赋值给变量counter。如果线程A读取counter到工作内存后，其他线程对这个值已经做了自增操作后，那么线程A的这个值自然而然就是一个过期的值，因此，总结果必然会是小于100000的。\n\n如果让volatile保证原子性，必须符合以下两条规则：\n\n 1. 运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值；\n 2. 变量不需要与其他的状态变量共同参与不变约束\n\n\n# 3、有序性\n\n> synchronized\n\nsynchronized语义表示锁在同一时刻只能由一个线程进行获取，当锁被占用后，其他线程只能等待。因此，synchronized语义就要求线程在访问读写共享变量时只能“串行”执行，因此synchronized具有有序性。\n\n> volatile\n\n在java内存模型中说过，为了性能优化，编译器和处理器会进行指令重排序；也就是说java程序天然的有序性可以总结为：如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的。在单例模式的实现上有一种双重检验锁定的方式（Double-checked Locking）。代码如下：\n\npublic class Singleton {\n    private Singleton() { }\n    private volatile static Singleton instance;\n    public Singleton getInstance(){\n        if(instance==null){\n            synchronized (Singleton.class){\n                if(instance==null){\n                    instance = new Singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这里为什么要加volatile了？我们先来分析一下不加volatile的情况，有问题的语句是这条：\n\ninstance = new Singleton();\n\n\n1\n\n\n这条语句实际上包含了三个操作：1. 分配对象的内存空间；2. 初始化对象；3. 设置instance指向刚分配的内存地址。但由于存在重排序的问题，可能有以下的执行顺序：\n\n\n\n如果2和3进行了重排序的话，线程B进行判断if(instance==null)时就会为true，而实际上这个instance并没有初始化成功，显而易见对线程B来说之后的操作就会是错得。而用volatile修饰的话就可以禁止2和3操作重排序，从而避免这种情况。volatile包含禁止指令重排序的语义，其具有有序性。\n\n\n# 4、可见性\n\n可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。通过之前对synchronzed内存语义进行了分析，当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。从而，synchronized具有可见性。同样的在volatile分析中，会通过在指令中添加lock指令，以实现内存可见性。因此，volatile具有可见性。\n\n\n# 5、总结\n\n通过这篇文章，主要是比较了synchronized和volatile在三条性质：原子性，可见性，以及有序性的情况，归纳如下：\n\n> synchronized: 具有原子性，有序性和可见性； volatile：具有有序性和可见性\n\n> 参考文献\n\n《java并发编程的艺术》 《深入理解java虚拟机》",normalizedContent:"说明\n\n三大性质总结：原子性、可见性以及有序性\n\n\n\n * 1、三大性质简介\n * 2、原子性\n * 3、有序性\n * 4、可见性\n * 5、总结\n\n\n\n\n# 三大性质总结：原子性、可见性以及有序性\n\n\n# 1、三大性质简介\n\n在并发编程中分析线程安全的问题时往往需要切入点，那就是两大核心：jmm抽象内存模型以及happens-before规则，三条性质：原子性，有序性和可见性。关于synchronized和volatile已经讨论过了，就想着将并发编程中这两大神器在 原子性，有序性和可见性上做一个比较，当然这也是面试中的高频考点，值得注意。\n\n\n# 2、原子性\n\n原子性是指一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉。及时在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。我们先来看看哪些是原子操作，哪些不是原子操作，有一个直观的印象：\n\nint a = 10; //1\na++; //2\nint b=a; //3\na = a+1; //4\n\n\n1\n2\n3\n4\n\n\n上面这四个语句中只有第1个语句是原子操作，将10赋值给线程工作内存的变量a，而语句2（a++），实际上包含了三个操作：1. 读取变量a的值；2：对a进行加一的操作；3.将计算后的值再赋值给变量a，而这三个操作无法构成原子操作。对语句3，4的分析同理可得这两条语句不具备原子性。当然，java内存模型中定义了8种操作都是原子的，不可再分的：\n\n 1. lock(锁定)：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态；\n 2. unlock(解锁)：作用于主内存中的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定\n 3. read(读取)：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便后面的load动作使用；\n 4. load(载入)：作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存中的变量副本\n 5. use(用)：作用于工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作；\n 6. assign(赋值)：作用于工作内存中的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作；\n 7. store(存储)：作用于工作内存的变量，它把工作内存中一个变量的值传送给主内存中以便随后的write操作使用；\n 8. write(操作)：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。\n\n上面的这些指令操作是相当底层的，可以作为扩展知识面掌握下。那么如何理解这些指令了？比如，把一个变量从主内存中复制到工作内存中就需要执行read,load操作，将工作内存同步到主内存中就需要执行store,write操作。注意的是：java内存模型只是要求上述两个操作是顺序执行的并不是连续执行的。也就是说read和load之间可以插入其他指令，store和writer可以插入其他指令。比如对主内存中的a,b进行访问就可以出现这样的操作顺序：read a,read b, load b,load a。\n\n由原子性变量操作read,load,use,assign,store,write，可以大致认为基本数据类型的访问读写具备原子性（例外就是long和double的非原子性协定）\n\n> synchronized\n\n上面一共有八条原子操作，其中六条可以满足基本数据类型的访问读写具备原子性，还剩下lock和unlock两条原子操作。如果我们需要更大范围的原子性操作就可以使用lock和unlock原子操作。尽管jvm没有把lock和unlock开放给我们使用，但jvm以更高层次的指令monitorenter和monitorexit指令开放给我们使用，反应到java代码中就是---synchronized关键字，也就是说synchronized满足原子性。\n\n> volatile 我们先来看这样一个例子：\n\npublic class volatileexample {\n    private static volatile int counter = 0;\n\n    public static void main(string[] args) {\n        for (int i = 0; i < 10; i++) {\n            thread thread = new thread(new runnable() {\n                @override\n                public void run() {\n                    for (int i = 0; i < 10000; i++)\n                        counter++;\n                }\n            });\n            thread.start();\n        }\n        try {\n            thread.sleep(1000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        system.out.println(counter);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n开启10个线程，每个线程都自加10000次，如果不出现线程安全的问题最终的结果应该就是：10*10000 = 100000，可是运行多次都是小于100000的结果，问题在于 volatile并不能保证原子性，在前面说过counter++这并不是一个原子操作，包含了三个步骤：1. 读取变量counter的值；2. 对counter加一；3. 将新值赋值给变量counter。如果线程a读取counter到工作内存后，其他线程对这个值已经做了自增操作后，那么线程a的这个值自然而然就是一个过期的值，因此，总结果必然会是小于100000的。\n\n如果让volatile保证原子性，必须符合以下两条规则：\n\n 1. 运算结果并不依赖于变量的当前值，或者能够确保只有一个线程修改变量的值；\n 2. 变量不需要与其他的状态变量共同参与不变约束\n\n\n# 3、有序性\n\n> synchronized\n\nsynchronized语义表示锁在同一时刻只能由一个线程进行获取，当锁被占用后，其他线程只能等待。因此，synchronized语义就要求线程在访问读写共享变量时只能“串行”执行，因此synchronized具有有序性。\n\n> volatile\n\n在java内存模型中说过，为了性能优化，编译器和处理器会进行指令重排序；也就是说java程序天然的有序性可以总结为：如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另一个线程，所有的操作都是无序的。在单例模式的实现上有一种双重检验锁定的方式（double-checked locking）。代码如下：\n\npublic class singleton {\n    private singleton() { }\n    private volatile static singleton instance;\n    public singleton getinstance(){\n        if(instance==null){\n            synchronized (singleton.class){\n                if(instance==null){\n                    instance = new singleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这里为什么要加volatile了？我们先来分析一下不加volatile的情况，有问题的语句是这条：\n\ninstance = new singleton();\n\n\n1\n\n\n这条语句实际上包含了三个操作：1. 分配对象的内存空间；2. 初始化对象；3. 设置instance指向刚分配的内存地址。但由于存在重排序的问题，可能有以下的执行顺序：\n\n\n\n如果2和3进行了重排序的话，线程b进行判断if(instance==null)时就会为true，而实际上这个instance并没有初始化成功，显而易见对线程b来说之后的操作就会是错得。而用volatile修饰的话就可以禁止2和3操作重排序，从而避免这种情况。volatile包含禁止指令重排序的语义，其具有有序性。\n\n\n# 4、可见性\n\n可见性是指当一个线程修改了共享变量后，其他线程能够立即得知这个修改。通过之前对synchronzed内存语义进行了分析，当线程获取锁时会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。从而，synchronized具有可见性。同样的在volatile分析中，会通过在指令中添加lock指令，以实现内存可见性。因此，volatile具有可见性。\n\n\n# 5、总结\n\n通过这篇文章，主要是比较了synchronized和volatile在三条性质：原子性，可见性，以及有序性的情况，归纳如下：\n\n> synchronized: 具有原子性，有序性和可见性； volatile：具有有序性和可见性\n\n> 参考文献\n\n《java并发编程的艺术》 《深入理解java虚拟机》",charsets:{cjk:!0},createdTime:1655628697e3},{title:"初识Lock与AbstractQueuedSynchronizer-AQS",frontmatter:{title:"初识Lock与AbstractQueuedSynchronizer-AQS",description:"初识Lock与AbstractQueuedSynchronizer(AQS)",date:"2022-03-31T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/08%E3%80%81%E5%88%9D%E8%AF%86Lock%E4%B8%8EAbstractQueuedSynchronizer-AQS.html",relativePath:"Java/Java并发编程的艺术/08、初识Lock与AbstractQueuedSynchronizer-AQS.md",key:"v-5ae78972",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/08%E3%80%81%E5%88%9D%E8%AF%86Lock%E4%B8%8EAbstractQueuedSynchronizer-AQS.html",headers:[{level:2,title:"1、concurrent包的结构层次",slug:"_1、concurrent包的结构层次",normalizedTitle:"1、concurrent包的结构层次",charIndex:49},{level:2,title:"2、lock简介",slug:"_2、lock简介",normalizedTitle:"2、lock简介",charIndex:71},{level:3,title:"Lock接口API",slug:"lock接口api",normalizedTitle:"lock接口api",charIndex:85},{level:3,title:"初识AQS",slug:"初识aqs",normalizedTitle:"初识aqs",charIndex:100},{level:3,title:"AQS的模板方法设计模式",slug:"aqs的模板方法设计模式",normalizedTitle:"aqs的模板方法设计模式",charIndex:111},{level:2,title:"3、一个例子",slug:"_3、一个例子",normalizedTitle:"3、一个例子",charIndex:127}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>初识Lock与AbstractQueuedSynchronizer(AQS)</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"1、concurrent包的结构层次 2、lock简介 Lock接口API 初识AQS AQS的模板方法设计模式 3、一个例子",content:"说明\n\n初识Lock与AbstractQueuedSynchronizer(AQS)\n\n\n\n * 1、concurrent包的结构层次\n * 2、lock简介\n   * Lock接口API\n   * 初识AQS\n   * AQS的模板方法设计模式\n * 3、一个例子\n\n\n\n\n# 初识Lock与AbstractQueuedSynchronizer(AQS)\n\n\n# 1、concurrent包的结构层次\n\n在针对并发编程中，Doug Lea大师为我们提供了大量实用，高性能的工具类，针对这些代码进行研究会让我们队并发编程的掌握更加透彻也会大大提升我们队并发编程技术的热爱。这些代码在java.util.concurrent包下。如下图，即为concurrent包的目录结构图。\n\n\n\n其中包含了两个子包：atomic以及lock，另外在concurrent下的阻塞队列以及executors，这些就是concurrent包中的精华，之后会一一进行学习。而这些类的实现主要是依赖于volatile以及CAS，从整体上来看concurrent包的整体实现图如下图所示：\n\n\n\n\n# 2、lock简介\n\n我们下来看concurent包下的lock子包。锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。在Lock接口出现之前，java程序主要是靠synchronized关键字实现锁功能的，而java SE5之后，并发包中增加了lock接口，它提供了与synchronized一样的锁功能。虽然它失去了像synchronize关键字隐式加锁解锁的便捷性，但是却拥有了锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。通常使用显示使用lock的形式如下：\n\nLock lock = new ReentrantLock();\nlock.lock();\ntry{\n    .......\n}finally{\n    lock.unlock();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n需要注意的是synchronized同步块执行完成或者遇到异常是锁会自动释放，而lock必须调用unlock()方法释放锁，因此在finally块中释放锁。\n\n\n# Lock接口API\n\n我们现在就来看看lock接口定义了哪些方法：\n\n\n\n上面是lock接口下的五个方法，也只是从源码中英译中翻译了一遍，感兴趣的可以自己的去看看。那么在locks包下有哪些类实现了该接口了？先从最熟悉的ReentrantLock说起。\n\npublic class ReentrantLock implements Lock, java.io.Serializable\n\n\n1\n\n\n很显然ReentrantLock实现了lock接口，接下来我们来仔细研究一下它是怎样实现的。当你查看源码时你会惊讶的发现ReentrantLock并没有多少代码，另外有一个很明显的特点是：基本上所有的方法的实现实际上都是调用了其静态内存类Sync中的方法，而Sync类继承了AbstractQueuedSynchronizer（AQS）。可以看出要想理解ReentrantLock关键核心在于对队列同步器AbstractQueuedSynchronizer（简称同步器）的理解。\n\n\n\n\n# 初识AQS\n\n关于AQS在源码中有十分具体的解释：\n\nProvides a framework for implementing blocking locks and related\n synchronizers (semaphores, events, etc) that rely on\n first-in-first-out (FIFO) wait queues.  This class is designed to\n be a useful basis for most kinds of synchronizers that rely on a\n single atomic {@code int} value to represent state. Subclasses\n must define the protected methods that change this state, and which\n define what that state means in terms of this object being acquired\n or released.  Given these, the other methods in this class carry\n out all queuing and blocking mechanics. Subclasses can maintain\n other state fields, but only the atomically updated {@code int}\n value manipulated using methods {@link #getState}, {@link\n #setState} and {@link #compareAndSetState} is tracked with respect\n to synchronization.\n\n <p>Subclasses should be defined as non-public internal helper\n classes that are used to implement the synchronization properties\n of their enclosing class.  Class\n {@code AbstractQueuedSynchronizer} does not implement any\n synchronization interface.  Instead it defines methods such as\n {@link #acquireInterruptibly} that can be invoked as\n appropriate by concrete locks and related synchronizers to\n implement their public methods.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n同步器是用来构建锁和其他同步组件的基础框架，它的实现主要依赖一个int成员变量来表示同步状态以及通过一个FIFO队列构成等待队列。它的子类必须重写AQS的几个protected修饰的用来改变同步状态的方法，其他方法主要是实现了排队和阻塞机制。状态的更新使用getState,setState以及compareAndSetState这三个方法。\n\n子类被推荐定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态的获取和释放方法来供自定义同步组件的使用，同步器既支持独占式获取同步状态，也可以支持共享式获取同步状态，这样就可以方便的实现不同类型的同步组件。\n\n同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：锁是面向使用者，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作。锁和同步器很好的隔离了使用者和实现者所需关注的领域。\n\n\n# AQS的模板方法设计模式\n\nAQS的设计是使用模板方法设计模式，它将一些方法开放给子类进行重写，而同步器给同步组件所提供模板方法又会重新调用被子类所重写的方法。\n\n举个例子，AQS中需要重写的方法tryAcquire：\n\nprotected boolean tryAcquire(int arg) {\n        throw new UnsupportedOperationException();\n}\n\n\n1\n2\n3\n\n\nReentrantLock中NonfairSync（继承AQS）会重写该方法为：\n\nprotected final boolean tryAcquire(int acquires) {\n    return nonfairTryAcquire(acquires);\n}\n\n\n1\n2\n3\n\n\n而AQS中的模板方法acquire():\n\n public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n }\n\n\n1\n2\n3\n4\n5\n\n\n会调用tryAcquire方法，而此时当继承AQS的NonfairSync调用模板方法acquire时就会调用已经被NonfairSync重写的tryAcquire方法。这就是使用AQS的方式，在弄懂这点后会lock的实现理解有很大的提升。可以归纳总结为这么几点：\n\n 1. 同步组件（这里不仅仅值锁，还包括CountDownLatch等）的实现依赖于同步器AQS，在同步组件实现中，使用AQS的方式被推荐定义继承AQS的静态内存类；\n 2. AQS采用模板方法进行设计，AQS的protected修饰的方法需要由继承AQS的子类进行重写实现，当调用AQS的子类的方法时就会调用被重写的方法；\n 3. AQS负责同步状态的管理，线程的排队，等待和唤醒这些底层操作，而Lock等同步组件主要专注于实现同步语义；\n 4. 在重写AQS的方式时，使用AQS提供的getState(),setState(),compareAndSetState()方法进行修改同步状态。\n\nAQS可重写的方法如下图：\n\n\n\n在实现同步组件时AQS提供的模板方法如下图：\n\n\n\nAQS提供的模板方法可以分为3类：\n\n 1. 独占式获取与释放同步状态；\n 2. 共享式获取与释放同步状态；\n 3. 查询同步队列中等待线程情况；\n\n同步组件通过AQS提供的模板方法实现自己的同步语义。\n\n\n# 3、一个例子\n\n下面使用一个例子来进一步理解下AQS的使用。这个例子也是来源于AQS源码中的example。\n\nclass Mutex implements Lock, java.io.Serializable {\n    // Our internal helper class\n    // 继承AQS的静态内存类\n    // 重写方法\n    private static class Sync extends AbstractQueuedSynchronizer {\n        // Reports whether in locked state\n        protected boolean isHeldExclusively() {\n            return getState() == 1;\n        }\n\n        // Acquires the lock if state is zero\n        public boolean tryAcquire(int acquires) {\n            assert acquires == 1; // Otherwise unused\n            if (compareAndSetState(0, 1)) {\n                setExclusiveOwnerThread(Thread.currentThread());\n                return true;\n            }\n            return false;\n        }\n\n        // Releases the lock by setting state to zero\n        protected boolean tryRelease(int releases) {\n            assert releases == 1; // Otherwise unused\n            if (getState() == 0) throw new IllegalMonitorStateException();\n            setExclusiveOwnerThread(null);\n            setState(0);\n            return true;\n        }\n\n        // Provides a Condition\n        Condition newCondition() {\n            return new ConditionObject();\n        }\n\n        // Deserializes properly\n        private void readObject(ObjectInputStream s)\n                throws IOException, ClassNotFoundException {\n            s.defaultReadObject();\n            setState(0); // reset to unlocked state\n        }\n    }\n\n    // The sync object does all the hard work. We just forward to it.\n    private final Sync sync = new Sync();\n    //使用同步器的模板方法实现自己的同步语义\n    public void lock() {\n        sync.acquire(1);\n    }\n\n    public boolean tryLock() {\n        return sync.tryAcquire(1);\n    }\n\n    public void unlock() {\n        sync.release(1);\n    }\n\n    public Condition newCondition() {\n        return sync.newCondition();\n    }\n\n    public boolean isLocked() {\n        return sync.isHeldExclusively();\n    }\n\n    public boolean hasQueuedThreads() {\n        return sync.hasQueuedThreads();\n    }\n\n    public void lockInterruptibly() throws InterruptedException {\n        sync.acquireInterruptibly(1);\n    }\n\n    public boolean tryLock(long timeout, TimeUnit unit)\n            throws InterruptedException {\n        return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\nMutexDemo：\n\npublic class MutextDemo {\n    private static Mutex mutex = new Mutex();\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            Thread thread = new Thread(() -> {\n                mutex.lock();\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    mutex.unlock();\n                }\n            });\n            thread.start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n执行情况：\n\n\n\n上面的这个例子实现了独占锁的语义，在同一个时刻只允许一个线程占有锁。MutexDemo新建了10个线程，分别睡眠3s。从执行情况也可以看出来当前Thread-6正在执行占有锁而其他Thread-7,Thread-8等线程处于WAIT状态。按照推荐的方式，Mutex定义了一个继承AQS的静态内部类Sync，并且重写了AQS的tryAcquire等等方法，而对state的更新也是利用了setState(),getState(),compareAndSetState()这三个方法。在实现实现lock接口中的方法也只是调用了AQS提供的模板方法（因为Sync继承AQS）。从这个例子就可以很清楚的看出来，在同步组件的实现上主要是利用了AQS，而AQS“屏蔽”了同步状态的修改，线程排队等底层实现，通过AQS的模板方法可以很方便的给同步组件的实现者进行调用。而针对用户来说，只需要调用同步组件提供的方法来实现并发编程即可。同时在新建一个同步组件时需要把握的两个关键点是：\n\n 1. 实现同步组件时推荐定义继承AQS的静态内存类，并重写需要的protected修饰的方法；\n 2. 同步组件语义的实现依赖于AQS的模板方法，而AQS模板方法又依赖于被AQS的子类所重写的方法。\n\n通俗点说，因为AQS整体设计思路采用模板方法设计模式，同步组件以及AQS的功能实际上别切分成各自的两部分：\n\n同步组件实现者的角度：\n\n通过可重写的方法：\n\n * 独占式： tryAcquire()(独占式获取同步状态），tryRelease()（独占式释放同步状态）；\n * 共享式 ：tryAcquireShared()(共享式获取同步状态)，tryReleaseShared()(共享式释放同步状态)；\n\n告诉AQS怎样判断当前同步状态是否成功获取或者是否成功释放。同步组件专注于对当前同步状态的逻辑判断，从而实现自己的同步语义。这句话比较抽象，举例来说，上面的Mutex例子中通过tryAcquire方法实现自己的同步语义，在该方法中如果当前同步状态为0（即该同步组件没被任何线程获取），当前线程可以获取同时将状态更改为1返回true，否则，该组件已经被线程占用返回false。很显然，该同步组件只能在同一时刻被线程占用，Mutex专注于获取释放的逻辑来实现自己想要表达的同步语义。\n\nAQS的角度\n\n而对AQS来说，只需要同步组件返回的true和false即可，因为AQS会对true和false会有不同的操作，true会认为当前线程获取同步组件成功直接返回，而false的话就AQS也会将当前线程插入同步队列等一系列的方法。\n\n总的来说，同步组件通过重写AQS的方法实现自己想要表达的同步语义，而AQS只需要同步组件表达的true和false即可，AQS会针对true和false不同的情况做不同的处理，至于底层实现，可以看这篇文章。\n\n> 参考文献\n\n《java并发编程的艺术》",normalizedContent:"说明\n\n初识lock与abstractqueuedsynchronizer(aqs)\n\n\n\n * 1、concurrent包的结构层次\n * 2、lock简介\n   * lock接口api\n   * 初识aqs\n   * aqs的模板方法设计模式\n * 3、一个例子\n\n\n\n\n# 初识lock与abstractqueuedsynchronizer(aqs)\n\n\n# 1、concurrent包的结构层次\n\n在针对并发编程中，doug lea大师为我们提供了大量实用，高性能的工具类，针对这些代码进行研究会让我们队并发编程的掌握更加透彻也会大大提升我们队并发编程技术的热爱。这些代码在java.util.concurrent包下。如下图，即为concurrent包的目录结构图。\n\n\n\n其中包含了两个子包：atomic以及lock，另外在concurrent下的阻塞队列以及executors，这些就是concurrent包中的精华，之后会一一进行学习。而这些类的实现主要是依赖于volatile以及cas，从整体上来看concurrent包的整体实现图如下图所示：\n\n\n\n\n# 2、lock简介\n\n我们下来看concurent包下的lock子包。锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源。在lock接口出现之前，java程序主要是靠synchronized关键字实现锁功能的，而java se5之后，并发包中增加了lock接口，它提供了与synchronized一样的锁功能。虽然它失去了像synchronize关键字隐式加锁解锁的便捷性，但是却拥有了锁获取和释放的可操作性，可中断的获取锁以及超时获取锁等多种synchronized关键字所不具备的同步特性。通常使用显示使用lock的形式如下：\n\nlock lock = new reentrantlock();\nlock.lock();\ntry{\n    .......\n}finally{\n    lock.unlock();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n需要注意的是synchronized同步块执行完成或者遇到异常是锁会自动释放，而lock必须调用unlock()方法释放锁，因此在finally块中释放锁。\n\n\n# lock接口api\n\n我们现在就来看看lock接口定义了哪些方法：\n\n\n\n上面是lock接口下的五个方法，也只是从源码中英译中翻译了一遍，感兴趣的可以自己的去看看。那么在locks包下有哪些类实现了该接口了？先从最熟悉的reentrantlock说起。\n\npublic class reentrantlock implements lock, java.io.serializable\n\n\n1\n\n\n很显然reentrantlock实现了lock接口，接下来我们来仔细研究一下它是怎样实现的。当你查看源码时你会惊讶的发现reentrantlock并没有多少代码，另外有一个很明显的特点是：基本上所有的方法的实现实际上都是调用了其静态内存类sync中的方法，而sync类继承了abstractqueuedsynchronizer（aqs）。可以看出要想理解reentrantlock关键核心在于对队列同步器abstractqueuedsynchronizer（简称同步器）的理解。\n\n\n\n\n# 初识aqs\n\n关于aqs在源码中有十分具体的解释：\n\nprovides a framework for implementing blocking locks and related\n synchronizers (semaphores, events, etc) that rely on\n first-in-first-out (fifo) wait queues.  this class is designed to\n be a useful basis for most kinds of synchronizers that rely on a\n single atomic {@code int} value to represent state. subclasses\n must define the protected methods that change this state, and which\n define what that state means in terms of this object being acquired\n or released.  given these, the other methods in this class carry\n out all queuing and blocking mechanics. subclasses can maintain\n other state fields, but only the atomically updated {@code int}\n value manipulated using methods {@link #getstate}, {@link\n #setstate} and {@link #compareandsetstate} is tracked with respect\n to synchronization.\n\n <p>subclasses should be defined as non-public internal helper\n classes that are used to implement the synchronization properties\n of their enclosing class.  class\n {@code abstractqueuedsynchronizer} does not implement any\n synchronization interface.  instead it defines methods such as\n {@link #acquireinterruptibly} that can be invoked as\n appropriate by concrete locks and related synchronizers to\n implement their public methods.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n同步器是用来构建锁和其他同步组件的基础框架，它的实现主要依赖一个int成员变量来表示同步状态以及通过一个fifo队列构成等待队列。它的子类必须重写aqs的几个protected修饰的用来改变同步状态的方法，其他方法主要是实现了排队和阻塞机制。状态的更新使用getstate,setstate以及compareandsetstate这三个方法。\n\n子类被推荐定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态的获取和释放方法来供自定义同步组件的使用，同步器既支持独占式获取同步状态，也可以支持共享式获取同步状态，这样就可以方便的实现不同类型的同步组件。\n\n同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。可以这样理解二者的关系：锁是面向使用者，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器是面向锁的实现者，它简化了锁的实现方式，屏蔽了同步状态的管理，线程的排队，等待和唤醒等底层操作。锁和同步器很好的隔离了使用者和实现者所需关注的领域。\n\n\n# aqs的模板方法设计模式\n\naqs的设计是使用模板方法设计模式，它将一些方法开放给子类进行重写，而同步器给同步组件所提供模板方法又会重新调用被子类所重写的方法。\n\n举个例子，aqs中需要重写的方法tryacquire：\n\nprotected boolean tryacquire(int arg) {\n        throw new unsupportedoperationexception();\n}\n\n\n1\n2\n3\n\n\nreentrantlock中nonfairsync（继承aqs）会重写该方法为：\n\nprotected final boolean tryacquire(int acquires) {\n    return nonfairtryacquire(acquires);\n}\n\n\n1\n2\n3\n\n\n而aqs中的模板方法acquire():\n\n public final void acquire(int arg) {\n        if (!tryacquire(arg) &&\n            acquirequeued(addwaiter(node.exclusive), arg))\n            selfinterrupt();\n }\n\n\n1\n2\n3\n4\n5\n\n\n会调用tryacquire方法，而此时当继承aqs的nonfairsync调用模板方法acquire时就会调用已经被nonfairsync重写的tryacquire方法。这就是使用aqs的方式，在弄懂这点后会lock的实现理解有很大的提升。可以归纳总结为这么几点：\n\n 1. 同步组件（这里不仅仅值锁，还包括countdownlatch等）的实现依赖于同步器aqs，在同步组件实现中，使用aqs的方式被推荐定义继承aqs的静态内存类；\n 2. aqs采用模板方法进行设计，aqs的protected修饰的方法需要由继承aqs的子类进行重写实现，当调用aqs的子类的方法时就会调用被重写的方法；\n 3. aqs负责同步状态的管理，线程的排队，等待和唤醒这些底层操作，而lock等同步组件主要专注于实现同步语义；\n 4. 在重写aqs的方式时，使用aqs提供的getstate(),setstate(),compareandsetstate()方法进行修改同步状态。\n\naqs可重写的方法如下图：\n\n\n\n在实现同步组件时aqs提供的模板方法如下图：\n\n\n\naqs提供的模板方法可以分为3类：\n\n 1. 独占式获取与释放同步状态；\n 2. 共享式获取与释放同步状态；\n 3. 查询同步队列中等待线程情况；\n\n同步组件通过aqs提供的模板方法实现自己的同步语义。\n\n\n# 3、一个例子\n\n下面使用一个例子来进一步理解下aqs的使用。这个例子也是来源于aqs源码中的example。\n\nclass mutex implements lock, java.io.serializable {\n    // our internal helper class\n    // 继承aqs的静态内存类\n    // 重写方法\n    private static class sync extends abstractqueuedsynchronizer {\n        // reports whether in locked state\n        protected boolean isheldexclusively() {\n            return getstate() == 1;\n        }\n\n        // acquires the lock if state is zero\n        public boolean tryacquire(int acquires) {\n            assert acquires == 1; // otherwise unused\n            if (compareandsetstate(0, 1)) {\n                setexclusiveownerthread(thread.currentthread());\n                return true;\n            }\n            return false;\n        }\n\n        // releases the lock by setting state to zero\n        protected boolean tryrelease(int releases) {\n            assert releases == 1; // otherwise unused\n            if (getstate() == 0) throw new illegalmonitorstateexception();\n            setexclusiveownerthread(null);\n            setstate(0);\n            return true;\n        }\n\n        // provides a condition\n        condition newcondition() {\n            return new conditionobject();\n        }\n\n        // deserializes properly\n        private void readobject(objectinputstream s)\n                throws ioexception, classnotfoundexception {\n            s.defaultreadobject();\n            setstate(0); // reset to unlocked state\n        }\n    }\n\n    // the sync object does all the hard work. we just forward to it.\n    private final sync sync = new sync();\n    //使用同步器的模板方法实现自己的同步语义\n    public void lock() {\n        sync.acquire(1);\n    }\n\n    public boolean trylock() {\n        return sync.tryacquire(1);\n    }\n\n    public void unlock() {\n        sync.release(1);\n    }\n\n    public condition newcondition() {\n        return sync.newcondition();\n    }\n\n    public boolean islocked() {\n        return sync.isheldexclusively();\n    }\n\n    public boolean hasqueuedthreads() {\n        return sync.hasqueuedthreads();\n    }\n\n    public void lockinterruptibly() throws interruptedexception {\n        sync.acquireinterruptibly(1);\n    }\n\n    public boolean trylock(long timeout, timeunit unit)\n            throws interruptedexception {\n        return sync.tryacquirenanos(1, unit.tonanos(timeout));\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\nmutexdemo：\n\npublic class mutextdemo {\n    private static mutex mutex = new mutex();\n\n    public static void main(string[] args) {\n        for (int i = 0; i < 10; i++) {\n            thread thread = new thread(() -> {\n                mutex.lock();\n                try {\n                    thread.sleep(3000);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                } finally {\n                    mutex.unlock();\n                }\n            });\n            thread.start();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n执行情况：\n\n\n\n上面的这个例子实现了独占锁的语义，在同一个时刻只允许一个线程占有锁。mutexdemo新建了10个线程，分别睡眠3s。从执行情况也可以看出来当前thread-6正在执行占有锁而其他thread-7,thread-8等线程处于wait状态。按照推荐的方式，mutex定义了一个继承aqs的静态内部类sync，并且重写了aqs的tryacquire等等方法，而对state的更新也是利用了setstate(),getstate(),compareandsetstate()这三个方法。在实现实现lock接口中的方法也只是调用了aqs提供的模板方法（因为sync继承aqs）。从这个例子就可以很清楚的看出来，在同步组件的实现上主要是利用了aqs，而aqs“屏蔽”了同步状态的修改，线程排队等底层实现，通过aqs的模板方法可以很方便的给同步组件的实现者进行调用。而针对用户来说，只需要调用同步组件提供的方法来实现并发编程即可。同时在新建一个同步组件时需要把握的两个关键点是：\n\n 1. 实现同步组件时推荐定义继承aqs的静态内存类，并重写需要的protected修饰的方法；\n 2. 同步组件语义的实现依赖于aqs的模板方法，而aqs模板方法又依赖于被aqs的子类所重写的方法。\n\n通俗点说，因为aqs整体设计思路采用模板方法设计模式，同步组件以及aqs的功能实际上别切分成各自的两部分：\n\n同步组件实现者的角度：\n\n通过可重写的方法：\n\n * 独占式： tryacquire()(独占式获取同步状态），tryrelease()（独占式释放同步状态）；\n * 共享式 ：tryacquireshared()(共享式获取同步状态)，tryreleaseshared()(共享式释放同步状态)；\n\n告诉aqs怎样判断当前同步状态是否成功获取或者是否成功释放。同步组件专注于对当前同步状态的逻辑判断，从而实现自己的同步语义。这句话比较抽象，举例来说，上面的mutex例子中通过tryacquire方法实现自己的同步语义，在该方法中如果当前同步状态为0（即该同步组件没被任何线程获取），当前线程可以获取同时将状态更改为1返回true，否则，该组件已经被线程占用返回false。很显然，该同步组件只能在同一时刻被线程占用，mutex专注于获取释放的逻辑来实现自己想要表达的同步语义。\n\naqs的角度\n\n而对aqs来说，只需要同步组件返回的true和false即可，因为aqs会对true和false会有不同的操作，true会认为当前线程获取同步组件成功直接返回，而false的话就aqs也会将当前线程插入同步队列等一系列的方法。\n\n总的来说，同步组件通过重写aqs的方法实现自己想要表达的同步语义，而aqs只需要同步组件表达的true和false即可，aqs会针对true和false不同的情况做不同的处理，至于底层实现，可以看这篇文章。\n\n> 参考文献\n\n《java并发编程的艺术》",charsets:{cjk:!0},createdTime:1655628697e3},{title:"深入理解读写锁ReentrantReadWriteLock",frontmatter:{title:"深入理解读写锁ReentrantReadWriteLock",description:"深入理解读写锁ReentrantReadWriteLock",date:"2022-04-02T16:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/11%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html",relativePath:"Java/Java并发编程的艺术/11、深入理解读写锁ReentrantReadWriteLock.md",key:"v-6266d266",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/11%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AF%BB%E5%86%99%E9%94%81ReentrantReadWriteLock.html",headers:[{level:2,title:"1、读写锁的介绍",slug:"_1、读写锁的介绍",normalizedTitle:"1、读写锁的介绍",charIndex:40},{level:2,title:"2、读写状态的设计",slug:"_2、读写状态的设计",normalizedTitle:"2、读写状态的设计",charIndex:52},{level:2,title:"3、写锁详解",slug:"_3、写锁详解",normalizedTitle:"3、写锁详解",charIndex:65},{level:3,title:"写锁的获取",slug:"写锁的获取",normalizedTitle:"写锁的获取",charIndex:77},{level:3,title:"写锁的释放",slug:"写锁的释放",normalizedTitle:"写锁的释放",charIndex:88},{level:2,title:"4、读锁详解",slug:"_4、读锁详解",normalizedTitle:"4、读锁详解",charIndex:97},{level:3,title:"读锁的获取",slug:"读锁的获取",normalizedTitle:"读锁的获取",charIndex:109},{level:3,title:"读锁的释放",slug:"读锁的释放",normalizedTitle:"读锁的释放",charIndex:120},{level:2,title:"5、降级锁",slug:"_5、降级锁",normalizedTitle:"5、降级锁",charIndex:129}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>深入理解读写锁ReentrantReadWriteLock</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"1、读写锁的介绍 2、读写状态的设计 3、写锁详解 写锁的获取 写锁的释放 4、读锁详解 读锁的获取 读锁的释放 5、降级锁",content:'说明\n\n深入理解读写锁ReentrantReadWriteLock\n\n\n\n * 1、读写锁的介绍\n * 2、读写状态的设计\n * 3、写锁详解\n   * 写锁的获取\n   * 写锁的释放\n * 4、读锁详解\n   * 读锁的获取\n   * 读锁的释放\n * 5、降级锁\n\n\n\n\n# 深入理解读写锁ReentrantReadWriteLock\n\n\n# 1、读写锁的介绍\n\n在并发场景中用于解决线程安全的问题，我们几乎会高频率的使用到独占式锁，通常使用java提供的关键字synchronized或者concurrents包中实现了Lock接口的ReentrantLock。它们都是独占式获取锁，也就是在同一时刻只有一个线程能够获取锁。而在一些业务场景中，大部分只是读数据，写数据很少，如果仅仅是读数据的话并不会影响数据正确性（出现脏读），而如果在这种业务场景下，依然使用独占锁的话，很显然这将是出现性能瓶颈的地方。\n\n针对这种读多写少的情况，java还提供了另外一个实现Lock接口的ReentrantReadWriteLock(读写锁)：读写锁允许同一时刻被多个读线程访问，但是在写线程访问时，所有的读线程和其他的写线程都会被阻塞。Java并发包提供读写锁的实现是ReentrantReadWriteLock，它提供的特性如下所示：\n\n 1. 公平性选择：支持非公平性（默认）和公平的锁获取方式，吞吐量还是非公平优于公平；\n 2. 重入性：支持重入，读锁获取后能再次获取，写锁获取之后能够再次获取写锁，同时也能够获取读锁；\n 3. 锁降级：遵循获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁\n\n要想能够彻底的理解读写锁必须能够理解这样几个问题：\n\n 1. 读写锁是怎样实现分别记录读写状态的？\n 2. 写锁是怎样获取和释放的？\n 3. 读锁是怎样获取和释放的？\n\n\n# 2、读写状态的设计\n\n读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。回想ReentrantLock中自定义同步器的实现，同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状 态，使得该状态的设计成为读写锁实现的关键。\n\n如果在一个整型变量上维护多种状态，就一定需要**“按位切割使用”**这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写，划分方式如图所示：\n\n\n\n当前同步状态表示一个线程已经获取了写锁，且重进入了两次，同时也连续获取了两次读锁。读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。假设当前同步状态值为S，写状态等于S&0x0000FFFF（将高16位全部抹去），读状态等于S>>>16（无符号补0右移16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1<<16)，也就是S+0x00010000。\n\n根据状态的划分能得出一个推论：S不等于0时，当写状态（S&0x0000FFFF）等于0时，则读状态（S>>>16）大于0，即读锁已被获取。\n\n\n# 3、写锁详解\n\n\n# 写锁的获取\n\n同步组件的实现聚合了同步器（AQS），并通过重写重写同步器（AQS）中的方法实现同步组件的同步语义。因此，写锁的实现依然也是采用这种方式。在同一时刻写锁是不能被多个线程所获取，很显然写锁是独占式锁，而实现写锁的同步语义是通过重写AQS中的tryAcquire方法实现的。源码为:\n\nprotected final boolean tryAcquire(int acquires) {\n    /*\n     * Walkthrough:\n     * 1. If read count nonzero or write count nonzero\n     *    and owner is a different thread, fail.\n     * 2. If count would saturate, fail. (This can only\n     *    happen if count is already nonzero.)\n     * 3. Otherwise, this thread is eligible for lock if\n     *    it is either a reentrant acquire or\n     *    queue policy allows it. If so, update state\n     *    and set owner.\n     */\n    Thread current = Thread.currentThread();\n    // 1. 获取写锁当前的同步状态\n    int c = getState();\n    // 2. 获取写锁获取的次数\n    int w = exclusiveCount(c);\n    if (c != 0) {\n        // (Note: if c != 0 and w == 0 then shared count != 0)\n        // 3.1 当读锁已被读线程获取或者当前线程不是已经获取写锁的线程的话\n        // 当前线程获取写锁失败\n        if (w == 0 || current != getExclusiveOwnerThread())\n            return false;\n        if (w + exclusiveCount(acquires) > MAX_COUNT)\n            throw new Error("Maximum lock count exceeded");\n        // Reentrant acquire\n        // 3.2 当前线程获取写锁，支持可重复加锁\n        setState(c + acquires);\n        return true;\n    }\n    // 3.3 写锁未被任何线程获取，当前线程可获取写锁\n    if (writerShouldBlock() ||\n        !compareAndSetState(c, c + acquires))\n        return false;\n    setExclusiveOwnerThread(current);\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n这段代码的逻辑请看注释，这里有一个地方需要重点关注，exclusiveCount(c)方法，该方法源码为：\n\nstatic int exclusiveCount(int c) {\n    return c & EXCLUSIVE_MASK;\n}\n\n\n1\n2\n3\n\n\n其中EXCLUSIVE_MASK为: static final int EXCLUSIVE_MASK = (1 << SHARED_SHIFT) - 1; EXCLUSIVE _MASK为1左移16位然后减1，即为0x0000FFFF。而exclusiveCount方法是将同步状态（state为int类型）与0x0000FFFF相与，即取同步状态的低16位。根据exclusiveCount方法的注释为独占式获取的次数即写锁被获取的次数，现在就可以得出来一个结论同步状态的低16位用来表示写锁的获取次数。同时还有一个方法值得我们注意：\n\nstatic int sharedCount(int c) {\n    return c >>> SHARED_SHIFT;\n}\n\n\n1\n2\n3\n\n\n该方法是获取读锁被获取的次数，是将同步状态（int c）右移16次，即取同步状态的高16位，现在我们可以得出另外一个结论同步状态的高16位用来表示读锁被获取的次数。\n\n其实这里也就对应了上面读写状态的设计的说明，反映了这种设计方式的巧妙。\n\n现在我们回过头来看写锁获取方法tryAcquire，其主要逻辑为：当读锁已经被读线程获取或者写锁已经被其他写线程获取，则写锁获取失败；否则，获取成功并支持重入，增加写状态。\n\n\n# 写锁的释放\n\n写锁释放通过重写AQS的tryRelease方法，源码为：\n\nprotected final boolean tryRelease(int releases) {\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    //1. 同步状态减去写状态\n    int nextc = getState() - releases;\n    //2. 当前写状态是否为0，为0则释放写锁\n    boolean free = exclusiveCount(nextc) == 0;\n    if (free)\n        setExclusiveOwnerThread(null);\n    //3. 不为0则更新同步状态\n    setState(nextc);\n    return free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n源码的实现逻辑请看注释，不难理解与ReentrantLock基本一致，这里需要注意的是，减少写状态int nextc = getState() - releases;只需要用当前同步状态直接减去写状态的原因正是我们刚才所说的写状态是由同步状态的低16位表示的。\n\n\n# 4、读锁详解\n\n\n# 读锁的获取\n\n看完了写锁，现在来看看读锁，读锁不是独占式锁，即同一时刻该锁可以被多个读线程获取也就是一种共享式锁。按照之前对AQS介绍，实现共享式同步组件的同步语义需要通过重写AQS的tryAcquireShared方法和tryReleaseShared方法。读锁的获取实现方法为：\n\nprotected final int tryAcquireShared(int unused) {\n    /*\n     * Walkthrough:\n     * 1. If write lock held by another thread, fail.\n     * 2. Otherwise, this thread is eligible for\n     *    lock wrt state, so ask if it should block\n     *    because of queue policy. If not, try\n     *    to grant by CASing state and updating count.\n     *    Note that step does not check for reentrant\n     *    acquires, which is postponed to full version\n     *    to avoid having to check hold count in\n     *    the more typical non-reentrant case.\n     * 3. If step 2 fails either because thread\n     *    apparently not eligible or CAS fails or count\n     *    saturated, chain to version with full retry loop.\n     */\n    Thread current = Thread.currentThread();\n    int c = getState();\n    //1. 如果写锁已经被获取并且获取写锁的线程不是当前线程的话，当前\n    // 线程获取读锁失败返回-1\n    if (exclusiveCount(c) != 0 &&\n        getExclusiveOwnerThread() != current)\n        return -1;\n    int r = sharedCount(c);\n    if (!readerShouldBlock() &&\n        r < MAX_COUNT &&\n        //2. 当前线程获取读锁\n        compareAndSetState(c, c + SHARED_UNIT)) {\n        //3. 下面的代码主要是新增的一些功能，比如getReadHoldCount()方法\n        //返回当前获取读锁的次数\n        if (r == 0) {\n            firstReader = current;\n            firstReaderHoldCount = 1;\n        } else if (firstReader == current) {\n            firstReaderHoldCount++;\n        } else {\n            HoldCounter rh = cachedHoldCounter;\n            if (rh == null || rh.tid != getThreadId(current))\n                cachedHoldCounter = rh = readHolds.get();\n            else if (rh.count == 0)\n                readHolds.set(rh);\n            rh.count++;\n        }\n        return 1;\n    }\n    //4. 处理在第二步中CAS操作失败的自旋已经实现重入性\n    return fullTryAcquireShared(current);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n代码的逻辑请看注释，需要注意的是 当写锁被其他线程获取后，读锁获取失败，否则获取成功利用CAS更新同步状态。另外，当前同步状态需要加上SHARED_UNIT（(1 << SHARED_SHIFT)即0x00010000）的原因就是我们在上面所说的同步状态的高16位用来表示读锁被获取的次数。如果CAS失败或者已经获取读锁的线程再次获取读锁时，是靠fullTryAcquireShared方法实现的，这段代码就不展开说了，有兴趣可以看看。\n\n\n# 读锁的释放\n\n读锁释放的实现主要通过方法tryReleaseShared，源码如下，主要逻辑请看注释：\n\nprotected final boolean tryReleaseShared(int unused) {\n    Thread current = Thread.currentThread();\n    // 前面还是为了实现getReadHoldCount等新功能\n    if (firstReader == current) {\n        // assert firstReaderHoldCount > 0;\n        if (firstReaderHoldCount == 1)\n            firstReader = null;\n        else\n            firstReaderHoldCount--;\n    } else {\n        HoldCounter rh = cachedHoldCounter;\n        if (rh == null || rh.tid != getThreadId(current))\n            rh = readHolds.get();\n        int count = rh.count;\n        if (count <= 1) {\n            readHolds.remove();\n            if (count <= 0)\n                throw unmatchedUnlockException();\n        }\n        --rh.count;\n    }\n    for (;;) {\n        int c = getState();\n        // 读锁释放 将同步状态减去读状态即可\n        int nextc = c - SHARED_UNIT;\n        if (compareAndSetState(c, nextc))\n            // Releasing the read lock has no effect on readers,\n            // but it may allow waiting writers to proceed if\n            // both read and write locks are now free.\n            return nextc == 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 5、降级锁\n\n锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。\n\n接下来看一个锁降级的示例。因为数据不常变化，所以多个线程可以并发地进行数据处理，当数据变更后，如果当前线程感知到数据变化，则进行数据的准备工作，同时其他处理线程被阻塞，直到当前线程完成数据的准备工作，如代码如下所示：\n\npublic void processData() {\n    readLock.lock();\n    if (!update) {\n        // 必须先释放读锁\n        readLock.unlock();\n        // 锁降级从写锁获取到开始\n        writeLock.lock();\n        try {\n            if (!update) {\n                ...\n                // 准备数据的流程（略）\n                update = true;\n            }\n            readLock.lock();\n        } finally {\n            writeLock.unlock();\n        }\n        // 锁降级完成，写锁降级为读锁\n    }try {\n        ...\n        // 使用数据的流程（略）\n    } finally {\n        readLock.unlock();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n上述示例中，当数据发生变更后，update变量（布尔类型且volatile修饰）被设置为false，此时所有访问processData()方法的线程都能够感知到变化，但只有一个线程能够获取到写锁，其他线程会被阻塞在读锁和写锁的lock()方法上。当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁，完成锁降级。\n\n**锁降级中读锁的获取是否必要呢？**答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程T）获取了写锁并修改了数据，那么当前线程无法感知线程T的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程T将会被阻塞，直到当前线程使用数据并释放读锁之后，线程T才能获取写锁进行数据更新。\n\nRentrantReadWriteLock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程 ）。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。',normalizedContent:'说明\n\n深入理解读写锁reentrantreadwritelock\n\n\n\n * 1、读写锁的介绍\n * 2、读写状态的设计\n * 3、写锁详解\n   * 写锁的获取\n   * 写锁的释放\n * 4、读锁详解\n   * 读锁的获取\n   * 读锁的释放\n * 5、降级锁\n\n\n\n\n# 深入理解读写锁reentrantreadwritelock\n\n\n# 1、读写锁的介绍\n\n在并发场景中用于解决线程安全的问题，我们几乎会高频率的使用到独占式锁，通常使用java提供的关键字synchronized或者concurrents包中实现了lock接口的reentrantlock。它们都是独占式获取锁，也就是在同一时刻只有一个线程能够获取锁。而在一些业务场景中，大部分只是读数据，写数据很少，如果仅仅是读数据的话并不会影响数据正确性（出现脏读），而如果在这种业务场景下，依然使用独占锁的话，很显然这将是出现性能瓶颈的地方。\n\n针对这种读多写少的情况，java还提供了另外一个实现lock接口的reentrantreadwritelock(读写锁)：读写锁允许同一时刻被多个读线程访问，但是在写线程访问时，所有的读线程和其他的写线程都会被阻塞。java并发包提供读写锁的实现是reentrantreadwritelock，它提供的特性如下所示：\n\n 1. 公平性选择：支持非公平性（默认）和公平的锁获取方式，吞吐量还是非公平优于公平；\n 2. 重入性：支持重入，读锁获取后能再次获取，写锁获取之后能够再次获取写锁，同时也能够获取读锁；\n 3. 锁降级：遵循获取写锁，获取读锁再释放写锁的次序，写锁能够降级成为读锁\n\n要想能够彻底的理解读写锁必须能够理解这样几个问题：\n\n 1. 读写锁是怎样实现分别记录读写状态的？\n 2. 写锁是怎样获取和释放的？\n 3. 读锁是怎样获取和释放的？\n\n\n# 2、读写状态的设计\n\n读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。回想reentrantlock中自定义同步器的实现，同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状 态，使得该状态的设计成为读写锁实现的关键。\n\n如果在一个整型变量上维护多种状态，就一定需要**“按位切割使用”**这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写，划分方式如图所示：\n\n\n\n当前同步状态表示一个线程已经获取了写锁，且重进入了两次，同时也连续获取了两次读锁。读写锁是如何迅速确定读和写各自的状态呢？答案是通过位运算。假设当前同步状态值为s，写状态等于s&0x0000ffff（将高16位全部抹去），读状态等于s>>>16（无符号补0右移16位）。当写状态增加1时，等于s+1，当读状态增加1时，等于s+(1<<16)，也就是s+0x00010000。\n\n根据状态的划分能得出一个推论：s不等于0时，当写状态（s&0x0000ffff）等于0时，则读状态（s>>>16）大于0，即读锁已被获取。\n\n\n# 3、写锁详解\n\n\n# 写锁的获取\n\n同步组件的实现聚合了同步器（aqs），并通过重写重写同步器（aqs）中的方法实现同步组件的同步语义。因此，写锁的实现依然也是采用这种方式。在同一时刻写锁是不能被多个线程所获取，很显然写锁是独占式锁，而实现写锁的同步语义是通过重写aqs中的tryacquire方法实现的。源码为:\n\nprotected final boolean tryacquire(int acquires) {\n    /*\n     * walkthrough:\n     * 1. if read count nonzero or write count nonzero\n     *    and owner is a different thread, fail.\n     * 2. if count would saturate, fail. (this can only\n     *    happen if count is already nonzero.)\n     * 3. otherwise, this thread is eligible for lock if\n     *    it is either a reentrant acquire or\n     *    queue policy allows it. if so, update state\n     *    and set owner.\n     */\n    thread current = thread.currentthread();\n    // 1. 获取写锁当前的同步状态\n    int c = getstate();\n    // 2. 获取写锁获取的次数\n    int w = exclusivecount(c);\n    if (c != 0) {\n        // (note: if c != 0 and w == 0 then shared count != 0)\n        // 3.1 当读锁已被读线程获取或者当前线程不是已经获取写锁的线程的话\n        // 当前线程获取写锁失败\n        if (w == 0 || current != getexclusiveownerthread())\n            return false;\n        if (w + exclusivecount(acquires) > max_count)\n            throw new error("maximum lock count exceeded");\n        // reentrant acquire\n        // 3.2 当前线程获取写锁，支持可重复加锁\n        setstate(c + acquires);\n        return true;\n    }\n    // 3.3 写锁未被任何线程获取，当前线程可获取写锁\n    if (writershouldblock() ||\n        !compareandsetstate(c, c + acquires))\n        return false;\n    setexclusiveownerthread(current);\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n这段代码的逻辑请看注释，这里有一个地方需要重点关注，exclusivecount(c)方法，该方法源码为：\n\nstatic int exclusivecount(int c) {\n    return c & exclusive_mask;\n}\n\n\n1\n2\n3\n\n\n其中exclusive_mask为: static final int exclusive_mask = (1 << shared_shift) - 1; exclusive _mask为1左移16位然后减1，即为0x0000ffff。而exclusivecount方法是将同步状态（state为int类型）与0x0000ffff相与，即取同步状态的低16位。根据exclusivecount方法的注释为独占式获取的次数即写锁被获取的次数，现在就可以得出来一个结论同步状态的低16位用来表示写锁的获取次数。同时还有一个方法值得我们注意：\n\nstatic int sharedcount(int c) {\n    return c >>> shared_shift;\n}\n\n\n1\n2\n3\n\n\n该方法是获取读锁被获取的次数，是将同步状态（int c）右移16次，即取同步状态的高16位，现在我们可以得出另外一个结论同步状态的高16位用来表示读锁被获取的次数。\n\n其实这里也就对应了上面读写状态的设计的说明，反映了这种设计方式的巧妙。\n\n现在我们回过头来看写锁获取方法tryacquire，其主要逻辑为：当读锁已经被读线程获取或者写锁已经被其他写线程获取，则写锁获取失败；否则，获取成功并支持重入，增加写状态。\n\n\n# 写锁的释放\n\n写锁释放通过重写aqs的tryrelease方法，源码为：\n\nprotected final boolean tryrelease(int releases) {\n    if (!isheldexclusively())\n        throw new illegalmonitorstateexception();\n    //1. 同步状态减去写状态\n    int nextc = getstate() - releases;\n    //2. 当前写状态是否为0，为0则释放写锁\n    boolean free = exclusivecount(nextc) == 0;\n    if (free)\n        setexclusiveownerthread(null);\n    //3. 不为0则更新同步状态\n    setstate(nextc);\n    return free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n源码的实现逻辑请看注释，不难理解与reentrantlock基本一致，这里需要注意的是，减少写状态int nextc = getstate() - releases;只需要用当前同步状态直接减去写状态的原因正是我们刚才所说的写状态是由同步状态的低16位表示的。\n\n\n# 4、读锁详解\n\n\n# 读锁的获取\n\n看完了写锁，现在来看看读锁，读锁不是独占式锁，即同一时刻该锁可以被多个读线程获取也就是一种共享式锁。按照之前对aqs介绍，实现共享式同步组件的同步语义需要通过重写aqs的tryacquireshared方法和tryreleaseshared方法。读锁的获取实现方法为：\n\nprotected final int tryacquireshared(int unused) {\n    /*\n     * walkthrough:\n     * 1. if write lock held by another thread, fail.\n     * 2. otherwise, this thread is eligible for\n     *    lock wrt state, so ask if it should block\n     *    because of queue policy. if not, try\n     *    to grant by casing state and updating count.\n     *    note that step does not check for reentrant\n     *    acquires, which is postponed to full version\n     *    to avoid having to check hold count in\n     *    the more typical non-reentrant case.\n     * 3. if step 2 fails either because thread\n     *    apparently not eligible or cas fails or count\n     *    saturated, chain to version with full retry loop.\n     */\n    thread current = thread.currentthread();\n    int c = getstate();\n    //1. 如果写锁已经被获取并且获取写锁的线程不是当前线程的话，当前\n    // 线程获取读锁失败返回-1\n    if (exclusivecount(c) != 0 &&\n        getexclusiveownerthread() != current)\n        return -1;\n    int r = sharedcount(c);\n    if (!readershouldblock() &&\n        r < max_count &&\n        //2. 当前线程获取读锁\n        compareandsetstate(c, c + shared_unit)) {\n        //3. 下面的代码主要是新增的一些功能，比如getreadholdcount()方法\n        //返回当前获取读锁的次数\n        if (r == 0) {\n            firstreader = current;\n            firstreaderholdcount = 1;\n        } else if (firstreader == current) {\n            firstreaderholdcount++;\n        } else {\n            holdcounter rh = cachedholdcounter;\n            if (rh == null || rh.tid != getthreadid(current))\n                cachedholdcounter = rh = readholds.get();\n            else if (rh.count == 0)\n                readholds.set(rh);\n            rh.count++;\n        }\n        return 1;\n    }\n    //4. 处理在第二步中cas操作失败的自旋已经实现重入性\n    return fulltryacquireshared(current);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n代码的逻辑请看注释，需要注意的是 当写锁被其他线程获取后，读锁获取失败，否则获取成功利用cas更新同步状态。另外，当前同步状态需要加上shared_unit（(1 << shared_shift)即0x00010000）的原因就是我们在上面所说的同步状态的高16位用来表示读锁被获取的次数。如果cas失败或者已经获取读锁的线程再次获取读锁时，是靠fulltryacquireshared方法实现的，这段代码就不展开说了，有兴趣可以看看。\n\n\n# 读锁的释放\n\n读锁释放的实现主要通过方法tryreleaseshared，源码如下，主要逻辑请看注释：\n\nprotected final boolean tryreleaseshared(int unused) {\n    thread current = thread.currentthread();\n    // 前面还是为了实现getreadholdcount等新功能\n    if (firstreader == current) {\n        // assert firstreaderholdcount > 0;\n        if (firstreaderholdcount == 1)\n            firstreader = null;\n        else\n            firstreaderholdcount--;\n    } else {\n        holdcounter rh = cachedholdcounter;\n        if (rh == null || rh.tid != getthreadid(current))\n            rh = readholds.get();\n        int count = rh.count;\n        if (count <= 1) {\n            readholds.remove();\n            if (count <= 0)\n                throw unmatchedunlockexception();\n        }\n        --rh.count;\n    }\n    for (;;) {\n        int c = getstate();\n        // 读锁释放 将同步状态减去读状态即可\n        int nextc = c - shared_unit;\n        if (compareandsetstate(c, nextc))\n            // releasing the read lock has no effect on readers,\n            // but it may allow waiting writers to proceed if\n            // both read and write locks are now free.\n            return nextc == 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 5、降级锁\n\n锁降级指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。\n\n接下来看一个锁降级的示例。因为数据不常变化，所以多个线程可以并发地进行数据处理，当数据变更后，如果当前线程感知到数据变化，则进行数据的准备工作，同时其他处理线程被阻塞，直到当前线程完成数据的准备工作，如代码如下所示：\n\npublic void processdata() {\n    readlock.lock();\n    if (!update) {\n        // 必须先释放读锁\n        readlock.unlock();\n        // 锁降级从写锁获取到开始\n        writelock.lock();\n        try {\n            if (!update) {\n                ...\n                // 准备数据的流程（略）\n                update = true;\n            }\n            readlock.lock();\n        } finally {\n            writelock.unlock();\n        }\n        // 锁降级完成，写锁降级为读锁\n    }try {\n        ...\n        // 使用数据的流程（略）\n    } finally {\n        readlock.unlock();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n上述示例中，当数据发生变更后，update变量（布尔类型且volatile修饰）被设置为false，此时所有访问processdata()方法的线程都能够感知到变化，但只有一个线程能够获取到写锁，其他线程会被阻塞在读锁和写锁的lock()方法上。当前线程获取写锁完成数据准备之后，再获取读锁，随后释放写锁，完成锁降级。\n\n**锁降级中读锁的获取是否必要呢？**答案是必要的。主要是为了保证数据的可见性，如果当前线程不获取读锁而是直接释放写锁，假设此刻另一个线程（记作线程t）获取了写锁并修改了数据，那么当前线程无法感知线程t的数据更新。如果当前线程获取读锁，即遵循锁降级的步骤，则线程t将会被阻塞，直到当前线程使用数据并释放读锁之后，线程t才能获取写锁进行数据更新。\n\nrentrantreadwritelock不支持锁升级（把持读锁、获取写锁，最后释放读锁的过程 ）。目的也是保证数据可见性，如果读锁已被多个线程获取，其中任意线程成功获取了写锁并更新了数据，则其更新对其他获取到读锁的线程是不可见的。',charsets:{cjk:!0},createdTime:1655628697e3},{title:"并发容器之ConcurrentLinkedQueue",frontmatter:{title:"并发容器之ConcurrentLinkedQueue",description:"并发容器之ConcurrentLinkedQueue",date:"2022-04-06T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/15%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentLinkedQueue.html",relativePath:"Java/Java并发编程的艺术/15、并发容器之ConcurrentLinkedQueue.md",key:"v-f65945d6",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/15%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentLinkedQueue.html",headers:[{level:2,title:"1、ConcurrentLinkedQueue简介",slug:"_1、concurrentlinkedqueue简介",normalizedTitle:"1、concurrentlinkedqueue简介",charIndex:37},{level:2,title:"2、ConcurrentLinkedQueue的结构",slug:"_2、concurrentlinkedqueue的结构",normalizedTitle:"2、concurrentlinkedqueue的结构",charIndex:66},{level:2,title:"3、操作Node的几个CAS操作",slug:"_3、操作node的几个cas操作",normalizedTitle:"3、操作node的几个cas操作",charIndex:96},{level:2,title:"4、offer方法",slug:"_4、offer方法",normalizedTitle:"4、offer方法",charIndex:116},{level:3,title:"单线程角度执行分析",slug:"单线程角度执行分析",normalizedTitle:"单线程角度执行分析",charIndex:131},{level:3,title:"多线程角度执行分析",slug:"多线程角度执行分析",normalizedTitle:"多线程角度执行分析",charIndex:146},{level:2,title:"5、poll方法",slug:"_5、poll方法",normalizedTitle:"5、poll方法",charIndex:159},{level:3,title:"单线程角度执行分析",slug:"单线程角度执行分析-2",normalizedTitle:"单线程角度执行分析",charIndex:131},{level:3,title:"多线程角度执行分析",slug:"多线程角度执行分析-2",normalizedTitle:"多线程角度执行分析",charIndex:146},{level:2,title:"6、offer方法中部分线程offer部分线程poll",slug:"_6、offer方法中部分线程offer部分线程poll",normalizedTitle:"6、offer方法中部分线程offer部分线程poll",charIndex:201}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>并发容器之ConcurrentLinkedQueue</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"1、ConcurrentLinkedQueue简介 2、ConcurrentLinkedQueue的结构 3、操作Node的几个CAS操作 4、offer方法 单线程角度执行分析 多线程角度执行分析 5、poll方法 单线程角度执行分析 多线程角度执行分析 6、offer方法中部分线程offer部分线程poll",content:'说明\n\n并发容器之ConcurrentLinkedQueue\n\n\n\n * 1、ConcurrentLinkedQueue简介\n * 2、ConcurrentLinkedQueue的结构\n * 3、操作Node的几个CAS操作\n * 4、offer方法\n   * 单线程角度执行分析\n   * 多线程角度执行分析\n * 5、poll方法\n   * 单线程角度执行分析\n   * 多线程角度执行分析\n * 6、offer方法中部分线程offer部分线程poll\n\n\n\n\n# 并发容器之ConcurrentLinkedQueue\n\n\n# 1、ConcurrentLinkedQueue简介\n\n在单线程编程中我们会经常用到一些集合类，比如ArrayList,HashMap等，但是这些类都不是线程安全的类。在面试中也经常会有一些考点，比如ArrayList不是线程安全的，Vector是线程安全。而保障Vector线程安全的方式，是非常粗暴的在方法上用synchronized独占锁，将多线程执行变成串行化。要想将ArrayList变成线程安全的也可以使用Collections.synchronizedList(List<T> list)方法ArrayList转换成线程安全的，但这种转换方式依然是通过synchronized修饰方法实现的，很显然这不是一种高效的方式，同时，队列也是我们常用的一种数据结构，为了解决线程安全的问题，Doug Lea大师为我们准备了ConcurrentLinkedQueue这个线程安全的队列。从类名就可以看的出来实现队列的数据结构是链式。\n\nConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait-free”算法（即CAS算法）来实现，该算法在 Michael&Scott 算法上进行了一些修改。\n\n\n# 2、ConcurrentLinkedQueue的结构\n\n通过ConcurrentLinkedQueue的类图来分析一下它的结构，如图所示：\n\n\n\nConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由数据域（item）和指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点，当我们调用无参构造器时，其源码为：\n\npublic ConcurrentLinkedQueue() {\n    head = tail = new Node<E>(null);\n}\n\n\n1\n2\n3\n\n\n\n# 3、操作Node的几个CAS操作\n\n在队列进行出队入队的时候免不了对节点需要进行操作，在多线程就很容易出现线程安全的问题。可以看出在处理器指令集能够支持CMPXCHG指令后，在java源码中涉及到并发处理都会使用CAS操作，那么在ConcurrentLinkedQueue对Node的CAS操作有这样几个：\n\n//更改Node中的数据域item\nboolean casItem(E cmp, E val) {\n    return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val);\n}\n//更改Node中的指针域next\nvoid lazySetNext(Node<E> val) {\n    UNSAFE.putOrderedObject(this, nextOffset, val);\n}\n//更改Node中的指针域next\nboolean casNext(Node<E> cmp, Node<E> val) {\n    return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n可以看出这些方法实际上是通过调用UNSAFE实例的方法，UNSAFE为sun.misc.Unsafe类，该类是hotspot底层方法，目前为止了解即可，知道CAS的操作归根结底是由该类提供就好。\n\n\n# 4、offer方法\n\n对一个队列来说，插入满足FIFO特性，插入元素总是在队列最末尾的地方进行插入，而取（移除）元素总是从队列的队头。所有要想能够彻底弄懂ConcurrentLinkedQueue自然而然是从offer方法和poll方法开始。另外，在看多线程的代码时，可采用这样的思维方式：\n\n> 单个线程offer\n> \n> 多个线程offer\n> \n> 部分线程offer，部分线程poll\n> \n>  * 当offer的速度快于poll：队列长度会越来越长，由于offer节点总是在对队列队尾，而poll节点总是在队列对头，也就是说offer线程和poll线程两者并无“交集”，也就是说两类线程间并不会相互影响，这种情况站在相对速率的角度来看，也就是一个"单线程offer"\n>  * 当offer的速度慢于poll：poll的相对速率快于offer，也就是队头删的速度要快于队尾添加节点的速度，导致的结果就是队列长度会越来越短，而offer线程和poll线程就会出现“交集”，即那一时刻就可以称之为offer线程和poll线程同时操作的节点为 临界点 ，且在该节点offer线程和poll线程必定相互影响。根据在临界点时offer和poll发生的相对顺序又可从两个角度去思考：1. 执行顺序为offer--\x3epoll--\x3eoffer，即表现为当offer线程在Node1后插入Node2时，此时poll线程已经将Node1删除，这种情况很显然需要在offer方法中考虑； 2.执行顺序可能为：poll--\x3eoffer--\x3epoll，即表现为当poll线程准备删除的节点为null时（队列为空队列），此时offer线程插入一个节点使得队列变为非空队列。\n\n先给出offer的源码：\n\npublic boolean offer(E e) {\n    checkNotNull(e);\n    final Node<E> newNode = new Node<E>(e);\n\n    for (Node<E> t = tail, p = t;;) {\n        Node<E> q = p.next;\n        if (q == null) {\n            // p is last node\n            if (p.casNext(null, newNode)) {\n                // Successful CAS is the linearization point\n                // for e to become an element of this queue,\n                // and for newNode to become "live".\n                if (p != t) // hop two nodes at a time\n                    casTail(t, newNode);  // Failure is OK.\n                return true;\n            }\n            // Lost CAS race to another thread; re-read next\n        }\n        else if (p == q)\n            // We have fallen off list.  If tail is unchanged, it\n            // will also be off-list, in which case we need to\n            // jump to head, from which all live nodes are always\n            // reachable.  Else the new tail is a better bet.\n            p = (t != (t = tail)) ? t : head;\n        else\n            // Check for tail updates after two hops.\n            p = (p != t && t != (t = tail)) ? t : q;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n下面是IDEA版本的代码，我们就以以下面的为例：\n\npublic boolean offer(E var1) {\n    //1、对是否为null进行判断，为null的话就直接抛出空指针异常\n    checkNotNull(var1);\n    //2、把数据E包装成Node类\n    ConcurrentLinkedQueue.Node var2 = new ConcurrentLinkedQueue.Node(var1);\n    //3、将当前尾结点引用为两个变量（这里将var4认为是真正的尾结点）\n    ConcurrentLinkedQueue.Node var3 = this.tail;\n    ConcurrentLinkedQueue.Node var4 = var3;\n\n    do {\n        //4、死循环，符合CAS的套路\n        while(true) {\n            //5、将var4的next节点引用为var5\n            ConcurrentLinkedQueue.Node var5 = var4.next;\n            if (var5 == null) {\n                break;\n            }\n\n            if (var4 == var5) {\n                var4 = var3 != (var3 = this.tail) ? var3 : this.head;\n            } else {\n                //6、定位真正的尾结点\n                var4 = var4 != var3 && var3 != (var3 = this.tail) ? var3 : var5;\n            }\n        }\n    } while(!var4.casNext((ConcurrentLinkedQueue.Node)null, var2));\n\n    //7、设置新的tail\n    if (var4 != var3) {\n        this.casTail(var3, var2);\n    }\n\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n再执行这么一段代码，创建一个ConcurrentLinkedQueue实例，先offer 1，然后再offer 2，然后从源码的角度来逐步分析。\n\nConcurrentLinkedQueue<Integer> queue = new ConcurrentLinkedQueue<>();\nqueue.offer(1);\nqueue.offer(2);\n\n\n1\n2\n3\n\n\n\n# 单线程角度执行分析\n\n先从单线程执行的角度看起，分析offer 1的过程。注释1代码会对是否为null进行判断，为null的话就直接抛出空指针异常，注释2代码将var1包装成一个Node类，这里实例变量var3被初始化为tail，var4被初始化为var3即tail。为了方便下面的理解，var4被认为队列真正的尾节点，tail不一定指向对象真正的尾节点，因为在ConcurrentLinkedQueue中tail是被延迟更新的，具体原因我们慢慢来看。下面进入do循环，注释4死循环，符合CAS的套路：先将var4的next节点引用为var5并看是否为null，这里明显为null，至此跳出注释4的死循环。紧接着while判断!var4.casNext((ConcurrentLinkedQueue.Node)null, var2)，将var4（当前真正的尾结点）的next节点变为var2，返回true取反为false，退出do while循环。执行最后的if，判断var4 != var3，明显是相等的，因为刚才上面根本就没动过这两个变量。至此offer(1);完成。此时ConcurrentLinkedQueue的状态如下图所示：\n\n\n\n如图，此时队列的尾节点应该为Node1，而tail指向的节点依然还是Node0，因此可以说明tail是延迟更新的。那么我们继续来看offer 2的时候的情况，很显然此时注释5代码var5指向的节点不为null了，而是指向Node1，注释5代码if判断为false，紧接着if判断var4 == var5，为啥要这么判断呢，其实他们俩相等只有一种可能就是var4节点和var4的next节点都等于空，表示这个队列刚初始化，正准备添加节点，所以将head节点赋予var4（真正的尾结点）这里肯定是不相等的，于是走else代码，明显var3是等于var4的，至此var4（真正的尾结点）变为var5（也就是我们新插入的item为2的Node2节点），到这就可以彻底理解"tail是被延迟更新的"这句话，而其实注释6代码的作用就是定位真正的尾结点：\n\nvar4 = var4 != var3 && var3 != (var3 = this.tail) ? var3 : var5;\n\n\n1\n\n\n然后while里通过casNext方法设置var4节点的next为当前新增的Node2，跳出do while循环。这个时候var4 != var3（上面重新定位到了tail），注释7代码if判断为true，会通过casTail(t, newNode)将当前节点Node2设置为队列的队尾节点，此时的队列状态示意图如下图所示：\n\n\n\ntail指向的节点由Node0改变为Node2，如果这里的casTail失败，是不需要重试的，原因是：offer代码中主要是通过var4的next节点var5ConcurrentLinkedQueue.Node var5 = var4.next;决定后面的逻辑走向的，当casTail失败时状态示意图如下：\n\n\n\n如图，如果这里casTail设置tail失败即tail还是指向Node0节点的话，无非就是多循环几次通过13行代码定位到队尾节点。\n\n通过对单线程执行角度进行分析，我们可以了解到offer的执行逻辑为：\n\n 1. 如果tail指向的节点的下一个节点（next域）为null的话，说明tail指向的节点即为队列真正的队尾节点，因此可以通过casNext插入当前待插入的节点，但此时tail并未变化，如图2;\n 2. 如果tail指向的节点的下一个节点（next域）不为null的话，说明tail指向的节点不是队列的真正队尾节点。通过var5 ConcurrentLinkedQueue.Node var5 = var4.next;指针往前递进去找到队尾节点，然后通过casNext插入当前待插入的节点，并通过casTail方式更改tail，如图3。\n\n不得不赞叹这个do while循环的巧妙，将原本臃肿的代码写的如此优美！\n\n我们回过头再来看var4 = var4 != var3 && var3 != (var3 = this.tail) ? var3 : var5;这行代码在单线程中，这段代码永远不会将var4赋值为var3，那么这么写就不会有任何作用，那我们试着在多线程的情况下进行分析。\n\n\n# 多线程角度执行分析\n\n> 多个线程offer\n\n很显然这么写另有深意，其实在多线程环境下这行代码很有意思的。 var3 != (var3 = this.tail)这个操作并非一个原子操作，有这样一种情况：\n\n\n\n如图，假设线程A此时读取了变量t，线程B刚好在这个时候offer一个Node后，此时会修改tail指针，那么这个时候线程A再次执行var4=this.tail时var4会指向另外一个节点，很显然线程A前后两次读取的变量var4指向的节点不相同，即var4 != (var4 = this.tail)为true，并且由于var4指向节点的变化var4 != var3也为true，此时该三目表达式会将var3赋给var4（其实也就是发现了多线程改动，导致这次的tail先不动），然后下面的if也不会成立，其实跟上面casTail设置tail失败的情况一样，等到下次再设置tail。\n\n> offer->poll->offer\n\n那么还剩下第11行的代码我们没有分析，大致可以猜想到应该就是回答一部分线程offer，一部分poll的这种情况。当if (var4 == var5)为true时，说明p指向的节点的next也指向它自己，这种节点称之为哨兵节点，这种节点在队列中存在的价值不大，一般表示为要删除的节点或者是空节点。为了能够很好的理解这种情况，我们先看看poll方法的执行过程后，再回过头来看，总之这是一个很有意思的事情。\n\n\n# 5、poll方法\n\npoll方法源码为：\n\npublic E poll() {\n    restartFromHead:\n    for (;;) {\n        for (Node<E> h = head, p = h, q;;) {\n            E item = p.item;\n\n            if (item != null && p.casItem(item, null)) {\n                // Successful CAS is the linearization point\n                // for item to be removed from this queue.\n                if (p != h) // hop two nodes at a time\n                    updateHead(h, ((q = p.next) != null) ? q : p);\n                return item;\n            }\n            else if ((q = p.next) == null) {\n                updateHead(h, p);\n                return null;\n            }\n            else if (p == q)\n                continue restartFromHead;\n            else\n                p = q;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n下面是IDEA版本的代码，我们就以以下面的为例：\n\npublic E poll() {\n    //1、外层循环\n    while(true) {\n        ConcurrentLinkedQueue.Node var1 = this.head;\n        ConcurrentLinkedQueue.Node var2 = var1;\n\n        //2、内层循环\n        while(true) {\n            Object var4 = var2.item;\n            ConcurrentLinkedQueue.Node var3;\n            //3\n            if (var4 != null && var2.casItem(var4, (Object)null)) {\n                //6\n                if (var2 != var1) {\n                    this.updateHead(var1, (var3 = var2.next) != null ? var3 : var2);\n                }\n\n                return var4;\n            }\n\n            //4、看队列中是否有下一个节点\n            if ((var3 = var2.next) == null) {\n                this.updateHead(var1, var2);\n                return null;\n            }\n\n            //5、定位新的head节点\n            if (var2 == var3) {\n                break;\n            }\n\n            var2 = var3;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 单线程角度执行分析\n\n我们还是先站在单线程的角度去理清该方法的基本逻辑。假设ConcurrentLinkedQueue初始状态如下图所示：\n\n\n\n参照上面offer方法，上来直接进行一个死循环，分别将当前的头节点（head）引用为var1和var2，而这里的var2也是代表队列真正的head节点。里面又是一个死循环，将var2节点的数据（item）引用为var4，然后再来一个var3（Node）节点，但未初始化。下面if判断var4是否为null，看数据是否为空，并且将var2的数据域（item）置空var2.casItem(var4, (Object)null)。这里如果CAS item失败或者var4为空则此次循环结束等待下一次循环进行重试。当然这里if判断为true，紧接着下面的if判断var1和var2是否相等，这里肯定是相等的（其实经过上面对offer方法的分析，我们大概知道这个if判断是为了防止多线程的干扰），所以为false，返回var4Object var4 = var2.item;，方法结束。此时的队列状态如下图：\n\n\n\n下面继续从队列中poll，很显然当前var1和var2指向的Node1的数据域为null，那么第一件事就是要定位准备删除的队头节点(找到数据域不为null的节点)。\n\n> 定位删除的队头节点\n\n直接来到注释3代码，由于上面poll Node1时已将其item域置空，所以注释3代码的if为false。来到注释4代码的if判断，var2.next是否为null，不为null，if判断为false。来到注释5代码if判断var3（上面一个if判断将var2.next赋予var3）和var2是否相等，如果相等退出注释2循环，重新开始注释1外层循环，这里是不相等的，就将var3赋给var2，也就是找到真正的head节点，然后进行下一次注释2的内侧循环。再来到注释3代码，var4（Node2节点的item域）不为空，并用var2.casItem(var4, (Object)null)将var2（Node2节点）的item域置空，来到注释6的if判断var2 != var1，由于上一次内层循环已经改变了var2 var2 = var3;，所以if判断为true，执行this.updateHead(var1, (var3 = var2.next) != null ? var3 : var2);，而(var3 = var2.next) != null ? var3 : var2)就是看Node2节点后面有没有节点了有的话就是Node2节点后面一个节点，没有的话就是Node2节点，这里的casItem方法源码如下：\n\nfinal void updateHead(ConcurrentLinkedQueue.Node<E> var1, ConcurrentLinkedQueue.Node<E> var2) {\n    if (var1 != var2 && this.casHead(var1, var2)) {\n        var1.lazySetNext(var1);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n该方法主要是通过casHead将队列的head指向Node3，并且通过 var1.lazySetNext将Node1的next域指向它自己（其实就是废弃Node1等待GC回收）。最后返回var4，也就是Node2节点的数据（item）。此时队列的状态如下图所示：\n\n\n\nNode1的next域指向它自己，head指向了Node3。以上的分析是从单线程执行的角度去看，也可以让我们了解poll的整体思路，现在来做一个总结：\n\n 1. 如果当前head，var1和var2指向的节点的Item不为null的话，说明该节点即为真正的队头节点（待删除节点），只需要通过casItem方法将item域设置为null,然后将原来的item直接返回即可。\n 2. 如果当前head，var1和var2指向的节点的item为null的话，则说明该节点不是真正的待删除节点，那么应该做的就是寻找item不为null的节点。通过让var3指向var2的下一个节点（var3 = var2.next）进行试探，若找到则通过updateHead方法更新head指向的节点以及构造哨兵节点（通过updateHead方法的var1.lazySetNext(h)）。\n\n\n# 多线程角度执行分析\n\n> 多个线程poll\n\n现在回过头来看poll方法的源码，有这样一部分：\n\nif (var2 == var3) {\n    break;\n}\n\n\n1\n2\n3\n\n\n这一部分就是处理多个线程poll的情况，var3 = var2.next也就是说var3永远指向的是var2的下一个节点，那么什么情况下会使得var2，var3指向同一个节点呢？根据上面我们的分析，只有var2指向的节点在poll的时候转变成了哨兵节点（通过updateHead方法中的var1.lazySetNext）。当线程A在判断var2 == var3时，线程B已经将执行完poll方法将var2指向的节点转换为哨兵节点并且head指向的节点已经发生了改变，所以就需要从外层循环处重新开始，保证用到的是最新的head。\n\n> poll->offer->poll\n\n试想，还有这样一种情况，如果当前队列为空队列，线程A进行poll操作，同时线程B执行offer，然后线程A在执行poll，那么此时线程A返回的是null还是线程B刚插入的最新的那个节点呢？我们来写一代demo：\n\npublic static void main(String[] args) {\n    Thread thread1 = new Thread(() -> {\n        Integer value = queue.poll();\n        System.out.println(Thread.currentThread().getName() + " poll 的值为：" + value);\n        System.out.println("queue当前是否为空队列：" + queue.isEmpty());\n    });\n    thread1.start();\n    Thread thread2 = new Thread(() -> {\n        queue.offer(1);\n    });\n    thread2.start();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n输出结果为：\n\n> Thread-0 poll 的值为：null\n> \n> queue当前是否为空队列：false\n\n通过debug控制线程thread1和线程thread2的执行顺序，thread1先执行到代码if ((var3 = var2.next) == null)，由于此时队列为空队列if判断为true，进入if块，此时先让thread1暂停，然后thread2进行offer插入值为1的节点后，thread2执行结束。再让thread1执行，这时thread1并没有进行重试，而是代码继续往下走，返回null，尽管此时队列由于thread2已经插入了值为1的新的节点。所以输出结果为thread0 poll的为null，然队列不为空队列。因此，在判断队列是否为空队列的时候是不能通过线程在poll的时候返回为null进行判断的，可以通过isEmpty方法进行判断。\n\n\n# 6、offer方法中部分线程offer部分线程poll\n\n在分析offer方法的时候我们还留下了一个问题，即对offer方法中if (p == q)代码的理解。\n\n> offer->poll->offer\n\n在offer方法的第11行代码if (p == q)，能够让if判断为true的情况为p指向的节点为哨兵节点，而什么时候会构造哨兵节点呢？在对poll方法的讨论中，我们已经找到了答案，即**当head指向的节点的item域为null时会寻找真正的队头节点，等到待插入的节点插入之后，会更新head，并且将原来head指向的节点设置为哨兵节点。**假设队列初始状态如下图所示：\n\n\n\n因此在线程A执行offer时，线程B执行poll就会存在如下一种情况：\n\n\n\n如图，线程A的tail节点存在next节点Node1，因此会通过引用q往前寻找队列真正的队尾节点，当执行到判断if (p == q)时，此时线程B执行poll操作，在对线程B来说，head和p指向Node0，由于Node0的item域为null，同样会往前递进找到队列真正的队头节点Node1,在线程B执行完poll之后，Node0就会转换为哨兵节点，也就意味着队列的head发生了改变，此时队列状态为下图：\n\n\n\n此时线程A在执行判断if (p == q)时就为true，会继续执行p = (t != (t = tail)) ? t : head;，由于tail指针没有发生改变所以p被赋值为head，重新从head开始完成插入操作。\n\n\n# 5. HOPS的设计\n\n通过上面对offer和poll方法的分析，我们发现tail和head是延迟更新的，两者更新触发时机为：\n\ntail更新触发时机：当tail指向的节点的下一个节点不为null的时候，会执行定位队列真正的队尾节点的操作，找到队尾节点后完成插入之后才会通过casTail进行tail更新；当tail指向的节点的下一个节点为null的时候，只插入节点不更新tail。\n\nhead更新触发时机：当head指向的节点的item域为null的时候，会执行定位队列真正的队头节点的操作，找到队头节点后完成删除之后才会通过updateHead进行head更新；当head指向的节点的item域不为null的时候，只删除节点不更新head。\n\n并且在更新操作时，源码中会有注释为：hop two nodes at a time。所以这种延迟更新的策略就被叫做HOPS的大概原因是这个（猜的 ），从上面更新时的状态图可以看出，head和tail的更新是“跳着的”即中间总是间隔了一个。那么这样设计的意图是什么呢？\n\n如果让tail永远作为队列的队尾节点，实现的代码量会更少，而且逻辑更易懂。但是，这样做有一个缺点，**如果大量的入队操作，每次都要执行CAS进行tail的更新，汇总起来对性能也会是大大的损耗。如果能减少CAS更新的操作，无疑可以大大提升入队的操作效率，所以doug lea大师每间隔1次（tail和队尾节点的距离为1）才利用CAS更新tail。**对head的更新也是同样的道理，虽然，这样设计会多出在循环中定位队尾节点，但总体来说读的操作效率要远远高于写的性能，因此，多出来的在循环中定位尾节点的操作的性能损耗相对而言是很小的。\n\n> 参考资料\n\n《java并发编程的艺术》\n\n《Java高并发程序设计》\n\n并发容器之ConcurrentLinkedQueue',normalizedContent:'说明\n\n并发容器之concurrentlinkedqueue\n\n\n\n * 1、concurrentlinkedqueue简介\n * 2、concurrentlinkedqueue的结构\n * 3、操作node的几个cas操作\n * 4、offer方法\n   * 单线程角度执行分析\n   * 多线程角度执行分析\n * 5、poll方法\n   * 单线程角度执行分析\n   * 多线程角度执行分析\n * 6、offer方法中部分线程offer部分线程poll\n\n\n\n\n# 并发容器之concurrentlinkedqueue\n\n\n# 1、concurrentlinkedqueue简介\n\n在单线程编程中我们会经常用到一些集合类，比如arraylist,hashmap等，但是这些类都不是线程安全的类。在面试中也经常会有一些考点，比如arraylist不是线程安全的，vector是线程安全。而保障vector线程安全的方式，是非常粗暴的在方法上用synchronized独占锁，将多线程执行变成串行化。要想将arraylist变成线程安全的也可以使用collections.synchronizedlist(list<t> list)方法arraylist转换成线程安全的，但这种转换方式依然是通过synchronized修饰方法实现的，很显然这不是一种高效的方式，同时，队列也是我们常用的一种数据结构，为了解决线程安全的问题，doug lea大师为我们准备了concurrentlinkedqueue这个线程安全的队列。从类名就可以看的出来实现队列的数据结构是链式。\n\nconcurrentlinkedqueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait-free”算法（即cas算法）来实现，该算法在 michael&scott 算法上进行了一些修改。\n\n\n# 2、concurrentlinkedqueue的结构\n\n通过concurrentlinkedqueue的类图来分析一下它的结构，如图所示：\n\n\n\nconcurrentlinkedqueue由head节点和tail节点组成，每个节点（node）由数据域（item）和指向下一个节点（next）的引用组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。默认情况下head节点存储的元素为空，tail节点等于head节点，当我们调用无参构造器时，其源码为：\n\npublic concurrentlinkedqueue() {\n    head = tail = new node<e>(null);\n}\n\n\n1\n2\n3\n\n\n\n# 3、操作node的几个cas操作\n\n在队列进行出队入队的时候免不了对节点需要进行操作，在多线程就很容易出现线程安全的问题。可以看出在处理器指令集能够支持cmpxchg指令后，在java源码中涉及到并发处理都会使用cas操作，那么在concurrentlinkedqueue对node的cas操作有这样几个：\n\n//更改node中的数据域item\nboolean casitem(e cmp, e val) {\n    return unsafe.compareandswapobject(this, itemoffset, cmp, val);\n}\n//更改node中的指针域next\nvoid lazysetnext(node<e> val) {\n    unsafe.putorderedobject(this, nextoffset, val);\n}\n//更改node中的指针域next\nboolean casnext(node<e> cmp, node<e> val) {\n    return unsafe.compareandswapobject(this, nextoffset, cmp, val);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n可以看出这些方法实际上是通过调用unsafe实例的方法，unsafe为sun.misc.unsafe类，该类是hotspot底层方法，目前为止了解即可，知道cas的操作归根结底是由该类提供就好。\n\n\n# 4、offer方法\n\n对一个队列来说，插入满足fifo特性，插入元素总是在队列最末尾的地方进行插入，而取（移除）元素总是从队列的队头。所有要想能够彻底弄懂concurrentlinkedqueue自然而然是从offer方法和poll方法开始。另外，在看多线程的代码时，可采用这样的思维方式：\n\n> 单个线程offer\n> \n> 多个线程offer\n> \n> 部分线程offer，部分线程poll\n> \n>  * 当offer的速度快于poll：队列长度会越来越长，由于offer节点总是在对队列队尾，而poll节点总是在队列对头，也就是说offer线程和poll线程两者并无“交集”，也就是说两类线程间并不会相互影响，这种情况站在相对速率的角度来看，也就是一个"单线程offer"\n>  * 当offer的速度慢于poll：poll的相对速率快于offer，也就是队头删的速度要快于队尾添加节点的速度，导致的结果就是队列长度会越来越短，而offer线程和poll线程就会出现“交集”，即那一时刻就可以称之为offer线程和poll线程同时操作的节点为 临界点 ，且在该节点offer线程和poll线程必定相互影响。根据在临界点时offer和poll发生的相对顺序又可从两个角度去思考：1. 执行顺序为offer--\x3epoll--\x3eoffer，即表现为当offer线程在node1后插入node2时，此时poll线程已经将node1删除，这种情况很显然需要在offer方法中考虑； 2.执行顺序可能为：poll--\x3eoffer--\x3epoll，即表现为当poll线程准备删除的节点为null时（队列为空队列），此时offer线程插入一个节点使得队列变为非空队列。\n\n先给出offer的源码：\n\npublic boolean offer(e e) {\n    checknotnull(e);\n    final node<e> newnode = new node<e>(e);\n\n    for (node<e> t = tail, p = t;;) {\n        node<e> q = p.next;\n        if (q == null) {\n            // p is last node\n            if (p.casnext(null, newnode)) {\n                // successful cas is the linearization point\n                // for e to become an element of this queue,\n                // and for newnode to become "live".\n                if (p != t) // hop two nodes at a time\n                    castail(t, newnode);  // failure is ok.\n                return true;\n            }\n            // lost cas race to another thread; re-read next\n        }\n        else if (p == q)\n            // we have fallen off list.  if tail is unchanged, it\n            // will also be off-list, in which case we need to\n            // jump to head, from which all live nodes are always\n            // reachable.  else the new tail is a better bet.\n            p = (t != (t = tail)) ? t : head;\n        else\n            // check for tail updates after two hops.\n            p = (p != t && t != (t = tail)) ? t : q;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n下面是idea版本的代码，我们就以以下面的为例：\n\npublic boolean offer(e var1) {\n    //1、对是否为null进行判断，为null的话就直接抛出空指针异常\n    checknotnull(var1);\n    //2、把数据e包装成node类\n    concurrentlinkedqueue.node var2 = new concurrentlinkedqueue.node(var1);\n    //3、将当前尾结点引用为两个变量（这里将var4认为是真正的尾结点）\n    concurrentlinkedqueue.node var3 = this.tail;\n    concurrentlinkedqueue.node var4 = var3;\n\n    do {\n        //4、死循环，符合cas的套路\n        while(true) {\n            //5、将var4的next节点引用为var5\n            concurrentlinkedqueue.node var5 = var4.next;\n            if (var5 == null) {\n                break;\n            }\n\n            if (var4 == var5) {\n                var4 = var3 != (var3 = this.tail) ? var3 : this.head;\n            } else {\n                //6、定位真正的尾结点\n                var4 = var4 != var3 && var3 != (var3 = this.tail) ? var3 : var5;\n            }\n        }\n    } while(!var4.casnext((concurrentlinkedqueue.node)null, var2));\n\n    //7、设置新的tail\n    if (var4 != var3) {\n        this.castail(var3, var2);\n    }\n\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n再执行这么一段代码，创建一个concurrentlinkedqueue实例，先offer 1，然后再offer 2，然后从源码的角度来逐步分析。\n\nconcurrentlinkedqueue<integer> queue = new concurrentlinkedqueue<>();\nqueue.offer(1);\nqueue.offer(2);\n\n\n1\n2\n3\n\n\n\n# 单线程角度执行分析\n\n先从单线程执行的角度看起，分析offer 1的过程。注释1代码会对是否为null进行判断，为null的话就直接抛出空指针异常，注释2代码将var1包装成一个node类，这里实例变量var3被初始化为tail，var4被初始化为var3即tail。为了方便下面的理解，var4被认为队列真正的尾节点，tail不一定指向对象真正的尾节点，因为在concurrentlinkedqueue中tail是被延迟更新的，具体原因我们慢慢来看。下面进入do循环，注释4死循环，符合cas的套路：先将var4的next节点引用为var5并看是否为null，这里明显为null，至此跳出注释4的死循环。紧接着while判断!var4.casnext((concurrentlinkedqueue.node)null, var2)，将var4（当前真正的尾结点）的next节点变为var2，返回true取反为false，退出do while循环。执行最后的if，判断var4 != var3，明显是相等的，因为刚才上面根本就没动过这两个变量。至此offer(1);完成。此时concurrentlinkedqueue的状态如下图所示：\n\n\n\n如图，此时队列的尾节点应该为node1，而tail指向的节点依然还是node0，因此可以说明tail是延迟更新的。那么我们继续来看offer 2的时候的情况，很显然此时注释5代码var5指向的节点不为null了，而是指向node1，注释5代码if判断为false，紧接着if判断var4 == var5，为啥要这么判断呢，其实他们俩相等只有一种可能就是var4节点和var4的next节点都等于空，表示这个队列刚初始化，正准备添加节点，所以将head节点赋予var4（真正的尾结点）这里肯定是不相等的，于是走else代码，明显var3是等于var4的，至此var4（真正的尾结点）变为var5（也就是我们新插入的item为2的node2节点），到这就可以彻底理解"tail是被延迟更新的"这句话，而其实注释6代码的作用就是定位真正的尾结点：\n\nvar4 = var4 != var3 && var3 != (var3 = this.tail) ? var3 : var5;\n\n\n1\n\n\n然后while里通过casnext方法设置var4节点的next为当前新增的node2，跳出do while循环。这个时候var4 != var3（上面重新定位到了tail），注释7代码if判断为true，会通过castail(t, newnode)将当前节点node2设置为队列的队尾节点，此时的队列状态示意图如下图所示：\n\n\n\ntail指向的节点由node0改变为node2，如果这里的castail失败，是不需要重试的，原因是：offer代码中主要是通过var4的next节点var5concurrentlinkedqueue.node var5 = var4.next;决定后面的逻辑走向的，当castail失败时状态示意图如下：\n\n\n\n如图，如果这里castail设置tail失败即tail还是指向node0节点的话，无非就是多循环几次通过13行代码定位到队尾节点。\n\n通过对单线程执行角度进行分析，我们可以了解到offer的执行逻辑为：\n\n 1. 如果tail指向的节点的下一个节点（next域）为null的话，说明tail指向的节点即为队列真正的队尾节点，因此可以通过casnext插入当前待插入的节点，但此时tail并未变化，如图2;\n 2. 如果tail指向的节点的下一个节点（next域）不为null的话，说明tail指向的节点不是队列的真正队尾节点。通过var5 concurrentlinkedqueue.node var5 = var4.next;指针往前递进去找到队尾节点，然后通过casnext插入当前待插入的节点，并通过castail方式更改tail，如图3。\n\n不得不赞叹这个do while循环的巧妙，将原本臃肿的代码写的如此优美！\n\n我们回过头再来看var4 = var4 != var3 && var3 != (var3 = this.tail) ? var3 : var5;这行代码在单线程中，这段代码永远不会将var4赋值为var3，那么这么写就不会有任何作用，那我们试着在多线程的情况下进行分析。\n\n\n# 多线程角度执行分析\n\n> 多个线程offer\n\n很显然这么写另有深意，其实在多线程环境下这行代码很有意思的。 var3 != (var3 = this.tail)这个操作并非一个原子操作，有这样一种情况：\n\n\n\n如图，假设线程a此时读取了变量t，线程b刚好在这个时候offer一个node后，此时会修改tail指针，那么这个时候线程a再次执行var4=this.tail时var4会指向另外一个节点，很显然线程a前后两次读取的变量var4指向的节点不相同，即var4 != (var4 = this.tail)为true，并且由于var4指向节点的变化var4 != var3也为true，此时该三目表达式会将var3赋给var4（其实也就是发现了多线程改动，导致这次的tail先不动），然后下面的if也不会成立，其实跟上面castail设置tail失败的情况一样，等到下次再设置tail。\n\n> offer->poll->offer\n\n那么还剩下第11行的代码我们没有分析，大致可以猜想到应该就是回答一部分线程offer，一部分poll的这种情况。当if (var4 == var5)为true时，说明p指向的节点的next也指向它自己，这种节点称之为哨兵节点，这种节点在队列中存在的价值不大，一般表示为要删除的节点或者是空节点。为了能够很好的理解这种情况，我们先看看poll方法的执行过程后，再回过头来看，总之这是一个很有意思的事情。\n\n\n# 5、poll方法\n\npoll方法源码为：\n\npublic e poll() {\n    restartfromhead:\n    for (;;) {\n        for (node<e> h = head, p = h, q;;) {\n            e item = p.item;\n\n            if (item != null && p.casitem(item, null)) {\n                // successful cas is the linearization point\n                // for item to be removed from this queue.\n                if (p != h) // hop two nodes at a time\n                    updatehead(h, ((q = p.next) != null) ? q : p);\n                return item;\n            }\n            else if ((q = p.next) == null) {\n                updatehead(h, p);\n                return null;\n            }\n            else if (p == q)\n                continue restartfromhead;\n            else\n                p = q;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n下面是idea版本的代码，我们就以以下面的为例：\n\npublic e poll() {\n    //1、外层循环\n    while(true) {\n        concurrentlinkedqueue.node var1 = this.head;\n        concurrentlinkedqueue.node var2 = var1;\n\n        //2、内层循环\n        while(true) {\n            object var4 = var2.item;\n            concurrentlinkedqueue.node var3;\n            //3\n            if (var4 != null && var2.casitem(var4, (object)null)) {\n                //6\n                if (var2 != var1) {\n                    this.updatehead(var1, (var3 = var2.next) != null ? var3 : var2);\n                }\n\n                return var4;\n            }\n\n            //4、看队列中是否有下一个节点\n            if ((var3 = var2.next) == null) {\n                this.updatehead(var1, var2);\n                return null;\n            }\n\n            //5、定位新的head节点\n            if (var2 == var3) {\n                break;\n            }\n\n            var2 = var3;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 单线程角度执行分析\n\n我们还是先站在单线程的角度去理清该方法的基本逻辑。假设concurrentlinkedqueue初始状态如下图所示：\n\n\n\n参照上面offer方法，上来直接进行一个死循环，分别将当前的头节点（head）引用为var1和var2，而这里的var2也是代表队列真正的head节点。里面又是一个死循环，将var2节点的数据（item）引用为var4，然后再来一个var3（node）节点，但未初始化。下面if判断var4是否为null，看数据是否为空，并且将var2的数据域（item）置空var2.casitem(var4, (object)null)。这里如果cas item失败或者var4为空则此次循环结束等待下一次循环进行重试。当然这里if判断为true，紧接着下面的if判断var1和var2是否相等，这里肯定是相等的（其实经过上面对offer方法的分析，我们大概知道这个if判断是为了防止多线程的干扰），所以为false，返回var4object var4 = var2.item;，方法结束。此时的队列状态如下图：\n\n\n\n下面继续从队列中poll，很显然当前var1和var2指向的node1的数据域为null，那么第一件事就是要定位准备删除的队头节点(找到数据域不为null的节点)。\n\n> 定位删除的队头节点\n\n直接来到注释3代码，由于上面poll node1时已将其item域置空，所以注释3代码的if为false。来到注释4代码的if判断，var2.next是否为null，不为null，if判断为false。来到注释5代码if判断var3（上面一个if判断将var2.next赋予var3）和var2是否相等，如果相等退出注释2循环，重新开始注释1外层循环，这里是不相等的，就将var3赋给var2，也就是找到真正的head节点，然后进行下一次注释2的内侧循环。再来到注释3代码，var4（node2节点的item域）不为空，并用var2.casitem(var4, (object)null)将var2（node2节点）的item域置空，来到注释6的if判断var2 != var1，由于上一次内层循环已经改变了var2 var2 = var3;，所以if判断为true，执行this.updatehead(var1, (var3 = var2.next) != null ? var3 : var2);，而(var3 = var2.next) != null ? var3 : var2)就是看node2节点后面有没有节点了有的话就是node2节点后面一个节点，没有的话就是node2节点，这里的casitem方法源码如下：\n\nfinal void updatehead(concurrentlinkedqueue.node<e> var1, concurrentlinkedqueue.node<e> var2) {\n    if (var1 != var2 && this.cashead(var1, var2)) {\n        var1.lazysetnext(var1);\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n该方法主要是通过cashead将队列的head指向node3，并且通过 var1.lazysetnext将node1的next域指向它自己（其实就是废弃node1等待gc回收）。最后返回var4，也就是node2节点的数据（item）。此时队列的状态如下图所示：\n\n\n\nnode1的next域指向它自己，head指向了node3。以上的分析是从单线程执行的角度去看，也可以让我们了解poll的整体思路，现在来做一个总结：\n\n 1. 如果当前head，var1和var2指向的节点的item不为null的话，说明该节点即为真正的队头节点（待删除节点），只需要通过casitem方法将item域设置为null,然后将原来的item直接返回即可。\n 2. 如果当前head，var1和var2指向的节点的item为null的话，则说明该节点不是真正的待删除节点，那么应该做的就是寻找item不为null的节点。通过让var3指向var2的下一个节点（var3 = var2.next）进行试探，若找到则通过updatehead方法更新head指向的节点以及构造哨兵节点（通过updatehead方法的var1.lazysetnext(h)）。\n\n\n# 多线程角度执行分析\n\n> 多个线程poll\n\n现在回过头来看poll方法的源码，有这样一部分：\n\nif (var2 == var3) {\n    break;\n}\n\n\n1\n2\n3\n\n\n这一部分就是处理多个线程poll的情况，var3 = var2.next也就是说var3永远指向的是var2的下一个节点，那么什么情况下会使得var2，var3指向同一个节点呢？根据上面我们的分析，只有var2指向的节点在poll的时候转变成了哨兵节点（通过updatehead方法中的var1.lazysetnext）。当线程a在判断var2 == var3时，线程b已经将执行完poll方法将var2指向的节点转换为哨兵节点并且head指向的节点已经发生了改变，所以就需要从外层循环处重新开始，保证用到的是最新的head。\n\n> poll->offer->poll\n\n试想，还有这样一种情况，如果当前队列为空队列，线程a进行poll操作，同时线程b执行offer，然后线程a在执行poll，那么此时线程a返回的是null还是线程b刚插入的最新的那个节点呢？我们来写一代demo：\n\npublic static void main(string[] args) {\n    thread thread1 = new thread(() -> {\n        integer value = queue.poll();\n        system.out.println(thread.currentthread().getname() + " poll 的值为：" + value);\n        system.out.println("queue当前是否为空队列：" + queue.isempty());\n    });\n    thread1.start();\n    thread thread2 = new thread(() -> {\n        queue.offer(1);\n    });\n    thread2.start();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n输出结果为：\n\n> thread-0 poll 的值为：null\n> \n> queue当前是否为空队列：false\n\n通过debug控制线程thread1和线程thread2的执行顺序，thread1先执行到代码if ((var3 = var2.next) == null)，由于此时队列为空队列if判断为true，进入if块，此时先让thread1暂停，然后thread2进行offer插入值为1的节点后，thread2执行结束。再让thread1执行，这时thread1并没有进行重试，而是代码继续往下走，返回null，尽管此时队列由于thread2已经插入了值为1的新的节点。所以输出结果为thread0 poll的为null，然队列不为空队列。因此，在判断队列是否为空队列的时候是不能通过线程在poll的时候返回为null进行判断的，可以通过isempty方法进行判断。\n\n\n# 6、offer方法中部分线程offer部分线程poll\n\n在分析offer方法的时候我们还留下了一个问题，即对offer方法中if (p == q)代码的理解。\n\n> offer->poll->offer\n\n在offer方法的第11行代码if (p == q)，能够让if判断为true的情况为p指向的节点为哨兵节点，而什么时候会构造哨兵节点呢？在对poll方法的讨论中，我们已经找到了答案，即**当head指向的节点的item域为null时会寻找真正的队头节点，等到待插入的节点插入之后，会更新head，并且将原来head指向的节点设置为哨兵节点。**假设队列初始状态如下图所示：\n\n\n\n因此在线程a执行offer时，线程b执行poll就会存在如下一种情况：\n\n\n\n如图，线程a的tail节点存在next节点node1，因此会通过引用q往前寻找队列真正的队尾节点，当执行到判断if (p == q)时，此时线程b执行poll操作，在对线程b来说，head和p指向node0，由于node0的item域为null，同样会往前递进找到队列真正的队头节点node1,在线程b执行完poll之后，node0就会转换为哨兵节点，也就意味着队列的head发生了改变，此时队列状态为下图：\n\n\n\n此时线程a在执行判断if (p == q)时就为true，会继续执行p = (t != (t = tail)) ? t : head;，由于tail指针没有发生改变所以p被赋值为head，重新从head开始完成插入操作。\n\n\n# 5. hops的设计\n\n通过上面对offer和poll方法的分析，我们发现tail和head是延迟更新的，两者更新触发时机为：\n\ntail更新触发时机：当tail指向的节点的下一个节点不为null的时候，会执行定位队列真正的队尾节点的操作，找到队尾节点后完成插入之后才会通过castail进行tail更新；当tail指向的节点的下一个节点为null的时候，只插入节点不更新tail。\n\nhead更新触发时机：当head指向的节点的item域为null的时候，会执行定位队列真正的队头节点的操作，找到队头节点后完成删除之后才会通过updatehead进行head更新；当head指向的节点的item域不为null的时候，只删除节点不更新head。\n\n并且在更新操作时，源码中会有注释为：hop two nodes at a time。所以这种延迟更新的策略就被叫做hops的大概原因是这个（猜的 ），从上面更新时的状态图可以看出，head和tail的更新是“跳着的”即中间总是间隔了一个。那么这样设计的意图是什么呢？\n\n如果让tail永远作为队列的队尾节点，实现的代码量会更少，而且逻辑更易懂。但是，这样做有一个缺点，**如果大量的入队操作，每次都要执行cas进行tail的更新，汇总起来对性能也会是大大的损耗。如果能减少cas更新的操作，无疑可以大大提升入队的操作效率，所以doug lea大师每间隔1次（tail和队尾节点的距离为1）才利用cas更新tail。**对head的更新也是同样的道理，虽然，这样设计会多出在循环中定位队尾节点，但总体来说读的操作效率要远远高于写的性能，因此，多出来的在循环中定位尾节点的操作的性能损耗相对而言是很小的。\n\n> 参考资料\n\n《java并发编程的艺术》\n\n《java高并发程序设计》\n\n并发容器之concurrentlinkedqueue',charsets:{cjk:!0},createdTime:1655628697e3},{title:"详解Condition的线程通信机制",frontmatter:{title:"详解Condition的线程通信机制",description:"详解Condition的线程通信机制",date:"2022-04-03T16:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/12%E3%80%81%E8%AF%A6%E8%A7%A3Condition%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6.html",relativePath:"Java/Java并发编程的艺术/12、详解Condition的线程通信机制.md",key:"v-e1ec06b4",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/12%E3%80%81%E8%AF%A6%E8%A7%A3Condition%E7%9A%84%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6.html",headers:[{level:2,title:"等待队列",slug:"等待队列",normalizedTitle:"等待队列",charIndex:29},{level:2,title:"await方法",slug:"await方法",normalizedTitle:"await方法",charIndex:37},{level:2,title:"addConditionWaiter方法",slug:"addconditionwaiter方法",normalizedTitle:"addconditionwaiter方法",charIndex:48},{level:2,title:"fullyRelease方法",slug:"fullyrelease方法",normalizedTitle:"fullyrelease方法",charIndex:72},{level:2,title:"await总结",slug:"await总结",normalizedTitle:"await总结",charIndex:90},{level:2,title:"signal/signalAll实现原理",slug:"signal-signalall实现原理",normalizedTitle:"signal/signalall实现原理",charIndex:101},{level:2,title:"doSignal方法",slug:"dosignal方法",normalizedTitle:"dosignal方法",charIndex:125},{level:2,title:"transferForSignal方法",slug:"transferforsignal方法",normalizedTitle:"transferforsignal方法",charIndex:139},{level:2,title:"signal总结",slug:"signal总结",normalizedTitle:"signal总结",charIndex:162}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>详解Condition的线程通信机制</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"等待队列 await方法 addConditionWaiter方法 fullyRelease方法 await总结 signal/signalAll实现原理 doSignal方法 transferForSignal方法 signal总结",content:'说明\n\n详解Condition的线程通信机制\n\n\n\n * 等待队列\n * await方法\n * addConditionWaiter方法\n * fullyRelease方法\n * await总结\n * signal/signalAll实现原理\n * doSignal方法\n * transferForSignal方法\n * signal总结\n\n\n\n\n# 详解Condition的线程通信机制\n\n\n# 1、Condition简介\n\n任何一个java对象都天然继承于Object类，在线程间实现通信的往往会应用到Object的几个方法，比如wait(),wait(long timeout),wait(long timeout, int nanos)与notify(),notifyAll()几个方法实现等待/通知机制，同样的， 在java Lock体系下依然会有同样的方法实现等待/通知机制。\n\n从整体上来看Object的wait和notify/notify是与对象监视器配合完成线程间的等待/通知机制，而Condition与Lock配合完成等待通知机制，前者是java底层级别的，后者是语言级别的，具有更高的可控制性和扩展性。两者除了在使用方式上不同外，在功能特性上还是有很多的不同：\n\n\n\n参照Object的wait和notify/notifyAll方法，Condition也提供了同样的方法：\n\n> 针对Object的wait方法\n\n 1. void await() throws InterruptedException：当前线程进入等待状态，如果其他线程调用condition的signal或者signalAll方法并且当前线程被选中唤醒；如果在等待状态中被中断会抛出被中断异常，如果当前等待线程从await()方法返回，那么表明该线程已经获取了Condition对象所对应的锁。\n 2. long awaitNanos(long nanosTimeout)：当前线程进入等待状态直到被通知，中断或者超时；\n 3. boolean await(long time, TimeUnit unit)throws InterruptedException：同第二种，支持自定义时间单位\n 4. boolean awaitUntil(Date deadline) throws InterruptedException：当前线程进入等待状态直到被通知，中断或者到了某个时间\n\n> 针对Object的notify/notifyAll方法\n\n 1. void signal()：唤醒一个等待在condition上的线程，将该线程从等待队列中转移到同步队列中，如果在同步队列中能够竞争到Lock则可以从等待方法中返回。\n 2. void signalAll()：与1的区别在于能够唤醒所有等待在condition上的线程\n\n既然功能都一样，问什么还需要使用Condition呢？简单来说，Condition需要和Lock一起使用，在不使用Lock时，使用关键字synchronized时的代码如下：\n\nsynchronized(obj){\n    obj.wait();\n}\nsynchronized(obj){\n    obj.notify();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n使用Lock时的代码如下：\n\nlock.lock();\ncondition.await();\nlock.unlock();\n\nlock.lock();\ncondition.signal();\nlock.unlock();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n从代码上可以看出，使用synchronized关键字时，所有没有获取锁的线程都会等待，这时相当于只有1个等待队列；而在实际应用中可能有时需要多个等待队列，比如ReadLock和WriteLock。Lock中的等待队列和Condition中的等待队列是分开的，例如在独占模式下，Lock的独占保证了在同一时刻只会有一个线程访问临界区，也就是lock()方法返回后，Condition中的等待队列保存着被阻塞的线程，也就是调用await()方法后阻塞的线程。所以使用lock比使用synchronized关键字更加灵活。\n\n\n# 2、Condition的使用\n\n在Condition接口的javadoc中，有一个很好的例子（有界缓冲区）来使用Condition，代码如下：\n\nclass BoundedBuffer {\n    final Lock lock = new ReentrantLock();\n    final Condition notFull  = lock.newCondition();\n    final Condition notEmpty = lock.newCondition();\n\n    final Object[] items = new Object[100];\n    int putptr, takeptr, count;\n\n    public void put(Object x) throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == items.length)\n                notFull.await();\n            items[putptr] = x;\n            if (++putptr == items.length) putptr = 0;\n            ++count;\n            notEmpty.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public Object take() throws InterruptedException {\n        lock.lock();\n        try {\n            while (count == 0)\n                notEmpty.await();\n            Object x = items[takeptr];\n            if (++takeptr == items.length) takeptr = 0;\n            --count;\n            notFull.signal();\n            return x;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n代码很简单，定义了一个数组items，put用于向items中添加数据，take用于从items中取出数据，count代表当前items中存放了多少个对象，putptr表示下一个需要添加的索引，takeptr表示下一个需要取出的索引，这样就实现了数组的循环添加和取出数据的功能。put和take的具体功能如下：\n\n * put\n   1. 当count与items的长度相同时，表示数组已满，则调用notFull.await()来等待同时释放了当前线程的锁；\n   2. 当线程被唤醒时，将x添加到putptr索引的位置；\n   3. 如果当前putptr的位置是最后一个，则下一个索引的位置从0开始；\n   4. 调用notEmpty.signal();通知其他线程可以从数组中取出数据了。\n * take\n   1. 当count为0时，表示数组是空的，则调用notEmpty.await()来等待同时释放了当前线程的锁；\n   2. 当线程被唤醒时，将x添加到takeptr索引的位置；\n   3. 如果当前takeptr的位置是最后一个，则下一个索引的位置从0开始；\n   4. 调用notFull.signal();通知其他线程可以向数组中添加数据了。\n\n\n# 3、Condition实现原理分析\n\n\n# 等待队列\n\n要想能够深入的掌握condition还是应该知道它的实现原理，现在我们一起来看看condiiton的源码。创建一个condition对象是通过lock.newCondition()，而这个方法实际上是会new出一个ConditionObject对象，该类是AQS的一个内部类。前面我们说过，condition是要和lock配合使用的也就是condition和Lock是绑定在一起的，而lock的实现原理又依赖于AQS，自然而然ConditionObject作为AQS的一个内部类无可厚非。\n\n我们知道在锁机制的实现上，AQS内部维护了一个同步队列，如果是独占式锁的话，所有获取锁失败的线程的尾插入到同步队列，同样的，condition内部也是使用同样的方式，内部维护了一个 等待队列，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步器（AQS）中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node。\n\n通过前面对AQS同步队列的学习，我们知道同步队列是一个双向队列，而事实上Condition的等待队列是一个单向队列，接下来我们用一个demo，通过debug进去看是不是符合我们的猜想：\n\npublic static void main(String[] args) {\n    for (int i = 0; i < 10; i++) {\n        Thread thread = new Thread(() -> {\n            lock.lock();\n            try {\n                condition.await();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }finally {\n                lock.unlock();\n            }\n        });\n        thread.start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这段代码没有任何实际意义，甚至很臭，只是想说明下我们刚才所想的。新建了10个线程，没有线程先获取锁，然后调用condition.await方法释放锁将当前线程加入到等待队列中，通过debug控制当走到第10个线程的时候查看firstWaiter即等待队列中的头结点，debug模式下情景图如下：\n\n\n\n从这个图我们可以很清楚的看到这样几点：\n\n 1. 调用condition.await方法后线程依次尾插入到等待队列中，如图队列中的线程引用依次为Thread-0,Thread-1,Thread-2....Thread-8；\n 2. 等待队列是一个单向队列（因为Node节点中的prev和next都为null）。\n\n而事实上，等待队列的基本结构图也正是如此：\n\n\n\n如图所示，Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。\n\n同时还有一点需要注意的是：我们可以多次调用lock.newCondition()方法创建多个condition对象，也就是一个lock可以持有多个等待队列。而在之前利用Object的方式实际上是指在对象Object对象监视器上只能拥有一个同步队列和一个等待队列，而并发包中的Lock拥有一个同步队列和多个等待队列。示意图如下：\n\n\n\n如图所示，Condition的实现是同步器的内部类，因此每个Condition实例都能够访问同步器提供的方法，相当于每个Condition都拥有所属同步器的引用。\n\n\n# await方法\n\n当调用condition.await()方法后会使得当前获取lock的线程进入到等待队列，如果该线程能够从await()方法返回的话一定是该线程获取了与condition相关联的lock。await()方法源码为：\n\npublic final void await() throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    // 1. 将当前线程包装成Node，尾插入到等待队列中\n    Node node = addConditionWaiter();\n    // 2. 释放当前线程所占用的lock，在释放的过程中会唤醒同步队列中的下一个节点\n    int savedState = fullyRelease(node);\n    int interruptMode = 0;\n    while (!isOnSyncQueue(node)) {\n        // 3. 当前线程进入到等待状态\n        LockSupport.park(this);\n        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n            break;\n    }\n    // 4. 自旋等待获取到同步状态（即获取到lock）\n    if (acquireQueued(node, savedState) && interruptMode != THROW_IE)\n        interruptMode = REINTERRUPT;\n    if (node.nextWaiter != null) // clean up if cancelled\n        unlinkCancelledWaiters();\n    // 5. 处理被中断的情况\n    if (interruptMode != 0)\n        reportInterruptAfterWait(interruptMode);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n代码的主要逻辑请看注释，我们都知道当当前线程调用condition.await()方法后，会使得当前线程释放lock然后加入到等待队列中，直至被signal/signalAll后会使得当前线程从等待队列中移至到同步队列中去，直到获得了lock后才会从await方法返回，或者在等待时被中断会做中断处理。\n\n那么关于这个实现过程我们只要弄清这样几个问题：\n\n 1. 是怎样将当前线程添加到等待队列中去的？\n 2. 释放锁的过程？\n 3. 怎样才能从await方法退出？\n\n\n# addConditionWaiter方法\n\n在第1步中调用addConditionWaiter将当前线程添加到等待队列中，该方法源码为：\n\nprivate Node addConditionWaiter() {\n    Node t = lastWaiter;\n    // If lastWaiter is cancelled, clean out.\n    if (t != null && t.waitStatus != Node.CONDITION) {\n        unlinkCancelledWaiters();\n        t = lastWaiter;\n    }\n    //将当前线程包装成Node\n    Node node = new Node(Thread.currentThread(), Node.CONDITION);\n    if (t == null)\n        firstWaiter = node;\n    else\n        //尾插入\n        t.nextWaiter = node;\n    //更新lastWaiter\n    lastWaiter = node;\n    return node;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这段代码就很容易理解了，将当前节点包装成Node，如果等待队列的firstWaiter为null的话（等待队列为空队列），则将firstWaiter指向当前的Node,否则，更新lastWaiter(尾节点)即可。就是通过尾插入的方式将当前线程封装的Node插入到等待队列中即可，同时可以看出等待队列是一个不带头结点的链式队列，之前我们学习AQS时知道同步队列是一个带头结点的链式队列，这是两者的一个区别。\n\n\n# fullyRelease方法\n\n将当前节点插入到等待对列之后，会使当前线程释放lock，由fullyRelease方法实现，fullyRelease源码为：\n\nfinal int fullyRelease(Node node) {\n    boolean failed = true;\n    try {\n        int savedState = getState();\n        if (release(savedState)) {\n            //成功释放同步状态\n            failed = false;\n            return savedState;\n        } else {\n            //不成功释放同步状态抛出异常\n            throw new IllegalMonitorStateException();\n        }\n    } finally {\n        if (failed)\n            node.waitStatus = Node.CANCELLED;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这段代码也很容易理解了，调用AQS的模板方法release方法释放AQS的同步状态并且唤醒在同步队列中头结点的后继节点引用的线程，如果释放成功则正常返回，若失败的话就抛出异常。\n\n最后一个问题：怎样从await方法退出？现在回过头再来看await方法有这样一段逻辑：\n\nwhile (!isOnSyncQueue(node)) {\n\t// 3. 当前线程进入到等待状态\n    LockSupport.park(this);\n    if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n        break;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n很显然，当线程第一次调用condition.await()方法时，会进入到这个while()循环中，然后通过LockSupport.park(this)方法使得当前线程进入等待状态，那么要想退出这个await方法第一个前提条件自然而然的是要先退出这个while循环，出口就只剩下两个地方：1. 逻辑走到break退出while循环；2. while循环中的逻辑判断为false。再看代码出现第1种情况的条件是当前等待的线程被中断后代码会走到break退出，第二种情况是当前节点被移动到了同步队列中（即另外线程调用的condition的signal或者signalAll方法），while中逻辑判断为false后结束while循环。\n\n\n# await总结\n\n总结下，就是当前线程被中断或者调用condition.signal/condition.signalAll方法当前节点移动到了同步队列后 ，这是当前线程退出await方法的前提条件。当退出while循环后就会调用acquireQueued(node, savedState)，这个方法在介绍AQS的底层实现时说过了，该方法的作用是在自旋过程中线程不断尝试获取同步状态，直至成功（线程获取到lock）。await方法示意图如下图：\n\n\n\n如图，调用condition.await方法的线程必须是已经获得了lock，也就是当前线程是同步队列中的头结点。调用该方法后会使得当前线程所封装的Node尾插入到等待队列中。\n\n> 超时机制的支持\n\ncondition还额外支持了超时机制，使用者可调用方法awaitNanos,awaitUtil。这两个方法的实现原理，基本上与AQS中的tryAcquire方法如出一辙，关于tryAcquire可以仔细阅读这篇文章的第3.4部分。\n\n> 不响应中断的支持\n\n要想不响应中断可以调用condition.awaitUninterruptibly()方法，该方法的源码为：\n\npublic final void awaitUninterruptibly() {\n    Node node = addConditionWaiter();\n    int savedState = fullyRelease(node);\n    boolean interrupted = false;\n    while (!isOnSyncQueue(node)) {\n        LockSupport.park(this);\n        if (Thread.interrupted())\n            interrupted = true;\n    }\n    if (acquireQueued(node, savedState) || interrupted)\n        selfInterrupt();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这段方法与上面的await方法基本一致，只不过减少了对中断的处理，并省略了reportInterruptAfterWait方法抛被中断的异常。\n\n\n# signal/signalAll实现原理\n\n调用condition的signal或者signalAll方法可以将等待队列中等待时间最长的节点移动到同步队列中，使得该节点能够有机会获得lock。按照等待队列是先进先出（FIFO）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用condition的signal方法是将头节点移动到同步队列中。我们来通过看源码的方式来看这样的猜想是不是对的，signal方法源码为：\n\npublic final void signal() {\n    //1. 先检测当前线程是否已经获取lock\n    if (!isHeldExclusively())\n        throw new IllegalMonitorStateException();\n    //2. 获取等待队列中第一个节点，之后的操作都是针对这个节点\n\tNode first = firstWaiter;\n    if (first != null)\n        doSignal(first);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nsignal方法首先会检测当前线程是否已经获取lock，如果没有获取lock会直接抛出异常，如果获取的话再得到等待队列的头指针引用的节点，之后的操作的doSignal方法也是基于该节点。\n\n\n# doSignal方法\n\n下面我们来看看doSignal方法做了些什么事情，doSignal方法源码为：\n\nprivate void doSignal(Node first) {\n    do {\n        if ( (firstWaiter = first.nextWaiter) == null)\n            lastWaiter = null;\n\t\t//1. 将头结点从等待队列中移除\n        first.nextWaiter = null;\n\t\t//2. while中transferForSignal方法对头结点做真正的处理\n    } while (!transferForSignal(first) &&\n             (first = firstWaiter) != null);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n具体逻辑请看注释，真正对头节点做处理的逻辑在transferForSignal方放\n\n\n# transferForSignal方法\n\n该方法源码为：\n\nfinal boolean transferForSignal(Node node) {\n    /*\n     * If cannot change waitStatus, the node has been cancelled.\n     */\n\t//1. 更新状态为0\n    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n        return false;\n\n    /*\n     * Splice onto queue and try to set waitStatus of predecessor to\n     * indicate that thread is (probably) waiting. If cancelled or\n     * attempt to set waitStatus fails, wake up to resync (in which\n     * case the waitStatus can be transiently and harmlessly wrong).\n     */\n\t//2.将该节点移入到同步队列中去\n    Node p = enq(node);\n    int ws = p.waitStatus;\n    if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n        LockSupport.unpark(node.thread);\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n关键逻辑请看注释，这段代码主要做了两件事情：\n\n 1. 将头结点的状态更改为CONDITION；\n\n 2. 调用enq方法，将该节点尾插入到同步队列中。\n\n\n# signal总结\n\n总结就是：\n\n * 通过调用同步器的enq(Node node)方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。\n\n * 被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。\n\n * 成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。\n\nsignal执行示意图如下图：\n\n\n\n> signalAll\n\nsigllAll与sigal方法的区别体现在doSignalAll方法上，前面我们已经知道doSignal方法只会对等待队列的头节点进行操作，而doSignalAll的源码为：\n\nprivate void doSignalAll(Node first) {\n    lastWaiter = firstWaiter = null;\n    do {\n        Node next = first.nextWaiter;\n        first.nextWaiter = null;\n        transferForSignal(first);\n        first = next;\n    } while (first != null);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n该方法只不过时间等待队列中的每一个节点都移入到同步队列中，即“通知”当前调用condition.await()方法的每一个线程。\n\n\n# 4、await与signal/signalAll的结合思考\n\n文章开篇提到等待/通知机制，通过使用condition提供的await和signal/signalAll方法就可以实现这种机制，而这种机制能够解决最经典的问题就是“生产者与消费者问题”，关于“生产者消费者问题”之后会用单独的一篇文章进行讲解，这也是面试的高频考点。await和signal和signalAll方法就像一个开关控制着线程A（等待方）和线程B（通知方）。它们之间的关系可以用下面一个图来表现得更加贴切：\n\n\n\n如图，线程awaitThread先通过lock.lock()方法获取锁成功后调用了condition.await方法进入等待队列，而另一个线程signalThread通过lock.lock()方法获取锁成功后调用了condition.signal或者signalAll方法，使得线程awaitThread能够有机会移入到同步队列中，当其他线程释放lock后使得线程awaitThread能够有机会获取lock，从而使得线程awaitThread能够从await方法中退出执行后续操作。如果awaitThread获取lock失败会直接进入到同步队列。\n\n\n# 5、一个例子\n\n我们用一个很简单的例子说说condition的用法：\n\npublic class AwaitSignal {\n    private static ReentrantLock lock = new ReentrantLock();\n    private static Condition condition = lock.newCondition();\n    private static volatile boolean flag = false;\n\n    public static void main(String[] args) {\n        Thread waiter = new Thread(new waiter());\n        waiter.start();\n        Thread signaler = new Thread(new signaler());\n        signaler.start();\n    }\n\n    static class waiter implements Runnable {\n\n        @Override\n        public void run() {\n            lock.lock();\n            try {\n                while (!flag) {\n                    System.out.println(Thread.currentThread().getName() + "当前条件不满足等待");\n                    try {\n                        condition.await();\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n                System.out.println(Thread.currentThread().getName() + "接收到通知条件满足");\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n\n    static class signaler implements Runnable {\n\n        @Override\n        public void run() {\n            lock.lock();\n            try {\n                flag = true;\n                condition.signalAll();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n输出结果为：\n\nThread-0当前条件不满足等待\nThread-0接收到通知，条件满足\n\n\n1\n2\n\n\n开启了两个线程waiter和signaler，waiter线程开始执行的时候由于条件不满足，执行condition.await方法使该线程进入等待状态同时释放锁，signaler线程获取到锁之后更改条件，并通知所有的等待线程后释放锁。这时，waiter线程获取到锁，并由于signaler线程更改了条件此时相对于waiter来说条件满足，继续执行。\n\n> 参考文献\n\n《java并发编程的艺术》\n\n深入理解AbstractQueuedSynchronizer（三）',normalizedContent:'说明\n\n详解condition的线程通信机制\n\n\n\n * 等待队列\n * await方法\n * addconditionwaiter方法\n * fullyrelease方法\n * await总结\n * signal/signalall实现原理\n * dosignal方法\n * transferforsignal方法\n * signal总结\n\n\n\n\n# 详解condition的线程通信机制\n\n\n# 1、condition简介\n\n任何一个java对象都天然继承于object类，在线程间实现通信的往往会应用到object的几个方法，比如wait(),wait(long timeout),wait(long timeout, int nanos)与notify(),notifyall()几个方法实现等待/通知机制，同样的， 在java lock体系下依然会有同样的方法实现等待/通知机制。\n\n从整体上来看object的wait和notify/notify是与对象监视器配合完成线程间的等待/通知机制，而condition与lock配合完成等待通知机制，前者是java底层级别的，后者是语言级别的，具有更高的可控制性和扩展性。两者除了在使用方式上不同外，在功能特性上还是有很多的不同：\n\n\n\n参照object的wait和notify/notifyall方法，condition也提供了同样的方法：\n\n> 针对object的wait方法\n\n 1. void await() throws interruptedexception：当前线程进入等待状态，如果其他线程调用condition的signal或者signalall方法并且当前线程被选中唤醒；如果在等待状态中被中断会抛出被中断异常，如果当前等待线程从await()方法返回，那么表明该线程已经获取了condition对象所对应的锁。\n 2. long awaitnanos(long nanostimeout)：当前线程进入等待状态直到被通知，中断或者超时；\n 3. boolean await(long time, timeunit unit)throws interruptedexception：同第二种，支持自定义时间单位\n 4. boolean awaituntil(date deadline) throws interruptedexception：当前线程进入等待状态直到被通知，中断或者到了某个时间\n\n> 针对object的notify/notifyall方法\n\n 1. void signal()：唤醒一个等待在condition上的线程，将该线程从等待队列中转移到同步队列中，如果在同步队列中能够竞争到lock则可以从等待方法中返回。\n 2. void signalall()：与1的区别在于能够唤醒所有等待在condition上的线程\n\n既然功能都一样，问什么还需要使用condition呢？简单来说，condition需要和lock一起使用，在不使用lock时，使用关键字synchronized时的代码如下：\n\nsynchronized(obj){\n    obj.wait();\n}\nsynchronized(obj){\n    obj.notify();\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n使用lock时的代码如下：\n\nlock.lock();\ncondition.await();\nlock.unlock();\n\nlock.lock();\ncondition.signal();\nlock.unlock();\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n从代码上可以看出，使用synchronized关键字时，所有没有获取锁的线程都会等待，这时相当于只有1个等待队列；而在实际应用中可能有时需要多个等待队列，比如readlock和writelock。lock中的等待队列和condition中的等待队列是分开的，例如在独占模式下，lock的独占保证了在同一时刻只会有一个线程访问临界区，也就是lock()方法返回后，condition中的等待队列保存着被阻塞的线程，也就是调用await()方法后阻塞的线程。所以使用lock比使用synchronized关键字更加灵活。\n\n\n# 2、condition的使用\n\n在condition接口的javadoc中，有一个很好的例子（有界缓冲区）来使用condition，代码如下：\n\nclass boundedbuffer {\n    final lock lock = new reentrantlock();\n    final condition notfull  = lock.newcondition();\n    final condition notempty = lock.newcondition();\n\n    final object[] items = new object[100];\n    int putptr, takeptr, count;\n\n    public void put(object x) throws interruptedexception {\n        lock.lock();\n        try {\n            while (count == items.length)\n                notfull.await();\n            items[putptr] = x;\n            if (++putptr == items.length) putptr = 0;\n            ++count;\n            notempty.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public object take() throws interruptedexception {\n        lock.lock();\n        try {\n            while (count == 0)\n                notempty.await();\n            object x = items[takeptr];\n            if (++takeptr == items.length) takeptr = 0;\n            --count;\n            notfull.signal();\n            return x;\n        } finally {\n            lock.unlock();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n代码很简单，定义了一个数组items，put用于向items中添加数据，take用于从items中取出数据，count代表当前items中存放了多少个对象，putptr表示下一个需要添加的索引，takeptr表示下一个需要取出的索引，这样就实现了数组的循环添加和取出数据的功能。put和take的具体功能如下：\n\n * put\n   1. 当count与items的长度相同时，表示数组已满，则调用notfull.await()来等待同时释放了当前线程的锁；\n   2. 当线程被唤醒时，将x添加到putptr索引的位置；\n   3. 如果当前putptr的位置是最后一个，则下一个索引的位置从0开始；\n   4. 调用notempty.signal();通知其他线程可以从数组中取出数据了。\n * take\n   1. 当count为0时，表示数组是空的，则调用notempty.await()来等待同时释放了当前线程的锁；\n   2. 当线程被唤醒时，将x添加到takeptr索引的位置；\n   3. 如果当前takeptr的位置是最后一个，则下一个索引的位置从0开始；\n   4. 调用notfull.signal();通知其他线程可以向数组中添加数据了。\n\n\n# 3、condition实现原理分析\n\n\n# 等待队列\n\n要想能够深入的掌握condition还是应该知道它的实现原理，现在我们一起来看看condiiton的源码。创建一个condition对象是通过lock.newcondition()，而这个方法实际上是会new出一个conditionobject对象，该类是aqs的一个内部类。前面我们说过，condition是要和lock配合使用的也就是condition和lock是绑定在一起的，而lock的实现原理又依赖于aqs，自然而然conditionobject作为aqs的一个内部类无可厚非。\n\n我们知道在锁机制的实现上，aqs内部维护了一个同步队列，如果是独占式锁的话，所有获取锁失败的线程的尾插入到同步队列，同样的，condition内部也是使用同样的方式，内部维护了一个 等待队列，如果一个线程调用了condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步器（aqs）中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类abstractqueuedsynchronizer.node。\n\n通过前面对aqs同步队列的学习，我们知道同步队列是一个双向队列，而事实上condition的等待队列是一个单向队列，接下来我们用一个demo，通过debug进去看是不是符合我们的猜想：\n\npublic static void main(string[] args) {\n    for (int i = 0; i < 10; i++) {\n        thread thread = new thread(() -> {\n            lock.lock();\n            try {\n                condition.await();\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }finally {\n                lock.unlock();\n            }\n        });\n        thread.start();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n这段代码没有任何实际意义，甚至很臭，只是想说明下我们刚才所想的。新建了10个线程，没有线程先获取锁，然后调用condition.await方法释放锁将当前线程加入到等待队列中，通过debug控制当走到第10个线程的时候查看firstwaiter即等待队列中的头结点，debug模式下情景图如下：\n\n\n\n从这个图我们可以很清楚的看到这样几点：\n\n 1. 调用condition.await方法后线程依次尾插入到等待队列中，如图队列中的线程引用依次为thread-0,thread-1,thread-2....thread-8；\n 2. 等待队列是一个单向队列（因为node节点中的prev和next都为null）。\n\n而事实上，等待队列的基本结构图也正是如此：\n\n\n\n如图所示，condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextwaiter指向它，并且更新尾节点即可。上述节点引用更新的过程并没有使用cas保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。\n\n同时还有一点需要注意的是：我们可以多次调用lock.newcondition()方法创建多个condition对象，也就是一个lock可以持有多个等待队列。而在之前利用object的方式实际上是指在对象object对象监视器上只能拥有一个同步队列和一个等待队列，而并发包中的lock拥有一个同步队列和多个等待队列。示意图如下：\n\n\n\n如图所示，condition的实现是同步器的内部类，因此每个condition实例都能够访问同步器提供的方法，相当于每个condition都拥有所属同步器的引用。\n\n\n# await方法\n\n当调用condition.await()方法后会使得当前获取lock的线程进入到等待队列，如果该线程能够从await()方法返回的话一定是该线程获取了与condition相关联的lock。await()方法源码为：\n\npublic final void await() throws interruptedexception {\n    if (thread.interrupted())\n        throw new interruptedexception();\n    // 1. 将当前线程包装成node，尾插入到等待队列中\n    node node = addconditionwaiter();\n    // 2. 释放当前线程所占用的lock，在释放的过程中会唤醒同步队列中的下一个节点\n    int savedstate = fullyrelease(node);\n    int interruptmode = 0;\n    while (!isonsyncqueue(node)) {\n        // 3. 当前线程进入到等待状态\n        locksupport.park(this);\n        if ((interruptmode = checkinterruptwhilewaiting(node)) != 0)\n            break;\n    }\n    // 4. 自旋等待获取到同步状态（即获取到lock）\n    if (acquirequeued(node, savedstate) && interruptmode != throw_ie)\n        interruptmode = reinterrupt;\n    if (node.nextwaiter != null) // clean up if cancelled\n        unlinkcancelledwaiters();\n    // 5. 处理被中断的情况\n    if (interruptmode != 0)\n        reportinterruptafterwait(interruptmode);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n代码的主要逻辑请看注释，我们都知道当当前线程调用condition.await()方法后，会使得当前线程释放lock然后加入到等待队列中，直至被signal/signalall后会使得当前线程从等待队列中移至到同步队列中去，直到获得了lock后才会从await方法返回，或者在等待时被中断会做中断处理。\n\n那么关于这个实现过程我们只要弄清这样几个问题：\n\n 1. 是怎样将当前线程添加到等待队列中去的？\n 2. 释放锁的过程？\n 3. 怎样才能从await方法退出？\n\n\n# addconditionwaiter方法\n\n在第1步中调用addconditionwaiter将当前线程添加到等待队列中，该方法源码为：\n\nprivate node addconditionwaiter() {\n    node t = lastwaiter;\n    // if lastwaiter is cancelled, clean out.\n    if (t != null && t.waitstatus != node.condition) {\n        unlinkcancelledwaiters();\n        t = lastwaiter;\n    }\n    //将当前线程包装成node\n    node node = new node(thread.currentthread(), node.condition);\n    if (t == null)\n        firstwaiter = node;\n    else\n        //尾插入\n        t.nextwaiter = node;\n    //更新lastwaiter\n    lastwaiter = node;\n    return node;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n这段代码就很容易理解了，将当前节点包装成node，如果等待队列的firstwaiter为null的话（等待队列为空队列），则将firstwaiter指向当前的node,否则，更新lastwaiter(尾节点)即可。就是通过尾插入的方式将当前线程封装的node插入到等待队列中即可，同时可以看出等待队列是一个不带头结点的链式队列，之前我们学习aqs时知道同步队列是一个带头结点的链式队列，这是两者的一个区别。\n\n\n# fullyrelease方法\n\n将当前节点插入到等待对列之后，会使当前线程释放lock，由fullyrelease方法实现，fullyrelease源码为：\n\nfinal int fullyrelease(node node) {\n    boolean failed = true;\n    try {\n        int savedstate = getstate();\n        if (release(savedstate)) {\n            //成功释放同步状态\n            failed = false;\n            return savedstate;\n        } else {\n            //不成功释放同步状态抛出异常\n            throw new illegalmonitorstateexception();\n        }\n    } finally {\n        if (failed)\n            node.waitstatus = node.cancelled;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这段代码也很容易理解了，调用aqs的模板方法release方法释放aqs的同步状态并且唤醒在同步队列中头结点的后继节点引用的线程，如果释放成功则正常返回，若失败的话就抛出异常。\n\n最后一个问题：怎样从await方法退出？现在回过头再来看await方法有这样一段逻辑：\n\nwhile (!isonsyncqueue(node)) {\n\t// 3. 当前线程进入到等待状态\n    locksupport.park(this);\n    if ((interruptmode = checkinterruptwhilewaiting(node)) != 0)\n        break;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n很显然，当线程第一次调用condition.await()方法时，会进入到这个while()循环中，然后通过locksupport.park(this)方法使得当前线程进入等待状态，那么要想退出这个await方法第一个前提条件自然而然的是要先退出这个while循环，出口就只剩下两个地方：1. 逻辑走到break退出while循环；2. while循环中的逻辑判断为false。再看代码出现第1种情况的条件是当前等待的线程被中断后代码会走到break退出，第二种情况是当前节点被移动到了同步队列中（即另外线程调用的condition的signal或者signalall方法），while中逻辑判断为false后结束while循环。\n\n\n# await总结\n\n总结下，就是当前线程被中断或者调用condition.signal/condition.signalall方法当前节点移动到了同步队列后 ，这是当前线程退出await方法的前提条件。当退出while循环后就会调用acquirequeued(node, savedstate)，这个方法在介绍aqs的底层实现时说过了，该方法的作用是在自旋过程中线程不断尝试获取同步状态，直至成功（线程获取到lock）。await方法示意图如下图：\n\n\n\n如图，调用condition.await方法的线程必须是已经获得了lock，也就是当前线程是同步队列中的头结点。调用该方法后会使得当前线程所封装的node尾插入到等待队列中。\n\n> 超时机制的支持\n\ncondition还额外支持了超时机制，使用者可调用方法awaitnanos,awaitutil。这两个方法的实现原理，基本上与aqs中的tryacquire方法如出一辙，关于tryacquire可以仔细阅读这篇文章的第3.4部分。\n\n> 不响应中断的支持\n\n要想不响应中断可以调用condition.awaituninterruptibly()方法，该方法的源码为：\n\npublic final void awaituninterruptibly() {\n    node node = addconditionwaiter();\n    int savedstate = fullyrelease(node);\n    boolean interrupted = false;\n    while (!isonsyncqueue(node)) {\n        locksupport.park(this);\n        if (thread.interrupted())\n            interrupted = true;\n    }\n    if (acquirequeued(node, savedstate) || interrupted)\n        selfinterrupt();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n这段方法与上面的await方法基本一致，只不过减少了对中断的处理，并省略了reportinterruptafterwait方法抛被中断的异常。\n\n\n# signal/signalall实现原理\n\n调用condition的signal或者signalall方法可以将等待队列中等待时间最长的节点移动到同步队列中，使得该节点能够有机会获得lock。按照等待队列是先进先出（fifo）的，所以等待队列的头节点必然会是等待时间最长的节点，也就是每次调用condition的signal方法是将头节点移动到同步队列中。我们来通过看源码的方式来看这样的猜想是不是对的，signal方法源码为：\n\npublic final void signal() {\n    //1. 先检测当前线程是否已经获取lock\n    if (!isheldexclusively())\n        throw new illegalmonitorstateexception();\n    //2. 获取等待队列中第一个节点，之后的操作都是针对这个节点\n\tnode first = firstwaiter;\n    if (first != null)\n        dosignal(first);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nsignal方法首先会检测当前线程是否已经获取lock，如果没有获取lock会直接抛出异常，如果获取的话再得到等待队列的头指针引用的节点，之后的操作的dosignal方法也是基于该节点。\n\n\n# dosignal方法\n\n下面我们来看看dosignal方法做了些什么事情，dosignal方法源码为：\n\nprivate void dosignal(node first) {\n    do {\n        if ( (firstwaiter = first.nextwaiter) == null)\n            lastwaiter = null;\n\t\t//1. 将头结点从等待队列中移除\n        first.nextwaiter = null;\n\t\t//2. while中transferforsignal方法对头结点做真正的处理\n    } while (!transferforsignal(first) &&\n             (first = firstwaiter) != null);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n具体逻辑请看注释，真正对头节点做处理的逻辑在transferforsignal方放\n\n\n# transferforsignal方法\n\n该方法源码为：\n\nfinal boolean transferforsignal(node node) {\n    /*\n     * if cannot change waitstatus, the node has been cancelled.\n     */\n\t//1. 更新状态为0\n    if (!compareandsetwaitstatus(node, node.condition, 0))\n        return false;\n\n    /*\n     * splice onto queue and try to set waitstatus of predecessor to\n     * indicate that thread is (probably) waiting. if cancelled or\n     * attempt to set waitstatus fails, wake up to resync (in which\n     * case the waitstatus can be transiently and harmlessly wrong).\n     */\n\t//2.将该节点移入到同步队列中去\n    node p = enq(node);\n    int ws = p.waitstatus;\n    if (ws > 0 || !compareandsetwaitstatus(p, ws, node.signal))\n        locksupport.unpark(node.thread);\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n关键逻辑请看注释，这段代码主要做了两件事情：\n\n 1. 将头结点的状态更改为condition；\n\n 2. 调用enq方法，将该节点尾插入到同步队列中。\n\n\n# signal总结\n\n总结就是：\n\n * 通过调用同步器的enq(node node)方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用locksupport唤醒该节点的线程。\n\n * 被唤醒后的线程，将从await()方法中的while循环中退出（isonsyncqueue(node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquirequeued()方法加入到获取同步状态的竞争中。\n\n * 成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。\n\nsignal执行示意图如下图：\n\n\n\n> signalall\n\nsigllall与sigal方法的区别体现在dosignalall方法上，前面我们已经知道dosignal方法只会对等待队列的头节点进行操作，而dosignalall的源码为：\n\nprivate void dosignalall(node first) {\n    lastwaiter = firstwaiter = null;\n    do {\n        node next = first.nextwaiter;\n        first.nextwaiter = null;\n        transferforsignal(first);\n        first = next;\n    } while (first != null);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n该方法只不过时间等待队列中的每一个节点都移入到同步队列中，即“通知”当前调用condition.await()方法的每一个线程。\n\n\n# 4、await与signal/signalall的结合思考\n\n文章开篇提到等待/通知机制，通过使用condition提供的await和signal/signalall方法就可以实现这种机制，而这种机制能够解决最经典的问题就是“生产者与消费者问题”，关于“生产者消费者问题”之后会用单独的一篇文章进行讲解，这也是面试的高频考点。await和signal和signalall方法就像一个开关控制着线程a（等待方）和线程b（通知方）。它们之间的关系可以用下面一个图来表现得更加贴切：\n\n\n\n如图，线程awaitthread先通过lock.lock()方法获取锁成功后调用了condition.await方法进入等待队列，而另一个线程signalthread通过lock.lock()方法获取锁成功后调用了condition.signal或者signalall方法，使得线程awaitthread能够有机会移入到同步队列中，当其他线程释放lock后使得线程awaitthread能够有机会获取lock，从而使得线程awaitthread能够从await方法中退出执行后续操作。如果awaitthread获取lock失败会直接进入到同步队列。\n\n\n# 5、一个例子\n\n我们用一个很简单的例子说说condition的用法：\n\npublic class awaitsignal {\n    private static reentrantlock lock = new reentrantlock();\n    private static condition condition = lock.newcondition();\n    private static volatile boolean flag = false;\n\n    public static void main(string[] args) {\n        thread waiter = new thread(new waiter());\n        waiter.start();\n        thread signaler = new thread(new signaler());\n        signaler.start();\n    }\n\n    static class waiter implements runnable {\n\n        @override\n        public void run() {\n            lock.lock();\n            try {\n                while (!flag) {\n                    system.out.println(thread.currentthread().getname() + "当前条件不满足等待");\n                    try {\n                        condition.await();\n                    } catch (interruptedexception e) {\n                        e.printstacktrace();\n                    }\n                }\n                system.out.println(thread.currentthread().getname() + "接收到通知条件满足");\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n\n    static class signaler implements runnable {\n\n        @override\n        public void run() {\n            lock.lock();\n            try {\n                flag = true;\n                condition.signalall();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n输出结果为：\n\nthread-0当前条件不满足等待\nthread-0接收到通知，条件满足\n\n\n1\n2\n\n\n开启了两个线程waiter和signaler，waiter线程开始执行的时候由于条件不满足，执行condition.await方法使该线程进入等待状态同时释放锁，signaler线程获取到锁之后更改条件，并通知所有的等待线程后释放锁。这时，waiter线程获取到锁，并由于signaler线程更改了条件此时相对于waiter来说条件满足，继续执行。\n\n> 参考文献\n\n《java并发编程的艺术》\n\n深入理解abstractqueuedsynchronizer（三）',charsets:{cjk:!0},createdTime:1655628697e3},{title:"LockSupport工具",frontmatter:{title:"LockSupport工具",description:"LockSupport工具",date:"2022-04-04T16:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/13%E3%80%81LockSupport%E5%B7%A5%E5%85%B7.html",relativePath:"Java/Java并发编程的艺术/13、LockSupport工具.md",key:"v-58e095d5",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/13%E3%80%81LockSupport%E5%B7%A5%E5%85%B7.html",headers:[{level:2,title:"1、LockSupport简介",slug:"_1、locksupport简介",normalizedTitle:"1、locksupport简介",charIndex:24},{level:2,title:"2、LockSupport方法介绍",slug:"_2、locksupport方法介绍",normalizedTitle:"2、locksupport方法介绍",charIndex:43},{level:2,title:"3、一个例子",slug:"_3、一个例子",normalizedTitle:"3、一个例子",charIndex:64}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>LockSupport工具</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"1、LockSupport简介 2、LockSupport方法介绍 3、一个例子",content:'说明\n\nLockSupport工具\n\n\n\n * 1、LockSupport简介\n * 2、LockSupport方法介绍\n * 3、一个例子\n\n\n\n\n# LockSupport工具\n\n\n# 1、LockSupport简介\n\n在之前介绍AQS的底层实现，已经在介绍java中的Lock时，比如ReentrantLock，ReentReadWriteLocks，已经在介绍线程间等待/通知机制使用的Condition时都会调用LockSupport.park()方法和LockSupport.unpark()方法。而这个在同步组件的实现中被频繁使用的LockSupport到底是何方神圣，现在就来看看。\n\nLockSupport位于java.util.concurrent.locks包下，t定义了一组的公共静态方法，该类的方法并不是很多。LockSupprot是线程的阻塞原语，用来阻塞线程和唤醒线程。每个使用LockSupport的线程都会与一个许可关联，如果该许可可用，并且可在线程中使用，则调用park()将会立即返回，否则可能阻塞。如果许可尚不可用，则可以调用 unpark 使其可用。但是注意许可不可重入，也就是说只能调用一次park()方法，否则会一直阻塞。\n\n\n# 2、LockSupport方法介绍\n\nLockSupport中的方法不多，这里将这些方法做一个总结：\n\n> 阻塞线程\n\n 1. void park()：阻塞当前线程，如果调用unpark方法或者当前线程被中断，从能从park()方法中返回\n 2. void park(Object blocker)：功能同方法1，入参增加一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；\n 3. void parkNanos(long nanos)：阻塞当前线程，最长不超过nanos纳秒，增加了超时返回的特性；\n 4. void parkNanos(Object blocker, long nanos)：功能同方法3，入参增加一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；\n 5. void parkUntil(long deadline)：阻塞当前线程，知道deadline；\n 6. void parkUntil(Object blocker, long deadline)：功能同方法5，入参增加一个Object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；\n\n> 唤醒线程\n\nvoid unpark(Thread thread):唤醒处于阻塞状态的指定线程\n\n实际上LockSupport阻塞和唤醒线程的功能是依赖于sun.misc.Unsafe，这是一个很底层的类，有兴趣的可以去查阅资料，比如park()方法的功能实现则是靠unsafe.park()方法。另外在阻塞线程这一系列方法中还有一个很有意思的现象就是，每个方法都会新增一个带有Object的阻塞对象的重载方法。那么增加了一个Object对象的入参会有什么不同的地方了？示例代码很简单就不说了，直接看dump线程的信息。\n\n调用park()方法dump线程：\n\n"main" #1 prio=5 os_prio=0 tid=0x02cdcc00 nid=0x2b48 waiting on condition [0x00d6f000]\n   java.lang.Thread.State: WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:304)\n        at learn.LockSupportDemo.main(LockSupportDemo.java:7)\n\n\n1\n2\n3\n4\n5\n\n\n调用park(Object blocker)方法dump线程\n\n"main" #1 prio=5 os_prio=0 tid=0x0069cc00 nid=0x6c0 waiting on condition [0x00dcf000]\n   java.lang.Thread.State: WAITING (parking)\n        at sun.misc.Unsafe.park(Native Method)\n        - parking to wait for  <0x048c2d18> (a java.lang.String)\n        at java.util.concurrent.locks.LockSupport.park(LockSupport.java:175)\n        at learn.LockSupportDemo.main(LockSupportDemo.java:7)\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过分别调用这两个方法然后dump线程信息可以看出，带Object的park方法相较于无参的park方法会增加parking to wait for <0x048c2d18> (a java.lang.String)的信息，这种信息就类似于记录“案发现场”，有助于工程人员能够迅速发现问题解决问题。有个有意思的事情是，我们都知道如果使用synchronzed阻塞了线程dump线程时都会有阻塞对象的描述，在java 5推出LockSupport时遗漏了这一点，在java 6时进行了补充。还有一点需要需要的是：synchronzed致使线程阻塞，线程会进入到BLOCKED状态，而调用LockSupprt方法阻塞线程会致使线程进入到WAITING状态。\n\n\n# 3、一个例子\n\n用一个很简单的例子说说这些方法怎么用。\n\npublic class LockSupportDemo {\n    public static void main(String[] args) {\n        Thread thread = new Thread(() -> {\n            LockSupport.park();\n            System.out.println(Thread.currentThread().getName() + "被唤醒");\n        });\n        thread.start();\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        LockSupport.unpark(thread);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nthread线程调用LockSupport.park()致使thread阻塞，当mian线程睡眠3秒结束后通过LockSupport.unpark(thread)方法唤醒thread线程，thread线程被唤醒执行后续操作。另外，还有一点值得关注的是，LockSupport.unpark(thread)可以指定线程对象唤醒指定的线程。',normalizedContent:'说明\n\nlocksupport工具\n\n\n\n * 1、locksupport简介\n * 2、locksupport方法介绍\n * 3、一个例子\n\n\n\n\n# locksupport工具\n\n\n# 1、locksupport简介\n\n在之前介绍aqs的底层实现，已经在介绍java中的lock时，比如reentrantlock，reentreadwritelocks，已经在介绍线程间等待/通知机制使用的condition时都会调用locksupport.park()方法和locksupport.unpark()方法。而这个在同步组件的实现中被频繁使用的locksupport到底是何方神圣，现在就来看看。\n\nlocksupport位于java.util.concurrent.locks包下，t定义了一组的公共静态方法，该类的方法并不是很多。locksupprot是线程的阻塞原语，用来阻塞线程和唤醒线程。每个使用locksupport的线程都会与一个许可关联，如果该许可可用，并且可在线程中使用，则调用park()将会立即返回，否则可能阻塞。如果许可尚不可用，则可以调用 unpark 使其可用。但是注意许可不可重入，也就是说只能调用一次park()方法，否则会一直阻塞。\n\n\n# 2、locksupport方法介绍\n\nlocksupport中的方法不多，这里将这些方法做一个总结：\n\n> 阻塞线程\n\n 1. void park()：阻塞当前线程，如果调用unpark方法或者当前线程被中断，从能从park()方法中返回\n 2. void park(object blocker)：功能同方法1，入参增加一个object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；\n 3. void parknanos(long nanos)：阻塞当前线程，最长不超过nanos纳秒，增加了超时返回的特性；\n 4. void parknanos(object blocker, long nanos)：功能同方法3，入参增加一个object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；\n 5. void parkuntil(long deadline)：阻塞当前线程，知道deadline；\n 6. void parkuntil(object blocker, long deadline)：功能同方法5，入参增加一个object对象，用来记录导致线程阻塞的阻塞对象，方便进行问题排查；\n\n> 唤醒线程\n\nvoid unpark(thread thread):唤醒处于阻塞状态的指定线程\n\n实际上locksupport阻塞和唤醒线程的功能是依赖于sun.misc.unsafe，这是一个很底层的类，有兴趣的可以去查阅资料，比如park()方法的功能实现则是靠unsafe.park()方法。另外在阻塞线程这一系列方法中还有一个很有意思的现象就是，每个方法都会新增一个带有object的阻塞对象的重载方法。那么增加了一个object对象的入参会有什么不同的地方了？示例代码很简单就不说了，直接看dump线程的信息。\n\n调用park()方法dump线程：\n\n"main" #1 prio=5 os_prio=0 tid=0x02cdcc00 nid=0x2b48 waiting on condition [0x00d6f000]\n   java.lang.thread.state: waiting (parking)\n        at sun.misc.unsafe.park(native method)\n        at java.util.concurrent.locks.locksupport.park(locksupport.java:304)\n        at learn.locksupportdemo.main(locksupportdemo.java:7)\n\n\n1\n2\n3\n4\n5\n\n\n调用park(object blocker)方法dump线程\n\n"main" #1 prio=5 os_prio=0 tid=0x0069cc00 nid=0x6c0 waiting on condition [0x00dcf000]\n   java.lang.thread.state: waiting (parking)\n        at sun.misc.unsafe.park(native method)\n        - parking to wait for  <0x048c2d18> (a java.lang.string)\n        at java.util.concurrent.locks.locksupport.park(locksupport.java:175)\n        at learn.locksupportdemo.main(locksupportdemo.java:7)\n\n\n1\n2\n3\n4\n5\n6\n\n\n通过分别调用这两个方法然后dump线程信息可以看出，带object的park方法相较于无参的park方法会增加parking to wait for <0x048c2d18> (a java.lang.string)的信息，这种信息就类似于记录“案发现场”，有助于工程人员能够迅速发现问题解决问题。有个有意思的事情是，我们都知道如果使用synchronzed阻塞了线程dump线程时都会有阻塞对象的描述，在java 5推出locksupport时遗漏了这一点，在java 6时进行了补充。还有一点需要需要的是：synchronzed致使线程阻塞，线程会进入到blocked状态，而调用locksupprt方法阻塞线程会致使线程进入到waiting状态。\n\n\n# 3、一个例子\n\n用一个很简单的例子说说这些方法怎么用。\n\npublic class locksupportdemo {\n    public static void main(string[] args) {\n        thread thread = new thread(() -> {\n            locksupport.park();\n            system.out.println(thread.currentthread().getname() + "被唤醒");\n        });\n        thread.start();\n        try {\n            thread.sleep(3000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        locksupport.unpark(thread);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nthread线程调用locksupport.park()致使thread阻塞，当mian线程睡眠3秒结束后通过locksupport.unpark(thread)方法唤醒thread线程，thread线程被唤醒执行后续操作。另外，还有一点值得关注的是，locksupport.unpark(thread)可以指定线程对象唤醒指定的线程。',charsets:{cjk:!0},createdTime:1655628697e3},{title:"并发容器之CopyOnWriteArrayList",frontmatter:{title:"并发容器之CopyOnWriteArrayList",description:"并发容器之CopyOnWriteArrayList",date:"2022-04-07T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/16%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BCopyOnWriteArrayList.html",relativePath:"Java/Java并发编程的艺术/16、并发容器之CopyOnWriteArrayList.md",key:"v-66485df2",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/16%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BCopyOnWriteArrayList.html",headers:[{level:2,title:"1、CopyOnWriteArrayList的简介",slug:"_1、copyonwritearraylist的简介",normalizedTitle:"1、copyonwritearraylist的简介",charIndex:36},{level:2,title:"2、COW的设计思想",slug:"_2、cow的设计思想",normalizedTitle:"2、cow的设计思想",charIndex:65},{level:2,title:"3、CopyOnWriteArrayList的实现原理",slug:"_3、copyonwritearraylist的实现原理",normalizedTitle:"3、copyonwritearraylist的实现原理",charIndex:79},{level:3,title:"3.1 get方法实现原理",slug:"_3-1-get方法实现原理",normalizedTitle:"3.1 get方法实现原理",charIndex:112},{level:3,title:"3.2 add方法实现原理",slug:"_3-2-add方法实现原理",normalizedTitle:"3.2 add方法实现原理",charIndex:131},{level:2,title:"4、总结",slug:"_4、总结",normalizedTitle:"4、总结",charIndex:148}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>并发容器之CopyOnWriteArrayList</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"1、CopyOnWriteArrayList的简介 2、COW的设计思想 3、CopyOnWriteArrayList的实现原理 3.1 get方法实现原理 3.2 add方法实现原理 4、总结",content:"说明\n\n并发容器之CopyOnWriteArrayList\n\n\n\n * 1、CopyOnWriteArrayList的简介\n * 2、COW的设计思想\n * 3、CopyOnWriteArrayList的实现原理\n   * 3.1 get方法实现原理\n   * 3.2 add方法实现原理\n * 4、总结\n\n\n\n\n# 并发容器之CopyOnWriteArrayList\n\n\n# 1、CopyOnWriteArrayList的简介\n\njava学习者都清楚ArrayList并不是线程安全的，在读线程在读取ArrayList的时候如果有写线程在写数据的时候，基于fast-fail机制，会抛出ConcurrentModificationException异常，也就是说ArrayList并不是一个线程安全的容器，当然您可以用Vector，或者使用Collections的静态方法将ArrayList包装成一个线程安全的类，但是这些方式都是采用java关键字synchronzied对方法进行修饰，利用独占式锁来保证线程安全的。但是，由于独占式锁在同一时刻只有一个线程能够获取到对象监视器，很显然这种方式效率并不是太高。\n\n回到业务场景中，有很多业务往往是读多写少的，比如系统配置的信息，除了在初始进行系统配置的时候需要写入数据，其他大部分时刻其他模块之后对系统信息只需要进行读取，又比如白名单，黑名单等配置，只需要读取名单配置然后检测当前用户是否在该配置范围以内。类似的还有很多业务场景，它们都是属于读多写少的场景。如果在这种情况用到上述的方法，使用Vector、Collections转换的这些方式是不合理的，因为尽管多个读线程从同一个数据容器中读取数据，但是读线程对数据容器的数据并不会发生发生修改。很自然而然的我们会联想到ReenTrantReadWriteLock，通过读写分离的思想，使得读读之间不会阻塞，无疑如果一个list能够做到被多个读线程读取的话，性能会大大提升不少。但是，如果仅仅是将list通过读写锁（ReentrantReadWriteLock）进行再一次封装的话，由于读写锁的特性，当写锁被写线程获取后，读写线程都会被阻塞。如果仅仅使用读写锁对list进行封装的话，这里仍然存在读线程在读数据的时候被阻塞的情况，如果想list的读效率更高的话，这里就是我们的突破口，如果我们保证读线程无论什么时候都不被阻塞，效率岂不是会更高？\n\nDoug Lea大师就为我们提供CopyOnWriteArrayList容器可以保证线程安全，保证读读之间在任何时候都不会被阻塞，CopyOnWriteArrayList也被广泛应用于很多业务场景之中，CopyOnWriteArrayList值得被我们好好认识一番。\n\n\n# 2、COW的设计思想\n\n回到上面所说的，如果简单的使用读写锁的话，在写锁被获取之后，读写线程被阻塞，只有当写锁被释放后读线程才有机会获取到锁从而读到最新的数据，站在读线程的角度来看，即读线程任何时候都是获取到最新的数据，满足数据实时性。既然我们说到要进行优化，必然有所取舍，我们就可以牺牲数据实时性满足数据的最终一致性即可。而CopyOnWriteArrayList就是通过Copy-On-Write(COW)，即写时复制的思想来通过延时更新的策略来实现数据的最终一致性，并且能够保证读线程间不阻塞。\n\nCOW通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。对CopyOnWrite容器进行并发的读的时候，不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，延时更新的策略是通过在写的时候针对的是不同的数据容器来实现的，放弃数据实时性达到数据的最终一致性。\n\n\n# 3、CopyOnWriteArrayList的实现原理\n\n现在我们来通过看源码的方式来理解CopyOnWriteArrayList，实际上CopyOnWriteArrayList内部维护的就是一个数组\n\n/** The array, accessed only via getArray/setArray. */\nprivate transient volatile Object[] array;\n\n\n1\n2\n\n\n并且该数组引用是被volatile修饰，注意这里仅仅是修饰的是数组引用，其中另有玄机，稍后揭晓。关于volatile很重要的一条性质是它能够保证可见性。对list来说，我们自然而然最关心的就是读写的时候，分别为get和add方法的实现。\n\n\n# 3.1 get方法实现原理\n\nget方法的源码为：\n\npublic E get(int index) {\n    return get(getArray(), index);\n}\n/**\n * Gets the array.  Non-private so as to also be accessible\n * from CopyOnWriteArraySet class.\n */\nfinal Object[] getArray() {\n    return array;\n}\nprivate E get(Object[] a, int index) {\n    return (E) a[index];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n可以看出来get方法实现非常简单，几乎就是一个“单线程”程序，没有对多线程添加任何的线程安全控制，也没有加锁也没有CAS操作等等，原因是，所有的读线程只是会读取数据容器中的数据，并不会进行修改。\n\n\n# 3.2 add方法实现原理\n\n再来看下如何进行添加数据的？add方法的源码为：\n\npublic boolean add(E e) {\n    final ReentrantLock lock = this.lock;\n\t//1. 使用Lock,保证写线程在同一时刻只有一个\n    lock.lock();\n    try {\n\t\t//2. 获取旧数组引用\n        Object[] elements = getArray();\n        int len = elements.length;\n\t\t//3. 创建新的数组，并将旧数组的数据复制到新数组中\n        Object[] newElements = Arrays.copyOf(elements, len + 1);\n\t\t//4. 往新数组中添加新的数据\n\t\tnewElements[len] = e;\n\t\t//5. 将旧数组引用指向新的数组\n        setArray(newElements);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nadd方法的逻辑也比较容易理解，请看上面的注释。需要注意这么几点：\n\n 1. 采用ReentrantLock，保证同一时刻只有一个写线程正在进行数组的复制，否则的话内存中会有多份被复制的数据；\n 2. 前面说过数组引用是volatile修饰的，因此将旧的数组引用指向新的数组，根据volatile的happens-before规则，写线程对数组引用的修改对读线程是可见的。\n 3. 由于在写数据的时候，是在新的数组中插入数据的，从而保证读写实在两个不同的数据容器中进行操作。\n\n\n# 4、总结\n\n我们知道COW和读写锁都是通过读写分离的思想实现的，但两者还是有些不同，可以进行比较：\n\n> COW vs 读写锁\n\n相同点：1. 两者都是通过读写分离的思想实现；2. 读线程间是互不阻塞的\n\n不同点：读写锁中对读线程而言，为了实现数据实时性，在写锁被获取后，读线程会等待或者当读锁被获取后，写线程会等待，从而解决“脏读”等问题。也就是说如果使用读写锁依然会出现读线程阻塞等待的情况。而COW则完全放开了牺牲数据实时性而保证数据最终一致性，即读线程对数据的更新是延时感知的，因此读线程不会存在等待的情况。\n\n对这一点从文字上还是很难理解，我们来通过debug看一下，add方法核心代码为：\n\nObject[] elements = getArray();\nint len = elements.length;\nObject[] newElements = Arrays.copyOf(elements, len + 1);\nnewElements[len] = e;\nsetArray(newElements);\n\n\n1\n2\n3\n4\n5\n\n\n假设COW的变化如下图所示：\n\n\n\n数组中已有数据1,2,3，现在写线程想往数组中添加数据4，我们在第5行处打上断点，让写线程暂停。读线程依然会“不受影响”的能从数组中读取数据，可是还是只能读到1,2,3。如果读线程能够立即读到新添加的数据的话就叫做能保证数据实时性。当对第5行的断点放开后，读线程才能感知到数据变化，读到完整的数据1,2,3,4，而保证数据最终一致性，尽管有可能中间间隔了好几秒才感知到。\n\n这里还有这样一个问题： 为什么需要复制呢？ 如果将array 数组设定为volitile的， 对volatile变量写happens-before读，读线程不是能够感知到volatile变量的变化。\n\n原因是，这里volatile的修饰的仅仅只是数组引用，数组中的元素的修改是不能保证可见性的。因此COW采用的是新旧两个数据容器，通过第5行代码将数组引用指向新的数组。\n\n这也是为什么concurrentHashMap只具有弱一致性的原因，关于volatile是否能保证数组中元素的可见性问题可以看这篇文章。\n\n> COW的缺点\n\nCopyOnWrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下：\n\n 1. 内存占用问题：因为CopyOnWrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对 象的内存，旧的对象和新写入的对象（注意：在复制的时候只是复制容器里的引用，只是在写的时候会创建新对 象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比 如说200M左右，那么再写入100M数据进去，内存就会占用300M，那么这个时候很有可能造成频繁的minor GC和major GC。\n 2. 数据一致性问题：CopyOnWrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用CopyOnWrite容器。\n\n> 参考资料\n\n《java并发编程的艺术》\n\nCOW讲解",normalizedContent:"说明\n\n并发容器之copyonwritearraylist\n\n\n\n * 1、copyonwritearraylist的简介\n * 2、cow的设计思想\n * 3、copyonwritearraylist的实现原理\n   * 3.1 get方法实现原理\n   * 3.2 add方法实现原理\n * 4、总结\n\n\n\n\n# 并发容器之copyonwritearraylist\n\n\n# 1、copyonwritearraylist的简介\n\njava学习者都清楚arraylist并不是线程安全的，在读线程在读取arraylist的时候如果有写线程在写数据的时候，基于fast-fail机制，会抛出concurrentmodificationexception异常，也就是说arraylist并不是一个线程安全的容器，当然您可以用vector，或者使用collections的静态方法将arraylist包装成一个线程安全的类，但是这些方式都是采用java关键字synchronzied对方法进行修饰，利用独占式锁来保证线程安全的。但是，由于独占式锁在同一时刻只有一个线程能够获取到对象监视器，很显然这种方式效率并不是太高。\n\n回到业务场景中，有很多业务往往是读多写少的，比如系统配置的信息，除了在初始进行系统配置的时候需要写入数据，其他大部分时刻其他模块之后对系统信息只需要进行读取，又比如白名单，黑名单等配置，只需要读取名单配置然后检测当前用户是否在该配置范围以内。类似的还有很多业务场景，它们都是属于读多写少的场景。如果在这种情况用到上述的方法，使用vector、collections转换的这些方式是不合理的，因为尽管多个读线程从同一个数据容器中读取数据，但是读线程对数据容器的数据并不会发生发生修改。很自然而然的我们会联想到reentrantreadwritelock，通过读写分离的思想，使得读读之间不会阻塞，无疑如果一个list能够做到被多个读线程读取的话，性能会大大提升不少。但是，如果仅仅是将list通过读写锁（reentrantreadwritelock）进行再一次封装的话，由于读写锁的特性，当写锁被写线程获取后，读写线程都会被阻塞。如果仅仅使用读写锁对list进行封装的话，这里仍然存在读线程在读数据的时候被阻塞的情况，如果想list的读效率更高的话，这里就是我们的突破口，如果我们保证读线程无论什么时候都不被阻塞，效率岂不是会更高？\n\ndoug lea大师就为我们提供copyonwritearraylist容器可以保证线程安全，保证读读之间在任何时候都不会被阻塞，copyonwritearraylist也被广泛应用于很多业务场景之中，copyonwritearraylist值得被我们好好认识一番。\n\n\n# 2、cow的设计思想\n\n回到上面所说的，如果简单的使用读写锁的话，在写锁被获取之后，读写线程被阻塞，只有当写锁被释放后读线程才有机会获取到锁从而读到最新的数据，站在读线程的角度来看，即读线程任何时候都是获取到最新的数据，满足数据实时性。既然我们说到要进行优化，必然有所取舍，我们就可以牺牲数据实时性满足数据的最终一致性即可。而copyonwritearraylist就是通过copy-on-write(cow)，即写时复制的思想来通过延时更新的策略来实现数据的最终一致性，并且能够保证读线程间不阻塞。\n\ncow通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。对copyonwrite容器进行并发的读的时候，不需要加锁，因为当前容器不会添加任何元素。所以copyonwrite容器也是一种读写分离的思想，延时更新的策略是通过在写的时候针对的是不同的数据容器来实现的，放弃数据实时性达到数据的最终一致性。\n\n\n# 3、copyonwritearraylist的实现原理\n\n现在我们来通过看源码的方式来理解copyonwritearraylist，实际上copyonwritearraylist内部维护的就是一个数组\n\n/** the array, accessed only via getarray/setarray. */\nprivate transient volatile object[] array;\n\n\n1\n2\n\n\n并且该数组引用是被volatile修饰，注意这里仅仅是修饰的是数组引用，其中另有玄机，稍后揭晓。关于volatile很重要的一条性质是它能够保证可见性。对list来说，我们自然而然最关心的就是读写的时候，分别为get和add方法的实现。\n\n\n# 3.1 get方法实现原理\n\nget方法的源码为：\n\npublic e get(int index) {\n    return get(getarray(), index);\n}\n/**\n * gets the array.  non-private so as to also be accessible\n * from copyonwritearrayset class.\n */\nfinal object[] getarray() {\n    return array;\n}\nprivate e get(object[] a, int index) {\n    return (e) a[index];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n可以看出来get方法实现非常简单，几乎就是一个“单线程”程序，没有对多线程添加任何的线程安全控制，也没有加锁也没有cas操作等等，原因是，所有的读线程只是会读取数据容器中的数据，并不会进行修改。\n\n\n# 3.2 add方法实现原理\n\n再来看下如何进行添加数据的？add方法的源码为：\n\npublic boolean add(e e) {\n    final reentrantlock lock = this.lock;\n\t//1. 使用lock,保证写线程在同一时刻只有一个\n    lock.lock();\n    try {\n\t\t//2. 获取旧数组引用\n        object[] elements = getarray();\n        int len = elements.length;\n\t\t//3. 创建新的数组，并将旧数组的数据复制到新数组中\n        object[] newelements = arrays.copyof(elements, len + 1);\n\t\t//4. 往新数组中添加新的数据\n\t\tnewelements[len] = e;\n\t\t//5. 将旧数组引用指向新的数组\n        setarray(newelements);\n        return true;\n    } finally {\n        lock.unlock();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nadd方法的逻辑也比较容易理解，请看上面的注释。需要注意这么几点：\n\n 1. 采用reentrantlock，保证同一时刻只有一个写线程正在进行数组的复制，否则的话内存中会有多份被复制的数据；\n 2. 前面说过数组引用是volatile修饰的，因此将旧的数组引用指向新的数组，根据volatile的happens-before规则，写线程对数组引用的修改对读线程是可见的。\n 3. 由于在写数据的时候，是在新的数组中插入数据的，从而保证读写实在两个不同的数据容器中进行操作。\n\n\n# 4、总结\n\n我们知道cow和读写锁都是通过读写分离的思想实现的，但两者还是有些不同，可以进行比较：\n\n> cow vs 读写锁\n\n相同点：1. 两者都是通过读写分离的思想实现；2. 读线程间是互不阻塞的\n\n不同点：读写锁中对读线程而言，为了实现数据实时性，在写锁被获取后，读线程会等待或者当读锁被获取后，写线程会等待，从而解决“脏读”等问题。也就是说如果使用读写锁依然会出现读线程阻塞等待的情况。而cow则完全放开了牺牲数据实时性而保证数据最终一致性，即读线程对数据的更新是延时感知的，因此读线程不会存在等待的情况。\n\n对这一点从文字上还是很难理解，我们来通过debug看一下，add方法核心代码为：\n\nobject[] elements = getarray();\nint len = elements.length;\nobject[] newelements = arrays.copyof(elements, len + 1);\nnewelements[len] = e;\nsetarray(newelements);\n\n\n1\n2\n3\n4\n5\n\n\n假设cow的变化如下图所示：\n\n\n\n数组中已有数据1,2,3，现在写线程想往数组中添加数据4，我们在第5行处打上断点，让写线程暂停。读线程依然会“不受影响”的能从数组中读取数据，可是还是只能读到1,2,3。如果读线程能够立即读到新添加的数据的话就叫做能保证数据实时性。当对第5行的断点放开后，读线程才能感知到数据变化，读到完整的数据1,2,3,4，而保证数据最终一致性，尽管有可能中间间隔了好几秒才感知到。\n\n这里还有这样一个问题： 为什么需要复制呢？ 如果将array 数组设定为volitile的， 对volatile变量写happens-before读，读线程不是能够感知到volatile变量的变化。\n\n原因是，这里volatile的修饰的仅仅只是数组引用，数组中的元素的修改是不能保证可见性的。因此cow采用的是新旧两个数据容器，通过第5行代码将数组引用指向新的数组。\n\n这也是为什么concurrenthashmap只具有弱一致性的原因，关于volatile是否能保证数组中元素的可见性问题可以看这篇文章。\n\n> cow的缺点\n\ncopyonwrite容器有很多优点，但是同时也存在两个问题，即内存占用问题和数据一致性问题。所以在开发的时候需要注意一下：\n\n 1. 内存占用问题：因为copyonwrite的写时复制机制，所以在进行写操作的时候，内存里会同时驻扎两个对 象的内存，旧的对象和新写入的对象（注意：在复制的时候只是复制容器里的引用，只是在写的时候会创建新对 象添加到新容器里，而旧容器的对象还在使用，所以有两份对象内存）。如果这些对象占用的内存比较大，比 如说200m左右，那么再写入100m数据进去，内存就会占用300m，那么这个时候很有可能造成频繁的minor gc和major gc。\n 2. 数据一致性问题：copyonwrite容器只能保证数据的最终一致性，不能保证数据的实时一致性。所以如果你希望写入的的数据，马上能读到，请不要使用copyonwrite容器。\n\n> 参考资料\n\n《java并发编程的艺术》\n\ncow讲解",charsets:{cjk:!0},createdTime:1655628697e3},{title:"深入理解AbstractQueuedSynchronizer-AQS",frontmatter:{title:"深入理解AbstractQueuedSynchronizer-AQS",description:"深入理解AbstractQueuedSynchronizer(AQS)",date:"2022-04-01T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/09%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer-AQS.html",relativePath:"Java/Java并发编程的艺术/09、深入理解AbstractQueuedSynchronizer-AQS.md",key:"v-7771c16d",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/09%E3%80%81%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3AbstractQueuedSynchronizer-AQS.html",headers:[{level:2,title:"同步队列",slug:"同步队列",normalizedTitle:"同步队列",charIndex:46},{level:2,title:"AQS的state变量",slug:"aqs的state变量",normalizedTitle:"aqs的state变量",charIndex:54},{level:2,title:"acquire方法",slug:"acquire方法",normalizedTitle:"acquire方法",charIndex:69},{level:2,title:"tryAcquire方法",slug:"tryacquire方法",normalizedTitle:"tryacquire方法",charIndex:82},{level:2,title:"addWaiter方法",slug:"addwaiter方法",normalizedTitle:"addwaiter方法",charIndex:98},{level:2,title:"enq方法",slug:"enq方法",normalizedTitle:"enq方法",charIndex:113},{level:2,title:"acquireQueued方法",slug:"acquirequeued方法",normalizedTitle:"acquirequeued方法",charIndex:122},{level:2,title:"获取锁失败",slug:"获取锁失败",normalizedTitle:"获取锁失败",charIndex:141},{level:2,title:"cancelAcquire方法",slug:"cancelacquire方法",normalizedTitle:"cancelacquire方法",charIndex:150},{level:2,title:"AQS获取独占锁的大致流程图",slug:"aqs获取独占锁的大致流程图",normalizedTitle:"aqs获取独占锁的大致流程图",charIndex:169},{level:2,title:"可中断式获取锁（acquireInterruptibly方法）",slug:"可中断式获取锁-acquireinterruptibly方法",normalizedTitle:"可中断式获取锁（acquireinterruptibly方法）",charIndex:187},{level:2,title:"超时等待式获取锁（tryAcquireNanos()方法）",slug:"超时等待式获取锁-tryacquirenanos-方法",normalizedTitle:"超时等待式获取锁（tryacquirenanos()方法）",charIndex:222},{level:2,title:"共享锁的获取（acquireShared()方法）",slug:"共享锁的获取-acquireshared-方法",normalizedTitle:"共享锁的获取（acquireshared()方法）",charIndex:255},{level:2,title:"共享锁的释放（releaseShared()方法）",slug:"共享锁的释放-releaseshared-方法",normalizedTitle:"共享锁的释放（releaseshared()方法）",charIndex:284},{level:2,title:"可中断（acquireSharedInterruptibly()方法），超时等待（tryAcquireSharedNanos()方法）",slug:"可中断-acquiresharedinterruptibly-方法-超时等待-tryacquiresharednanos-方法",normalizedTitle:"可中断（acquiresharedinterruptibly()方法），超时等待（tryacquiresharednanos()方法）",charIndex:313}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>深入理解AbstractQueuedSynchronizer(AQS)</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"同步队列 AQS的state变量 acquire方法 tryAcquire方法 addWaiter方法 enq方法 acquireQueued方法 获取锁失败 cancelAcquire方法 AQS获取独占锁的大致流程图 可中断式获取锁（acquireInterruptibly方法） 超时等待式获取锁（tryAcquireNanos()方法） 共享锁的获取（acquireShared()方法） 共享锁的释放（releaseShared()方法） 可中断（acquireSharedInterruptibly()方法），超时等待（tryAcquireSharedNanos()方法）",content:'说明\n\n深入理解AbstractQueuedSynchronizer(AQS)\n\n\n\n * 同步队列\n * AQS的state变量\n * acquire方法\n * tryAcquire方法\n * addWaiter方法\n * enq方法\n * acquireQueued方法\n * 获取锁失败\n * cancelAcquire方法\n * AQS获取独占锁的大致流程图\n * 可中断式获取锁（acquireInterruptibly方法）\n * 超时等待式获取锁（tryAcquireNanos()方法）\n * 共享锁的获取（acquireShared()方法）\n * 共享锁的释放（releaseShared()方法）\n * 可中断（acquireSharedInterruptibly()方法），超时等待（tryAcquireSharedNanos()方法）\n\n\n\n\n# 深入理解AbstractQueuedSynchronizer(AQS)\n\n\n\n\n# 1、AQS简介\n\n在上一篇文章中我们对lock和AbstractQueuedSynchronizer(AQS)有了初步的认识。在同步组件的实现中，AQS是核心部分，同步组件的实现者通过使用AQS提供的模板方法实现同步组件语义，AQS则实现了对同步状态的管理，以及对阻塞线程进行排队，等待通知等等一些底层的实现处理。AQS的核心也包括了这些方面：同步队列，独占式锁的获取和释放，共享锁的获取和释放以及可中断锁，超时等待锁获取这些特性的实现，而这些实际上则是AQS提供出来的模板方法，归纳整理如下：\n\nAbstractQueuedSynchronizer提供了一个FIFO队列，可以看做是一个可以用来实现锁以及其他需要同步功能的框架。AQS的使用依靠继承来完成，子类通过继承自AQS并实现所需的方法来管理同步状态。例如ReentrantLock，CountDownLatch等。\n\n本篇文章基于JDK1.8来介绍，该类有许多实现类：\n\n\n\n其中，我们最常用的大概就是ReentrantLock和CountDownLatch了。ReentrantLock提供了对代码块的并发访问控制，也就是锁，说是锁，但其实并没有用到关键字synchronized，这么神奇？其实其内部就是基于同步器来实现的，本文结合ReentrantLock的使用来分析同步器独占锁的原理。\n\n\n# 2、AQS的两种功能\n\n从使用上来说，AQS的功能可以分为两种：独占和共享。对于这两种功能，有一个很常用的类：ReentrantReadWriteLock，其就是通过两个内部类来分别实现了这两种功能，提供了读锁和写锁的功能。但子类实现时，只能实现其中的一种功能，即要么是独占功能，要么是共享功能。\n\n对于独占功能，例如如下代码：\n\nReentrantLock lock = new ReentrantLock();\n...\n\npublic void function(){\n\n    lock.lock();\n    try {\n\n    // do something...\n\n\n    } finally {\n        lock.unlock();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这个很好理解，通过ReentrantLock来保证在lock.lock()之后的代码在同一时刻只能有一个线程来执行，其余的线程将会被阻塞，直到该线程执行了lock.unlock()。这就是一个独占锁的功能。\n\n对于共享功能，例如如下代码：\n\nReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n...\n\npublic void function(){\n\n    lock.readLock().lock();\n    try {\n\n    // do something...\n\n\n    } finally {\n        lock.readLock().unlock();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n代码中的lock是ReentrantReadWriteLock类的实例，而lock.readLock()为获取其中的读锁，即共享锁，使用方式并无差别，但和独占锁是有区别的：\n\n * 读锁与读锁可以共享\n * 读锁与写锁不可以共享（排他）\n * 写锁与写锁不可以共享（排他）\n\n\n# 3、AQS的主要数据结构\n\n\n# 同步队列\n\n当共享资源被某个线程占有，其他请求该资源的线程将会阻塞，从而进入同步队列。就数据结构而言，队列的实现方式无外乎两者一是通过数组的形式，另外一种则是链表的形式。AQS中的同步队列则是通过链式方式进行实现。接下来，很显然我们至少会抱有这样的疑问：\n\n 1. 节点的数据结构是什么样的？\n 2. 是单向还是双向？\n 3. 是带头结点的还是不带头节点的？\n\n我们依旧先是通过看源码的方式：\n\n在AQS有一个静态内部类Node，其中有这样一些属性：\n\nstatic final class Node {\n    int waitStatus;\n    Node prev;\n    Node next;\n    Node nextWaiter;\n    Thread thread;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * waitStatus：表示节点的状态，其中包含的状态有：\n   * CANCELLED：值为1，表示当前节点被取消；\n   * SIGNAL：值为-1，表示当前节点的的后继节点将要或者已经被阻塞，在当前节点释放的时候需要unpark后继节点；\n   * CONDITION：值为-2，表示当前节点在等待condition，即在condition队列中；\n   * PROPAGATE：值为-3，表示releaseShared需要被传播给后续节点（仅在共享模式下使用）；\n   * 0：无状态，表示当前节点在队列中等待获取锁。\n * prev：前继节点；\n * next：后继节点；\n * nextWaiter：存储condition队列中的后继节点；\n * thread：当前线程。\n\n节点是构成同步队列的基础，同步器拥有首节点（head）和尾节点（tail），没有成功获取同步状态的线程将会成为节点加入该队列的尾部，同步队列的基本结构如图所示：\n\n\n\n如图，同步器包含了两个节点类型的引用，一个指向头节点，而另一个指向尾节点。试想一下，当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Nodeupdate)，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。\n\n\n\n同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点，该过程如图所示：\n\n\n\n如图，设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用CAS来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。\n\n现在我们可以清楚的知道这样几点：\n\n 1. 节点的数据结构，即AQS的静态内部类Node，节点的等待状态等信息；\n 2. 同步队列是一个双向队列，AQS通过持有头尾指针管理同步队列；\n 3. 节点的入队和出队实际上对应着锁的获取和释放两个操作：获取锁失败进行入队操作，获取锁成功进行出队操作。\n\n\n# AQS的state变量\n\nAQS中有一个state变量，该变量对不同的子类实现具有不同的意义，对ReentrantLock来说，它表示加锁的状态：\n\n * 无锁时state=0，有锁时state>0；\n * 第一次加锁时，将state设置为1；\n * 由于ReentrantLock是可重入锁，所以持有锁的线程可以多次加锁，经过判断加锁线程就是当前持有锁的线程时（即exclusiveOwnerThread==Thread.currentThread()），即可加锁，每次加锁都会将state的值+1，state等于几，就代表当前持有锁的线程加了几次锁；\n * 解锁时每解一次锁就会将state减1，state减到0后，锁就被释放掉，这时其它线程可以加锁；\n * 当持有锁的线程释放锁以后，如果是等待队列获取到了加锁权限，则会在等待队列头部取出第一个线程去获取锁，获取锁的线程会被移出队列；\n\nstate变量定义如下：\n\n/**\n * The synchronization state.\n */\nprivate volatile int state;\n\n\n1\n2\n3\n4\n\n\n\n# 4、ReentrantLock类的结构\n\n下面通过ReentrantLock的实现进一步分析重入锁的实现。\n\n首先看一下lock方法：\n\npublic void lock() {\n    sync.lock();\n}\n\n\n1\n2\n3\n\n\n该方法调用了sync实例的lock方法，这里要说明一下ReentrantLock中的几个内部类：\n\n * Sync\n * FairSync\n * NonfairSync\n\n对于ReentrantLock，有两种获取锁的模式：公平锁和非公平锁。所以对应有两个内部类，都继承自Sync。而Sync继承自AQS：\n\n\n\n本文主要通过公平锁来介绍，看一下FairSync的定义：\n\n/**\n * Sync object for fair locks\n */\nstatic final class FairSync extends Sync {\n    private static final long serialVersionUID = -3000897897090466540L;\n\n    final void lock() {\n        acquire(1);\n    }\n\n    /**\n     * Fair version of tryAcquire.  Don\'t grant access unless\n     * recursive call or no waiters or is first.\n     */\n    protected final boolean tryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        // 获取state\n        int c = getState();\n        // state=0表示当前队列中没有线程被加锁\n        if (c == 0) {\n            /*\n             * 首先判断是否有前继结点，如果没有则当前队列中还没有其他线程；\n             * 设置状态为acquires，即lock方法中写死的1（这里为什么不直接setState？因为可能同时有多个线程同时在执行到此处，所以用CAS来执行）；\n             * 设置当前线程独占锁。\n             */\n            if (!hasQueuedPredecessors() &&\n                compareAndSetState(0, acquires)) {\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        /*\n         * 如果state不为0，表示已经有线程独占锁了，这时还需要判断独占锁的线程是否是当前的线程，原因是由于ReentrantLock为可重入锁；\n         * 如果独占锁的线程是当前线程，则将状态加1，并setState;\n         * 这里为什么不用compareAndSetState？因为独占锁的线程已经是当前线程，不需要通过CAS来设置。\n         */\n        else if (current == getExclusiveOwnerThread()) {\n            int nextc = c + acquires;\n            if (nextc < 0)\n                throw new Error("Maximum lock count exceeded");\n            setState(nextc);\n            return true;\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 5、AQS获取独占锁的实现\n\n\n# acquire方法\n\nacquire是AQS中的方法，代码如下：\n\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) &&\n        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n        selfInterrupt();\n}\n\n\n1\n2\n3\n4\n5\n\n\n该方法主要工作如下：\n\n 1. 尝试获取独占锁；\n 2. 获取成功则返回，否则执行步骤3;\n 3. addWaiter方法将当前线程封装成Node对象，并添加到队列尾部；\n 4. 自旋获取锁，并判断中断标志位。如果中断标志位为true，执行步骤5，否则返回；\n 5. 设置线程中断。\n\n\n# tryAcquire方法\n\ntryAcquire方法在FairSync中已经说明，它重写了AQS中的方法，在AQS中它的定义如下：\n\nprotected boolean tryAcquire(int arg) {\n    throw new UnsupportedOperationException();\n}\n\n\n1\n2\n3\n\n\n既然该方法需要子类来实现，为什么不使用abstract来修饰呢？上文中提到过，AQS有两种功能：独占和共享，而且子类只能实现其一种功能，所以，如果使用abstract来修饰，那么每个子类都需要同时实现两种功能的方法，这对子类来说不太友好，所以没有使用abstract来修饰。\n\n该方法是在ReentrantLock中的FairSync和NonfairSync的两个内部类来实现的，这里以FairSysc-公平锁来说明：\n\nprotected final boolean tryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (!hasQueuedPredecessors() &&\n            compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new Error("Maximum lock count exceeded");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# addWaiter方法\n\n看下addWaiter方法的定义：\n\nprivate Node addWaiter(Node mode) {\n    // 根据当前线程创建一个Node对象\n    Node node = new Node(Thread.currentThread(), mode);\n    // Try the fast path of enq; backup to full enq on failure\n    Node pred = tail;\n    // 判断tail是否为空，如果为空表示队列是空的，直接enq\n    if (pred != null) {\n        node.prev = pred;\n        // 这里尝试CAS来设置队尾，如果成功则将当前节点设置为tail，否则enq\n        if (compareAndSetTail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    enq(node);\n    return node;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n分析可以看上面的注释。程序的逻辑主要分为两个部分：\n\n 1. 当前同步队列的尾节点为null，调用方法enq()插入;\n 2. 当前队列的尾节点不为null，则采用尾插入（compareAndSetTail()方法）的方式入队。\n\n另外还会有另外一个问题：如果 if (compareAndSetTail(pred, node))为false怎么办？会继续执行到enq()方法，同时很明显compareAndSetTail是一个CAS操作，通常来说如果CAS操作失败会继续自旋（死循环）进行重试。因此，经过我们这样的分析，enq()方法可能承担两个任务：\n\n 1. 处理当前同步队列尾节点为null时进行入队操作；\n 2. 如果CAS尾插入节点失败后负责自旋进行尝试。那么是不是真的就像我们分析的一样了？只有源码会告诉我们答案。\n\n\n# enq方法\n\nprivate Node enq(final Node node) {\n    // 重复直到成功\n    for (;;) {\n        Node t = tail;\n        // 如果tail为null，则必须创建一个Node节点并进行初始化\n        if (t == null) { // Must initialize\n            if (compareAndSetHead(new Node()))\n                tail = head;\n        } else {\n            node.prev = t;\n            // 尝试CAS来设置队尾\n            if (compareAndSetTail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n在上面的分析中我们可以看出会先创建头结点，说明同步队列是带头结点的链式存储结构。带头结点与不带头结点相比，会在入队和出队的操作中获得更大的便捷性，因此同步队列选择了带头结点的链式存储结构。那么带头节点的队列初始化时机是什么？自然而然是在tail为null时，即当前线程是第一次插入同步队列。compareAndSetTail(t, node)方法会利用CAS操作设置尾节点，如果CAS操作失败会在for (;;)死循环中不断尝试，直至成功return返回为止。因此，对enq()方法可以做这样的总结：\n\n 1. 在当前线程是第一个加入同步队列时，调用compareAndSetHead(new Node())方法，完成链式队列的头结点的初始化；\n 2. 自旋不断尝试CAS尾插入节点直至成功为止。\n\n现在我们已经很清楚获取独占式锁失败的线程包装成Node然后插入同步队列的过程了？那么紧接着会有下一个问题？在同步队列中的节点（线程）会做什么事情了来保证自己能够有机会获得独占式锁了？带着这样的问题我们就来看看acquireQueued()方法。\n\n\n# acquireQueued方法\n\n该方法的功能是循环的尝试获取锁，直到成功为止，最后返回中断标志位。\n\nfinal boolean acquireQueued(final Node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            // 1. 获得当前节点的先驱节点\n            final Node p = node.predecessor();\n            // 2. 当前节点能否获取独占式锁\n            // 2.1 如果当前节点的先驱节点是头结点并且成功获取同步状态，即可以获得独占式锁\n            if (p == head && tryAcquire(arg)) {\n                //队列头指针用指向当前节点\n                setHead(node);\n                //释放前驱节点\n                p.next = null; // help GC\n                failed = false;\n                return interrupted;\n            }\n            // 2.2 获取锁失败，线程进入等待状态等待获取独占式锁\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n程序逻辑通过注释已经标出，整体来看这是一个这又是一个自旋的过程（for (;😉），代码首先获取当前节点的先驱节点，如果先驱节点是头结点的并且成功获得同步状态的时候（if (p == head && tryAcquire(arg))），当前节点所指向的线程能够获取锁。反之，获取锁失败进入等待状态。整体示意图为下图：\n\n\n\n获取锁的节点出队的逻辑是acquireQueued方法中的如下代码：\n\n//队列头结点引用指向当前节点\nsetHead(node);\n//释放前驱节点\np.next = null; // help GC\nfailed = false;\nreturn interrupted;\n\n\n1\n2\n3\n4\n5\n6\n\n\nsetHead()方法为：\n\nprivate void setHead(Node node) {\n    head = node;\n    node.thread = null;\n    node.prev = null;\n}Copy to clipboardErrorCopied\n\n\n1\n2\n3\n4\n5\n\n\n将当前节点通过setHead()方法设置为队列的头结点，然后将之前的头结点的next域设置为null并且pre域也为null，即与队列断开，无任何引用方便GC时能够将内存进行回收。示意图如下：\n\n\n\n\n# 获取锁失败\n\n那么当获取锁失败的时候会调用shouldParkAfterFailedAcquire()方法和parkAndCheckInterrupt()方法，看看他们做了什么事情。看下shouldParkAfterFailedAcquire方法的代码：\n\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;\n    if (ws == Node.SIGNAL)\n        /*\n         * This node has already set status asking a release\n         * to signal it, so it can safely park.\n         */\n        return true;\n    if (ws > 0) {\n        /*\n         * Predecessor was cancelled. Skip over predecessors and\n         * indicate retry.\n         */\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n        /*\n         * waitStatus must be 0 or PROPAGATE.  Indicate that we\n         * need a signal, but don\'t park yet.  Caller will need to\n         * retry to make sure it cannot acquire before parking.\n         */\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nshouldParkAfterFailedAcquire()方法主要逻辑是使用compareAndSetWaitStatus(pred, ws, Node.SIGNAL)使用CAS将节点状态由INITIAL设置成SIGNAL，表示当前线程阻塞。当compareAndSetWaitStatus设置失败则说明shouldParkAfterFailedAcquire方法返回false，然后会在acquireQueued()方法中for (;;)死循环中会继续重试，直至compareAndSetWaitStatus设置节点状态位为SIGNAL时shouldParkAfterFailedAcquire返回true时才会执行方法parkAndCheckInterrupt()方法，该方法的源码为：\n\nprivate final boolean parkAndCheckInterrupt() {\n    LockSupport.park(this);\n    return Thread.interrupted();\n}\n\n\n1\n2\n3\n4\n\n\n该方法的关键是会调用LookSupport.park()方法（关于LookSupport会在以后的文章进行讨论），该方法是用来阻塞当前线程的，然后返回线程的中断状态并复位中断状态。\n\n> 注意interrupted()方法的作用，该方法是获取线程的中断状态，并复位，也就是说，如果当前线程是中断状态，则第一次调用该方法获取的是true，第二次则是false。而isInterrupted()方法则只是返回线程的中断状态，不执行复位操作。\n\n如果acquireQueued执行完毕，返回中断状态，回到acquire方法中，根据返回的中断状态判断是否需要执行Thread.currentThread().interrupt()。\n\n为什么要多做这一步呢？先判断中断状态，然后复位，如果之前线程是中断状态，再进行中断？\n\n这里就要介绍一下park方法了。park方法是Unsafe类中的方法，与之对应的是unpark方法。简单来说，当前线程如果执行了park方法，也就是阻塞了当前线程，反之，unpark就是唤醒一个线程。\n\n具体的说明请参考博客\n\npark与wait的作用类似，但是对中断状态的处理并不相同。如果当前线程不是中断的状态，park与wait的效果是一样的；如果一个线程是中断的状态，这时执行wait方法会报java.lang.IllegalMonitorStateException，而执行park时并不会报异常，而是直接返回。\n\n所以，知道了这一点，就可以知道为什么要进行中断状态的复位了：\n\n * 如果当前线程是非中断状态，则在执行park时被阻塞，这是返回中断状态是false；\n * 如果当前线程是中断状态，则park方法不起作用，会立即返回，然后parkAndCheckInterrupt方法会获取中断的状态，也就是true，并复位；\n * 再次执行循环的时候，由于在前一步已经把该线程的中断状态进行了复位，则再次调用park方法时会阻塞。\n\n所以，这里判断线程中断的状态实际上是为了不让循环一直执行，要让当前线程进入阻塞的状态。想象一下，如果不这样判断，前一个线程在获取锁之后执行了很耗时的操作，那么岂不是要一直执行该死循环？这样就造成了CPU使用率飙升，这是很严重的后果。\n\n\n# cancelAcquire方法\n\n在acquireQueued方法的finally语句块中，如果在循环的过程中出现了异常，则执行cancelAcquire方法，用于将该节点标记为取消状态。该方法代码如下：\n\nprivate void cancelAcquire(Node node) {\n    // Ignore if node doesn\'t exist\n    if (node == null)\n        return;\n    // 设置该节点不再关联任何线程\n    node.thread = null;\n\n    // Skip cancelled predecessors\n    // 通过前继节点跳过取消状态的node\n    Node pred = node.prev;\n    while (pred.waitStatus > 0)\n        node.prev = pred = pred.prev;\n\n    // predNext is the apparent node to unsplice. CASes below will\n    // fail if not, in which case, we lost race vs another cancel\n    // or signal, so no further action is necessary.\n    // 获取过滤后的前继节点的后继节点\n    Node predNext = pred.next;\n\n    // Can use unconditional write instead of CAS here.\n    // After this atomic step, other Nodes can skip past us.\n    // Before, we are free of interference from other threads.\n    // 设置状态为取消状态\n    node.waitStatus = Node.CANCELLED;\n\n    /*\n     * If we are the tail, remove ourselves.\n     * 1.如果当前节点是tail：\n     * 尝试更新tail节点，设置tail为pred；\n     * 更新失败则返回，成功则设置tail的后继节点为null\n     */\n    if (node == tail && compareAndSetTail(node, pred)) {\n        compareAndSetNext(pred, predNext, null);\n    } else {\n        // If successor needs signal, try to set pred\'s next-link\n        // so it will get one. Otherwise wake it up to propagate.\n        int ws;\n        /*\n         * 2.如果当前节点不是head的后继节点：\n         * 判断当前节点的前继节点的状态是否是SIGNAL，如果不是则尝试设置前继节点的状态为SIGNAL；\n         * 上面两个条件如果有一个返回true，则再判断前继节点的thread是否不为空；\n         * 若满足以上条件，则尝试设置当前节点的前继节点的后继节点为当前节点的后继节点，也就是相当于将当前节点从队列中删除\n         */\n        if (pred != head &&\n            ((ws = pred.waitStatus) == Node.SIGNAL ||\n             (ws <= 0 && compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &&\n            pred.thread != null) {\n            Node next = node.next;\n            if (next != null && next.waitStatus <= 0)\n                compareAndSetNext(pred, predNext, next);\n        } else {\n            // 3.如果是head的后继节点或者状态判断或设置失败，则唤醒当前节点的后继节点\n            unparkSuccessor(node);\n        }\n\n        node.next = node; // help GC\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n该方法中执行的过程有些复杂，首先是要获取当前节点的前继节点，如果前继节点的状态不是取消状态（即pred.waitStatus > 0），则向前遍历队列，直到遇到第一个waitStatus <= 0的节点，并把当前节点的前继节点设置为该节点，然后设置当前节点的状态为取消状态。\n\n接下来的工作可以分为3种情况：\n\n * 当前节点是tail；\n * 当前节点不是head的后继节点（即队列的第一个节点，不包括head），也不是tail；\n * 当前节点是head的后继节点。\n\n我们依次来分析一下：\n\n当前节点是tail\n\n这种情况很简单，因为tail是队列的最后一个节点，如果该节点需要取消，则直接把该节点的前继节点的next指向null，也就是把当前节点移除队列。出队的过程如下：\n\n\n\n注意：经验证，这里并没有设置node的prev为null。\n\n当前节点不是head的后继节点，也不是tail\n\n\n\n这里将node的前继节点的next指向了node的后继节点，真正执行的代码就是如下一行：\n\ncompareAndSetNext(pred, predNext, next);\n\n\n1\n\n\n当前节点是head的后继节点\n\n\n\n这里直接unpark后继节点的线程，然后将next指向了自己。\n\n这里可能会有疑问，既然要删除节点，为什么都没有对prev进行操作，而仅仅是修改了next？\n\n要明确的一点是，这里修改指针的操作都是CAS操作，在AQS中所有以compareAndSet开头的方法都是尝试更新，并不保证成功，图中所示的都是执行成功的情况。\n\n那么在执行cancelAcquire方法时，当前节点的前继节点有可能已经执行完并移除队列了（参见setHead方法），所以在这里只能用CAS来尝试更新，而就算是尝试更新，也只能更新next，不能更新prev，因为prev是不确定的，否则有可能会导致整个队列的不完整，例如把prev指向一个已经移除队列的node。\n\n什么时候修改prev呢？其实prev是由其他线程来修改的。回去看下shouldParkAfterFailedAcquire方法，该方法有这样一段代码：\n\ndo {\n    node.prev = pred = pred.prev;\n} while (pred.waitStatus > 0);\npred.next = node;\n\n\n1\n2\n3\n4\n\n\n该段代码的作用就是通过prev遍历到第一个不是取消状态的node，并修改prev。\n\n这里为什么可以更新prev？因为shouldParkAfterFailedAcquire方法是在获取锁失败的情况下才能执行，因此进入该方法时，说明已经有线程获得锁了，并且在执行该方法时，当前节点之前的节点不会变化（因为只有当下一个节点获得锁的时候才会设置head），所以这里可以更新prev，而且不必用CAS来更新。\n\n\n# AQS获取独占锁的大致流程图\n\n经过上面的分析，独占式锁的获取过程也就是acquire()方法的执行流程如下图所示：\n\n\n\n\n# 6、AQS释放独占锁的实现\n\n释放通过unlock方法来实现：\n\npublic void unlock() {\n    sync.release(1);\n}\n\n\n1\n2\n3\n\n\n该方法调用了release方法，release是在AQS中定义的，看下release代码：\n\npublic final boolean release(int arg) {\n    // 尝试释放锁\n    if (tryRelease(arg)) {\n        // 释放成功后unpark后继节点的线程\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这里首先尝试着去释放锁，成功了之后要去唤醒后继节点的线程，这样其他的线程才有机会去执行。\n\ntryRelease代码如下：\n\nprotected boolean tryRelease(int arg) {\n    throw new UnsupportedOperationException();\n}\n\n\n1\n2\n3\n\n\n是不是和tryAcquire方法类似？该方法也需要被重写，在Sync类中的代码如下：\n\nprotected final boolean tryRelease(int releases) {\n    // 这里是将锁的数量减1\n    int c = getState() - releases;\n    // 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常\n    if (Thread.currentThread() != getExclusiveOwnerThread())\n        throw new IllegalMonitorStateException();\n    boolean free = false;\n    // 由于重入的关系，不是每次释放锁c都等于0，\n    // 直到最后一次释放锁时，才会把当前线程释放\n    if (c == 0) {\n        free = true;\n        setExclusiveOwnerThread(null);\n    }\n    // 记录锁的数量\n    setState(c);\n    return free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n当前线程被释放之后，需要唤醒下一个节点的线程，通过unparkSuccessor方法来实现：\n\nprivate void unparkSuccessor(Node node) {\n    /*\n     * If status is negative (i.e., possibly needing signal) try\n     * to clear in anticipation of signalling.  It is OK if this\n     * fails or if status is changed by waiting thread.\n     */\n    int ws = node.waitStatus;\n    if (ws < 0)\n        compareAndSetWaitStatus(node, ws, 0);\n\n    /*\n     * Thread to unpark is held in successor, which is normally\n     * just the next node.  But if cancelled or apparently null,\n     * traverse backwards from tail to find the actual\n     * non-cancelled successor.\n     */\n    Node s = node.next;\n    if (s == null || s.waitStatus > 0) {\n        s = null;\n        for (Node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitStatus <= 0)\n                s = t;\n    }\n    if (s != null)\n        LockSupport.unpark(s.thread);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n主要功能就是要唤醒下一个线程，这里s == null || s.waitStatus > 0判断后继节点是否为空或者是否是取消状态，然后从队列尾部向前遍历找到最前面的一个waitStatus小于0的节点，至于为什么从尾部开始向前遍历，回想一下cancelAcquire方法的处理过程，cancelAcquire只是设置了next的变化，没有设置prev的变化，在最后有这样一行代码：node.next = node，如果这时执行了unparkSuccessor方法，并且向后遍历的话，就成了死循环了，所以这时只有prev是稳定的。\n\n到这里，通过ReentrantLock的lock和unlock来分析AQS独占锁的实现已经基本完成了，但ReentrantLock还有一个非公平锁NonfairSync。\n\n其实NonfairSync和FairSync主要就是在获取锁的方式上不同，公平锁是按顺序去获取，而非公平锁是抢占式的获取，lock的时候先去尝试修改state变量，如果抢占成功，则获取到锁：\n\nfinal void lock() {\n    if (compareAndSetState(0, 1))\n        setExclusiveOwnerThread(Thread.currentThread());\n    else\n        acquire(1);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n非公平锁的tryAcquire方法调用了nonfairTryAcquire方法：\n\nfinal boolean nonfairTryAcquire(int acquires) {\n    final Thread current = Thread.currentThread();\n    int c = getState();\n    if (c == 0) {\n        if (compareAndSetState(0, acquires)) {\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n    }\n    else if (current == getExclusiveOwnerThread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new Error("Maximum lock count exceeded");\n        setState(nextc);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n该方法比公平锁的tryAcquire方法在第二个if判断中少了一个是否存在前继节点判断，FairSync中的tryAcquire代码中的这个if语句块如下：\n\nif (!hasQueuedPredecessors() &&\n    compareAndSetState(0, acquires)) {\n    setExclusiveOwnerThread(current);\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n\n\n到现在我们终于啃下了一块硬骨头了，通过学习源码的方式非常深刻的学习到了独占式锁的获取和释放的过程以及同步队列。可以做一下总结：\n\n 1. 线程获取锁失败，线程被封装成Node进行入队操作，核心方法在于addWaiter()和enq()，同时enq()完成对同步队列的头结点初始化工作以及CAS操作失败的重试;\n 2. 线程获取锁是一个自旋的过程，只有当前节点的前驱节点是头结点并且成功获得同步状态时，节点出队即该节点引用的线程获得锁，否则，当不满足条件时就会调用LookSupport.park()方法使得线程阻塞；\n 3. 释放锁的时候会唤醒后继节点；\n\n总体来说：在获取同步状态时，AQS维护一个同步队列，获取同步状态失败的线程会加入到队列中进行自旋；移除队列（或停止自旋）的条件是前驱节点是头结点并且成功获得了同步状态。在释放同步状态时，同步器会调用unparkSuccessor()方法唤醒后继节点。\n\n\n# 7、独占锁特性学习\n\n\n# 可中断式获取锁（acquireInterruptibly方法）\n\n我们知道lock相较于synchronized有一些更方便的特性，比如能响应中断以及超时等待等特性，现在我们依旧采用通过学习源码的方式来看看能够响应中断是怎么实现的。可响应中断式锁可调用方法lock.lockInterruptibly();而该方法其底层会调用AQS的acquireInterruptibly方法，源码为：\n\npublic final void acquireInterruptibly(int arg) throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (!tryAcquire(arg))\n        //线程获取锁失败\n        doAcquireInterruptibly(arg);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在获取同步状态失败后就会调用doAcquireInterruptibly方法：\n\nprivate void doAcquireInterruptibly(int arg)\n    throws InterruptedException {\n    //将节点插入到同步队列中\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            //获取锁出队\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return;\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                //线程中断抛异常\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n关键信息请看注释，现在看这段代码就很轻松了，与acquire方法逻辑几乎一致，唯一的区别是当parkAndCheckInterrupt返回true时即线程阻塞时该线程被中断，代码抛出被中断异常。\n\n\n# 超时等待式获取锁（tryAcquireNanos()方法）\n\n通过调用lock.tryLock(timeout,TimeUnit)方式达到超时等待获取锁的效果，该方法会在三种情况下才会返回：\n\n 1. 在超时时间内，当前线程成功获取了锁；\n 2. 当前线程在超时时间内被中断；\n 3. 超时时间结束，仍未获得锁返回false。\n\n我们仍然通过采取阅读源码的方式来学习底层具体是怎么实现的，该方法会调用AQS的方法tryAcquireNanos(),源码为：\n\npublic final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    return tryAcquire(arg) ||\n        //实现超时等待的效果\n        doAcquireNanos(arg, nanosTimeout);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n很显然这段源码最终是靠doAcquireNanos方法实现超时等待的效果，该方法源码如下：\n\nprivate boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException {\n    if (nanosTimeout <= 0L)\n        return false;\n    //1. 根据超时时间和当前时间计算出截止时间\n    final long deadline = System.nanoTime() + nanosTimeout;\n    final Node node = addWaiter(Node.EXCLUSIVE);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            //2. 当前线程获得锁出队列\n            if (p == head && tryAcquire(arg)) {\n                setHead(node);\n                p.next = null; // help GC\n                failed = false;\n                return true;\n            }\n            // 3.1 重新计算超时时间\n            nanosTimeout = deadline - System.nanoTime();\n            // 3.2 已经超时返回false\n            if (nanosTimeout <= 0L)\n                return false;\n            // 3.3 线程阻塞等待\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                nanosTimeout > spinForTimeoutThreshold)\n                LockSupport.parkNanos(this, nanosTimeout);\n            // 3.4 线程被中断抛出被中断异常\n            if (Thread.interrupted())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n程序逻辑如图所示：\n\n\n\n程序逻辑同独占锁可响应中断式获取基本一致，唯一的不同在于获取锁失败后，对超时时间的处理上，在第1步会先计算出按照现在时间和超时时间计算出理论上的截止时间，比如当前时间是8h10min，超时时间是10min，那么根据deadline = System.nanoTime() + nanosTimeout计算出刚好达到超时时间时的系统时间就是8h 10min+10min = 8h 20min。然后根据deadline - System.nanoTime()就可以判断是否已经超时了，比如，当前系统时间是8h 30min很明显已经超过了理论上的系统时间8h 20min，deadline - System.nanoTime()计算出来就是一个负数，自然而然会在3.2步中的If判断之间返回false。如果还没有超时即3.2步中的if判断为true时就会继续执行3.3步通过LockSupport.parkNanos使得当前线程阻塞，同时在3.4步增加了对中断的检测，若检测出被中断直接抛出被中断异常。\n\n\n# 8、共享锁\n\n\n# 共享锁的获取（acquireShared()方法）\n\n在聊完AQS对独占锁的实现后，我们继续一鼓作气的来看看共享锁是怎样实现的？共享锁的获取方法为acquireShared，源码为：\n\npublic final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) < 0)\n        doAcquireShared(arg);\n}\n\n\n1\n2\n3\n4\n\n\n这段源码的逻辑很容易理解，在该方法中会首先调用tryAcquireShared方法，tryAcquireShared返回值是一个int类型，当返回值为大于等于0的时候方法结束说明获得成功获取锁，否则，表明获取同步状态失败即所引用的线程获取锁失败，会执行doAcquireShared方法，该方法的源码为：\n\nprivate void doAcquireShared(int arg) {\n    final Node node = addWaiter(Node.SHARED);\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head) {\n                int r = tryAcquireShared(arg);\n                if (r >= 0) {\n                    // 当该节点的前驱节点是头结点且成功获取同步状态\n                    setHeadAndPropagate(node, r);\n                    p.next = null; // help GC\n                    if (interrupted)\n                        selfInterrupt();\n                    failed = false;\n                    return;\n                }\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n现在来看这段代码会不会很容易了？逻辑几乎和独占式锁的获取一模一样，这里的自旋过程中能够退出的条件是当前节点的前驱节点是头结点并且tryAcquireShared(arg)返回值大于等于0即能成功获得同步状态。\n\n\n# 共享锁的释放（releaseShared()方法）\n\n共享锁的释放在AQS中会调用方法releaseShared：\n\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当成功释放同步状态之后即tryReleaseShared会继续执行doReleaseShared方法：\n\nprivate void doReleaseShared() {\n    /*\n     * Ensure that a release propagates, even if there are other\n     * in-progress acquires/releases.  This proceeds in the usual\n     * way of trying to unparkSuccessor of head if it needs\n     * signal. But if it does not, status is set to PROPAGATE to\n     * ensure that upon release, propagation continues.\n     * Additionally, we must loop in case a new node is added\n     * while we are doing this. Also, unlike other uses of\n     * unparkSuccessor, we need to know if CAS to reset status\n     * fails, if so rechecking.\n     */\n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitStatus;\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;            // loop to recheck cases\n                unparkSuccessor(h);\n            }\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;                // loop on failed CAS\n        }\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n这段方法跟独占式锁释放过程有点点不同，在共享式锁的释放过程中，对于能够支持多个线程同时访问的并发组件，必须保证多个线程能够安全的释放同步状态，这里采用的CAS保证，当CAS操作失败continue，在下一次循环中进行重试。\n\n\n# 可中断（acquireSharedInterruptibly()方法），超时等待（tryAcquireSharedNanos()方法）\n\n关于可中断锁以及超时等待的特性其实现和独占式锁可中断获取锁以及超时等待的实现几乎一致，具体的就不再说了，如果理解了上面的内容对这部分的理解也是水到渠成的。\n\n> 参考文献\n\n《java并发编程的艺术》\n\n深入理解AbstractQueuedSynchronizer（一）',normalizedContent:'说明\n\n深入理解abstractqueuedsynchronizer(aqs)\n\n\n\n * 同步队列\n * aqs的state变量\n * acquire方法\n * tryacquire方法\n * addwaiter方法\n * enq方法\n * acquirequeued方法\n * 获取锁失败\n * cancelacquire方法\n * aqs获取独占锁的大致流程图\n * 可中断式获取锁（acquireinterruptibly方法）\n * 超时等待式获取锁（tryacquirenanos()方法）\n * 共享锁的获取（acquireshared()方法）\n * 共享锁的释放（releaseshared()方法）\n * 可中断（acquiresharedinterruptibly()方法），超时等待（tryacquiresharednanos()方法）\n\n\n\n\n# 深入理解abstractqueuedsynchronizer(aqs)\n\n\n\n\n# 1、aqs简介\n\n在上一篇文章中我们对lock和abstractqueuedsynchronizer(aqs)有了初步的认识。在同步组件的实现中，aqs是核心部分，同步组件的实现者通过使用aqs提供的模板方法实现同步组件语义，aqs则实现了对同步状态的管理，以及对阻塞线程进行排队，等待通知等等一些底层的实现处理。aqs的核心也包括了这些方面：同步队列，独占式锁的获取和释放，共享锁的获取和释放以及可中断锁，超时等待锁获取这些特性的实现，而这些实际上则是aqs提供出来的模板方法，归纳整理如下：\n\nabstractqueuedsynchronizer提供了一个fifo队列，可以看做是一个可以用来实现锁以及其他需要同步功能的框架。aqs的使用依靠继承来完成，子类通过继承自aqs并实现所需的方法来管理同步状态。例如reentrantlock，countdownlatch等。\n\n本篇文章基于jdk1.8来介绍，该类有许多实现类：\n\n\n\n其中，我们最常用的大概就是reentrantlock和countdownlatch了。reentrantlock提供了对代码块的并发访问控制，也就是锁，说是锁，但其实并没有用到关键字synchronized，这么神奇？其实其内部就是基于同步器来实现的，本文结合reentrantlock的使用来分析同步器独占锁的原理。\n\n\n# 2、aqs的两种功能\n\n从使用上来说，aqs的功能可以分为两种：独占和共享。对于这两种功能，有一个很常用的类：reentrantreadwritelock，其就是通过两个内部类来分别实现了这两种功能，提供了读锁和写锁的功能。但子类实现时，只能实现其中的一种功能，即要么是独占功能，要么是共享功能。\n\n对于独占功能，例如如下代码：\n\nreentrantlock lock = new reentrantlock();\n...\n\npublic void function(){\n\n    lock.lock();\n    try {\n\n    // do something...\n\n\n    } finally {\n        lock.unlock();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这个很好理解，通过reentrantlock来保证在lock.lock()之后的代码在同一时刻只能有一个线程来执行，其余的线程将会被阻塞，直到该线程执行了lock.unlock()。这就是一个独占锁的功能。\n\n对于共享功能，例如如下代码：\n\nreentrantreadwritelock lock = new reentrantreadwritelock();\n...\n\npublic void function(){\n\n    lock.readlock().lock();\n    try {\n\n    // do something...\n\n\n    } finally {\n        lock.readlock().unlock();\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n代码中的lock是reentrantreadwritelock类的实例，而lock.readlock()为获取其中的读锁，即共享锁，使用方式并无差别，但和独占锁是有区别的：\n\n * 读锁与读锁可以共享\n * 读锁与写锁不可以共享（排他）\n * 写锁与写锁不可以共享（排他）\n\n\n# 3、aqs的主要数据结构\n\n\n# 同步队列\n\n当共享资源被某个线程占有，其他请求该资源的线程将会阻塞，从而进入同步队列。就数据结构而言，队列的实现方式无外乎两者一是通过数组的形式，另外一种则是链表的形式。aqs中的同步队列则是通过链式方式进行实现。接下来，很显然我们至少会抱有这样的疑问：\n\n 1. 节点的数据结构是什么样的？\n 2. 是单向还是双向？\n 3. 是带头结点的还是不带头节点的？\n\n我们依旧先是通过看源码的方式：\n\n在aqs有一个静态内部类node，其中有这样一些属性：\n\nstatic final class node {\n    int waitstatus;\n    node prev;\n    node next;\n    node nextwaiter;\n    thread thread;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n * waitstatus：表示节点的状态，其中包含的状态有：\n   * cancelled：值为1，表示当前节点被取消；\n   * signal：值为-1，表示当前节点的的后继节点将要或者已经被阻塞，在当前节点释放的时候需要unpark后继节点；\n   * condition：值为-2，表示当前节点在等待condition，即在condition队列中；\n   * propagate：值为-3，表示releaseshared需要被传播给后续节点（仅在共享模式下使用）；\n   * 0：无状态，表示当前节点在队列中等待获取锁。\n * prev：前继节点；\n * next：后继节点；\n * nextwaiter：存储condition队列中的后继节点；\n * thread：当前线程。\n\n节点是构成同步队列的基础，同步器拥有首节点（head）和尾节点（tail），没有成功获取同步状态的线程将会成为节点加入该队列的尾部，同步队列的基本结构如图所示：\n\n\n\n如图，同步器包含了两个节点类型的引用，一个指向头节点，而另一个指向尾节点。试想一下，当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于cas的设置尾节点的方法：compareandsettail(node expect,nodeupdate)，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。\n\n\n\n同步队列遵循fifo，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，将会唤醒后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点，该过程如图所示：\n\n\n\n如图，设置首节点是通过获取同步状态成功的线程来完成的，由于只有一个线程能够成功获取到同步状态，因此设置头节点的方法并不需要使用cas来保证，它只需要将首节点设置成为原首节点的后继节点并断开原首节点的next引用即可。\n\n现在我们可以清楚的知道这样几点：\n\n 1. 节点的数据结构，即aqs的静态内部类node，节点的等待状态等信息；\n 2. 同步队列是一个双向队列，aqs通过持有头尾指针管理同步队列；\n 3. 节点的入队和出队实际上对应着锁的获取和释放两个操作：获取锁失败进行入队操作，获取锁成功进行出队操作。\n\n\n# aqs的state变量\n\naqs中有一个state变量，该变量对不同的子类实现具有不同的意义，对reentrantlock来说，它表示加锁的状态：\n\n * 无锁时state=0，有锁时state>0；\n * 第一次加锁时，将state设置为1；\n * 由于reentrantlock是可重入锁，所以持有锁的线程可以多次加锁，经过判断加锁线程就是当前持有锁的线程时（即exclusiveownerthread==thread.currentthread()），即可加锁，每次加锁都会将state的值+1，state等于几，就代表当前持有锁的线程加了几次锁；\n * 解锁时每解一次锁就会将state减1，state减到0后，锁就被释放掉，这时其它线程可以加锁；\n * 当持有锁的线程释放锁以后，如果是等待队列获取到了加锁权限，则会在等待队列头部取出第一个线程去获取锁，获取锁的线程会被移出队列；\n\nstate变量定义如下：\n\n/**\n * the synchronization state.\n */\nprivate volatile int state;\n\n\n1\n2\n3\n4\n\n\n\n# 4、reentrantlock类的结构\n\n下面通过reentrantlock的实现进一步分析重入锁的实现。\n\n首先看一下lock方法：\n\npublic void lock() {\n    sync.lock();\n}\n\n\n1\n2\n3\n\n\n该方法调用了sync实例的lock方法，这里要说明一下reentrantlock中的几个内部类：\n\n * sync\n * fairsync\n * nonfairsync\n\n对于reentrantlock，有两种获取锁的模式：公平锁和非公平锁。所以对应有两个内部类，都继承自sync。而sync继承自aqs：\n\n\n\n本文主要通过公平锁来介绍，看一下fairsync的定义：\n\n/**\n * sync object for fair locks\n */\nstatic final class fairsync extends sync {\n    private static final long serialversionuid = -3000897897090466540l;\n\n    final void lock() {\n        acquire(1);\n    }\n\n    /**\n     * fair version of tryacquire.  don\'t grant access unless\n     * recursive call or no waiters or is first.\n     */\n    protected final boolean tryacquire(int acquires) {\n        final thread current = thread.currentthread();\n        // 获取state\n        int c = getstate();\n        // state=0表示当前队列中没有线程被加锁\n        if (c == 0) {\n            /*\n             * 首先判断是否有前继结点，如果没有则当前队列中还没有其他线程；\n             * 设置状态为acquires，即lock方法中写死的1（这里为什么不直接setstate？因为可能同时有多个线程同时在执行到此处，所以用cas来执行）；\n             * 设置当前线程独占锁。\n             */\n            if (!hasqueuedpredecessors() &&\n                compareandsetstate(0, acquires)) {\n                setexclusiveownerthread(current);\n                return true;\n            }\n        }\n        /*\n         * 如果state不为0，表示已经有线程独占锁了，这时还需要判断独占锁的线程是否是当前的线程，原因是由于reentrantlock为可重入锁；\n         * 如果独占锁的线程是当前线程，则将状态加1，并setstate;\n         * 这里为什么不用compareandsetstate？因为独占锁的线程已经是当前线程，不需要通过cas来设置。\n         */\n        else if (current == getexclusiveownerthread()) {\n            int nextc = c + acquires;\n            if (nextc < 0)\n                throw new error("maximum lock count exceeded");\n            setstate(nextc);\n            return true;\n        }\n        return false;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 5、aqs获取独占锁的实现\n\n\n# acquire方法\n\nacquire是aqs中的方法，代码如下：\n\npublic final void acquire(int arg) {\n    if (!tryacquire(arg) &&\n        acquirequeued(addwaiter(node.exclusive), arg))\n        selfinterrupt();\n}\n\n\n1\n2\n3\n4\n5\n\n\n该方法主要工作如下：\n\n 1. 尝试获取独占锁；\n 2. 获取成功则返回，否则执行步骤3;\n 3. addwaiter方法将当前线程封装成node对象，并添加到队列尾部；\n 4. 自旋获取锁，并判断中断标志位。如果中断标志位为true，执行步骤5，否则返回；\n 5. 设置线程中断。\n\n\n# tryacquire方法\n\ntryacquire方法在fairsync中已经说明，它重写了aqs中的方法，在aqs中它的定义如下：\n\nprotected boolean tryacquire(int arg) {\n    throw new unsupportedoperationexception();\n}\n\n\n1\n2\n3\n\n\n既然该方法需要子类来实现，为什么不使用abstract来修饰呢？上文中提到过，aqs有两种功能：独占和共享，而且子类只能实现其一种功能，所以，如果使用abstract来修饰，那么每个子类都需要同时实现两种功能的方法，这对子类来说不太友好，所以没有使用abstract来修饰。\n\n该方法是在reentrantlock中的fairsync和nonfairsync的两个内部类来实现的，这里以fairsysc-公平锁来说明：\n\nprotected final boolean tryacquire(int acquires) {\n    final thread current = thread.currentthread();\n    int c = getstate();\n    if (c == 0) {\n        if (!hasqueuedpredecessors() &&\n            compareandsetstate(0, acquires)) {\n            setexclusiveownerthread(current);\n            return true;\n        }\n    }\n    else if (current == getexclusiveownerthread()) {\n        int nextc = c + acquires;\n        if (nextc < 0)\n            throw new error("maximum lock count exceeded");\n        setstate(nextc);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# addwaiter方法\n\n看下addwaiter方法的定义：\n\nprivate node addwaiter(node mode) {\n    // 根据当前线程创建一个node对象\n    node node = new node(thread.currentthread(), mode);\n    // try the fast path of enq; backup to full enq on failure\n    node pred = tail;\n    // 判断tail是否为空，如果为空表示队列是空的，直接enq\n    if (pred != null) {\n        node.prev = pred;\n        // 这里尝试cas来设置队尾，如果成功则将当前节点设置为tail，否则enq\n        if (compareandsettail(pred, node)) {\n            pred.next = node;\n            return node;\n        }\n    }\n    enq(node);\n    return node;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n分析可以看上面的注释。程序的逻辑主要分为两个部分：\n\n 1. 当前同步队列的尾节点为null，调用方法enq()插入;\n 2. 当前队列的尾节点不为null，则采用尾插入（compareandsettail()方法）的方式入队。\n\n另外还会有另外一个问题：如果 if (compareandsettail(pred, node))为false怎么办？会继续执行到enq()方法，同时很明显compareandsettail是一个cas操作，通常来说如果cas操作失败会继续自旋（死循环）进行重试。因此，经过我们这样的分析，enq()方法可能承担两个任务：\n\n 1. 处理当前同步队列尾节点为null时进行入队操作；\n 2. 如果cas尾插入节点失败后负责自旋进行尝试。那么是不是真的就像我们分析的一样了？只有源码会告诉我们答案。\n\n\n# enq方法\n\nprivate node enq(final node node) {\n    // 重复直到成功\n    for (;;) {\n        node t = tail;\n        // 如果tail为null，则必须创建一个node节点并进行初始化\n        if (t == null) { // must initialize\n            if (compareandsethead(new node()))\n                tail = head;\n        } else {\n            node.prev = t;\n            // 尝试cas来设置队尾\n            if (compareandsettail(t, node)) {\n                t.next = node;\n                return t;\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n在上面的分析中我们可以看出会先创建头结点，说明同步队列是带头结点的链式存储结构。带头结点与不带头结点相比，会在入队和出队的操作中获得更大的便捷性，因此同步队列选择了带头结点的链式存储结构。那么带头节点的队列初始化时机是什么？自然而然是在tail为null时，即当前线程是第一次插入同步队列。compareandsettail(t, node)方法会利用cas操作设置尾节点，如果cas操作失败会在for (;;)死循环中不断尝试，直至成功return返回为止。因此，对enq()方法可以做这样的总结：\n\n 1. 在当前线程是第一个加入同步队列时，调用compareandsethead(new node())方法，完成链式队列的头结点的初始化；\n 2. 自旋不断尝试cas尾插入节点直至成功为止。\n\n现在我们已经很清楚获取独占式锁失败的线程包装成node然后插入同步队列的过程了？那么紧接着会有下一个问题？在同步队列中的节点（线程）会做什么事情了来保证自己能够有机会获得独占式锁了？带着这样的问题我们就来看看acquirequeued()方法。\n\n\n# acquirequeued方法\n\n该方法的功能是循环的尝试获取锁，直到成功为止，最后返回中断标志位。\n\nfinal boolean acquirequeued(final node node, int arg) {\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            // 1. 获得当前节点的先驱节点\n            final node p = node.predecessor();\n            // 2. 当前节点能否获取独占式锁\n            // 2.1 如果当前节点的先驱节点是头结点并且成功获取同步状态，即可以获得独占式锁\n            if (p == head && tryacquire(arg)) {\n                //队列头指针用指向当前节点\n                sethead(node);\n                //释放前驱节点\n                p.next = null; // help gc\n                failed = false;\n                return interrupted;\n            }\n            // 2.2 获取锁失败，线程进入等待状态等待获取独占式锁\n            if (shouldparkafterfailedacquire(p, node) &&\n                parkandcheckinterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelacquire(node);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n程序逻辑通过注释已经标出，整体来看这是一个这又是一个自旋的过程（for (;😉），代码首先获取当前节点的先驱节点，如果先驱节点是头结点的并且成功获得同步状态的时候（if (p == head && tryacquire(arg))），当前节点所指向的线程能够获取锁。反之，获取锁失败进入等待状态。整体示意图为下图：\n\n\n\n获取锁的节点出队的逻辑是acquirequeued方法中的如下代码：\n\n//队列头结点引用指向当前节点\nsethead(node);\n//释放前驱节点\np.next = null; // help gc\nfailed = false;\nreturn interrupted;\n\n\n1\n2\n3\n4\n5\n6\n\n\nsethead()方法为：\n\nprivate void sethead(node node) {\n    head = node;\n    node.thread = null;\n    node.prev = null;\n}copy to clipboarderrorcopied\n\n\n1\n2\n3\n4\n5\n\n\n将当前节点通过sethead()方法设置为队列的头结点，然后将之前的头结点的next域设置为null并且pre域也为null，即与队列断开，无任何引用方便gc时能够将内存进行回收。示意图如下：\n\n\n\n\n# 获取锁失败\n\n那么当获取锁失败的时候会调用shouldparkafterfailedacquire()方法和parkandcheckinterrupt()方法，看看他们做了什么事情。看下shouldparkafterfailedacquire方法的代码：\n\nprivate static boolean shouldparkafterfailedacquire(node pred, node node) {\n    int ws = pred.waitstatus;\n    if (ws == node.signal)\n        /*\n         * this node has already set status asking a release\n         * to signal it, so it can safely park.\n         */\n        return true;\n    if (ws > 0) {\n        /*\n         * predecessor was cancelled. skip over predecessors and\n         * indicate retry.\n         */\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitstatus > 0);\n        pred.next = node;\n    } else {\n        /*\n         * waitstatus must be 0 or propagate.  indicate that we\n         * need a signal, but don\'t park yet.  caller will need to\n         * retry to make sure it cannot acquire before parking.\n         */\n        compareandsetwaitstatus(pred, ws, node.signal);\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\nshouldparkafterfailedacquire()方法主要逻辑是使用compareandsetwaitstatus(pred, ws, node.signal)使用cas将节点状态由initial设置成signal，表示当前线程阻塞。当compareandsetwaitstatus设置失败则说明shouldparkafterfailedacquire方法返回false，然后会在acquirequeued()方法中for (;;)死循环中会继续重试，直至compareandsetwaitstatus设置节点状态位为signal时shouldparkafterfailedacquire返回true时才会执行方法parkandcheckinterrupt()方法，该方法的源码为：\n\nprivate final boolean parkandcheckinterrupt() {\n    locksupport.park(this);\n    return thread.interrupted();\n}\n\n\n1\n2\n3\n4\n\n\n该方法的关键是会调用looksupport.park()方法（关于looksupport会在以后的文章进行讨论），该方法是用来阻塞当前线程的，然后返回线程的中断状态并复位中断状态。\n\n> 注意interrupted()方法的作用，该方法是获取线程的中断状态，并复位，也就是说，如果当前线程是中断状态，则第一次调用该方法获取的是true，第二次则是false。而isinterrupted()方法则只是返回线程的中断状态，不执行复位操作。\n\n如果acquirequeued执行完毕，返回中断状态，回到acquire方法中，根据返回的中断状态判断是否需要执行thread.currentthread().interrupt()。\n\n为什么要多做这一步呢？先判断中断状态，然后复位，如果之前线程是中断状态，再进行中断？\n\n这里就要介绍一下park方法了。park方法是unsafe类中的方法，与之对应的是unpark方法。简单来说，当前线程如果执行了park方法，也就是阻塞了当前线程，反之，unpark就是唤醒一个线程。\n\n具体的说明请参考博客\n\npark与wait的作用类似，但是对中断状态的处理并不相同。如果当前线程不是中断的状态，park与wait的效果是一样的；如果一个线程是中断的状态，这时执行wait方法会报java.lang.illegalmonitorstateexception，而执行park时并不会报异常，而是直接返回。\n\n所以，知道了这一点，就可以知道为什么要进行中断状态的复位了：\n\n * 如果当前线程是非中断状态，则在执行park时被阻塞，这是返回中断状态是false；\n * 如果当前线程是中断状态，则park方法不起作用，会立即返回，然后parkandcheckinterrupt方法会获取中断的状态，也就是true，并复位；\n * 再次执行循环的时候，由于在前一步已经把该线程的中断状态进行了复位，则再次调用park方法时会阻塞。\n\n所以，这里判断线程中断的状态实际上是为了不让循环一直执行，要让当前线程进入阻塞的状态。想象一下，如果不这样判断，前一个线程在获取锁之后执行了很耗时的操作，那么岂不是要一直执行该死循环？这样就造成了cpu使用率飙升，这是很严重的后果。\n\n\n# cancelacquire方法\n\n在acquirequeued方法的finally语句块中，如果在循环的过程中出现了异常，则执行cancelacquire方法，用于将该节点标记为取消状态。该方法代码如下：\n\nprivate void cancelacquire(node node) {\n    // ignore if node doesn\'t exist\n    if (node == null)\n        return;\n    // 设置该节点不再关联任何线程\n    node.thread = null;\n\n    // skip cancelled predecessors\n    // 通过前继节点跳过取消状态的node\n    node pred = node.prev;\n    while (pred.waitstatus > 0)\n        node.prev = pred = pred.prev;\n\n    // prednext is the apparent node to unsplice. cases below will\n    // fail if not, in which case, we lost race vs another cancel\n    // or signal, so no further action is necessary.\n    // 获取过滤后的前继节点的后继节点\n    node prednext = pred.next;\n\n    // can use unconditional write instead of cas here.\n    // after this atomic step, other nodes can skip past us.\n    // before, we are free of interference from other threads.\n    // 设置状态为取消状态\n    node.waitstatus = node.cancelled;\n\n    /*\n     * if we are the tail, remove ourselves.\n     * 1.如果当前节点是tail：\n     * 尝试更新tail节点，设置tail为pred；\n     * 更新失败则返回，成功则设置tail的后继节点为null\n     */\n    if (node == tail && compareandsettail(node, pred)) {\n        compareandsetnext(pred, prednext, null);\n    } else {\n        // if successor needs signal, try to set pred\'s next-link\n        // so it will get one. otherwise wake it up to propagate.\n        int ws;\n        /*\n         * 2.如果当前节点不是head的后继节点：\n         * 判断当前节点的前继节点的状态是否是signal，如果不是则尝试设置前继节点的状态为signal；\n         * 上面两个条件如果有一个返回true，则再判断前继节点的thread是否不为空；\n         * 若满足以上条件，则尝试设置当前节点的前继节点的后继节点为当前节点的后继节点，也就是相当于将当前节点从队列中删除\n         */\n        if (pred != head &&\n            ((ws = pred.waitstatus) == node.signal ||\n             (ws <= 0 && compareandsetwaitstatus(pred, ws, node.signal))) &&\n            pred.thread != null) {\n            node next = node.next;\n            if (next != null && next.waitstatus <= 0)\n                compareandsetnext(pred, prednext, next);\n        } else {\n            // 3.如果是head的后继节点或者状态判断或设置失败，则唤醒当前节点的后继节点\n            unparksuccessor(node);\n        }\n\n        node.next = node; // help gc\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n该方法中执行的过程有些复杂，首先是要获取当前节点的前继节点，如果前继节点的状态不是取消状态（即pred.waitstatus > 0），则向前遍历队列，直到遇到第一个waitstatus <= 0的节点，并把当前节点的前继节点设置为该节点，然后设置当前节点的状态为取消状态。\n\n接下来的工作可以分为3种情况：\n\n * 当前节点是tail；\n * 当前节点不是head的后继节点（即队列的第一个节点，不包括head），也不是tail；\n * 当前节点是head的后继节点。\n\n我们依次来分析一下：\n\n当前节点是tail\n\n这种情况很简单，因为tail是队列的最后一个节点，如果该节点需要取消，则直接把该节点的前继节点的next指向null，也就是把当前节点移除队列。出队的过程如下：\n\n\n\n注意：经验证，这里并没有设置node的prev为null。\n\n当前节点不是head的后继节点，也不是tail\n\n\n\n这里将node的前继节点的next指向了node的后继节点，真正执行的代码就是如下一行：\n\ncompareandsetnext(pred, prednext, next);\n\n\n1\n\n\n当前节点是head的后继节点\n\n\n\n这里直接unpark后继节点的线程，然后将next指向了自己。\n\n这里可能会有疑问，既然要删除节点，为什么都没有对prev进行操作，而仅仅是修改了next？\n\n要明确的一点是，这里修改指针的操作都是cas操作，在aqs中所有以compareandset开头的方法都是尝试更新，并不保证成功，图中所示的都是执行成功的情况。\n\n那么在执行cancelacquire方法时，当前节点的前继节点有可能已经执行完并移除队列了（参见sethead方法），所以在这里只能用cas来尝试更新，而就算是尝试更新，也只能更新next，不能更新prev，因为prev是不确定的，否则有可能会导致整个队列的不完整，例如把prev指向一个已经移除队列的node。\n\n什么时候修改prev呢？其实prev是由其他线程来修改的。回去看下shouldparkafterfailedacquire方法，该方法有这样一段代码：\n\ndo {\n    node.prev = pred = pred.prev;\n} while (pred.waitstatus > 0);\npred.next = node;\n\n\n1\n2\n3\n4\n\n\n该段代码的作用就是通过prev遍历到第一个不是取消状态的node，并修改prev。\n\n这里为什么可以更新prev？因为shouldparkafterfailedacquire方法是在获取锁失败的情况下才能执行，因此进入该方法时，说明已经有线程获得锁了，并且在执行该方法时，当前节点之前的节点不会变化（因为只有当下一个节点获得锁的时候才会设置head），所以这里可以更新prev，而且不必用cas来更新。\n\n\n# aqs获取独占锁的大致流程图\n\n经过上面的分析，独占式锁的获取过程也就是acquire()方法的执行流程如下图所示：\n\n\n\n\n# 6、aqs释放独占锁的实现\n\n释放通过unlock方法来实现：\n\npublic void unlock() {\n    sync.release(1);\n}\n\n\n1\n2\n3\n\n\n该方法调用了release方法，release是在aqs中定义的，看下release代码：\n\npublic final boolean release(int arg) {\n    // 尝试释放锁\n    if (tryrelease(arg)) {\n        // 释放成功后unpark后继节点的线程\n        node h = head;\n        if (h != null && h.waitstatus != 0)\n            unparksuccessor(h);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这里首先尝试着去释放锁，成功了之后要去唤醒后继节点的线程，这样其他的线程才有机会去执行。\n\ntryrelease代码如下：\n\nprotected boolean tryrelease(int arg) {\n    throw new unsupportedoperationexception();\n}\n\n\n1\n2\n3\n\n\n是不是和tryacquire方法类似？该方法也需要被重写，在sync类中的代码如下：\n\nprotected final boolean tryrelease(int releases) {\n    // 这里是将锁的数量减1\n    int c = getstate() - releases;\n    // 如果释放的线程和获取锁的线程不是同一个，抛出非法监视器状态异常\n    if (thread.currentthread() != getexclusiveownerthread())\n        throw new illegalmonitorstateexception();\n    boolean free = false;\n    // 由于重入的关系，不是每次释放锁c都等于0，\n    // 直到最后一次释放锁时，才会把当前线程释放\n    if (c == 0) {\n        free = true;\n        setexclusiveownerthread(null);\n    }\n    // 记录锁的数量\n    setstate(c);\n    return free;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n当前线程被释放之后，需要唤醒下一个节点的线程，通过unparksuccessor方法来实现：\n\nprivate void unparksuccessor(node node) {\n    /*\n     * if status is negative (i.e., possibly needing signal) try\n     * to clear in anticipation of signalling.  it is ok if this\n     * fails or if status is changed by waiting thread.\n     */\n    int ws = node.waitstatus;\n    if (ws < 0)\n        compareandsetwaitstatus(node, ws, 0);\n\n    /*\n     * thread to unpark is held in successor, which is normally\n     * just the next node.  but if cancelled or apparently null,\n     * traverse backwards from tail to find the actual\n     * non-cancelled successor.\n     */\n    node s = node.next;\n    if (s == null || s.waitstatus > 0) {\n        s = null;\n        for (node t = tail; t != null && t != node; t = t.prev)\n            if (t.waitstatus <= 0)\n                s = t;\n    }\n    if (s != null)\n        locksupport.unpark(s.thread);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n主要功能就是要唤醒下一个线程，这里s == null || s.waitstatus > 0判断后继节点是否为空或者是否是取消状态，然后从队列尾部向前遍历找到最前面的一个waitstatus小于0的节点，至于为什么从尾部开始向前遍历，回想一下cancelacquire方法的处理过程，cancelacquire只是设置了next的变化，没有设置prev的变化，在最后有这样一行代码：node.next = node，如果这时执行了unparksuccessor方法，并且向后遍历的话，就成了死循环了，所以这时只有prev是稳定的。\n\n到这里，通过reentrantlock的lock和unlock来分析aqs独占锁的实现已经基本完成了，但reentrantlock还有一个非公平锁nonfairsync。\n\n其实nonfairsync和fairsync主要就是在获取锁的方式上不同，公平锁是按顺序去获取，而非公平锁是抢占式的获取，lock的时候先去尝试修改state变量，如果抢占成功，则获取到锁：\n\nfinal void lock() {\n    if (compareandsetstate(0, 1))\n        setexclusiveownerthread(thread.currentthread());\n    else\n        acquire(1);\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n非公平锁的tryacquire方法调用了nonfairtryacquire方法：\n\nfinal boolean nonfairtryacquire(int acquires) {\n    final thread current = thread.currentthread();\n    int c = getstate();\n    if (c == 0) {\n        if (compareandsetstate(0, acquires)) {\n            setexclusiveownerthread(current);\n            return true;\n        }\n    }\n    else if (current == getexclusiveownerthread()) {\n        int nextc = c + acquires;\n        if (nextc < 0) // overflow\n            throw new error("maximum lock count exceeded");\n        setstate(nextc);\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n该方法比公平锁的tryacquire方法在第二个if判断中少了一个是否存在前继节点判断，fairsync中的tryacquire代码中的这个if语句块如下：\n\nif (!hasqueuedpredecessors() &&\n    compareandsetstate(0, acquires)) {\n    setexclusiveownerthread(current);\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n\n\n到现在我们终于啃下了一块硬骨头了，通过学习源码的方式非常深刻的学习到了独占式锁的获取和释放的过程以及同步队列。可以做一下总结：\n\n 1. 线程获取锁失败，线程被封装成node进行入队操作，核心方法在于addwaiter()和enq()，同时enq()完成对同步队列的头结点初始化工作以及cas操作失败的重试;\n 2. 线程获取锁是一个自旋的过程，只有当前节点的前驱节点是头结点并且成功获得同步状态时，节点出队即该节点引用的线程获得锁，否则，当不满足条件时就会调用looksupport.park()方法使得线程阻塞；\n 3. 释放锁的时候会唤醒后继节点；\n\n总体来说：在获取同步状态时，aqs维护一个同步队列，获取同步状态失败的线程会加入到队列中进行自旋；移除队列（或停止自旋）的条件是前驱节点是头结点并且成功获得了同步状态。在释放同步状态时，同步器会调用unparksuccessor()方法唤醒后继节点。\n\n\n# 7、独占锁特性学习\n\n\n# 可中断式获取锁（acquireinterruptibly方法）\n\n我们知道lock相较于synchronized有一些更方便的特性，比如能响应中断以及超时等待等特性，现在我们依旧采用通过学习源码的方式来看看能够响应中断是怎么实现的。可响应中断式锁可调用方法lock.lockinterruptibly();而该方法其底层会调用aqs的acquireinterruptibly方法，源码为：\n\npublic final void acquireinterruptibly(int arg) throws interruptedexception {\n    if (thread.interrupted())\n        throw new interruptedexception();\n    if (!tryacquire(arg))\n        //线程获取锁失败\n        doacquireinterruptibly(arg);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n在获取同步状态失败后就会调用doacquireinterruptibly方法：\n\nprivate void doacquireinterruptibly(int arg)\n    throws interruptedexception {\n    //将节点插入到同步队列中\n    final node node = addwaiter(node.exclusive);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final node p = node.predecessor();\n            //获取锁出队\n            if (p == head && tryacquire(arg)) {\n                sethead(node);\n                p.next = null; // help gc\n                failed = false;\n                return;\n            }\n            if (shouldparkafterfailedacquire(p, node) &&\n                parkandcheckinterrupt())\n                //线程中断抛异常\n                throw new interruptedexception();\n        }\n    } finally {\n        if (failed)\n            cancelacquire(node);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n关键信息请看注释，现在看这段代码就很轻松了，与acquire方法逻辑几乎一致，唯一的区别是当parkandcheckinterrupt返回true时即线程阻塞时该线程被中断，代码抛出被中断异常。\n\n\n# 超时等待式获取锁（tryacquirenanos()方法）\n\n通过调用lock.trylock(timeout,timeunit)方式达到超时等待获取锁的效果，该方法会在三种情况下才会返回：\n\n 1. 在超时时间内，当前线程成功获取了锁；\n 2. 当前线程在超时时间内被中断；\n 3. 超时时间结束，仍未获得锁返回false。\n\n我们仍然通过采取阅读源码的方式来学习底层具体是怎么实现的，该方法会调用aqs的方法tryacquirenanos(),源码为：\n\npublic final boolean tryacquirenanos(int arg, long nanostimeout) throws interruptedexception {\n    if (thread.interrupted())\n        throw new interruptedexception();\n    return tryacquire(arg) ||\n        //实现超时等待的效果\n        doacquirenanos(arg, nanostimeout);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n很显然这段源码最终是靠doacquirenanos方法实现超时等待的效果，该方法源码如下：\n\nprivate boolean doacquirenanos(int arg, long nanostimeout) throws interruptedexception {\n    if (nanostimeout <= 0l)\n        return false;\n    //1. 根据超时时间和当前时间计算出截止时间\n    final long deadline = system.nanotime() + nanostimeout;\n    final node node = addwaiter(node.exclusive);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final node p = node.predecessor();\n            //2. 当前线程获得锁出队列\n            if (p == head && tryacquire(arg)) {\n                sethead(node);\n                p.next = null; // help gc\n                failed = false;\n                return true;\n            }\n            // 3.1 重新计算超时时间\n            nanostimeout = deadline - system.nanotime();\n            // 3.2 已经超时返回false\n            if (nanostimeout <= 0l)\n                return false;\n            // 3.3 线程阻塞等待\n            if (shouldparkafterfailedacquire(p, node) &&\n                nanostimeout > spinfortimeoutthreshold)\n                locksupport.parknanos(this, nanostimeout);\n            // 3.4 线程被中断抛出被中断异常\n            if (thread.interrupted())\n                throw new interruptedexception();\n        }\n    } finally {\n        if (failed)\n            cancelacquire(node);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n程序逻辑如图所示：\n\n\n\n程序逻辑同独占锁可响应中断式获取基本一致，唯一的不同在于获取锁失败后，对超时时间的处理上，在第1步会先计算出按照现在时间和超时时间计算出理论上的截止时间，比如当前时间是8h10min，超时时间是10min，那么根据deadline = system.nanotime() + nanostimeout计算出刚好达到超时时间时的系统时间就是8h 10min+10min = 8h 20min。然后根据deadline - system.nanotime()就可以判断是否已经超时了，比如，当前系统时间是8h 30min很明显已经超过了理论上的系统时间8h 20min，deadline - system.nanotime()计算出来就是一个负数，自然而然会在3.2步中的if判断之间返回false。如果还没有超时即3.2步中的if判断为true时就会继续执行3.3步通过locksupport.parknanos使得当前线程阻塞，同时在3.4步增加了对中断的检测，若检测出被中断直接抛出被中断异常。\n\n\n# 8、共享锁\n\n\n# 共享锁的获取（acquireshared()方法）\n\n在聊完aqs对独占锁的实现后，我们继续一鼓作气的来看看共享锁是怎样实现的？共享锁的获取方法为acquireshared，源码为：\n\npublic final void acquireshared(int arg) {\n    if (tryacquireshared(arg) < 0)\n        doacquireshared(arg);\n}\n\n\n1\n2\n3\n4\n\n\n这段源码的逻辑很容易理解，在该方法中会首先调用tryacquireshared方法，tryacquireshared返回值是一个int类型，当返回值为大于等于0的时候方法结束说明获得成功获取锁，否则，表明获取同步状态失败即所引用的线程获取锁失败，会执行doacquireshared方法，该方法的源码为：\n\nprivate void doacquireshared(int arg) {\n    final node node = addwaiter(node.shared);\n    boolean failed = true;\n    try {\n        boolean interrupted = false;\n        for (;;) {\n            final node p = node.predecessor();\n            if (p == head) {\n                int r = tryacquireshared(arg);\n                if (r >= 0) {\n                    // 当该节点的前驱节点是头结点且成功获取同步状态\n                    setheadandpropagate(node, r);\n                    p.next = null; // help gc\n                    if (interrupted)\n                        selfinterrupt();\n                    failed = false;\n                    return;\n                }\n            }\n            if (shouldparkafterfailedacquire(p, node) &&\n                parkandcheckinterrupt())\n                interrupted = true;\n        }\n    } finally {\n        if (failed)\n            cancelacquire(node);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n现在来看这段代码会不会很容易了？逻辑几乎和独占式锁的获取一模一样，这里的自旋过程中能够退出的条件是当前节点的前驱节点是头结点并且tryacquireshared(arg)返回值大于等于0即能成功获得同步状态。\n\n\n# 共享锁的释放（releaseshared()方法）\n\n共享锁的释放在aqs中会调用方法releaseshared：\n\npublic final boolean releaseshared(int arg) {\n    if (tryreleaseshared(arg)) {\n        doreleaseshared();\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n当成功释放同步状态之后即tryreleaseshared会继续执行doreleaseshared方法：\n\nprivate void doreleaseshared() {\n    /*\n     * ensure that a release propagates, even if there are other\n     * in-progress acquires/releases.  this proceeds in the usual\n     * way of trying to unparksuccessor of head if it needs\n     * signal. but if it does not, status is set to propagate to\n     * ensure that upon release, propagation continues.\n     * additionally, we must loop in case a new node is added\n     * while we are doing this. also, unlike other uses of\n     * unparksuccessor, we need to know if cas to reset status\n     * fails, if so rechecking.\n     */\n    for (;;) {\n        node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitstatus;\n            if (ws == node.signal) {\n                if (!compareandsetwaitstatus(h, node.signal, 0))\n                    continue;            // loop to recheck cases\n                unparksuccessor(h);\n            }\n            else if (ws == 0 &&\n                     !compareandsetwaitstatus(h, 0, node.propagate))\n                continue;                // loop on failed cas\n        }\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n这段方法跟独占式锁释放过程有点点不同，在共享式锁的释放过程中，对于能够支持多个线程同时访问的并发组件，必须保证多个线程能够安全的释放同步状态，这里采用的cas保证，当cas操作失败continue，在下一次循环中进行重试。\n\n\n# 可中断（acquiresharedinterruptibly()方法），超时等待（tryacquiresharednanos()方法）\n\n关于可中断锁以及超时等待的特性其实现和独占式锁可中断获取锁以及超时等待的实现几乎一致，具体的就不再说了，如果理解了上面的内容对这部分的理解也是水到渠成的。\n\n> 参考文献\n\n《java并发编程的艺术》\n\n深入理解abstractqueuedsynchronizer（一）',charsets:{cjk:!0},createdTime:1655628697e3},{title:"并发容器之ThreadLocal",frontmatter:{title:"并发容器之ThreadLocal",description:"并发容器之ThreadLocal",date:"2022-04-08T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/17%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BThreadLocal.html",relativePath:"Java/Java并发编程的艺术/17、并发容器之ThreadLocal.md",key:"v-5c491b59",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/17%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BThreadLocal.html",headers:[{level:2,title:"1、ThreadLocal的简介",slug:"_1、threadlocal的简介",normalizedTitle:"1、threadlocal的简介",charIndex:27},{level:2,title:"2、ThreadLocal的实现原理",slug:"_2、threadlocal的实现原理",normalizedTitle:"2、threadlocal的实现原理",charIndex:47},{level:2,title:"3、ThreadLocalMap详解",slug:"_3、threadlocalmap详解",normalizedTitle:"3、threadlocalmap详解",charIndex:69},{level:3,title:"3.1 Entry数据结构",slug:"_3-1-entry数据结构",normalizedTitle:"3.1 entry数据结构",charIndex:93},{level:3,title:"3.2 set方法",slug:"_3-2-set方法",normalizedTitle:"3.2 set方法",charIndex:112},{level:3,title:"3.3 getEntry方法",slug:"_3-3-getentry方法",normalizedTitle:"3.3 getentry方法",charIndex:127},{level:3,title:"3.4 remove方法",slug:"_3-4-remove方法",normalizedTitle:"3.4 remove方法",charIndex:147},{level:2,title:"4、ThreadLocal的使用场景",slug:"_4、threadlocal的使用场景",normalizedTitle:"4、threadlocal的使用场景",charIndex:163},{level:2,title:"5、ThreadLocal最佳实践",slug:"_5、threadlocal最佳实践",normalizedTitle:"5、threadlocal最佳实践",charIndex:185}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>并发容器之ThreadLocal</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"1、ThreadLocal的简介 2、ThreadLocal的实现原理 3、ThreadLocalMap详解 3.1 Entry数据结构 3.2 set方法 3.3 getEntry方法 3.4 remove方法 4、ThreadLocal的使用场景 5、ThreadLocal最佳实践",content:'说明\n\n并发容器之ThreadLocal\n\n\n\n * 1、ThreadLocal的简介\n * 2、ThreadLocal的实现原理\n * 3、ThreadLocalMap详解\n   * 3.1 Entry数据结构\n   * 3.2 set方法\n   * 3.3 getEntry方法\n   * 3.4 remove方法\n * 4、ThreadLocal的使用场景\n * 5、ThreadLocal最佳实践\n\n\n\n\n# 并发容器之ThreadLocal\n\n\n# 1、ThreadLocal的简介\n\nthreadLocal是为了解决对象不能被多线程共享访问的问题，通过threadLocal.set方法将对象实例保存在每个线程自己所拥有的threadLocalMap中，这样每个线程使用自己的对象实例，彼此不会影响达到隔离的作用，从而就解决了对象在被共享访问带来线程安全问题。如果将同步机制和threadLocal做一个横向比较的话，同步机制就是通过控制线程访问共享对象的顺序，而threadLocal就是为每一个线程分配一个该对象，各用各的互不影响。打个比方说，现在有100个同学需要填写一张表格但是只有一支笔，同步就相当于A使用完这支笔后给B，B使用后给C用......老师就控制着这支笔的使用顺序，使得同学之间不会产生冲突。而threadLocal就相当于，老师直接准备了100支笔，这样每个同学都使用自己的，同学之间就不会产生冲突。很显然这就是两种不同的思路，同步机制以“时间换空间”，由于每个线程在同一时刻共享对象只能被一个线程访问造成整体上响应时间增加，但是对象只占有一份内存，牺牲了时间效率换来了空间效率即“时间换空间”。而threadLocal，为每个线程都分配了一份对象，自然而然内存使用率增加，每个线程各用各的，整体上时间效率要增加很多，牺牲了空间效率换来时间效率即“空间换时间”。\n\n虽然ThreadLocal并不在java.util.concurrent包中而在java.lang包中，但我更倾向于把它当作是一种并发容器（虽然真正存放数据的是ThreadLoclMap）进行归类。从ThreadLocal这个类名可以顾名思义的进行理解，表示线程的“本地变量”，即每个线程都拥有该变量副本，达到人手一份的效果，各用各的这样就可以避免共享资源的竞争。\n\n\n# 2、ThreadLocal的实现原理\n\n要想学习到ThreadLocal的实现原理，就必须了解它的几个核心方法，包括怎样存怎样取等等，下面我们一个个来看。\n\n> void set(T value)\n\nset方法设置在当前线程中threadLocal变量的值，该方法的源码为：\n\npublic void set(T value) {\n    //1. 获取当前线程实例对象\n    Thread t = Thread.currentThread();\n    //2. 通过当前线程实例获取到ThreadLocalMap对象\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        //3. 如果Map不为null,则以当前threadLocl实例为key,值为value进行存入\n        map.set(this, value);\n    else\n        //4.map为null,则新建ThreadLocalMap并存入value\n        createMap(t, value);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n方法的逻辑很清晰，具体请看上面的注释。通过源码我们知道value是存放在了ThreadLocalMap里了，当前先把它理解为一个普普通通的map即可，也就是说，数据value是真正的存放在了ThreadLocalMap这个容器中了，并且是以当前threadLocal实例为key。先简单的看下ThreadLocalMap是什么，有个简单的认识就好，下面会具体说的。\n\n首先ThreadLocalMap是怎样来的？源码很清楚，是通过getMap(t)进行获取：\n\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n\n\n1\n2\n3\n\n\n该方法直接返回的就是当前线程对象t的一个成员变量threadLocals：\n\n/* ThreadLocal values pertaining to this thread. This map is maintained\n * by the ThreadLocal class. */\nThreadLocal.ThreadLocalMap threadLocals = null;\n\n\n1\n2\n3\n\n\n也就是说ThreadLocalMap的引用是作为Thread的一个成员变量，被Thread进行维护的。回过头再来看看set方法，当map为Null的时候会通过createMap(t，value)方法：\n\nvoid createMap(Thread t, T firstValue) {\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n\n\n1\n2\n3\n\n\n该方法就是new一个ThreadLocalMap实例对象，然后同样以当前threadLocal实例作为key，值为value存放到threadLocalMap中，然后将当前线程对象的threadLocals赋值为threadLocalMap。\n\n现在来对set方法进行总结一下： 通过当前线程对象thread获取该thread所维护的threadLocalMap，若threadLocalMap不为null，则以threadLocal实例为key，值为value的键值对存入threadLocalMap，若threadLocalMap为null的话，就新建threadLocalMap然后在以threadLocal为键，值为value的键值对存入即可。\n\n> T get()\n\nget方法是获取当前线程中threadLocal变量的值，同样的还是来看看源码：\n\npublic T get() {\n    //1. 获取当前线程的实例对象\n    Thread t = Thread.currentThread();\n    //2. 获取当前线程的threadLocalMap\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        //3. 获取map中当前threadLocal实例为key的值的entry\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null) {\n            @SuppressWarnings("unchecked")\n            //4. 当前entitiy不为null的话，就返回相应的值value\n            T result = (T)e.value;\n            return result;\n        }\n    }\n    //5. 若map为null或者entry为null的话通过该方法初始化，并返回该方法返回的value\n    return setInitialValue();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n弄懂了set方法的逻辑，看get方法只需要带着逆向思维去看就好，如果是那样存的，反过来去拿就好。代码逻辑请看注释，另外，看下setInitialValue主要做了些什么事情？\n\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这段方法的逻辑和set方法几乎一致，另外值得关注的是initialValue方法：\n\nprotected T initialValue() {\n    return null;\n}\n\n\n1\n2\n3\n\n\n这个方法是protected修饰的也就是说继承ThreadLocal的子类可重写该方法，实现赋值为其他的初始值。\n\n关于get方法来总结一下：通过当前线程thread实例获取到它所维护的threadLocalMap，然后以当前threadLocal实例为key获取该map中的键值对（Entry），若Entry不为null则返回Entry的value。如果获取threadLocalMap为null或者Entry为null的话，就以当前threadLocal为Key，value为null存入map后，并返回null。\n\n> void remove()\n\npublic void remove() {\n\t//1. 获取当前线程的threadLocalMap\n\tThreadLocalMap m = getMap(Thread.currentThread());\n \tif (m != null)\n\t\t//2. 从map中删除以当前threadLocal实例为key的键值对\n\t\tm.remove(this);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nget，set方法实现了存数据和读数据，我们当然还得学会如何删数据。删除数据当然是从map中删除数据，先获取与当前线程相关联的threadLocalMap然后从map中删除该threadLocal实例为key的键值对即可。\n\n\n# 3、ThreadLocalMap详解\n\n从上面的分析我们已经知道，数据其实都放在了threadLocalMap中，threadLocal的get，set和remove方法实际上具体是通过threadLocalMap的getEntry，set和remove方法实现的。如果想真正全方位的弄懂threadLocal，势必得在对threadLocalMap做一番理解。\n\n首先threadLocalMap是threadLocal的内部静态类，而Entry是threadLocalMap的内部静态类。\n\n\n# 3.1 Entry数据结构\n\nThreadLocalMap是threadLocal一个静态内部类，和大多数容器一样内部维护了一个数组，同样的threadLocalMap内部维护了一个Entry类型的table数组。\n\n/**\n * The table, resized as necessary.\n * table.length MUST always be a power of two.\n */\nprivate Entry[] table;\n\n\n1\n2\n3\n4\n5\n\n\n通过注释可以看出，table数组的长度为2的幂次方。接下来看下Entry是什么：\n\nstatic class Entry extends WeakReference<ThreadLocal<?>> {\n    /** The value associated with this ThreadLocal. */\n    Object value;\n\n    Entry(ThreadLocal<?> k, Object v) {\n        super(k);\n        value = v;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nEntry是一个以ThreadLocal为key，Object为value的键值对，另外需要注意的是这里的threadLocal是弱引用，因为Entry继承了WeakReference，在Entry的构造方法中，调用了super(k)方法就会将threadLocal实例包装成一个WeakReferenece。到这里我们可以用一个图来理解下thread，threadLocal，threadLocalMap，Entry之间的关系：\n\n\n\n注意上图中的实线表示强引用，虚线表示弱引用。如图所示，每个线程实例中可以通过threadLocals获取到threadLocalMap，而threadLocalMap实际上就是一个以threadLocal实例为key，任意对象为value的Entry数组。当我们为threadLocal变量赋值，实际上就是用以当前threadLocal实例为key，值为value的Entry往这个threadLocalMap中存放。\n\n需要注意的是**Entry中的key是弱引用，当threadLocal外部强引用被置为null(threadLocalInstance = null)，那么系统 GC 的时候，根据可达性分析，这个threadLocal实例就没有任何一条链路能够引用到它，这个ThreadLocal势必会被回收，这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value永远无法回收，造成内存泄漏。**当然，如果当前thread运行结束，threadLocal，threadLocalMap，Entry没有引用链可达，在垃圾回收的时候都会被系统进行回收。\n\n在实际开发中，会使用线程池去维护线程的创建和复用，比如固定大小的线程池，线程为了复用是不会主动结束的，所以，threadLocal的内存泄漏问题，是应该值得我们思考和注意的问题，关于这个问题可以看这篇文章----详解threadLocal内存泄漏问题\n\n\n# 3.2 set方法\n\n与concurrentHashMap，hashMap等容器一样，threadLocalMap也是采用散列表进行实现的。在了解set方法前，我们先来回顾下关于散列表相关的知识（也可以查看这篇文章）：\n\n * 散列表\n\n理想状态下，散列表就是一个包含关键字的固定大小的数组，通过使用散列函数，将关键字映射到数组的不同位置。\n\n\n\n下面是在理想状态下，哈希函数可以将关键字均匀的分散到数组的不同位置，不会出现两个关键字散列值相同（假设关键字数量小于数组的大小）的情况。但是在实际使用中，经常会出现多个关键字散列值相同的情况（被映射到数组的同一个位置），我们将这种情况称为散列冲突。为了解决散列冲突，主要采用下面两种方式： 分离链表法（separate chaining）和开放定址法（open addressing）\n\n * 分离链表法\n\n分散链表法使用链表解决冲突，将散列值相同的元素都保存到一个链表中。当查询的时候，首先找到元素所在的链表，然后遍历链表查找对应的元素，典型实现为hashMap，concurrentHashMap的拉链法。下面是一个示意图：\n\n\n\n * 开放定址法\n\n开放定址法不会创建链表，当关键字散列到的数组单元已经被另外一个关键字占用的时候，就会尝试在数组中寻找其他的单元，直到找到一个空的单元。探测数组空单元的方式有很多，这里介绍一种最简单的 -- 线性探测法。线性探测法就是从冲突的数组单元开始，依次往后搜索空单元，如果到数组尾部，再从头开始搜索（环形查找）。如下图所示：\n\n\n\n关于两种方式的比较，可以参考 这篇文章。ThreadLocalMap 中使用开放地址法来处理散列冲突，而 HashMap 中使用的分离链表法。之所以采用不同的方式主要是因为：在 ThreadLocalMap 中的散列值分散的十分均匀，很少会出现冲突。并且 ThreadLocalMap 经常需要清除无用的对象，使用纯数组更加方便。\n\n在了解这些相关知识后我们再回过头来看一下set方法。set方法的源码为：\n\nprivate void set(ThreadLocal<?> key, Object value) {\n\n    // We don\'t use a fast path as with get() because it is at\n    // least as common to use set() to create new entries as\n    // it is to replace existing ones, in which case, a fast\n    // path would fail more often than not.\n\n    Entry[] tab = table;\n    int len = tab.length;\n    //根据threadLocal的hashCode确定Entry应该存放的位置\n    int i = key.threadLocalHashCode & (len-1);\n\n    //采用开放地址法，hash冲突的时候使用线性探测\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        ThreadLocal<?> k = e.get();\n        //覆盖旧Entry\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n        //当key为null时，说明threadLocal强引用已经被释放掉，那么就无法\n        //再通过这个key获取threadLocalMap中对应的entry，这里就存在内存泄漏的可能性\n        if (k == null) {\n            //用当前插入的值替换掉这个key为null的“脏”entry\n            replaceStaleEntry(key, value, i);\n            return;\n        }\n    }\n    //新建entry并插入table中i处\n    tab[i] = new Entry(key, value);\n    int sz = ++size;\n    //插入后再次清除一些key为null的“脏”entry,如果大于阈值就需要扩容\n    if (!cleanSomeSlots(i, sz) && sz >= threshold)\n        rehash();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\nset方法的关键部分请看上面的注释，主要有这样几点需要注意：\n\n 1. threadLocal的hashcode?\n\n private final int threadLocalHashCode = nextHashCode();\n private static final int HASH_INCREMENT = 0x61c88647;\n private static AtomicInteger nextHashCode =new AtomicInteger();\n /**\n  * Returns the next hash code.\n  */\n private static int nextHashCode() {\n     return nextHashCode.getAndAdd(HASH_INCREMENT);\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n从源码中我们可以清楚的看到threadLocal实例的hashCode是通过nextHashCode()方法实现的，该方法实际上总是用一个AtomicInteger加上0x61c88647来实现的。0x61c88647这个数是有特殊意义的，它能够保证hash表的每个散列桶能够均匀的分布，这是Fibonacci Hashing，关于更多介绍可以看这篇文章的threadLocal散列值部分。也正是能够均匀分布，所以threadLocal选择使用开放地址法来解决hash冲突的问题。\n\n 2. 怎样确定新值插入到哈希表中的位置？\n\n该操作源码为：key.threadLocalHashCode & (len-1)，同hashMap和ConcurrentHashMap等容器的方式一样，利用当前key(即threadLocal实例)的hashcode与哈希表大小相比，因为哈希表大小总是为2的幂次方，所以相与等同于一个取模的过程，这样就可以通过Key分配到具体的哈希桶中去。而至于为什么取模要通过位与运算的原因就是位运算的执行效率远远高于了取模运算。\n\n 3. 怎样解决hash冲突？\n\n源码中通过nextIndex(i, len)方法解决hash冲突的问题，该方法为((i + 1 < len) ? i + 1 : 0);，也就是不断往后线性探测，当到哈希表末尾的时候再从0开始，成环形。\n\n 4. 怎样解决“脏”Entry？\n\n在分析threadLocal，threadLocalMap以及Entry的关系的时候，我们已经知道使用threadLocal有可能存在内存泄漏（对象创建出来后，在之后的逻辑一直没有使用该对象，但是垃圾回收器无法回收这个部分的内存），在源码中针对这种key为null的Entry称之为“stale entry”，直译为不新鲜的entry，我把它理解为“脏entry”，自然而然，Josh Bloch and Doug Lea大师考虑到了这种情况，在set方法的for循环中寻找和当前Key相同的可覆盖entry的过程中通过replaceStaleEntry方法解决脏entry的问题。如果当前table[i]为null的话，直接插入新entry后也会通过cleanSomeSlots来解决脏entry的问题，关于cleanSomeSlots和replaceStaleEntry方法，会在详解threadLocal内存泄漏中讲到，具体可看那篇文章。\n\n 5. 如何进行扩容？\n\n> threshold的确定\n\n也几乎和大多数容器一样，threadLocalMap会有扩容机制，那么它的threshold又是怎样确定的了？\n\n\tprivate int threshold; // Default to 0\n\t/**\n     * The initial capacity -- MUST be a power of two.\n     */\n    private static final int INITIAL_CAPACITY = 16;\n\n    ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n        table = new Entry[INITIAL_CAPACITY];\n        int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);\n        table[i] = new Entry(firstKey, firstValue);\n        size = 1;\n        setThreshold(INITIAL_CAPACITY);\n    }\n\n\t/**\n     * Set the resize threshold to maintain at worst a 2/3 load factor.\n     */\n    private void setThreshold(int len) {\n        threshold = len * 2 / 3;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n根据源码可知，在第一次为threadLocal进行赋值的时候会创建初始大小为16的threadLocalMap，并且通过setThreshold方法设置threshold，其值为当前哈希数组长度乘以（2/3），也就是说加载因子为2/3(加载因子是衡量哈希表密集程度的一个参数，如果加载因子越大的话，说明哈希表被装载的越多，出现hash冲突的可能性越大，反之，则被装载的越少，出现hash冲突的可能性越小。同时如果过小，很显然内存使用率不高，该值取值应该考虑到内存使用率和hash冲突概率的一个平衡，如hashMap，concurrentHashMap的加载因子都为0.75)。这里threadLocalMap初始大小为16，加载因子为2/3，所以哈希表可用大小为：16*2/3=10，即哈希表可用容量为10。\n\n> 扩容resize\n\n从set方法中可以看出当hash表的size大于threshold的时候，会通过resize方法进行扩容。\n\n/**\n * Double the capacity of the table.\n */\nprivate void resize() {\n    Entry[] oldTab = table;\n    int oldLen = oldTab.length;\n\t//新数组为原数组的2倍\n    int newLen = oldLen * 2;\n    Entry[] newTab = new Entry[newLen];\n    int count = 0;\n\n    for (int j = 0; j < oldLen; ++j) {\n        Entry e = oldTab[j];\n        if (e != null) {\n            ThreadLocal<?> k = e.get();\n\t\t\t//遍历过程中如果遇到脏entry的话直接另value为null,有助于value能够被回收\n            if (k == null) {\n                e.value = null; // Help the GC\n            } else {\n\t\t\t\t//重新确定entry在新数组的位置，然后进行插入\n                int h = k.threadLocalHashCode & (newLen - 1);\n                while (newTab[h] != null)\n                    h = nextIndex(h, newLen);\n                newTab[h] = e;\n                count++;\n            }\n        }\n    }\n\t//设置新哈希表的threshHold和size属性\n    setThreshold(newLen);\n    size = count;\n    table = newTab;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n方法逻辑请看注释，新建一个大小为原来数组长度的两倍的数组，然后遍历旧数组中的entry并将其插入到新的hash数组中，主要注意的是，在扩容的过程中针对脏entry的话会令value为null，以便能够被垃圾回收器能够回收，解决隐藏的内存泄漏的问题。\n\n\n# 3.3 getEntry方法\n\ngetEntry方法源码为：\n\nprivate Entry getEntry(ThreadLocal<?> key) {\n\t//1. 确定在散列数组中的位置\n    int i = key.threadLocalHashCode & (table.length - 1);\n\t//2. 根据索引i获取entry\n    Entry e = table[i];\n\t//3. 满足条件则返回该entry\n    if (e != null && e.get() == key)\n        return e;\n    else\n\t\t//4. 未查找到满足条件的entry，额外在做的处理\n        return getEntryAfterMiss(key, i, e);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n方法逻辑很简单，若能当前定位的entry的key和查找的key相同的话就直接返回这个entry，否则的话就是在set的时候存在hash冲突的情况，需要通过getEntryAfterMiss做进一步处理。getEntryAfterMiss方法为：\n\nprivate Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n    Entry[] tab = table;\n    int len = tab.length;\n\n    while (e != null) {\n        ThreadLocal<?> k = e.get();\n        if (k == key)\n\t\t\t//找到和查询的key相同的entry则返回\n            return e;\n        if (k == null)\n\t\t\t//解决脏entry的问题\n            expungeStaleEntry(i);\n        else\n\t\t\t//继续向后环形查找\n            i = nextIndex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n这个方法同样很好理解，通过nextIndex往后环形查找，如果找到和查询的key相同的entry的话就直接返回，如果在查找过程中遇到脏entry的话使用expungeStaleEntry方法进行处理。到目前为止**，为了解决潜在的内存泄漏的问题，在set，resize，getEntry这些地方都会对这些脏entry进行处理，可见为了尽可能解决这个问题几乎无时无刻都在做出努力。**\n\n\n# 3.4 remove方法\n\n/**\n * Remove the entry for key.\n */\nprivate void remove(ThreadLocal<?> key) {\n    Entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadLocalHashCode & (len-1);\n    for (Entry e = tab[i];\n         e != null;\n         e = tab[i = nextIndex(i, len)]) {\n        if (e.get() == key) {\n\t\t\t//将entry的key置为null\n            e.clear();\n\t\t\t//将该entry的value也置为null\n            expungeStaleEntry(i);\n            return;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n该方法逻辑很简单，通过往后环形查找到与指定key相同的entry后，先通过clear方法将key置为null后，使其转换为一个脏entry，然后调用expungeStaleEntry方法将其value置为null，以便垃圾回收时能够清理，同时将table[i]置为null。\n\n\n# 4、ThreadLocal的使用场景\n\nThreadLocal 不是用来解决共享对象的多线程访问问题的，数据实质上是放在每个thread实例引用的threadLocalMap，也就是说每个不同的线程都拥有专属于自己的数据容器（threadLocalMap），彼此不影响。因此threadLocal只适用于 共享对象会造成线程安全 的业务场景。比如hibernate中通过threadLocal管理Session就是一个典型的案例，不同的请求线程（用户）拥有自己的session，若将session共享出去被多线程访问，必然会带来线程安全问题。下面，我们自己来写一个例子，SimpleDateFormat.parse方法会有线程安全的问题，我们可以尝试使用threadLocal包装SimpleDateFormat，将该实例不被多线程共享即可。\n\npublic class ThreadLocalDemo {\n    private static ThreadLocal<SimpleDateFormat> sdf = new ThreadLocal<>();\n\n    public static void main(String[] args) {\n        ExecutorService executorService = Executors.newFixedThreadPool(10);\n        for (int i = 0; i < 100; i++) {\n            executorService.submit(new DateUtil("2019-11-25 09:00:" + i % 60));\n        }\n    }\n\n    static class DateUtil implements Runnable {\n        private String date;\n\n        public DateUtil(String date) {\n            this.date = date;\n        }\n\n        @Override\n        public void run() {\n            if (sdf.get() == null) {\n                sdf.set(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"));\n            } else {\n                try {\n                    Date date = sdf.get().parse(this.date);\n                    System.out.println(date);\n                } catch (ParseException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n 1. 如果当前线程不持有SimpleDateformat对象实例，那么就新建一个并把它设置到当前线程中，如果已经持有，就直接使用。另外，从if (sdf.get() == null){....}else{.....}可以看出为每一个线程分配一个SimpleDateformat对象实例是从应用层面（业务代码逻辑）去保证的。\n 2. 在上面我们说过threadLocal有可能存在内存泄漏，在使用完之后，最好使用remove方法将这个变量移除，就像在使用数据库连接一样，及时关闭连接。\n\n\n# 5、ThreadLocal最佳实践\n\n上面说ThreadLocal有内存泄漏问题，对那么实践中我们应该怎么做？\n\n 1. 每次使用完ThreadLocal，都调用它的remove()方法，清除数据。\n 2. 在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。\n\n> 参考资料\n\n《java高并发程序设计》\n\n并发容器之ThreadLocal',normalizedContent:'说明\n\n并发容器之threadlocal\n\n\n\n * 1、threadlocal的简介\n * 2、threadlocal的实现原理\n * 3、threadlocalmap详解\n   * 3.1 entry数据结构\n   * 3.2 set方法\n   * 3.3 getentry方法\n   * 3.4 remove方法\n * 4、threadlocal的使用场景\n * 5、threadlocal最佳实践\n\n\n\n\n# 并发容器之threadlocal\n\n\n# 1、threadlocal的简介\n\nthreadlocal是为了解决对象不能被多线程共享访问的问题，通过threadlocal.set方法将对象实例保存在每个线程自己所拥有的threadlocalmap中，这样每个线程使用自己的对象实例，彼此不会影响达到隔离的作用，从而就解决了对象在被共享访问带来线程安全问题。如果将同步机制和threadlocal做一个横向比较的话，同步机制就是通过控制线程访问共享对象的顺序，而threadlocal就是为每一个线程分配一个该对象，各用各的互不影响。打个比方说，现在有100个同学需要填写一张表格但是只有一支笔，同步就相当于a使用完这支笔后给b，b使用后给c用......老师就控制着这支笔的使用顺序，使得同学之间不会产生冲突。而threadlocal就相当于，老师直接准备了100支笔，这样每个同学都使用自己的，同学之间就不会产生冲突。很显然这就是两种不同的思路，同步机制以“时间换空间”，由于每个线程在同一时刻共享对象只能被一个线程访问造成整体上响应时间增加，但是对象只占有一份内存，牺牲了时间效率换来了空间效率即“时间换空间”。而threadlocal，为每个线程都分配了一份对象，自然而然内存使用率增加，每个线程各用各的，整体上时间效率要增加很多，牺牲了空间效率换来时间效率即“空间换时间”。\n\n虽然threadlocal并不在java.util.concurrent包中而在java.lang包中，但我更倾向于把它当作是一种并发容器（虽然真正存放数据的是threadloclmap）进行归类。从threadlocal这个类名可以顾名思义的进行理解，表示线程的“本地变量”，即每个线程都拥有该变量副本，达到人手一份的效果，各用各的这样就可以避免共享资源的竞争。\n\n\n# 2、threadlocal的实现原理\n\n要想学习到threadlocal的实现原理，就必须了解它的几个核心方法，包括怎样存怎样取等等，下面我们一个个来看。\n\n> void set(t value)\n\nset方法设置在当前线程中threadlocal变量的值，该方法的源码为：\n\npublic void set(t value) {\n    //1. 获取当前线程实例对象\n    thread t = thread.currentthread();\n    //2. 通过当前线程实例获取到threadlocalmap对象\n    threadlocalmap map = getmap(t);\n    if (map != null)\n        //3. 如果map不为null,则以当前threadlocl实例为key,值为value进行存入\n        map.set(this, value);\n    else\n        //4.map为null,则新建threadlocalmap并存入value\n        createmap(t, value);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n方法的逻辑很清晰，具体请看上面的注释。通过源码我们知道value是存放在了threadlocalmap里了，当前先把它理解为一个普普通通的map即可，也就是说，数据value是真正的存放在了threadlocalmap这个容器中了，并且是以当前threadlocal实例为key。先简单的看下threadlocalmap是什么，有个简单的认识就好，下面会具体说的。\n\n首先threadlocalmap是怎样来的？源码很清楚，是通过getmap(t)进行获取：\n\nthreadlocalmap getmap(thread t) {\n    return t.threadlocals;\n}\n\n\n1\n2\n3\n\n\n该方法直接返回的就是当前线程对象t的一个成员变量threadlocals：\n\n/* threadlocal values pertaining to this thread. this map is maintained\n * by the threadlocal class. */\nthreadlocal.threadlocalmap threadlocals = null;\n\n\n1\n2\n3\n\n\n也就是说threadlocalmap的引用是作为thread的一个成员变量，被thread进行维护的。回过头再来看看set方法，当map为null的时候会通过createmap(t，value)方法：\n\nvoid createmap(thread t, t firstvalue) {\n    t.threadlocals = new threadlocalmap(this, firstvalue);\n}\n\n\n1\n2\n3\n\n\n该方法就是new一个threadlocalmap实例对象，然后同样以当前threadlocal实例作为key，值为value存放到threadlocalmap中，然后将当前线程对象的threadlocals赋值为threadlocalmap。\n\n现在来对set方法进行总结一下： 通过当前线程对象thread获取该thread所维护的threadlocalmap，若threadlocalmap不为null，则以threadlocal实例为key，值为value的键值对存入threadlocalmap，若threadlocalmap为null的话，就新建threadlocalmap然后在以threadlocal为键，值为value的键值对存入即可。\n\n> t get()\n\nget方法是获取当前线程中threadlocal变量的值，同样的还是来看看源码：\n\npublic t get() {\n    //1. 获取当前线程的实例对象\n    thread t = thread.currentthread();\n    //2. 获取当前线程的threadlocalmap\n    threadlocalmap map = getmap(t);\n    if (map != null) {\n        //3. 获取map中当前threadlocal实例为key的值的entry\n        threadlocalmap.entry e = map.getentry(this);\n        if (e != null) {\n            @suppresswarnings("unchecked")\n            //4. 当前entitiy不为null的话，就返回相应的值value\n            t result = (t)e.value;\n            return result;\n        }\n    }\n    //5. 若map为null或者entry为null的话通过该方法初始化，并返回该方法返回的value\n    return setinitialvalue();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n弄懂了set方法的逻辑，看get方法只需要带着逆向思维去看就好，如果是那样存的，反过来去拿就好。代码逻辑请看注释，另外，看下setinitialvalue主要做了些什么事情？\n\nprivate t setinitialvalue() {\n    t value = initialvalue();\n    thread t = thread.currentthread();\n    threadlocalmap map = getmap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createmap(t, value);\n    return value;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这段方法的逻辑和set方法几乎一致，另外值得关注的是initialvalue方法：\n\nprotected t initialvalue() {\n    return null;\n}\n\n\n1\n2\n3\n\n\n这个方法是protected修饰的也就是说继承threadlocal的子类可重写该方法，实现赋值为其他的初始值。\n\n关于get方法来总结一下：通过当前线程thread实例获取到它所维护的threadlocalmap，然后以当前threadlocal实例为key获取该map中的键值对（entry），若entry不为null则返回entry的value。如果获取threadlocalmap为null或者entry为null的话，就以当前threadlocal为key，value为null存入map后，并返回null。\n\n> void remove()\n\npublic void remove() {\n\t//1. 获取当前线程的threadlocalmap\n\tthreadlocalmap m = getmap(thread.currentthread());\n \tif (m != null)\n\t\t//2. 从map中删除以当前threadlocal实例为key的键值对\n\t\tm.remove(this);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nget，set方法实现了存数据和读数据，我们当然还得学会如何删数据。删除数据当然是从map中删除数据，先获取与当前线程相关联的threadlocalmap然后从map中删除该threadlocal实例为key的键值对即可。\n\n\n# 3、threadlocalmap详解\n\n从上面的分析我们已经知道，数据其实都放在了threadlocalmap中，threadlocal的get，set和remove方法实际上具体是通过threadlocalmap的getentry，set和remove方法实现的。如果想真正全方位的弄懂threadlocal，势必得在对threadlocalmap做一番理解。\n\n首先threadlocalmap是threadlocal的内部静态类，而entry是threadlocalmap的内部静态类。\n\n\n# 3.1 entry数据结构\n\nthreadlocalmap是threadlocal一个静态内部类，和大多数容器一样内部维护了一个数组，同样的threadlocalmap内部维护了一个entry类型的table数组。\n\n/**\n * the table, resized as necessary.\n * table.length must always be a power of two.\n */\nprivate entry[] table;\n\n\n1\n2\n3\n4\n5\n\n\n通过注释可以看出，table数组的长度为2的幂次方。接下来看下entry是什么：\n\nstatic class entry extends weakreference<threadlocal<?>> {\n    /** the value associated with this threadlocal. */\n    object value;\n\n    entry(threadlocal<?> k, object v) {\n        super(k);\n        value = v;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nentry是一个以threadlocal为key，object为value的键值对，另外需要注意的是这里的threadlocal是弱引用，因为entry继承了weakreference，在entry的构造方法中，调用了super(k)方法就会将threadlocal实例包装成一个weakreferenece。到这里我们可以用一个图来理解下thread，threadlocal，threadlocalmap，entry之间的关系：\n\n\n\n注意上图中的实线表示强引用，虚线表示弱引用。如图所示，每个线程实例中可以通过threadlocals获取到threadlocalmap，而threadlocalmap实际上就是一个以threadlocal实例为key，任意对象为value的entry数组。当我们为threadlocal变量赋值，实际上就是用以当前threadlocal实例为key，值为value的entry往这个threadlocalmap中存放。\n\n需要注意的是**entry中的key是弱引用，当threadlocal外部强引用被置为null(threadlocalinstance = null)，那么系统 gc 的时候，根据可达性分析，这个threadlocal实例就没有任何一条链路能够引用到它，这个threadlocal势必会被回收，这样一来，threadlocalmap中就会出现key为null的entry，就没有办法访问这些key为null的entry的value，如果当前线程再迟迟不结束的话，这些key为null的entry的value就会一直存在一条强引用链：thread ref -> thread -> threalocalmap -> entry -> value永远无法回收，造成内存泄漏。**当然，如果当前thread运行结束，threadlocal，threadlocalmap，entry没有引用链可达，在垃圾回收的时候都会被系统进行回收。\n\n在实际开发中，会使用线程池去维护线程的创建和复用，比如固定大小的线程池，线程为了复用是不会主动结束的，所以，threadlocal的内存泄漏问题，是应该值得我们思考和注意的问题，关于这个问题可以看这篇文章----详解threadlocal内存泄漏问题\n\n\n# 3.2 set方法\n\n与concurrenthashmap，hashmap等容器一样，threadlocalmap也是采用散列表进行实现的。在了解set方法前，我们先来回顾下关于散列表相关的知识（也可以查看这篇文章）：\n\n * 散列表\n\n理想状态下，散列表就是一个包含关键字的固定大小的数组，通过使用散列函数，将关键字映射到数组的不同位置。\n\n\n\n下面是在理想状态下，哈希函数可以将关键字均匀的分散到数组的不同位置，不会出现两个关键字散列值相同（假设关键字数量小于数组的大小）的情况。但是在实际使用中，经常会出现多个关键字散列值相同的情况（被映射到数组的同一个位置），我们将这种情况称为散列冲突。为了解决散列冲突，主要采用下面两种方式： 分离链表法（separate chaining）和开放定址法（open addressing）\n\n * 分离链表法\n\n分散链表法使用链表解决冲突，将散列值相同的元素都保存到一个链表中。当查询的时候，首先找到元素所在的链表，然后遍历链表查找对应的元素，典型实现为hashmap，concurrenthashmap的拉链法。下面是一个示意图：\n\n\n\n * 开放定址法\n\n开放定址法不会创建链表，当关键字散列到的数组单元已经被另外一个关键字占用的时候，就会尝试在数组中寻找其他的单元，直到找到一个空的单元。探测数组空单元的方式有很多，这里介绍一种最简单的 -- 线性探测法。线性探测法就是从冲突的数组单元开始，依次往后搜索空单元，如果到数组尾部，再从头开始搜索（环形查找）。如下图所示：\n\n\n\n关于两种方式的比较，可以参考 这篇文章。threadlocalmap 中使用开放地址法来处理散列冲突，而 hashmap 中使用的分离链表法。之所以采用不同的方式主要是因为：在 threadlocalmap 中的散列值分散的十分均匀，很少会出现冲突。并且 threadlocalmap 经常需要清除无用的对象，使用纯数组更加方便。\n\n在了解这些相关知识后我们再回过头来看一下set方法。set方法的源码为：\n\nprivate void set(threadlocal<?> key, object value) {\n\n    // we don\'t use a fast path as with get() because it is at\n    // least as common to use set() to create new entries as\n    // it is to replace existing ones, in which case, a fast\n    // path would fail more often than not.\n\n    entry[] tab = table;\n    int len = tab.length;\n    //根据threadlocal的hashcode确定entry应该存放的位置\n    int i = key.threadlocalhashcode & (len-1);\n\n    //采用开放地址法，hash冲突的时候使用线性探测\n    for (entry e = tab[i];\n         e != null;\n         e = tab[i = nextindex(i, len)]) {\n        threadlocal<?> k = e.get();\n        //覆盖旧entry\n        if (k == key) {\n            e.value = value;\n            return;\n        }\n        //当key为null时，说明threadlocal强引用已经被释放掉，那么就无法\n        //再通过这个key获取threadlocalmap中对应的entry，这里就存在内存泄漏的可能性\n        if (k == null) {\n            //用当前插入的值替换掉这个key为null的“脏”entry\n            replacestaleentry(key, value, i);\n            return;\n        }\n    }\n    //新建entry并插入table中i处\n    tab[i] = new entry(key, value);\n    int sz = ++size;\n    //插入后再次清除一些key为null的“脏”entry,如果大于阈值就需要扩容\n    if (!cleansomeslots(i, sz) && sz >= threshold)\n        rehash();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\nset方法的关键部分请看上面的注释，主要有这样几点需要注意：\n\n 1. threadlocal的hashcode?\n\n private final int threadlocalhashcode = nexthashcode();\n private static final int hash_increment = 0x61c88647;\n private static atomicinteger nexthashcode =new atomicinteger();\n /**\n  * returns the next hash code.\n  */\n private static int nexthashcode() {\n     return nexthashcode.getandadd(hash_increment);\n }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n从源码中我们可以清楚的看到threadlocal实例的hashcode是通过nexthashcode()方法实现的，该方法实际上总是用一个atomicinteger加上0x61c88647来实现的。0x61c88647这个数是有特殊意义的，它能够保证hash表的每个散列桶能够均匀的分布，这是fibonacci hashing，关于更多介绍可以看这篇文章的threadlocal散列值部分。也正是能够均匀分布，所以threadlocal选择使用开放地址法来解决hash冲突的问题。\n\n 2. 怎样确定新值插入到哈希表中的位置？\n\n该操作源码为：key.threadlocalhashcode & (len-1)，同hashmap和concurrenthashmap等容器的方式一样，利用当前key(即threadlocal实例)的hashcode与哈希表大小相比，因为哈希表大小总是为2的幂次方，所以相与等同于一个取模的过程，这样就可以通过key分配到具体的哈希桶中去。而至于为什么取模要通过位与运算的原因就是位运算的执行效率远远高于了取模运算。\n\n 3. 怎样解决hash冲突？\n\n源码中通过nextindex(i, len)方法解决hash冲突的问题，该方法为((i + 1 < len) ? i + 1 : 0);，也就是不断往后线性探测，当到哈希表末尾的时候再从0开始，成环形。\n\n 4. 怎样解决“脏”entry？\n\n在分析threadlocal，threadlocalmap以及entry的关系的时候，我们已经知道使用threadlocal有可能存在内存泄漏（对象创建出来后，在之后的逻辑一直没有使用该对象，但是垃圾回收器无法回收这个部分的内存），在源码中针对这种key为null的entry称之为“stale entry”，直译为不新鲜的entry，我把它理解为“脏entry”，自然而然，josh bloch and doug lea大师考虑到了这种情况，在set方法的for循环中寻找和当前key相同的可覆盖entry的过程中通过replacestaleentry方法解决脏entry的问题。如果当前table[i]为null的话，直接插入新entry后也会通过cleansomeslots来解决脏entry的问题，关于cleansomeslots和replacestaleentry方法，会在详解threadlocal内存泄漏中讲到，具体可看那篇文章。\n\n 5. 如何进行扩容？\n\n> threshold的确定\n\n也几乎和大多数容器一样，threadlocalmap会有扩容机制，那么它的threshold又是怎样确定的了？\n\n\tprivate int threshold; // default to 0\n\t/**\n     * the initial capacity -- must be a power of two.\n     */\n    private static final int initial_capacity = 16;\n\n    threadlocalmap(threadlocal<?> firstkey, object firstvalue) {\n        table = new entry[initial_capacity];\n        int i = firstkey.threadlocalhashcode & (initial_capacity - 1);\n        table[i] = new entry(firstkey, firstvalue);\n        size = 1;\n        setthreshold(initial_capacity);\n    }\n\n\t/**\n     * set the resize threshold to maintain at worst a 2/3 load factor.\n     */\n    private void setthreshold(int len) {\n        threshold = len * 2 / 3;\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n根据源码可知，在第一次为threadlocal进行赋值的时候会创建初始大小为16的threadlocalmap，并且通过setthreshold方法设置threshold，其值为当前哈希数组长度乘以（2/3），也就是说加载因子为2/3(加载因子是衡量哈希表密集程度的一个参数，如果加载因子越大的话，说明哈希表被装载的越多，出现hash冲突的可能性越大，反之，则被装载的越少，出现hash冲突的可能性越小。同时如果过小，很显然内存使用率不高，该值取值应该考虑到内存使用率和hash冲突概率的一个平衡，如hashmap，concurrenthashmap的加载因子都为0.75)。这里threadlocalmap初始大小为16，加载因子为2/3，所以哈希表可用大小为：16*2/3=10，即哈希表可用容量为10。\n\n> 扩容resize\n\n从set方法中可以看出当hash表的size大于threshold的时候，会通过resize方法进行扩容。\n\n/**\n * double the capacity of the table.\n */\nprivate void resize() {\n    entry[] oldtab = table;\n    int oldlen = oldtab.length;\n\t//新数组为原数组的2倍\n    int newlen = oldlen * 2;\n    entry[] newtab = new entry[newlen];\n    int count = 0;\n\n    for (int j = 0; j < oldlen; ++j) {\n        entry e = oldtab[j];\n        if (e != null) {\n            threadlocal<?> k = e.get();\n\t\t\t//遍历过程中如果遇到脏entry的话直接另value为null,有助于value能够被回收\n            if (k == null) {\n                e.value = null; // help the gc\n            } else {\n\t\t\t\t//重新确定entry在新数组的位置，然后进行插入\n                int h = k.threadlocalhashcode & (newlen - 1);\n                while (newtab[h] != null)\n                    h = nextindex(h, newlen);\n                newtab[h] = e;\n                count++;\n            }\n        }\n    }\n\t//设置新哈希表的threshhold和size属性\n    setthreshold(newlen);\n    size = count;\n    table = newtab;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n方法逻辑请看注释，新建一个大小为原来数组长度的两倍的数组，然后遍历旧数组中的entry并将其插入到新的hash数组中，主要注意的是，在扩容的过程中针对脏entry的话会令value为null，以便能够被垃圾回收器能够回收，解决隐藏的内存泄漏的问题。\n\n\n# 3.3 getentry方法\n\ngetentry方法源码为：\n\nprivate entry getentry(threadlocal<?> key) {\n\t//1. 确定在散列数组中的位置\n    int i = key.threadlocalhashcode & (table.length - 1);\n\t//2. 根据索引i获取entry\n    entry e = table[i];\n\t//3. 满足条件则返回该entry\n    if (e != null && e.get() == key)\n        return e;\n    else\n\t\t//4. 未查找到满足条件的entry，额外在做的处理\n        return getentryaftermiss(key, i, e);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n方法逻辑很简单，若能当前定位的entry的key和查找的key相同的话就直接返回这个entry，否则的话就是在set的时候存在hash冲突的情况，需要通过getentryaftermiss做进一步处理。getentryaftermiss方法为：\n\nprivate entry getentryaftermiss(threadlocal<?> key, int i, entry e) {\n    entry[] tab = table;\n    int len = tab.length;\n\n    while (e != null) {\n        threadlocal<?> k = e.get();\n        if (k == key)\n\t\t\t//找到和查询的key相同的entry则返回\n            return e;\n        if (k == null)\n\t\t\t//解决脏entry的问题\n            expungestaleentry(i);\n        else\n\t\t\t//继续向后环形查找\n            i = nextindex(i, len);\n        e = tab[i];\n    }\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n这个方法同样很好理解，通过nextindex往后环形查找，如果找到和查询的key相同的entry的话就直接返回，如果在查找过程中遇到脏entry的话使用expungestaleentry方法进行处理。到目前为止**，为了解决潜在的内存泄漏的问题，在set，resize，getentry这些地方都会对这些脏entry进行处理，可见为了尽可能解决这个问题几乎无时无刻都在做出努力。**\n\n\n# 3.4 remove方法\n\n/**\n * remove the entry for key.\n */\nprivate void remove(threadlocal<?> key) {\n    entry[] tab = table;\n    int len = tab.length;\n    int i = key.threadlocalhashcode & (len-1);\n    for (entry e = tab[i];\n         e != null;\n         e = tab[i = nextindex(i, len)]) {\n        if (e.get() == key) {\n\t\t\t//将entry的key置为null\n            e.clear();\n\t\t\t//将该entry的value也置为null\n            expungestaleentry(i);\n            return;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n该方法逻辑很简单，通过往后环形查找到与指定key相同的entry后，先通过clear方法将key置为null后，使其转换为一个脏entry，然后调用expungestaleentry方法将其value置为null，以便垃圾回收时能够清理，同时将table[i]置为null。\n\n\n# 4、threadlocal的使用场景\n\nthreadlocal 不是用来解决共享对象的多线程访问问题的，数据实质上是放在每个thread实例引用的threadlocalmap，也就是说每个不同的线程都拥有专属于自己的数据容器（threadlocalmap），彼此不影响。因此threadlocal只适用于 共享对象会造成线程安全 的业务场景。比如hibernate中通过threadlocal管理session就是一个典型的案例，不同的请求线程（用户）拥有自己的session，若将session共享出去被多线程访问，必然会带来线程安全问题。下面，我们自己来写一个例子，simpledateformat.parse方法会有线程安全的问题，我们可以尝试使用threadlocal包装simpledateformat，将该实例不被多线程共享即可。\n\npublic class threadlocaldemo {\n    private static threadlocal<simpledateformat> sdf = new threadlocal<>();\n\n    public static void main(string[] args) {\n        executorservice executorservice = executors.newfixedthreadpool(10);\n        for (int i = 0; i < 100; i++) {\n            executorservice.submit(new dateutil("2019-11-25 09:00:" + i % 60));\n        }\n    }\n\n    static class dateutil implements runnable {\n        private string date;\n\n        public dateutil(string date) {\n            this.date = date;\n        }\n\n        @override\n        public void run() {\n            if (sdf.get() == null) {\n                sdf.set(new simpledateformat("yyyy-mm-dd hh:mm:ss"));\n            } else {\n                try {\n                    date date = sdf.get().parse(this.date);\n                    system.out.println(date);\n                } catch (parseexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n 1. 如果当前线程不持有simpledateformat对象实例，那么就新建一个并把它设置到当前线程中，如果已经持有，就直接使用。另外，从if (sdf.get() == null){....}else{.....}可以看出为每一个线程分配一个simpledateformat对象实例是从应用层面（业务代码逻辑）去保证的。\n 2. 在上面我们说过threadlocal有可能存在内存泄漏，在使用完之后，最好使用remove方法将这个变量移除，就像在使用数据库连接一样，及时关闭连接。\n\n\n# 5、threadlocal最佳实践\n\n上面说threadlocal有内存泄漏问题，对那么实践中我们应该怎么做？\n\n 1. 每次使用完threadlocal，都调用它的remove()方法，清除数据。\n 2. 在使用线程池的情况下，没有及时清理threadlocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用threadlocal就跟加锁完要解锁一样，用完就清理。\n\n> 参考资料\n\n《java高并发程序设计》\n\n并发容器之threadlocal',charsets:{cjk:!0},createdTime:1655628697e3},{title:"FutureTask源码解析",frontmatter:{title:"FutureTask源码解析",description:"FutureTask源码解析",date:"2022-04-12T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/21%E3%80%81FutureTask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html",relativePath:"Java/Java并发编程的艺术/21、FutureTask源码解析.md",key:"v-64a9c608",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/21%E3%80%81FutureTask%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html",headers:[{level:2,title:"FutureTask的状态",slug:"futuretask的状态",normalizedTitle:"futuretask的状态",charIndex:25},{level:2,title:"FutureTask使用过程",slug:"futuretask使用过程",normalizedTitle:"futuretask使用过程",charIndex:42},{level:2,title:"FutureTask内部结构",slug:"futuretask内部结构",normalizedTitle:"futuretask内部结构",charIndex:60},{level:2,title:"FutureTask构造方法",slug:"futuretask构造方法",normalizedTitle:"futuretask构造方法",charIndex:78},{level:2,title:"run方法",slug:"run方法",normalizedTitle:"run方法",charIndex:96},{level:2,title:"setException方法",slug:"setexception方法",normalizedTitle:"setexception方法",charIndex:105},{level:2,title:"set方法",slug:"set方法",normalizedTitle:"set方法",charIndex:123},{level:2,title:"handlePossibleCancellationInterrupt方法",slug:"handlepossiblecancellationinterrupt方法",normalizedTitle:"handlepossiblecancellationinterrupt方法",charIndex:132},{level:2,title:"finishCompletion方法",slug:"finishcompletion方法",normalizedTitle:"finishcompletion方法",charIndex:173},{level:2,title:"get方法",slug:"get方法",normalizedTitle:"get方法",charIndex:195},{level:2,title:"awaitDone方法",slug:"awaitdone方法",normalizedTitle:"awaitdone方法",charIndex:204},{level:2,title:"removeWaiter方法",slug:"removewaiter方法",normalizedTitle:"removewaiter方法",charIndex:219},{level:2,title:"cancel方法",slug:"cancel方法",normalizedTitle:"cancel方法",charIndex:237},{level:2,title:"report方法",slug:"report方法",normalizedTitle:"report方法",charIndex:249},{level:2,title:"runAndReset方法",slug:"runandreset方法",normalizedTitle:"runandreset方法",charIndex:261}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>FutureTask源码解析</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"FutureTask的状态 FutureTask使用过程 FutureTask内部结构 FutureTask构造方法 run方法 setException方法 set方法 handlePossibleCancellationInterrupt方法 finishCompletion方法 get方法 awaitDone方法 removeWaiter方法 cancel方法 report方法 runAndReset方法",content:"说明\n\nFutureTask源码解析\n\n\n\n * FutureTask的状态\n * FutureTask使用过程\n * FutureTask内部结构\n * FutureTask构造方法\n * run方法\n * setException方法\n * set方法\n * handlePossibleCancellationInterrupt方法\n * finishCompletion方法\n * get方法\n * awaitDone方法\n * removeWaiter方法\n * cancel方法\n * report方法\n * runAndReset方法\n\n\n\n\n# FutureTask源码解析\n\n\n# 1、FutureTask介绍\n\nFutureTask是一种可以取消的异步的计算任务。它的计算是通过Callable实现的，可以把它理解为是可以返回结果的Runnable。\n\n使用FutureTask的优势有：\n\n 1. 可以获取线程执行后的返回结果；\n 2. 提供了超时控制功能。\n\n它实现了Runnable接口和Future接口：\n\n\n\n什么是异步计算呢？也就是说，在让该任务执行时，不需要一直等待其运行结束返回结果，而是可以先去处理其他的事情，然后再获取返回结果。例如你想下载一个很大的文件，这时很耗时的操作，没必要一直等待着文件下载完，你可以先去吃个饭，然后再回来看下文件是否下载完成，如果下载完成就可以使用了，否则还需要继续等待。\n\n\n# 2、FutureTask的实现\n\n\n# FutureTask的状态\n\nFutureTask内部有这样几种状态：\n\nprivate static final int NEW          = 0;\nprivate static final int COMPLETING   = 1;\nprivate static final int NORMAL       = 2;\nprivate static final int EXCEPTIONAL  = 3;\nprivate static final int CANCELLED    = 4;\nprivate static final int INTERRUPTING = 5;\nprivate static final int INTERRUPTED  = 6;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n看名字应该很好理解了，当创建一个FutureTask对象是，初始的状态是NEW，在运行时状态会转换，有4中状态的转换过程：\n\n * NEW -> COMPLETING -> NORMAL：正常执行并返回；\n * NEW -> COMPLETING -> EXCEPTIONAL：执行过程中出现了异常；\n * NEW -> CANCELLED；执行前被取消；\n * NEW -> INTERRUPTING -> INTERRUPTED：取消时被中断。\n\n另外，在《java并发编程的艺术》一书，作者根据FutureTask.run()方法的执行的时机，将FutureTask分为了3种状态：\n\n 1. 未启动。FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态。当创建一个FutureTask，还没有执行FutureTask.run()方法之前，FutureTask处于未启动状态。\n 2. 已启动。FutureTask.run()方法被执行的过程中，FutureTask处于已启动状态。\n 3. 已完成。FutureTask.run()方法执行结束，或者调用FutureTask.cancel(...)方法取消任务，或者在执行任务期间抛出异常，这些情况都称之为FutureTask的已完成状态。\n\n下图总结了FutureTask的状态变化的过程：\n\n\n\n由于FutureTask具有这三种状态，因此执行FutureTask的get方法和cancel方法，当前处于不同的状态对应的结果也是大不相同。这里对get方法和cancel方法先做个总结：\n\n> get方法\n\n当FutureTask处于未启动或已启动状态时，执行FutureTask.get()方法将导致调用线程阻塞。如果FutureTask处于已完成状态，调用FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常。\n\n> cancel方法\n\n当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将此任务永远不会执行；\n\n当FutureTask处于已启动状态时，执行FutureTask.cancel(true)方法将以中断线程的方式来阻止任务继续进行，如果执行FutureTask.cancel(false)将不会对正在执行任务的线程有任何影响；\n\n当FutureTask处于已完成状态时，执行FutureTask.cancel(...)方法将返回false。\n\n对Future的get()方法和cancel()方法用下图进行总结：\n\n\n\n\n# FutureTask使用过程\n\n下面看一下具体的使用过程：\n\npublic class FutureTaskTest {\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService executor = Executors.newSingleThreadExecutor();\n        FutureTask<Integer> future = new FutureTask<>(new Callable<Integer>() {\n            @Override\n            public Integer call() throws Exception {\n                int result = 0;\n                for (int i = 0; i < 100; i++) {\n                    result += i;\n                }\n                return result;\n            }\n        });\n\n        executor.execute(future);\n\n        System.out.println(future.get());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# FutureTask内部结构\n\npublic class FutureTask<V> implements RunnableFuture<V> {\n\n    private volatile int state;\n    private static final int NEW          = 0;\n    private static final int COMPLETING   = 1;\n    private static final int NORMAL       = 2;\n    private static final int EXCEPTIONAL  = 3;\n    private static final int CANCELLED    = 4;\n    private static final int INTERRUPTING = 5;\n    private static final int INTERRUPTED  = 6;\n\n    /** The underlying callable; nulled out after running */\n    private Callable<V> callable;\n    /** The result to return or exception to throw from get() */\n    private Object outcome; // non-volatile, protected by state reads/writes\n    /** 执行callable的线程 **/\n    private volatile Thread runner;\n    /**\n     * Treiber stack of waiting threads\n     * 使用Treiber算法实现的无阻塞的Stack，\n     * 用于存放等待的线程\n     */\n    private volatile WaitNode waiters;\n\n    static final class WaitNode {\n        volatile Thread thread;\n        volatile WaitNode next;\n        WaitNode() { thread = Thread.currentThread(); }\n    }\n\n    public V get() throws InterruptedException, ExecutionException {\n        ...\n    }\n\n    public V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException {\n        ...\n    }\n\n    ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n这里的waiters理解为一个stack，因为在调用get方法时任务可能还没有执行完，这时需要将调用get方法的线程放入waiters中。\n\n最重要的两个get方法，用于获取返回结果，第二种提供了超时控制功能。\n\n\n# FutureTask构造方法\n\nFutureTask有两个构造方法：\n\npublic FutureTask(Callable<V> callable) {\n    if (callable == null)\n        throw new NullPointerException();\n    this.callable = callable;\n    this.state = NEW;       // ensure visibility of callable\n}\n\npublic FutureTask(Runnable runnable, V result) {\n    this.callable = Executors.callable(runnable, result);\n    this.state = NEW;       // ensure visibility of callable\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n第二种构造方法传入一个Runnable对象和一个返回值对象，因为Runnable是没有返回值的，所以要通过result参数在执行完之后返回结果。\n\n\n# run方法\n\nFutureTask实现了Runnable接口，所以需要实现run方法，代码如下：\n\npublic void run() {\n    /*\n     * 首先判断状态，如果不是初始状态，说明任务已经被执行或取消；\n     * runner是FutureTask的一个属性，用于保存执行任务的线程，\n     * 如果不为空则表示已经有线程正在执行，这里用CAS来设置，失败则返回。\n     */\n    if (state != NEW ||\n        !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                     null, Thread.currentThread()))\n        return;\n    try {\n        Callable<V> c = callable;\n        // 只有初始状态才会执行\n        if (c != null && state == NEW) {\n            V result;\n            boolean ran;\n            try {\n                // 执行任务\n                result = c.call();\n                // 如果没出现异常，则说明执行成功了\n                ran = true;\n            } catch (Throwable ex) {\n                result = null;\n                ran = false;\n                // 设置异常\n                setException(ex);\n            }\n            // 如果执行成功，则设置返回结果\n            if (ran)\n                set(result);\n        }\n    } finally {\n        // runner must be non-null until state is settled to\n        // prevent concurrent calls to run()\n        // 无论是否执行成功，把runner设置为null\n        runner = null;\n        // state must be re-read after nulling runner to prevent\n        // leaked interrupts\n        int s = state;\n        // 如果被中断，则说明调用的cancel(true)，\n        // 这里要保证在cancel方法中把state设置为INTERRUPTED\n        // 否则可能在cancel方法中还没执行中断，造成中断的泄露\n        if (s >= INTERRUPTING)\n            handlePossibleCancellationInterrupt(s);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n总结一下run方法的执行过程：\n\n 1. 只有state为NEW的时候才执行任务；\n 2. 执行前要设置runner为当前线程，使用CAS来设置是为了防止竞争；\n 3. 如果任务执行成功，任务状态从NEW转换为COMPLETING，如果执行正常，设置最终状态为NORMAL；如果执行中出现了异常，设置最终状态为EXCEPTIONAL；\n 4. 唤醒并删除Treiber Stack中的所有节点；\n 5. 如果调用了cancel(true)方法进行了中断，要确保在run方法执行结束前的状态是INTERRUPTED。\n\n这里涉及到3个比较重要的方法：setException，set和handlePossibleCancellationInterrupt。\n\n\n# setException方法\n\nprotected void setException(Throwable t) {\n    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n        outcome = t;\n        UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state\n        finishCompletion();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果在执行过程中（也就是调用call方法时）出现了异常，则要把状态先设置为COMPLETING，如果成功，设置outcome = t，outcome对象是Object类型的，用来保存异常或者返回结果对象，也就是说，在正常的执行过程中（没有异常，没有调用cancel方法），outcome保存着返回结果对象，会被返回，如果出现了异常或者中断，则不会返回并抛出异常，这个在介绍report方法时会讲到。\n\n接着设置状态为EXCEPTIONAL，这也是最终的状态。\n\nfinishCompletion方法稍后再分析。\n\n\n# set方法\n\nprotected void set(V v) {\n    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {\n        outcome = v;\n        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state\n        finishCompletion();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n很简单，与setException类似，只不过这里的outcome是返回结果对象，状态先设置为COMPLETING，然后再设置为MORMAL。\n\n\n# handlePossibleCancellationInterrupt方法\n\nprivate void handlePossibleCancellationInterrupt(int s) {\n    // It is possible for our interrupter to stall before getting a\n    // chance to interrupt us.  Let's spin-wait patiently.\n    if (s == INTERRUPTING)\n        while (state == INTERRUPTING)\n            Thread.yield(); // wait out pending interrupt\n\n    // assert state == INTERRUPTED;\n\n    // We want to clear any interrupt we may have received from\n    // cancel(true).  However, it is permissible to use interrupts\n    // as an independent mechanism for a task to communicate with\n    // its caller, and there is no way to clear only the\n    // cancellation interrupt.\n    //\n    // Thread.interrupted();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nhandlePossibleCancellationInterrupt方法要确保cancel(true)产生的中断发生在run或runAndReset方法执行的过程中。这里会循环的调用Thread.yield()来确保状态在cancel方法中被设置为INTERRUPTED。\n\n这里不能够清除中断标记，因为不能确定中断一定来自于cancel方法。\n\n\n# finishCompletion方法\n\nprivate void finishCompletion() {\n    // assert state > COMPLETING;\n    // 执行该方法时state必须大于COMPLETING\n    // 逐个唤醒waiters中的线程\n    for (WaitNode q; (q = waiters) != null;) {\n        // 设置栈顶节点为null\n        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {\n            for (;;) {\n                Thread t = q.thread;\n                // 唤醒线程\n                if (t != null) {\n                    q.thread = null;\n                    LockSupport.unpark(t);\n                }\n                // 如果next为空，说明栈空了，跳出循环\n                WaitNode next = q.next;\n                if (next == null)\n                    break;\n                // 方便gc回收\n                q.next = null; // unlink to help gc\n                // 重新设置栈顶node\n                q = next;\n            }\n            break;\n        }\n    }\n    // 钩子方法\n    done();\n\n    callable = null;        // to reduce footprint\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n在调用get方法时，如果任务还没有执行结束，则会阻塞调用的线程，然后把调用的线程放入waiters中，这时，如果任务执行完毕，也就是调用了finishCompletion方法，waiters会依次出栈并逐个唤醒对应的线程。\n\n由此可以想到，WaitNode一定是在get方法中被添加到栈中的，下面来看下get方法的实现。\n\n\n# get方法\n\npublic V get() throws InterruptedException, ExecutionException {\n    int s = state;\n    if (s <= COMPLETING)\n        s = awaitDone(false, 0L);\n    return report(s);\n}\n\npublic V get(long timeout, TimeUnit unit)\n    throws InterruptedException, ExecutionException, TimeoutException {\n    if (unit == null)\n        throw new NullPointerException();\n    int s = state;\n    if (s <= COMPLETING &&\n        (s = awaitDone(true, unit.toNanos(timeout))) <= COMPLETING)\n        throw new TimeoutException();\n    return report(s);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这两个方法类似，首先判断状态，如果s <= COMPLETING，说明任务已经执行完毕，但set方法或setException方法还未执行结束（还未设置状态为NORMAL或EXCEPTIONAL），这时需要将当前线程添加到waiters中并阻塞。\n\n第二种get提供了超时功能，如果在规定时间内任务还未执行完毕或者状态还是COMPLETING，则获取结果超时，抛出TimeoutException。而第一种get会一直阻塞直到state > COMPLETING。\n\n\n# awaitDone方法\n\nawaitDone方法的工作是根据状态来判断是否能够返回结果，如果任务还未执行完毕，要添加到waiters中并阻塞，否则返回状态。代码如下：\n\nprivate int awaitDone(boolean timed, long nanos)\n    throws InterruptedException {\n    // 计算到期时间\n    final long deadline = timed ? System.nanoTime() + nanos : 0L;\n    WaitNode q = null;\n    boolean queued = false;\n    for (;;) {\n        // 如果被中断，删除节点，抛出异常\n        if (Thread.interrupted()) {\n            removeWaiter(q);\n            throw new InterruptedException();\n        }\n\n        int s = state;\n        // 如果任务执行完毕并且设置了最终状态或者被取消，则返回\n        if (s > COMPLETING) {\n            if (q != null)\n                q.thread = null;\n            return s;\n        }\n        // s == COMPLETING时通过Thread.yield();让步其他线程执行，\n        // 主要是为了让状态改变\n        else if (s == COMPLETING) // cannot time out yet\n            Thread.yield();\n        // 创建一个WaitNode\n        else if (q == null)\n            q = new WaitNode();\n        // CAS设置栈顶节点\n        else if (!queued)\n            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                 q.next = waiters, q);\n        // 如果设置了超时，则计算是否已经到了开始设置的到期时间\n        else if (timed) {\n            nanos = deadline - System.nanoTime();\n            // 如果已经到了到期时间，删除节点，返回状态\n            if (nanos <= 0L) {\n                removeWaiter(q);\n                return state;\n            }\n            // 阻塞到到期时间\n            LockSupport.parkNanos(this, nanos);\n        }\n        // 如果没有设置超时，会一直阻塞，直到被中断或者被唤醒\n        else\n            LockSupport.park(this);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# removeWaiter方法\n\nprivate void removeWaiter(WaitNode node) {\n    if (node != null) {\n        // 将thread设置为null是因为下面要根据thread是否为null判断是否要把node移出\n        node.thread = null;\n        // 这里自旋保证删除成功\n        retry:\n        for (;;) {          // restart on removeWaiter race\n            for (WaitNode pred = null, q = waiters, s; q != null; q = s) {\n                s = q.next;\n                // q.thread != null说明该q节点不需要移除\n                if (q.thread != null)\n                    pred = q;\n                // 如果q.thread == null，且pred != null，需要删除q节点\n                else if (pred != null) {\n                    // 删除q节点\n                    pred.next = s;\n                    // pred.thread == null时说明在并发情况下被其他线程修改了；\n                    // 返回第一个for循环重试\n                    if (pred.thread == null) // check for race\n                        continue retry;\n                }\n                // 如果q.thread != null且pred == null，说明q是栈顶节点\n                // 设置栈顶元素为s节点，如果失败则返回重试\n                else if (!UNSAFE.compareAndSwapObject(this, waitersOffset,\n                                                      q, s))\n                    continue retry;\n            }\n            break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# cancel方法\n\ncancel方法用于取消任务，这里可能有两种情况，一种是任务已经执行了，另一种是还未执行，代码如下：\n\npublic boolean cancel(boolean mayInterruptIfRunning) {\n    if (!(state == NEW &&\n          UNSAFE.compareAndSwapInt(this, stateOffset, NEW,\n              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))\n        return false;\n    try {    // in case call to interrupt throws exception\n        // mayInterruptIfRunning参数表示是否要进行中断\n        if (mayInterruptIfRunning) {\n            try {\n                // runner保存着当前执行任务的线程\n                Thread t = runner;\n                // 中断线程\n                if (t != null)\n                    t.interrupt();\n            } finally { // final state\n                // 设置最终状态为INTERRUPTED\n                UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED);\n            }\n        }\n    } finally {\n        finishCompletion();\n    }\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n第一个if判断可能有些不好理解，其实等价于如下代码：\n\nif (!state == NEW ||\n          !UNSAFE.compareAndSwapInt(this, stateOffset, NEW,\n              mayInterruptIfRunning ? INTERRUPTING : CANCELLED))\n\n\n1\n2\n3\n\n\n如果状态不是NEW，或者设置状态为INTERRUPTING或CANCELLED失败，则取消失败，返回false。\n\n简单来说有一下两种情况：\n\n * 如果当前任务还没有执行，那么state == NEW，那么会尝试设置状态，如果设置状态失败会返回false，表示取消失败；\n * 如果当前任务已经被执行了，那么state > NEW，也就是!state == NEW为true，直接返回false。\n\n也就是说，如果任务一旦开始执行了（state != NEW），那么就不能被取消。\n\n如果mayInterruptIfRunning为true，要中断当前执行任务的线程。\n\n\n# report方法\n\nget方法在调用awaitDone方法后，会调用report方法进行返回：\n\nprivate V report(int s) throws ExecutionException {\n    Object x = outcome;\n    if (s == NORMAL)\n        return (V)x;\n    if (s >= CANCELLED)\n        throw new CancellationException();\n    throw new ExecutionException((Throwable)x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n很简单，可以看到有3中执行情况：\n\n 1. 如果s == NORMAL为true，说明是正常执行结束，那么根据上述的分析，在正常执行结束时outcome存放的是返回结果，把outcome返回；\n 2. 如果s >= CANCELLED为true，说明是被取消了，抛出CancellationException；\n 3. 如果s < CANCELLED，那么状态只能是是EXCEPTIONAL，表示在执行过程中出现了异常，抛出ExecutionException。\n\n\n# runAndReset方法\n\n该方法和run方法类似，区别在于这个方法不会设置任务的执行结果值，所以在正常执行时，不会修改state，除非发生了异常或者中断，最后返回是否正确的执行并复位：\n\nprotected boolean runAndReset() {\n    if (state != NEW ||\n        !UNSAFE.compareAndSwapObject(this, runnerOffset,\n                                     null, Thread.currentThread()))\n        return false;\n    boolean ran = false;\n    int s = state;\n    try {\n        Callable<V> c = callable;\n        if (c != null && s == NEW) {\n            try {\n                // 不获取和设置返回值\n                c.call(); // don't set result\n                ran = true;\n            } catch (Throwable ex) {\n                setException(ex);\n            }\n        }\n    } finally {\n        // runner must be non-null until state is settled to\n        // prevent concurrent calls to run()\n        runner = null;\n        // state must be re-read after nulling runner to prevent\n        // leaked interrupts\n        s = state;\n        if (s >= INTERRUPTING)\n            handlePossibleCancellationInterrupt(s);\n    }\n    // 是否正确的执行并复位\n    return ran && s == NEW;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 3、总结\n\n本文分析了FutureTask的执行过程和获取返回值的过程，要注意以下几个地方：\n\n * FutureTask是线程安全的，在多线程下任务也只会被执行一次；\n * 注意在执行时各种状态的切换；\n * get方法调用时，如果任务没有结束，要阻塞当前线程，法阻塞的线程会保存在一个Treiber Stack中；\n * get方法超时功能如果超时未获取成功，会抛出TimeoutException；\n * 注意在取消时的线程中断，在run方法中一定要保证结束时的状态是INTERRUPTED，否则在cancel方法中可能没有执行interrupt，造成中断的泄露。\n\n> 参考文献\n\nFutureTask源码解析",normalizedContent:"说明\n\nfuturetask源码解析\n\n\n\n * futuretask的状态\n * futuretask使用过程\n * futuretask内部结构\n * futuretask构造方法\n * run方法\n * setexception方法\n * set方法\n * handlepossiblecancellationinterrupt方法\n * finishcompletion方法\n * get方法\n * awaitdone方法\n * removewaiter方法\n * cancel方法\n * report方法\n * runandreset方法\n\n\n\n\n# futuretask源码解析\n\n\n# 1、futuretask介绍\n\nfuturetask是一种可以取消的异步的计算任务。它的计算是通过callable实现的，可以把它理解为是可以返回结果的runnable。\n\n使用futuretask的优势有：\n\n 1. 可以获取线程执行后的返回结果；\n 2. 提供了超时控制功能。\n\n它实现了runnable接口和future接口：\n\n\n\n什么是异步计算呢？也就是说，在让该任务执行时，不需要一直等待其运行结束返回结果，而是可以先去处理其他的事情，然后再获取返回结果。例如你想下载一个很大的文件，这时很耗时的操作，没必要一直等待着文件下载完，你可以先去吃个饭，然后再回来看下文件是否下载完成，如果下载完成就可以使用了，否则还需要继续等待。\n\n\n# 2、futuretask的实现\n\n\n# futuretask的状态\n\nfuturetask内部有这样几种状态：\n\nprivate static final int new          = 0;\nprivate static final int completing   = 1;\nprivate static final int normal       = 2;\nprivate static final int exceptional  = 3;\nprivate static final int cancelled    = 4;\nprivate static final int interrupting = 5;\nprivate static final int interrupted  = 6;\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n看名字应该很好理解了，当创建一个futuretask对象是，初始的状态是new，在运行时状态会转换，有4中状态的转换过程：\n\n * new -> completing -> normal：正常执行并返回；\n * new -> completing -> exceptional：执行过程中出现了异常；\n * new -> cancelled；执行前被取消；\n * new -> interrupting -> interrupted：取消时被中断。\n\n另外，在《java并发编程的艺术》一书，作者根据futuretask.run()方法的执行的时机，将futuretask分为了3种状态：\n\n 1. 未启动。futuretask.run()方法还没有被执行之前，futuretask处于未启动状态。当创建一个futuretask，还没有执行futuretask.run()方法之前，futuretask处于未启动状态。\n 2. 已启动。futuretask.run()方法被执行的过程中，futuretask处于已启动状态。\n 3. 已完成。futuretask.run()方法执行结束，或者调用futuretask.cancel(...)方法取消任务，或者在执行任务期间抛出异常，这些情况都称之为futuretask的已完成状态。\n\n下图总结了futuretask的状态变化的过程：\n\n\n\n由于futuretask具有这三种状态，因此执行futuretask的get方法和cancel方法，当前处于不同的状态对应的结果也是大不相同。这里对get方法和cancel方法先做个总结：\n\n> get方法\n\n当futuretask处于未启动或已启动状态时，执行futuretask.get()方法将导致调用线程阻塞。如果futuretask处于已完成状态，调用futuretask.get()方法将导致调用线程立即返回结果或者抛出异常。\n\n> cancel方法\n\n当futuretask处于未启动状态时，执行futuretask.cancel()方法将此任务永远不会执行；\n\n当futuretask处于已启动状态时，执行futuretask.cancel(true)方法将以中断线程的方式来阻止任务继续进行，如果执行futuretask.cancel(false)将不会对正在执行任务的线程有任何影响；\n\n当futuretask处于已完成状态时，执行futuretask.cancel(...)方法将返回false。\n\n对future的get()方法和cancel()方法用下图进行总结：\n\n\n\n\n# futuretask使用过程\n\n下面看一下具体的使用过程：\n\npublic class futuretasktest {\n\n    public static void main(string[] args) throws executionexception, interruptedexception {\n        executorservice executor = executors.newsinglethreadexecutor();\n        futuretask<integer> future = new futuretask<>(new callable<integer>() {\n            @override\n            public integer call() throws exception {\n                int result = 0;\n                for (int i = 0; i < 100; i++) {\n                    result += i;\n                }\n                return result;\n            }\n        });\n\n        executor.execute(future);\n\n        system.out.println(future.get());\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# futuretask内部结构\n\npublic class futuretask<v> implements runnablefuture<v> {\n\n    private volatile int state;\n    private static final int new          = 0;\n    private static final int completing   = 1;\n    private static final int normal       = 2;\n    private static final int exceptional  = 3;\n    private static final int cancelled    = 4;\n    private static final int interrupting = 5;\n    private static final int interrupted  = 6;\n\n    /** the underlying callable; nulled out after running */\n    private callable<v> callable;\n    /** the result to return or exception to throw from get() */\n    private object outcome; // non-volatile, protected by state reads/writes\n    /** 执行callable的线程 **/\n    private volatile thread runner;\n    /**\n     * treiber stack of waiting threads\n     * 使用treiber算法实现的无阻塞的stack，\n     * 用于存放等待的线程\n     */\n    private volatile waitnode waiters;\n\n    static final class waitnode {\n        volatile thread thread;\n        volatile waitnode next;\n        waitnode() { thread = thread.currentthread(); }\n    }\n\n    public v get() throws interruptedexception, executionexception {\n        ...\n    }\n\n    public v get(long timeout, timeunit unit)\n        throws interruptedexception, executionexception, timeoutexception {\n        ...\n    }\n\n    ...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n这里的waiters理解为一个stack，因为在调用get方法时任务可能还没有执行完，这时需要将调用get方法的线程放入waiters中。\n\n最重要的两个get方法，用于获取返回结果，第二种提供了超时控制功能。\n\n\n# futuretask构造方法\n\nfuturetask有两个构造方法：\n\npublic futuretask(callable<v> callable) {\n    if (callable == null)\n        throw new nullpointerexception();\n    this.callable = callable;\n    this.state = new;       // ensure visibility of callable\n}\n\npublic futuretask(runnable runnable, v result) {\n    this.callable = executors.callable(runnable, result);\n    this.state = new;       // ensure visibility of callable\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n第二种构造方法传入一个runnable对象和一个返回值对象，因为runnable是没有返回值的，所以要通过result参数在执行完之后返回结果。\n\n\n# run方法\n\nfuturetask实现了runnable接口，所以需要实现run方法，代码如下：\n\npublic void run() {\n    /*\n     * 首先判断状态，如果不是初始状态，说明任务已经被执行或取消；\n     * runner是futuretask的一个属性，用于保存执行任务的线程，\n     * 如果不为空则表示已经有线程正在执行，这里用cas来设置，失败则返回。\n     */\n    if (state != new ||\n        !unsafe.compareandswapobject(this, runneroffset,\n                                     null, thread.currentthread()))\n        return;\n    try {\n        callable<v> c = callable;\n        // 只有初始状态才会执行\n        if (c != null && state == new) {\n            v result;\n            boolean ran;\n            try {\n                // 执行任务\n                result = c.call();\n                // 如果没出现异常，则说明执行成功了\n                ran = true;\n            } catch (throwable ex) {\n                result = null;\n                ran = false;\n                // 设置异常\n                setexception(ex);\n            }\n            // 如果执行成功，则设置返回结果\n            if (ran)\n                set(result);\n        }\n    } finally {\n        // runner must be non-null until state is settled to\n        // prevent concurrent calls to run()\n        // 无论是否执行成功，把runner设置为null\n        runner = null;\n        // state must be re-read after nulling runner to prevent\n        // leaked interrupts\n        int s = state;\n        // 如果被中断，则说明调用的cancel(true)，\n        // 这里要保证在cancel方法中把state设置为interrupted\n        // 否则可能在cancel方法中还没执行中断，造成中断的泄露\n        if (s >= interrupting)\n            handlepossiblecancellationinterrupt(s);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n总结一下run方法的执行过程：\n\n 1. 只有state为new的时候才执行任务；\n 2. 执行前要设置runner为当前线程，使用cas来设置是为了防止竞争；\n 3. 如果任务执行成功，任务状态从new转换为completing，如果执行正常，设置最终状态为normal；如果执行中出现了异常，设置最终状态为exceptional；\n 4. 唤醒并删除treiber stack中的所有节点；\n 5. 如果调用了cancel(true)方法进行了中断，要确保在run方法执行结束前的状态是interrupted。\n\n这里涉及到3个比较重要的方法：setexception，set和handlepossiblecancellationinterrupt。\n\n\n# setexception方法\n\nprotected void setexception(throwable t) {\n    if (unsafe.compareandswapint(this, stateoffset, new, completing)) {\n        outcome = t;\n        unsafe.putorderedint(this, stateoffset, exceptional); // final state\n        finishcompletion();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果在执行过程中（也就是调用call方法时）出现了异常，则要把状态先设置为completing，如果成功，设置outcome = t，outcome对象是object类型的，用来保存异常或者返回结果对象，也就是说，在正常的执行过程中（没有异常，没有调用cancel方法），outcome保存着返回结果对象，会被返回，如果出现了异常或者中断，则不会返回并抛出异常，这个在介绍report方法时会讲到。\n\n接着设置状态为exceptional，这也是最终的状态。\n\nfinishcompletion方法稍后再分析。\n\n\n# set方法\n\nprotected void set(v v) {\n    if (unsafe.compareandswapint(this, stateoffset, new, completing)) {\n        outcome = v;\n        unsafe.putorderedint(this, stateoffset, normal); // final state\n        finishcompletion();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n很简单，与setexception类似，只不过这里的outcome是返回结果对象，状态先设置为completing，然后再设置为mormal。\n\n\n# handlepossiblecancellationinterrupt方法\n\nprivate void handlepossiblecancellationinterrupt(int s) {\n    // it is possible for our interrupter to stall before getting a\n    // chance to interrupt us.  let's spin-wait patiently.\n    if (s == interrupting)\n        while (state == interrupting)\n            thread.yield(); // wait out pending interrupt\n\n    // assert state == interrupted;\n\n    // we want to clear any interrupt we may have received from\n    // cancel(true).  however, it is permissible to use interrupts\n    // as an independent mechanism for a task to communicate with\n    // its caller, and there is no way to clear only the\n    // cancellation interrupt.\n    //\n    // thread.interrupted();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nhandlepossiblecancellationinterrupt方法要确保cancel(true)产生的中断发生在run或runandreset方法执行的过程中。这里会循环的调用thread.yield()来确保状态在cancel方法中被设置为interrupted。\n\n这里不能够清除中断标记，因为不能确定中断一定来自于cancel方法。\n\n\n# finishcompletion方法\n\nprivate void finishcompletion() {\n    // assert state > completing;\n    // 执行该方法时state必须大于completing\n    // 逐个唤醒waiters中的线程\n    for (waitnode q; (q = waiters) != null;) {\n        // 设置栈顶节点为null\n        if (unsafe.compareandswapobject(this, waitersoffset, q, null)) {\n            for (;;) {\n                thread t = q.thread;\n                // 唤醒线程\n                if (t != null) {\n                    q.thread = null;\n                    locksupport.unpark(t);\n                }\n                // 如果next为空，说明栈空了，跳出循环\n                waitnode next = q.next;\n                if (next == null)\n                    break;\n                // 方便gc回收\n                q.next = null; // unlink to help gc\n                // 重新设置栈顶node\n                q = next;\n            }\n            break;\n        }\n    }\n    // 钩子方法\n    done();\n\n    callable = null;        // to reduce footprint\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n在调用get方法时，如果任务还没有执行结束，则会阻塞调用的线程，然后把调用的线程放入waiters中，这时，如果任务执行完毕，也就是调用了finishcompletion方法，waiters会依次出栈并逐个唤醒对应的线程。\n\n由此可以想到，waitnode一定是在get方法中被添加到栈中的，下面来看下get方法的实现。\n\n\n# get方法\n\npublic v get() throws interruptedexception, executionexception {\n    int s = state;\n    if (s <= completing)\n        s = awaitdone(false, 0l);\n    return report(s);\n}\n\npublic v get(long timeout, timeunit unit)\n    throws interruptedexception, executionexception, timeoutexception {\n    if (unit == null)\n        throw new nullpointerexception();\n    int s = state;\n    if (s <= completing &&\n        (s = awaitdone(true, unit.tonanos(timeout))) <= completing)\n        throw new timeoutexception();\n    return report(s);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这两个方法类似，首先判断状态，如果s <= completing，说明任务已经执行完毕，但set方法或setexception方法还未执行结束（还未设置状态为normal或exceptional），这时需要将当前线程添加到waiters中并阻塞。\n\n第二种get提供了超时功能，如果在规定时间内任务还未执行完毕或者状态还是completing，则获取结果超时，抛出timeoutexception。而第一种get会一直阻塞直到state > completing。\n\n\n# awaitdone方法\n\nawaitdone方法的工作是根据状态来判断是否能够返回结果，如果任务还未执行完毕，要添加到waiters中并阻塞，否则返回状态。代码如下：\n\nprivate int awaitdone(boolean timed, long nanos)\n    throws interruptedexception {\n    // 计算到期时间\n    final long deadline = timed ? system.nanotime() + nanos : 0l;\n    waitnode q = null;\n    boolean queued = false;\n    for (;;) {\n        // 如果被中断，删除节点，抛出异常\n        if (thread.interrupted()) {\n            removewaiter(q);\n            throw new interruptedexception();\n        }\n\n        int s = state;\n        // 如果任务执行完毕并且设置了最终状态或者被取消，则返回\n        if (s > completing) {\n            if (q != null)\n                q.thread = null;\n            return s;\n        }\n        // s == completing时通过thread.yield();让步其他线程执行，\n        // 主要是为了让状态改变\n        else if (s == completing) // cannot time out yet\n            thread.yield();\n        // 创建一个waitnode\n        else if (q == null)\n            q = new waitnode();\n        // cas设置栈顶节点\n        else if (!queued)\n            queued = unsafe.compareandswapobject(this, waitersoffset,\n                                                 q.next = waiters, q);\n        // 如果设置了超时，则计算是否已经到了开始设置的到期时间\n        else if (timed) {\n            nanos = deadline - system.nanotime();\n            // 如果已经到了到期时间，删除节点，返回状态\n            if (nanos <= 0l) {\n                removewaiter(q);\n                return state;\n            }\n            // 阻塞到到期时间\n            locksupport.parknanos(this, nanos);\n        }\n        // 如果没有设置超时，会一直阻塞，直到被中断或者被唤醒\n        else\n            locksupport.park(this);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# removewaiter方法\n\nprivate void removewaiter(waitnode node) {\n    if (node != null) {\n        // 将thread设置为null是因为下面要根据thread是否为null判断是否要把node移出\n        node.thread = null;\n        // 这里自旋保证删除成功\n        retry:\n        for (;;) {          // restart on removewaiter race\n            for (waitnode pred = null, q = waiters, s; q != null; q = s) {\n                s = q.next;\n                // q.thread != null说明该q节点不需要移除\n                if (q.thread != null)\n                    pred = q;\n                // 如果q.thread == null，且pred != null，需要删除q节点\n                else if (pred != null) {\n                    // 删除q节点\n                    pred.next = s;\n                    // pred.thread == null时说明在并发情况下被其他线程修改了；\n                    // 返回第一个for循环重试\n                    if (pred.thread == null) // check for race\n                        continue retry;\n                }\n                // 如果q.thread != null且pred == null，说明q是栈顶节点\n                // 设置栈顶元素为s节点，如果失败则返回重试\n                else if (!unsafe.compareandswapobject(this, waitersoffset,\n                                                      q, s))\n                    continue retry;\n            }\n            break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# cancel方法\n\ncancel方法用于取消任务，这里可能有两种情况，一种是任务已经执行了，另一种是还未执行，代码如下：\n\npublic boolean cancel(boolean mayinterruptifrunning) {\n    if (!(state == new &&\n          unsafe.compareandswapint(this, stateoffset, new,\n              mayinterruptifrunning ? interrupting : cancelled)))\n        return false;\n    try {    // in case call to interrupt throws exception\n        // mayinterruptifrunning参数表示是否要进行中断\n        if (mayinterruptifrunning) {\n            try {\n                // runner保存着当前执行任务的线程\n                thread t = runner;\n                // 中断线程\n                if (t != null)\n                    t.interrupt();\n            } finally { // final state\n                // 设置最终状态为interrupted\n                unsafe.putorderedint(this, stateoffset, interrupted);\n            }\n        }\n    } finally {\n        finishcompletion();\n    }\n    return true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n第一个if判断可能有些不好理解，其实等价于如下代码：\n\nif (!state == new ||\n          !unsafe.compareandswapint(this, stateoffset, new,\n              mayinterruptifrunning ? interrupting : cancelled))\n\n\n1\n2\n3\n\n\n如果状态不是new，或者设置状态为interrupting或cancelled失败，则取消失败，返回false。\n\n简单来说有一下两种情况：\n\n * 如果当前任务还没有执行，那么state == new，那么会尝试设置状态，如果设置状态失败会返回false，表示取消失败；\n * 如果当前任务已经被执行了，那么state > new，也就是!state == new为true，直接返回false。\n\n也就是说，如果任务一旦开始执行了（state != new），那么就不能被取消。\n\n如果mayinterruptifrunning为true，要中断当前执行任务的线程。\n\n\n# report方法\n\nget方法在调用awaitdone方法后，会调用report方法进行返回：\n\nprivate v report(int s) throws executionexception {\n    object x = outcome;\n    if (s == normal)\n        return (v)x;\n    if (s >= cancelled)\n        throw new cancellationexception();\n    throw new executionexception((throwable)x);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n很简单，可以看到有3中执行情况：\n\n 1. 如果s == normal为true，说明是正常执行结束，那么根据上述的分析，在正常执行结束时outcome存放的是返回结果，把outcome返回；\n 2. 如果s >= cancelled为true，说明是被取消了，抛出cancellationexception；\n 3. 如果s < cancelled，那么状态只能是是exceptional，表示在执行过程中出现了异常，抛出executionexception。\n\n\n# runandreset方法\n\n该方法和run方法类似，区别在于这个方法不会设置任务的执行结果值，所以在正常执行时，不会修改state，除非发生了异常或者中断，最后返回是否正确的执行并复位：\n\nprotected boolean runandreset() {\n    if (state != new ||\n        !unsafe.compareandswapobject(this, runneroffset,\n                                     null, thread.currentthread()))\n        return false;\n    boolean ran = false;\n    int s = state;\n    try {\n        callable<v> c = callable;\n        if (c != null && s == new) {\n            try {\n                // 不获取和设置返回值\n                c.call(); // don't set result\n                ran = true;\n            } catch (throwable ex) {\n                setexception(ex);\n            }\n        }\n    } finally {\n        // runner must be non-null until state is settled to\n        // prevent concurrent calls to run()\n        runner = null;\n        // state must be re-read after nulling runner to prevent\n        // leaked interrupts\n        s = state;\n        if (s >= interrupting)\n            handlepossiblecancellationinterrupt(s);\n    }\n    // 是否正确的执行并复位\n    return ran && s == new;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 3、总结\n\n本文分析了futuretask的执行过程和获取返回值的过程，要注意以下几个地方：\n\n * futuretask是线程安全的，在多线程下任务也只会被执行一次；\n * 注意在执行时各种状态的切换；\n * get方法调用时，如果任务没有结束，要阻塞当前线程，法阻塞的线程会保存在一个treiber stack中；\n * get方法超时功能如果超时未获取成功，会抛出timeoutexception；\n * 注意在取消时的线程中断，在run方法中一定要保证结束时的状态是interrupted，否则在cancel方法中可能没有执行interrupt，造成中断的泄露。\n\n> 参考文献\n\nfuturetask源码解析",charsets:{cjk:!0},createdTime:1655628697e3},{title:"并发容器之ConcurrentHashMap-JDK1.8",frontmatter:{title:"并发容器之ConcurrentHashMap-JDK1.8",description:"并发容器之ConcurrentHashMap(JDK1.8)",date:"2022-04-05T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/14%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap-JDK1.8.html",relativePath:"Java/Java并发编程的艺术/14、并发容器之ConcurrentHashMap-JDK1.8.md",key:"v-5af16972",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/14%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap-JDK1.8.html",headers:[{level:2,title:"1、ConcurrentHashmap简介",slug:"_1、concurrenthashmap简介",normalizedTitle:"1、concurrenthashmap简介",charIndex:42},{level:2,title:"2、关键属性及类",slug:"_2、关键属性及类",normalizedTitle:"2、关键属性及类",charIndex:67},{level:3,title:"ConcurrentHashMap的关键属性",slug:"concurrenthashmap的关键属性",normalizedTitle:"concurrenthashmap的关键属性",charIndex:81},{level:3,title:"ConcurrentHashMap中关键内部类",slug:"concurrenthashmap中关键内部类",normalizedTitle:"concurrenthashmap中关键内部类",charIndex:109},{level:3,title:"CAS关键操作",slug:"cas关键操作",normalizedTitle:"cas关键操作",charIndex:138},{level:2,title:"3、重点方法详解",slug:"_3、重点方法详解",normalizedTitle:"3、重点方法详解",charIndex:149},{level:3,title:"3.1 实例构造器方法",slug:"_3-1-实例构造器方法",normalizedTitle:"3.1 实例构造器方法",charIndex:163},{level:3,title:"3.2 initTable方法",slug:"_3-2-inittable方法",normalizedTitle:"3.2 inittable方法",charIndex:180},{level:3,title:"3.3 put方法",slug:"_3-3-put方法",normalizedTitle:"3.3 put方法",charIndex:201},{level:3,title:"3.4 get方法",slug:"_3-4-get方法",normalizedTitle:"3.4 get方法",charIndex:216},{level:3,title:"3.5 transfer方法",slug:"_3-5-transfer方法",normalizedTitle:"3.5 transfer方法",charIndex:231},{level:3,title:"3.6 与size相关的一些方法",slug:"_3-6-与size相关的一些方法",normalizedTitle:"3.6 与size相关的一些方法",charIndex:251},{level:2,title:"4、总结",slug:"_4、总结",normalizedTitle:"4、总结",charIndex:271}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>并发容器之ConcurrentHashMap(JDK 1.8)</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"1、ConcurrentHashmap简介 2、关键属性及类 ConcurrentHashMap的关键属性 ConcurrentHashMap中关键内部类 CAS关键操作 3、重点方法详解 3.1 实例构造器方法 3.2 initTable方法 3.3 put方法 3.4 get方法 3.5 transfer方法 3.6 与size相关的一些方法 4、总结",content:'说明\n\n并发容器之ConcurrentHashMap(JDK 1.8)\n\n\n\n * 1、ConcurrentHashmap简介\n * 2、关键属性及类\n   * ConcurrentHashMap的关键属性\n   * ConcurrentHashMap中关键内部类\n   * CAS关键操作\n * 3、重点方法详解\n   * 3.1 实例构造器方法\n   * 3.2 initTable方法\n   * 3.3 put方法\n   * 3.4 get方法\n   * 3.5 transfer方法\n   * 3.6 与size相关的一些方法\n * 4、总结\n\n\n\n\n# 并发容器之ConcurrentHashMap(JDK1.8)\n\n\n# 1、ConcurrentHashmap简介\n\n在并发编程中使用HashMap可能导致程序死循环。而使用线程安全的HashTable效率又非常低下，基于以上两个原因，便有了ConcurrentHashMap的登场机会。\n\n * 线程不安全的HashMap\n   \n   在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。例如，执行以下代码会引起死循环。\n   \n   final HashMap<String, String> map = new HashMap<String, String>;\n   Thread t = new Thread(new Runnable() {\n       @Override\n       public void run() {\n           for (int i = 0; i < 10000; i++) {\n               new Thread(new Runnable() {\n                   @Override\n                   public void run() {\n                       map.put(UUID.randomUUID().toString(), "");\n                   }\n               }, "ftf" + i).start();\n           }\n       }\n   }, "ftf");\n   t.start();\n   t.join();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n   \n   HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。\n\n * 效率低下的HashTable\n   \n   HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。\n\n * ConcurrentHashMap的锁分段技术可有效提升并发访问率\n   \n   HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。\n\nConcurrentHashMap在JDK1.6的版本网上资料很多，有兴趣的可以去看看。 JDK 1.6版本关键要素：\n\n 1. segment继承了ReentrantLock充当锁的角色，为每一个segment提供了线程安全的保障；\n 2. segment维护了哈希散列表的若干个桶，每个桶由HashEntry构成的链表。\n\n而到了JDK 1.8的ConcurrentHashMap就有了很大的变化，光是代码量就足足增加了很多。1.8版本舍弃了segment，并且大量使用了synchronized，以及CAS无锁操作以保证ConcurrentHashMap操作的线程安全性。至于为什么不用ReentrantLock而是Synchronzied呢？实际上，synchronzied做了很多的优化，包括偏向锁，轻量级锁，重量级锁，可以依次向上升级锁状态，但不能降级，因此，使用synchronized相较于ReentrantLock的性能会持平甚至在某些情况更优，具体的性能测试可以去网上查阅一些资料。另外，底层数据结构改变为采用数组+链表+红黑树的数据形式。\n\n\n# 2、关键属性及类\n\n在了解ConcurrentHashMap的具体方法实现前，我们需要系统的来看一下几个关键的地方。\n\n\n# ConcurrentHashMap的关键属性\n\n 1. volatile Node<K,V>[] table：装载Node的数组，作为ConcurrentHashMap的数据容器，采用懒加载的方式，直到第一次插入数据的时候才会进行初始化操作，数组的大小总是为2的幂次方。\n\n 2. volatile Node<K,V>[] nextTable：扩容时使用，平时为null，只有在扩容的时候才为非null\n\n 3. volatile int sizeCtl：该属性用来控制table数组的大小，根据是否初始化和是否正在扩容有几种情况： 当值为负数时，如果为-1表示正在初始化，如果为-N则表示当前正有N-1个线程进行扩容操作； 当值为正数时，如果当前数组为null的话表示table在初始化过程中，sizeCtl表示为需要新建数组的长度； 若已经初始化了，表示当前数据容器（table数组）可用容量也可以理解成临界值（插入节点数超过了该临界值就需要扩容），具体值为数组的长度n 乘以 加载因子loadFactor； 当值为0时，即数组长度为默认初始值。\n\n 4. sun.misc.Unsafe U：在ConcurrentHashMapde的实现中可以看到大量的U.compareAndSwapXXXX的方法去修改ConcurrentHashMap的一些属性。这些方法实际上是利用了CAS算法保证了线程安全性，这是一种乐观策略，假设每一次操作都不会产生冲突，当且仅当冲突发生的时候再去尝试。而CAS操作依赖于现代处理器指令集，通过底层CMPXCHG指令实现。CAS(V,O,N)核心思想为：若当前变量实际值V与期望的旧值O相同，则表明该变量没被其他线程进行修改，因此可以安全的将新值N赋值给变量；若当前变量实际值V与期望的旧值O不相同，则表明该变量已经被其他线程做了处理，此时将新值N赋给变量操作就是不安全的，在进行重试。而在大量的同步组件和并发容器的实现中使用CAS是通过sun.misc.Unsafe类实现的，该类提供了一些可以直接操控内存和线程的底层操作，可以理解为java中的“指针”。该成员变量的获取是在静态代码块中：\n    \n     static {\n         try {\n             U = sun.misc.Unsafe.getUnsafe();\n     \t\t.......\n         } catch (Exception e) {\n             throw new Error(e);\n         }\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n\n# ConcurrentHashMap中关键内部类\n\n 1. Node Node类实现了Map.Entry接口，主要存放key-value对，并且具有next域\n    \n     static class Node<K,V> implements Map.Entry<K,V> {\n             final int hash;\n             final K key;\n             volatile V val;\n             volatile Node<K,V> next;\n     \t\t......\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n    \n    另外可以看出很多属性都是用volatile进行修饰的，也就是为了保证内存可见性。\n\n 2. TreeNode 树节点，继承于承载数据的Node类。而红黑树的操作是针对TreeBin类的，从该类的注释也可以看出，也就是TreeBin会将TreeNode进行再一次封装\n    \n     **\n      * Nodes for use in TreeBins\n      */\n     static final class TreeNode<K,V> extends Node<K,V> {\n             TreeNode<K,V> parent;  // red-black tree links\n             TreeNode<K,V> left;\n             TreeNode<K,V> right;\n             TreeNode<K,V> prev;    // needed to unlink next upon deletion\n             boolean red;\n     \t\t......\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 3. TreeBin 这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象。\n    \n     static final class TreeBin<K,V> extends Node<K,V> {\n             TreeNode<K,V> root;\n             volatile TreeNode<K,V> first;\n             volatile Thread waiter;\n             volatile int lockState;\n             // values for lockState\n             static final int WRITER = 1; // set while holding write lock\n             static final int WAITER = 2; // set when waiting for write lock\n             static final int READER = 4; // increment value for setting read lock\n     \t\t......\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 4. ForwardingNode 在扩容时才会出现的特殊节点，其key,value,hash全部为null。并拥有nextTable指针引用新的table数组。\n    \n     static final class ForwardingNode<K,V> extends Node<K,V> {\n         final Node<K,V>[] nextTable;\n         ForwardingNode(Node<K,V>[] tab) {\n             super(MOVED, null, null, null);\n             this.nextTable = tab;\n         }\n        .....\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n\n# CAS关键操作\n\n在上面我们提及到在ConcurrentHashMap中会大量使用CAS修改它的属性和一些操作。因此，在理解ConcurrentHashMap的方法前我们需要了解下面几个常用的利用CAS算法来保障线程安全的操作。\n\n 1. tabAt\n    \n     static final <K,V> Node<K,V> tabAt(Node<K,V>[] tab, int i) {\n         return (Node<K,V>)U.getObjectVolatile(tab, ((long)i << ASHIFT) + ABASE);\n     }\n    \n    \n    1\n    2\n    3\n    \n    \n    该方法用来获取table数组中索引为i的Node元素。\n\n 2. casTabAt\n    \n     static final <K,V> boolean casTabAt(Node<K,V>[] tab, int i,\n                                         Node<K,V> c, Node<K,V> v) {\n         return U.compareAndSwapObject(tab, ((long)i << ASHIFT) + ABASE, c, v);\n     }\n    \n    \n    1\n    2\n    3\n    4\n    \n    \n    利用CAS操作设置table数组中索引为i的元素\n\n 3. setTabAt\n    \n     static final <K,V> void setTabAt(Node<K,V>[] tab, int i, Node<K,V> v) {\n         U.putObjectVolatile(tab, ((long)i << ASHIFT) + ABASE, v);\n     }\n    \n    \n    1\n    2\n    3\n    \n    \n    该方法用来设置table数组中索引为i的元素\n\n\n# 3、重点方法详解\n\n在熟悉上面的这核心信息之后，我们接下来就来依次看看几个常用的方法是怎样实现的。\n\n\n# 3.1 实例构造器方法\n\n在使用ConcurrentHashMap第一件事自然而然就是new 出来一个ConcurrentHashMap对象，一共提供了如下几个构造器方法：\n\n// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16\nConcurrentHashMap()\n// 2. 给定map的大小\nConcurrentHashMap(int initialCapacity)\n// 3. 给定一个map\nConcurrentHashMap(Map<? extends K, ? extends V> m)\n// 4. 给定map的大小以及加载因子\nConcurrentHashMap(int initialCapacity, float loadFactor)\n// 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程）\nConcurrentHashMap(int initialCapacity,float loadFactor, int concurrencyLevel)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nConcurrentHashMap一共给我们提供了5中构造器方法，具体使用请看注释，我们来看看第2种构造器，传入指定大小时的情况，该构造器源码为：\n\npublic ConcurrentHashMap(int initialCapacity) {\n\t//1. 小于0直接抛异常\n    if (initialCapacity < 0)\n        throw new IllegalArgumentException();\n\t//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理\n    int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?\n               MAXIMUM_CAPACITY :\n               tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1));\n\t//3. 赋值给sizeCtl\n    this.sizeCtl = cap;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这段代码的逻辑请看注释，很容易理解，如果小于0就直接抛出异常，如果指定值大于了所允许的最大值的话就取最大值，否则，在对指定值做进一步处理。最后将cap赋值给sizeCtl，关于sizeCtl的说明请看上面的说明，当调用构造器方法之后，sizeCtl的大小应该就代表了ConcurrentHashMap的大小，即table数组长度。tableSizeFor做了哪些事情了？源码为：\n\n/**\n * Returns a power of two table size for the given desired capacity.\n * See Hackers Delight, sec 3.2\n */\nprivate static final int tableSizeFor(int c) {\n    int n = c - 1;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n通过注释就很清楚了，该方法会将调用构造器方法时指定的大小转换成一个2的幂次方数，也就是说ConcurrentHashMap的大小一定是2的幂次方，比如，当指定大小为18时，为了满足2的幂次方特性，实际上concurrentHashMapd的大小为2的5次方（32）。另外，需要注意的是，调用构造器方法的时候并未构造出table数组（可以理解为ConcurrentHashMap的数据容器），只是算出table数组的长度，当第一次向ConcurrentHashMap插入数据的时候才真正的完成初始化创建table数组的工作。\n\n\n# 3.2 initTable方法\n\n直接上源码：\n\nprivate final Node<K,V>[] initTable() {\n    Node<K,V>[] tab; int sc;\n    while ((tab = table) == null || tab.length == 0) {\n        if ((sc = sizeCtl) < 0)\n            // 1. 保证只有一个线程正在进行初始化操作\n            Thread.yield(); // lost initialization race; just spin\n        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\n            try {\n                if ((tab = table) == null || tab.length == 0) {\n                    // 2. 得出数组的大小\n                    int n = (sc > 0) ? sc : DEFAULT_CAPACITY;\n                    @SuppressWarnings("unchecked")\n                    // 3. 这里才真正的初始化数组\n                    Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                    table = tab = nt;\n                    // 4. 计算数组中可用的大小：实际大小n*0.75（加载因子）\n                    sc = n - (n >>> 2);\n                }\n            } finally {\n                sizeCtl = sc;\n            }\n            break;\n        }\n    }\n    return tab;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n代码的逻辑请见注释，有可能存在一个情况是多个线程同时走到这个方法中，为了保证能够正确初始化，在第1步中会先通过if进行判断，若当前已经有一个线程正在初始化即sizeCtl值变为-1，这个时候其他线程在if判断为true从而调用Thread.yield()让出CPU时间片。正在进行初始化的线程会调用U.compareAndSwapInt方法将sizeCtl改为-1即正在初始化的状态。另外还需要注意的事情是，在第四步中会进一步计算数组中可用的大小即为数组实际大小n乘以加载因子0.75.可以看看这里乘以0.75是怎么算的，0.75为四分之三，这里n - (n >>> 2)是不是刚好是n-(1/4)n=(3/4)n。如果选择是无参的构造器的话，这里在new Node数组的时候会使用默认大小为DEFAULT_CAPACITY（16），然后乘以加载因子0.75为12，也就是说数组的可用大小为12。\n\n\n# 3.3 put方法\n\n使用ConcurrentHashMap最长用的也应该是put和get方法了吧，我们先来看看put方法是怎样实现的。调用put方法时实际具体实现是putVal方法，源码如下：\n\n/**\n* Implementation for put and putIfAbsent\n*/\nfinal V putVal(K key, V value, boolean onlyIfAbsent) {\n    if (key == null || value == null) throw new NullPointerException();\n    //1. 计算key的hash值\n    int hash = spread(key.hashCode());\n    int binCount = 0;\n    for (Node<K,V>[] tab = table;;) {\n        Node<K,V> f; int n, i, fh;\n        //2. 如果当前table还没有初始化先调用initTable方法将tab进行初始化\n        if (tab == null || (n = tab.length) == 0)\n            tab = initTable();\n        //3. tab中索引为i的位置的元素为null，则直接使用CAS将值插入即可\n        else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n            if (casTabAt(tab, i, null, new Node<K,V>(hash, key, value, null)))\n                break; // no lock when adding to empty bin\n        }\n        //4. 当前正在扩容\n        else if ((fh = f.hash) == MOVED)\n            tab = helpTransfer(tab, f);\n        else {\n            V oldVal = null;\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    //5. 当前为链表，在链表中插入新的键值对\n                    if (fh >= 0) {\n                        binCount = 1;\n                        for (Node<K,V> e = f;; ++binCount) {\n                            K ek;\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                oldVal = e.val;\n                                if (!onlyIfAbsent)\n                                    e.val = value;\n                                break;\n                            }\n                            Node<K,V> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new Node<K,V>(hash, key, value, null);\n                                break;\n                            }\n                        }\n                    }\n                    // 6.当前为红黑树，将新的键值对插入到红黑树中\n                    else if (f instanceof TreeBin) {\n                        Node<K,V> p;\n                        binCount = 2;\n                        if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) {\n                            oldVal = p.val;\n                            if (!onlyIfAbsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n            // 7.插入完键值对后再根据实际大小看是否需要转换成红黑树\n            if (binCount != 0) {\n                if (binCount >= TREEIFY_THRESHOLD)\n                    treeifyBin(tab, i);\n                if (oldVal != null)\n                    return oldVal;\n                break;\n            }\n        }\n    }\n    //8.对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容\n    addCount(1L, binCount);\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\nput方法的代码量有点长，我们按照上面的分解的步骤一步步来看。从整体而言，为了解决线程安全的问题，ConcurrentHashMap使用了synchronzied和CAS的方式。在之前了解过HashMap以及1.8版本之前的ConcurrenHashMap都应该知道ConcurrentHashMap结构图，为了方面下面的讲解这里先直接给出，如果对这有疑问的话，可以在网上随便搜搜即可。\n\n\n\nConcurrentHashMap是一个哈希桶数组，如果不出现哈希冲突的时候，每个元素均匀的分布在哈希桶数组中。当出现哈希冲突的时候，是标准的链地址的解决方式，将hash值相同的节点构成链表的形式，称为“拉链法”，另外，在1.8版本中为了防止拉链过长，当链表的长度大于8的时候会将链表转换成红黑树。table数组中的每个元素实际上是单链表的头结点或者红黑树的根节点。当插入键值对时首先应该定位到要插入的桶，即插入table数组的索引i处。那么，怎样计算得出索引i呢？当然是根据key的hashCode值。\n\n> 1、spread()重哈希，以减小Hash冲突\n\n我们知道对于一个hash表来说，hash值分散的不够均匀的话会大大增加哈希冲突的概率，从而影响到hash表的性能。因此通过spread方法进行了一次重hash从而大大减小哈希冲突的可能性。spread方法为：\n\nstatic final int spread(int h) {\n    return (h ^ (h >>> 16)) & HASH_BITS;\n}\n\n\n1\n2\n3\n\n\n该方法主要是将key的hashCode的低16位于高16位进行异或运算，这样不仅能够使得hash值能够分散能够均匀减小hash冲突的概率，另外只用到了异或运算，在性能开销上也能兼顾，做到平衡的trade-off。\n\n> 2、初始化table\n\n紧接着到第2步，会判断当前table数组是否初始化了，没有的话就调用initTable进行初始化，该方法在上面已经讲过了。\n\n> 3、能否直接将新值插入到table数组中\n\n从上面的结构示意图就可以看出存在这样一种情况，如果插入值待插入的位置刚好所在的table数组为null的话就可以直接将值插入即可。那么怎样根据hash确定在table中待插入的索引i呢？很显然可以通过hash值与数组的长度取模操作，从而确定新值插入到数组的哪个位置。而之前我们提过ConcurrentHashMap的大小总是2的幂次方，(n - 1) & hash运算等价于对长度n取模，也就是hash%n，但是位运算比取模运算的效率要高很多，Doug lea大师在设计并发容器的时候也是将性能优化到了极致，令人钦佩。\n\n确定好数组的索引i后，就可以可以tabAt()方法获取该位置上的元素，如果当前Node f为null的话，就可以直接用casTabAt方法将新值插入即可。\n\n> 4、当前是否正在扩容\n\n如果当前节点不为null，且该节点为特殊节点（forwardingNode）的话，就说明当前concurrentHashMap正在进行扩容操作，关于扩容操作，下面会作为一个具体的方法进行讲解。那么怎样确定当前的这个Node是不是特殊的节点了？是通过判断该节点的hash值是不是等于-1（MOVED），代码为(fh = f.hash) == MOVED，对MOVED的解释在源码上也写的很清楚了：\n\nstatic final int MOVED = -1; // hash for forwarding nodes\n\n\n1\n\n\n> 5、当table[i]为链表的头结点，在链表中插入新值\n\n在table[i]不为null并且不为forwardingNode时，并且当前Node f的hash值大于0（fh >= 0）的话说明当前节点f为当前桶的所有的节点组成的链表的头结点。那么接下来，要想向ConcurrentHashMap插入新值的话就是向这个链表插入新值。通过synchronized (f)的方式进行加锁以实现线程安全性。往链表中插入节点的部分代码为：\n\nif (fh >= 0) {\n    binCount = 1;\n    for (Node<K,V> e = f;; ++binCount) {\n        K ek;\n\t\t// 找到hash值相同的key,覆盖旧值即可\n        if (e.hash == hash &&\n            ((ek = e.key) == key ||\n             (ek != null && key.equals(ek)))) {\n            oldVal = e.val;\n            if (!onlyIfAbsent)\n                e.val = value;\n            break;\n        }\n        Node<K,V> pred = e;\n        if ((e = e.next) == null) {\n\t\t\t//如果到链表末尾仍未找到，则直接将新值插入到链表末尾即可\n            pred.next = new Node<K,V>(hash, key, value, null);\n            break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这部分代码很好理解，就是两种情况：1. 在链表中如果找到了与待插入的键值对的key相同的节点，就直接覆盖即可；2. 如果直到找到了链表的末尾都没有找到的话，就直接将待插入的键值对追加到链表的末尾即可\n\n> 6、当table[i]为红黑树的根节点，在红黑树中插入新值\n\n按照之前的数组+链表的设计方案，这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，甚至在极端情况下，查找一个节点会出现时间复杂度为O(n)的情况，则会严重影响ConcurrentHashMap的性能，于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高ConcurrentHashMap的性能，其中会用到红黑树的插入、删除、查找等算法。当table[i]为红黑树的树节点时的操作为：\n\nif (f instanceof TreeBin) {\n    Node<K,V> p;\n    binCount = 2;\n    if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key, value)) != null) {\n        oldVal = p.val;\n        if (!onlyIfAbsent)\n            p.val = value;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n首先在if中通过f instanceof TreeBin判断当前table[i]是否是树节点，这下也正好验证了我们在最上面介绍时说的TreeBin会对TreeNode做进一步封装，对红黑树进行操作的时候针对的是TreeBin而不是TreeNode。这段代码很简单，调用putTreeVal方法完成向红黑树插入新节点，同样的逻辑，如果在红黑树中存在于待插入键值对的Key相同（hash值相等并且equals方法判断为true）的节点的话，就覆盖旧值，否则就向红黑树追加新节点。\n\n> 7、根据当前节点个数进行调整\n\n当完成数据新节点插入之后，会进一步对当前链表大小进行调整，这部分代码为：\n\nif (binCount != 0) {\n    if (binCount >= TREEIFY_THRESHOLD)\n        treeifyBin(tab, i);\n    if (oldVal != null)\n        return oldVal;\n    break;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n很容易理解，如果当前链表节点个数大于等于8（TREEIFY_THRESHOLD）的时候，就会调用treeifyBin方法将tabel[i]（第i个散列桶）拉链转换成红黑树。\n\n至此，关于Put方法的逻辑就基本说的差不多了，现在来做一些总结：\n\n整体流程：\n\n 1. 首先对于每一个放入的值，首先利用spread方法对key的hashcode进行一次hash计算，由此来确定这个值在 table 中的位置；\n 2. 如果当前table数组还未初始化，先将table数组进行初始化操作；\n 3. 如果这个位置是null的，那么使用CAS操作直接放入；\n 4. 如果这个位置存在结点，说明发生了hash碰撞，首先判断这个节点的类型。如果该节点fh==MOVED(代表forwardingNode,数组正在进行扩容)的话，说明正在进行扩容；\n 5. 如果是链表节点（fh>0），则得到的结点就是hash值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到key相同的节点，则只需要覆盖该结点的value值即可。否则依次向后遍历，直到链表尾插入这个结点；\n 6. 如果这个节点的类型是TreeBin的话，直接调用红黑树的插入方法进行插入新的节点；\n 7. 插入完节点之后再次检查链表长度，如果长度大于8，就把这个链表转换成红黑树；\n 8. 对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容。\n\n\n# 3.4 get方法\n\n看完了put方法再来看get方法就很容易了，用逆向思维去看就好，这样存的话我反过来这么取就好了。get方法源码为：\n\npublic V get(Object key) {\n    Node<K,V>[] tab; Node<K,V> e, p; int n, eh; K ek;\n\t// 1. 重hash\n    int h = spread(key.hashCode());\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (e = tabAt(tab, (n - 1) & h)) != null) {\n        // 2. table[i]桶节点的key与查找的key相同，则直接返回\n\t\tif ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                return e.val;\n        }\n\t\t// 3. 当前节点hash小于0说明为树节点，在红黑树中查找即可\n        else if (eh < 0)\n            return (p = e.find(h, key)) != null ? p.val : null;\n        while ((e = e.next) != null) {\n\t\t//4. 从链表中查找，查找到则返回该节点的value，否则就返回null即可\n            if (e.hash == h &&\n                ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n代码的逻辑请看注释，首先先看当前的hash桶数组节点即table[i]是否为查找的节点，若是则直接返回；若不是，则继续再看当前是不是树节点？通过看节点的hash值是否为小于0，如果小于0则为树节点。如果是树节点在红黑树中查找节点；如果不是树节点，那就只剩下为链表的形式的一种可能性了，就向后遍历查找节点，若查找到则返回节点的value即可，若没有找到就返回null。\n\n\n# 3.5 transfer方法\n\n当ConcurrentHashMap容量不足的时候，需要对table进行扩容。这个方法的基本思想跟HashMap是很像的，但是由于它是支持并发扩容的，所以要复杂的多。原因是它支持多线程进行扩容操作，而并没有加锁。我想这样做的目的不仅仅是为了满足concurrent的要求，而是希望利用并发处理去减少扩容带来的时间影响。transfer方法源码为：\n\nprivate final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {\n    int n = tab.length, stride;\n    if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)\n        stride = MIN_TRANSFER_STRIDE; // subdivide range\n    //1. 新建Node数组，容量为之前的两倍\n    if (nextTab == null) {            // initiating\n        try {\n            @SuppressWarnings("unchecked")\n            Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];\n            nextTab = nt;\n        } catch (Throwable ex) {      // try to cope with OOME\n            sizeCtl = Integer.MAX_VALUE;\n            return;\n        }\n        nextTable = nextTab;\n        transferIndex = n;\n    }\n    int nextn = nextTab.length;\n    //2. 新建forwardingNode引用，在之后会用到\n    ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);\n    boolean advance = true;\n    boolean finishing = false; // to ensure sweep before committing nextTab\n    for (int i = 0, bound = 0;;) {\n        Node<K,V> f; int fh;\n        // 3. 确定遍历中的索引i\n        while (advance) {\n            int nextIndex, nextBound;\n            if (--i >= bound || finishing)\n                advance = false;\n            else if ((nextIndex = transferIndex) <= 0) {\n                i = -1;\n                advance = false;\n            }\n            else if (U.compareAndSwapInt(this, TRANSFERINDEX, nextIndex,\n                                         nextBound = (nextIndex > stride ? nextIndex - stride : 0))) {\n                bound = nextBound;\n                i = nextIndex - 1;\n                advance = false;\n            }\n        }\n        //4.将原数组中的元素复制到新数组中去\n        //4.5 for循环退出，扩容结束修改sizeCtl属性\n        if (i < 0 || i >= n || i + n >= nextn) {\n            int sc;\n            if (finishing) {\n                nextTable = null;\n                table = nextTab;\n                sizeCtl = (n << 1) - (n >>> 1);\n                return;\n            }\n            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n                if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)\n                    return;\n                finishing = advance = true;\n                i = n; // recheck before commit\n            }\n        }\n        //4.1 当前数组中第i个元素为null，用CAS设置成特殊节点forwardingNode(可以理解成占位符)\n        else if ((f = tabAt(tab, i)) == null)\n            advance = casTabAt(tab, i, null, fwd);\n        //4.2 如果遍历到ForwardingNode节点，说明这个点已经被处理过了，直接跳过，这里是控制并发扩容的核心\n        else if ((fh = f.hash) == MOVED)\n            advance = true; // already processed\n        else {\n            synchronized (f) {\n                if (tabAt(tab, i) == f) {\n                    Node<K,V> ln, hn;\n                    if (fh >= 0) {\n                        //4.3 处理当前节点为链表的头结点的情况，构造两个链表，一个是原链表，另一个是原链表的反序排列\n                        int runBit = fh & n;\n                        Node<K,V> lastRun = f;\n                        for (Node<K,V> p = f.next; p != null; p = p.next) {\n                            int b = p.hash & n;\n                            if (b != runBit) {\n                                runBit = b;\n                                lastRun = p;\n                            }\n                        }\n                        if (runBit == 0) {\n                            ln = lastRun;\n                            hn = null;\n                        }\n                        else {\n                            hn = lastRun;\n                            ln = null;\n                        }\n                        for (Node<K,V> p = f; p != lastRun; p = p.next) {\n                            int ph = p.hash; K pk = p.key; V pv = p.val;\n                            if ((ph & n) == 0)\n                                ln = new Node<K,V>(ph, pk, pv, ln);\n                            else\n                                hn = new Node<K,V>(ph, pk, pv, hn);\n                        }\n                        //在nextTable的i位置上插入一个链表\n                        setTabAt(nextTab, i, ln);\n                        //在nextTable的i+n的位置上插入另一个链表\n                        setTabAt(nextTab, i + n, hn);\n                        //在table的i位置上插入forwardNode节点  表示已经处理过该节点\n                        setTabAt(tab, i, fwd);\n                        //设置advance为true 返回到上面的while循环中 就可以执行i--操作\n                        advance = true;\n                    }\n                    //4.4 处理当前节点是TreeBin时的情况，操作和上面的类似\n                    else if (f instanceof TreeBin) {\n                        TreeBin<K,V> t = (TreeBin<K,V>)f;\n                        TreeNode<K,V> lo = null, loTail = null;\n                        TreeNode<K,V> hi = null, hiTail = null;\n                        int lc = 0, hc = 0;\n                        for (Node<K,V> e = t.first; e != null; e = e.next) {\n                            int h = e.hash;\n                            TreeNode<K,V> p = new TreeNode<K,V>\n                                (h, e.key, e.val, null, null);\n                            if ((h & n) == 0) {\n                                if ((p.prev = loTail) == null)\n                                    lo = p;\n                                else\n                                    loTail.next = p;\n                                loTail = p;\n                                ++lc;\n                            }\n                            else {\n                                if ((p.prev = hiTail) == null)\n                                    hi = p;\n                                else\n                                    hiTail.next = p;\n                                hiTail = p;\n                                ++hc;\n                            }\n                        }\n                        ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :\n                        (hc != 0) ? new TreeBin<K,V>(lo) : t;\n                        hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :\n                        (lc != 0) ? new TreeBin<K,V>(hi) : t;\n                        setTabAt(nextTab, i, ln);\n                        setTabAt(nextTab, i + n, hn);\n                        setTabAt(tab, i, fwd);\n                        advance = true;\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n\n\n代码逻辑请看注释，整个扩容操作分为两个部分：\n\n第一部分是构建一个nextTable，它的容量是原来的两倍，这个操作是单线程完成的。新建table数组的代码为:Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1]，在原容量大小的基础上右移一位。\n\n第二个部分就是将原来table中的元素复制到nextTable中，主要是遍历复制的过程。 根据运算得到当前遍历的数组的位置i，然后利用tabAt方法获得i位置的元素再进行判断：\n\n 1. 如果这个位置为空，就在原table中的i位置放入forwardNode节点，这个也是触发并发扩容的关键点；\n\n 2. 如果这个位置是Node节点（fh>=0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在nextTable的i和i+n的位置上\n\n 3. 如果这个位置是TreeBin节点（fh<0），也做一个反序处理，并且判断是否需要untreefi，把处理的结果分别放在nextTable的i和i+n的位置上\n\n 4. 遍历过所有的节点以后就完成了复制工作，这时让nextTable作为新的table，并且更新sizeCtl为新容量的0.75倍 ，完成扩容。设置为新容量的0.75倍代码为 sizeCtl = (n << 1) - (n >>> 1)，仔细体会下是不是很巧妙，n<<1相当于n左移一位表示n的两倍即2n，n>>>1右移一位相当于n除以2即0.5n，然后两者相减为2n-0.5n=1.5n，就刚好等于新容量的0.75倍即2n*0.75=1.5n。最后用一个示意图来进行总结（图片摘自网络）：\n    \n    \n\n\n# 3.6 与size相关的一些方法\n\n对于ConcurrentHashMap来说，这个table里到底装了多少东西其实是个不确定的数量，因为不可能在调用size()方法的时候像GC的“stop the world”一样让其他线程都停下来让你去统计，因此只能说这个数量是个估计值。对于这个估计值，ConcurrentHashMap也是大费周章才计算出来的。\n\n为了统计元素个数，ConcurrentHashMap定义了一些变量和一个内部类：\n\n/**\n * A padded cell for distributing counts.  Adapted from LongAdder\n * and Striped64.  See their internal docs for explanation.\n */\n@sun.misc.Contended static final class CounterCell {\n    volatile long value;\n    CounterCell(long x) {\n        value = x;\n    }\n}\n\n/******************************************/\n\n/**\n * 实际上保存的是hashmap中的元素个数，利用CAS锁进行更新但它并不用返回当前hashmap的元素个数\n */\nprivate transient volatile long baseCount;\n\n/**\n * Spinlock (locked via CAS) used when resizing and/or creating CounterCells.\n */\nprivate transient volatile int cellsBusy;\n\n/**\n * Table of counter cells. When non-null, size is a power of 2.\n */\nprivate transient volatile CounterCell[] counterCells;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n> mappingCount与size方法\n\nmappingCount与size方法类似，从给出的注释来看，应该使用mappingCount代替size方法，两个方法都没有直接返回 basecount 而是统计一次这个值，而这个值其实也是一个大概的数值，因此可能在统计的时候有其他线程正在执行插入或删除操作。\n\npublic int size() {\n    long n = sumCount();\n    return ((n < 0L) ? 0 :\n            (n > (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE :\n            (int)n);\n}\n/**\n * Returns the number of mappings. This method should be used\n * instead of {@link #size} because a ConcurrentHashMap may\n * contain more mappings than can be represented as an int. The\n * value returned is an estimate; the actual count may differ if\n * there are concurrent insertions or removals.\n *\n * @return the number of mappings\n * @since 1.8\n */\npublic long mappingCount() {\n    long n = sumCount();\n    return (n < 0L) ? 0L : n; // ignore transient negative values\n}\n\nfinal long sumCount() {\n    CounterCell[] as = counterCells; CounterCell a;\n    long sum = baseCount;\n    if (as != null) {\n        for (int i = 0; i < as.length; ++i) {\n            if ((a = as[i]) != null)\n                sum += a.value;//所有counter的值求和\n        }\n    }\n    return sum;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n> addCount方法\n\n在put方法结尾处调用了addCount方法，把当前ConcurrentHashMap的元素个数+1这个方法一共做了两件事：更新baseCount的值，检测是否进行扩容。\n\nprivate final void addCount(long x, int check) {\n    CounterCell[] as; long b, s;\n    //利用CAS方法更新baseCount的值\n    if ((as = counterCells) != null ||\n        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {\n        CounterCell a; long v; int m;\n        boolean uncontended = true;\n        if (as == null || (m = as.length - 1) < 0 ||\n            (a = as[ThreadLocalRandom.getProbe() & m]) == null ||\n            !(uncontended =\n              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {\n            fullAddCount(x, uncontended);\n            return;\n        }\n        if (check <= 1)\n            return;\n        s = sumCount();\n    }\n    //如果check值大于等于0 则需要检验是否需要进行扩容操作\n    if (check >= 0) {\n        Node<K,V>[] tab, nt; int n, sc;\n        while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&\n               (n = tab.length) < MAXIMUM_CAPACITY) {\n            int rs = resizeStamp(n);\n            //\n            if (sc < 0) {\n                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||\n                    transferIndex <= 0)\n                    break;\n                //如果已经有其他线程在执行扩容操作\n                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\n                    transfer(tab, nt);\n            }\n            //当前线程是唯一的或是第一个发起扩容的线程  此时nextTable=null\n            else if (U.compareAndSwapInt(this, SIZECTL, sc,\n                                         (rs << RESIZE_STAMP_SHIFT) + 2))\n                transfer(tab, null);\n            s = sumCount();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 4、总结\n\nConcurrentHashMap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 HashTable 和同步包装器包装的 HashMap，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。\n\nJDK6,7中的ConcurrentHashmap主要使用Segment来实现减小锁粒度，分割成若干个Segment，在put的时候需要锁住Segment，get时候不加锁，使用volatile来保证可见性，当要统计全局时（比如size），首先会尝试多次计算modcount来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回size。如果有，则需要依次锁住所有的Segment来计算。\n\n1.8之前put定位节点时要先定位到具体的segment，然后再在segment中定位到具体的桶。而在1.8的时候摒弃了segment臃肿的设计，直接针对的是Node[] tale数组中的每一个桶，进一步减小了锁粒度。并且防止拉链过长导致性能下降，当链表长度大于8的时候采用红黑树的设计。\n\n主要设计上的变化有以下几点：\n\n 1. 不采用segment而采用node，锁住node来实现减小锁粒度。\n 2. 设计了MOVED状态，当resize的过程中，线程2还在put数据，线程2会帮助resize。\n 3. 使用3个CAS操作来确保node的一些操作的原子性，这种方式代替了锁。\n 4. sizeCtl的不同值来代表不同含义，起到了控制的作用。\n 5. 采用synchronized而不是ReentrantLock（莫非是因为1.8的虚拟机对内置锁已经优化的足够快了？）。\n\n更多关于1.7版本与1.8版本的ConcurrentHashMap的实现对比，可以参考这篇文章。\n\n> 参考文章\n\nJava-concurrency/并发容器之ConcurrentHashMap(JDK 1.8版本)',normalizedContent:'说明\n\n并发容器之concurrenthashmap(jdk 1.8)\n\n\n\n * 1、concurrenthashmap简介\n * 2、关键属性及类\n   * concurrenthashmap的关键属性\n   * concurrenthashmap中关键内部类\n   * cas关键操作\n * 3、重点方法详解\n   * 3.1 实例构造器方法\n   * 3.2 inittable方法\n   * 3.3 put方法\n   * 3.4 get方法\n   * 3.5 transfer方法\n   * 3.6 与size相关的一些方法\n * 4、总结\n\n\n\n\n# 并发容器之concurrenthashmap(jdk1.8)\n\n\n# 1、concurrenthashmap简介\n\n在并发编程中使用hashmap可能导致程序死循环。而使用线程安全的hashtable效率又非常低下，基于以上两个原因，便有了concurrenthashmap的登场机会。\n\n * 线程不安全的hashmap\n   \n   在多线程环境下，使用hashmap进行put操作会引起死循环，导致cpu利用率接近100%，所以在并发情况下不能使用hashmap。例如，执行以下代码会引起死循环。\n   \n   final hashmap<string, string> map = new hashmap<string, string>;\n   thread t = new thread(new runnable() {\n       @override\n       public void run() {\n           for (int i = 0; i < 10000; i++) {\n               new thread(new runnable() {\n                   @override\n                   public void run() {\n                       map.put(uuid.randomuuid().tostring(), "");\n                   }\n               }, "ftf" + i).start();\n           }\n       }\n   }, "ftf");\n   t.start();\n   t.join();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n   \n   hashmap在并发执行put操作时会引起死循环，是因为多线程会导致hashmap的entry链表形成环形数据结构，一旦形成环形数据结构，entry的next节点永远不为空，就会产生死循环获取entry。\n\n * 效率低下的hashtable\n   \n   hashtable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下hashtable的效率非常低下。因为当一个线程访问hashtable的同步方法，其他线程也访问hashtable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。\n\n * concurrenthashmap的锁分段技术可有效提升并发访问率\n   \n   hashtable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问hashtable的线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是concurrenthashmap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。\n\nconcurrenthashmap在jdk1.6的版本网上资料很多，有兴趣的可以去看看。 jdk 1.6版本关键要素：\n\n 1. segment继承了reentrantlock充当锁的角色，为每一个segment提供了线程安全的保障；\n 2. segment维护了哈希散列表的若干个桶，每个桶由hashentry构成的链表。\n\n而到了jdk 1.8的concurrenthashmap就有了很大的变化，光是代码量就足足增加了很多。1.8版本舍弃了segment，并且大量使用了synchronized，以及cas无锁操作以保证concurrenthashmap操作的线程安全性。至于为什么不用reentrantlock而是synchronzied呢？实际上，synchronzied做了很多的优化，包括偏向锁，轻量级锁，重量级锁，可以依次向上升级锁状态，但不能降级，因此，使用synchronized相较于reentrantlock的性能会持平甚至在某些情况更优，具体的性能测试可以去网上查阅一些资料。另外，底层数据结构改变为采用数组+链表+红黑树的数据形式。\n\n\n# 2、关键属性及类\n\n在了解concurrenthashmap的具体方法实现前，我们需要系统的来看一下几个关键的地方。\n\n\n# concurrenthashmap的关键属性\n\n 1. volatile node<k,v>[] table：装载node的数组，作为concurrenthashmap的数据容器，采用懒加载的方式，直到第一次插入数据的时候才会进行初始化操作，数组的大小总是为2的幂次方。\n\n 2. volatile node<k,v>[] nexttable：扩容时使用，平时为null，只有在扩容的时候才为非null\n\n 3. volatile int sizectl：该属性用来控制table数组的大小，根据是否初始化和是否正在扩容有几种情况： 当值为负数时，如果为-1表示正在初始化，如果为-n则表示当前正有n-1个线程进行扩容操作； 当值为正数时，如果当前数组为null的话表示table在初始化过程中，sizectl表示为需要新建数组的长度； 若已经初始化了，表示当前数据容器（table数组）可用容量也可以理解成临界值（插入节点数超过了该临界值就需要扩容），具体值为数组的长度n 乘以 加载因子loadfactor； 当值为0时，即数组长度为默认初始值。\n\n 4. sun.misc.unsafe u：在concurrenthashmapde的实现中可以看到大量的u.compareandswapxxxx的方法去修改concurrenthashmap的一些属性。这些方法实际上是利用了cas算法保证了线程安全性，这是一种乐观策略，假设每一次操作都不会产生冲突，当且仅当冲突发生的时候再去尝试。而cas操作依赖于现代处理器指令集，通过底层cmpxchg指令实现。cas(v,o,n)核心思想为：若当前变量实际值v与期望的旧值o相同，则表明该变量没被其他线程进行修改，因此可以安全的将新值n赋值给变量；若当前变量实际值v与期望的旧值o不相同，则表明该变量已经被其他线程做了处理，此时将新值n赋给变量操作就是不安全的，在进行重试。而在大量的同步组件和并发容器的实现中使用cas是通过sun.misc.unsafe类实现的，该类提供了一些可以直接操控内存和线程的底层操作，可以理解为java中的“指针”。该成员变量的获取是在静态代码块中：\n    \n     static {\n         try {\n             u = sun.misc.unsafe.getunsafe();\n     \t\t.......\n         } catch (exception e) {\n             throw new error(e);\n         }\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n\n# concurrenthashmap中关键内部类\n\n 1. node node类实现了map.entry接口，主要存放key-value对，并且具有next域\n    \n     static class node<k,v> implements map.entry<k,v> {\n             final int hash;\n             final k key;\n             volatile v val;\n             volatile node<k,v> next;\n     \t\t......\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n    \n    另外可以看出很多属性都是用volatile进行修饰的，也就是为了保证内存可见性。\n\n 2. treenode 树节点，继承于承载数据的node类。而红黑树的操作是针对treebin类的，从该类的注释也可以看出，也就是treebin会将treenode进行再一次封装\n    \n     **\n      * nodes for use in treebins\n      */\n     static final class treenode<k,v> extends node<k,v> {\n             treenode<k,v> parent;  // red-black tree links\n             treenode<k,v> left;\n             treenode<k,v> right;\n             treenode<k,v> prev;    // needed to unlink next upon deletion\n             boolean red;\n     \t\t......\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 3. treebin 这个类并不负责包装用户的key、value信息，而是包装的很多treenode节点。实际的concurrenthashmap“数组”中，存放的是treebin对象，而不是treenode对象。\n    \n     static final class treebin<k,v> extends node<k,v> {\n             treenode<k,v> root;\n             volatile treenode<k,v> first;\n             volatile thread waiter;\n             volatile int lockstate;\n             // values for lockstate\n             static final int writer = 1; // set while holding write lock\n             static final int waiter = 2; // set when waiting for write lock\n             static final int reader = 4; // increment value for setting read lock\n     \t\t......\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 4. forwardingnode 在扩容时才会出现的特殊节点，其key,value,hash全部为null。并拥有nexttable指针引用新的table数组。\n    \n     static final class forwardingnode<k,v> extends node<k,v> {\n         final node<k,v>[] nexttable;\n         forwardingnode(node<k,v>[] tab) {\n             super(moved, null, null, null);\n             this.nexttable = tab;\n         }\n        .....\n     }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    \n\n\n# cas关键操作\n\n在上面我们提及到在concurrenthashmap中会大量使用cas修改它的属性和一些操作。因此，在理解concurrenthashmap的方法前我们需要了解下面几个常用的利用cas算法来保障线程安全的操作。\n\n 1. tabat\n    \n     static final <k,v> node<k,v> tabat(node<k,v>[] tab, int i) {\n         return (node<k,v>)u.getobjectvolatile(tab, ((long)i << ashift) + abase);\n     }\n    \n    \n    1\n    2\n    3\n    \n    \n    该方法用来获取table数组中索引为i的node元素。\n\n 2. castabat\n    \n     static final <k,v> boolean castabat(node<k,v>[] tab, int i,\n                                         node<k,v> c, node<k,v> v) {\n         return u.compareandswapobject(tab, ((long)i << ashift) + abase, c, v);\n     }\n    \n    \n    1\n    2\n    3\n    4\n    \n    \n    利用cas操作设置table数组中索引为i的元素\n\n 3. settabat\n    \n     static final <k,v> void settabat(node<k,v>[] tab, int i, node<k,v> v) {\n         u.putobjectvolatile(tab, ((long)i << ashift) + abase, v);\n     }\n    \n    \n    1\n    2\n    3\n    \n    \n    该方法用来设置table数组中索引为i的元素\n\n\n# 3、重点方法详解\n\n在熟悉上面的这核心信息之后，我们接下来就来依次看看几个常用的方法是怎样实现的。\n\n\n# 3.1 实例构造器方法\n\n在使用concurrenthashmap第一件事自然而然就是new 出来一个concurrenthashmap对象，一共提供了如下几个构造器方法：\n\n// 1. 构造一个空的map，即table数组还未初始化，初始化放在第一次插入数据时，默认大小为16\nconcurrenthashmap()\n// 2. 给定map的大小\nconcurrenthashmap(int initialcapacity)\n// 3. 给定一个map\nconcurrenthashmap(map<? extends k, ? extends v> m)\n// 4. 给定map的大小以及加载因子\nconcurrenthashmap(int initialcapacity, float loadfactor)\n// 5. 给定map大小，加载因子以及并发度（预计同时操作数据的线程）\nconcurrenthashmap(int initialcapacity,float loadfactor, int concurrencylevel)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nconcurrenthashmap一共给我们提供了5中构造器方法，具体使用请看注释，我们来看看第2种构造器，传入指定大小时的情况，该构造器源码为：\n\npublic concurrenthashmap(int initialcapacity) {\n\t//1. 小于0直接抛异常\n    if (initialcapacity < 0)\n        throw new illegalargumentexception();\n\t//2. 判断是否超过了允许的最大值，超过了话则取最大值，否则再对该值进一步处理\n    int cap = ((initialcapacity >= (maximum_capacity >>> 1)) ?\n               maximum_capacity :\n               tablesizefor(initialcapacity + (initialcapacity >>> 1) + 1));\n\t//3. 赋值给sizectl\n    this.sizectl = cap;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n这段代码的逻辑请看注释，很容易理解，如果小于0就直接抛出异常，如果指定值大于了所允许的最大值的话就取最大值，否则，在对指定值做进一步处理。最后将cap赋值给sizectl，关于sizectl的说明请看上面的说明，当调用构造器方法之后，sizectl的大小应该就代表了concurrenthashmap的大小，即table数组长度。tablesizefor做了哪些事情了？源码为：\n\n/**\n * returns a power of two table size for the given desired capacity.\n * see hackers delight, sec 3.2\n */\nprivate static final int tablesizefor(int c) {\n    int n = c - 1;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    return (n < 0) ? 1 : (n >= maximum_capacity) ? maximum_capacity : n + 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n通过注释就很清楚了，该方法会将调用构造器方法时指定的大小转换成一个2的幂次方数，也就是说concurrenthashmap的大小一定是2的幂次方，比如，当指定大小为18时，为了满足2的幂次方特性，实际上concurrenthashmapd的大小为2的5次方（32）。另外，需要注意的是，调用构造器方法的时候并未构造出table数组（可以理解为concurrenthashmap的数据容器），只是算出table数组的长度，当第一次向concurrenthashmap插入数据的时候才真正的完成初始化创建table数组的工作。\n\n\n# 3.2 inittable方法\n\n直接上源码：\n\nprivate final node<k,v>[] inittable() {\n    node<k,v>[] tab; int sc;\n    while ((tab = table) == null || tab.length == 0) {\n        if ((sc = sizectl) < 0)\n            // 1. 保证只有一个线程正在进行初始化操作\n            thread.yield(); // lost initialization race; just spin\n        else if (u.compareandswapint(this, sizectl, sc, -1)) {\n            try {\n                if ((tab = table) == null || tab.length == 0) {\n                    // 2. 得出数组的大小\n                    int n = (sc > 0) ? sc : default_capacity;\n                    @suppresswarnings("unchecked")\n                    // 3. 这里才真正的初始化数组\n                    node<k,v>[] nt = (node<k,v>[])new node<?,?>[n];\n                    table = tab = nt;\n                    // 4. 计算数组中可用的大小：实际大小n*0.75（加载因子）\n                    sc = n - (n >>> 2);\n                }\n            } finally {\n                sizectl = sc;\n            }\n            break;\n        }\n    }\n    return tab;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n代码的逻辑请见注释，有可能存在一个情况是多个线程同时走到这个方法中，为了保证能够正确初始化，在第1步中会先通过if进行判断，若当前已经有一个线程正在初始化即sizectl值变为-1，这个时候其他线程在if判断为true从而调用thread.yield()让出cpu时间片。正在进行初始化的线程会调用u.compareandswapint方法将sizectl改为-1即正在初始化的状态。另外还需要注意的事情是，在第四步中会进一步计算数组中可用的大小即为数组实际大小n乘以加载因子0.75.可以看看这里乘以0.75是怎么算的，0.75为四分之三，这里n - (n >>> 2)是不是刚好是n-(1/4)n=(3/4)n。如果选择是无参的构造器的话，这里在new node数组的时候会使用默认大小为default_capacity（16），然后乘以加载因子0.75为12，也就是说数组的可用大小为12。\n\n\n# 3.3 put方法\n\n使用concurrenthashmap最长用的也应该是put和get方法了吧，我们先来看看put方法是怎样实现的。调用put方法时实际具体实现是putval方法，源码如下：\n\n/**\n* implementation for put and putifabsent\n*/\nfinal v putval(k key, v value, boolean onlyifabsent) {\n    if (key == null || value == null) throw new nullpointerexception();\n    //1. 计算key的hash值\n    int hash = spread(key.hashcode());\n    int bincount = 0;\n    for (node<k,v>[] tab = table;;) {\n        node<k,v> f; int n, i, fh;\n        //2. 如果当前table还没有初始化先调用inittable方法将tab进行初始化\n        if (tab == null || (n = tab.length) == 0)\n            tab = inittable();\n        //3. tab中索引为i的位置的元素为null，则直接使用cas将值插入即可\n        else if ((f = tabat(tab, i = (n - 1) & hash)) == null) {\n            if (castabat(tab, i, null, new node<k,v>(hash, key, value, null)))\n                break; // no lock when adding to empty bin\n        }\n        //4. 当前正在扩容\n        else if ((fh = f.hash) == moved)\n            tab = helptransfer(tab, f);\n        else {\n            v oldval = null;\n            synchronized (f) {\n                if (tabat(tab, i) == f) {\n                    //5. 当前为链表，在链表中插入新的键值对\n                    if (fh >= 0) {\n                        bincount = 1;\n                        for (node<k,v> e = f;; ++bincount) {\n                            k ek;\n                            if (e.hash == hash &&\n                                ((ek = e.key) == key ||\n                                 (ek != null && key.equals(ek)))) {\n                                oldval = e.val;\n                                if (!onlyifabsent)\n                                    e.val = value;\n                                break;\n                            }\n                            node<k,v> pred = e;\n                            if ((e = e.next) == null) {\n                                pred.next = new node<k,v>(hash, key, value, null);\n                                break;\n                            }\n                        }\n                    }\n                    // 6.当前为红黑树，将新的键值对插入到红黑树中\n                    else if (f instanceof treebin) {\n                        node<k,v> p;\n                        bincount = 2;\n                        if ((p = ((treebin<k,v>)f).puttreeval(hash, key, value)) != null) {\n                            oldval = p.val;\n                            if (!onlyifabsent)\n                                p.val = value;\n                        }\n                    }\n                }\n            }\n            // 7.插入完键值对后再根据实际大小看是否需要转换成红黑树\n            if (bincount != 0) {\n                if (bincount >= treeify_threshold)\n                    treeifybin(tab, i);\n                if (oldval != null)\n                    return oldval;\n                break;\n            }\n        }\n    }\n    //8.对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容\n    addcount(1l, bincount);\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\nput方法的代码量有点长，我们按照上面的分解的步骤一步步来看。从整体而言，为了解决线程安全的问题，concurrenthashmap使用了synchronzied和cas的方式。在之前了解过hashmap以及1.8版本之前的concurrenhashmap都应该知道concurrenthashmap结构图，为了方面下面的讲解这里先直接给出，如果对这有疑问的话，可以在网上随便搜搜即可。\n\n\n\nconcurrenthashmap是一个哈希桶数组，如果不出现哈希冲突的时候，每个元素均匀的分布在哈希桶数组中。当出现哈希冲突的时候，是标准的链地址的解决方式，将hash值相同的节点构成链表的形式，称为“拉链法”，另外，在1.8版本中为了防止拉链过长，当链表的长度大于8的时候会将链表转换成红黑树。table数组中的每个元素实际上是单链表的头结点或者红黑树的根节点。当插入键值对时首先应该定位到要插入的桶，即插入table数组的索引i处。那么，怎样计算得出索引i呢？当然是根据key的hashcode值。\n\n> 1、spread()重哈希，以减小hash冲突\n\n我们知道对于一个hash表来说，hash值分散的不够均匀的话会大大增加哈希冲突的概率，从而影响到hash表的性能。因此通过spread方法进行了一次重hash从而大大减小哈希冲突的可能性。spread方法为：\n\nstatic final int spread(int h) {\n    return (h ^ (h >>> 16)) & hash_bits;\n}\n\n\n1\n2\n3\n\n\n该方法主要是将key的hashcode的低16位于高16位进行异或运算，这样不仅能够使得hash值能够分散能够均匀减小hash冲突的概率，另外只用到了异或运算，在性能开销上也能兼顾，做到平衡的trade-off。\n\n> 2、初始化table\n\n紧接着到第2步，会判断当前table数组是否初始化了，没有的话就调用inittable进行初始化，该方法在上面已经讲过了。\n\n> 3、能否直接将新值插入到table数组中\n\n从上面的结构示意图就可以看出存在这样一种情况，如果插入值待插入的位置刚好所在的table数组为null的话就可以直接将值插入即可。那么怎样根据hash确定在table中待插入的索引i呢？很显然可以通过hash值与数组的长度取模操作，从而确定新值插入到数组的哪个位置。而之前我们提过concurrenthashmap的大小总是2的幂次方，(n - 1) & hash运算等价于对长度n取模，也就是hash%n，但是位运算比取模运算的效率要高很多，doug lea大师在设计并发容器的时候也是将性能优化到了极致，令人钦佩。\n\n确定好数组的索引i后，就可以可以tabat()方法获取该位置上的元素，如果当前node f为null的话，就可以直接用castabat方法将新值插入即可。\n\n> 4、当前是否正在扩容\n\n如果当前节点不为null，且该节点为特殊节点（forwardingnode）的话，就说明当前concurrenthashmap正在进行扩容操作，关于扩容操作，下面会作为一个具体的方法进行讲解。那么怎样确定当前的这个node是不是特殊的节点了？是通过判断该节点的hash值是不是等于-1（moved），代码为(fh = f.hash) == moved，对moved的解释在源码上也写的很清楚了：\n\nstatic final int moved = -1; // hash for forwarding nodes\n\n\n1\n\n\n> 5、当table[i]为链表的头结点，在链表中插入新值\n\n在table[i]不为null并且不为forwardingnode时，并且当前node f的hash值大于0（fh >= 0）的话说明当前节点f为当前桶的所有的节点组成的链表的头结点。那么接下来，要想向concurrenthashmap插入新值的话就是向这个链表插入新值。通过synchronized (f)的方式进行加锁以实现线程安全性。往链表中插入节点的部分代码为：\n\nif (fh >= 0) {\n    bincount = 1;\n    for (node<k,v> e = f;; ++bincount) {\n        k ek;\n\t\t// 找到hash值相同的key,覆盖旧值即可\n        if (e.hash == hash &&\n            ((ek = e.key) == key ||\n             (ek != null && key.equals(ek)))) {\n            oldval = e.val;\n            if (!onlyifabsent)\n                e.val = value;\n            break;\n        }\n        node<k,v> pred = e;\n        if ((e = e.next) == null) {\n\t\t\t//如果到链表末尾仍未找到，则直接将新值插入到链表末尾即可\n            pred.next = new node<k,v>(hash, key, value, null);\n            break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这部分代码很好理解，就是两种情况：1. 在链表中如果找到了与待插入的键值对的key相同的节点，就直接覆盖即可；2. 如果直到找到了链表的末尾都没有找到的话，就直接将待插入的键值对追加到链表的末尾即可\n\n> 6、当table[i]为红黑树的根节点，在红黑树中插入新值\n\n按照之前的数组+链表的设计方案，这里存在一个问题，即使负载因子和hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，甚至在极端情况下，查找一个节点会出现时间复杂度为o(n)的情况，则会严重影响concurrenthashmap的性能，于是，在jdk1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高concurrenthashmap的性能，其中会用到红黑树的插入、删除、查找等算法。当table[i]为红黑树的树节点时的操作为：\n\nif (f instanceof treebin) {\n    node<k,v> p;\n    bincount = 2;\n    if ((p = ((treebin<k,v>)f).puttreeval(hash, key, value)) != null) {\n        oldval = p.val;\n        if (!onlyifabsent)\n            p.val = value;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n首先在if中通过f instanceof treebin判断当前table[i]是否是树节点，这下也正好验证了我们在最上面介绍时说的treebin会对treenode做进一步封装，对红黑树进行操作的时候针对的是treebin而不是treenode。这段代码很简单，调用puttreeval方法完成向红黑树插入新节点，同样的逻辑，如果在红黑树中存在于待插入键值对的key相同（hash值相等并且equals方法判断为true）的节点的话，就覆盖旧值，否则就向红黑树追加新节点。\n\n> 7、根据当前节点个数进行调整\n\n当完成数据新节点插入之后，会进一步对当前链表大小进行调整，这部分代码为：\n\nif (bincount != 0) {\n    if (bincount >= treeify_threshold)\n        treeifybin(tab, i);\n    if (oldval != null)\n        return oldval;\n    break;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n很容易理解，如果当前链表节点个数大于等于8（treeify_threshold）的时候，就会调用treeifybin方法将tabel[i]（第i个散列桶）拉链转换成红黑树。\n\n至此，关于put方法的逻辑就基本说的差不多了，现在来做一些总结：\n\n整体流程：\n\n 1. 首先对于每一个放入的值，首先利用spread方法对key的hashcode进行一次hash计算，由此来确定这个值在 table 中的位置；\n 2. 如果当前table数组还未初始化，先将table数组进行初始化操作；\n 3. 如果这个位置是null的，那么使用cas操作直接放入；\n 4. 如果这个位置存在结点，说明发生了hash碰撞，首先判断这个节点的类型。如果该节点fh==moved(代表forwardingnode,数组正在进行扩容)的话，说明正在进行扩容；\n 5. 如果是链表节点（fh>0），则得到的结点就是hash值相同的节点组成的链表的头节点。需要依次向后遍历确定这个新加入的值所在位置。如果遇到key相同的节点，则只需要覆盖该结点的value值即可。否则依次向后遍历，直到链表尾插入这个结点；\n 6. 如果这个节点的类型是treebin的话，直接调用红黑树的插入方法进行插入新的节点；\n 7. 插入完节点之后再次检查链表长度，如果长度大于8，就把这个链表转换成红黑树；\n 8. 对当前容量大小进行检查，如果超过了临界值（实际大小*加载因子）就需要扩容。\n\n\n# 3.4 get方法\n\n看完了put方法再来看get方法就很容易了，用逆向思维去看就好，这样存的话我反过来这么取就好了。get方法源码为：\n\npublic v get(object key) {\n    node<k,v>[] tab; node<k,v> e, p; int n, eh; k ek;\n\t// 1. 重hash\n    int h = spread(key.hashcode());\n    if ((tab = table) != null && (n = tab.length) > 0 &&\n        (e = tabat(tab, (n - 1) & h)) != null) {\n        // 2. table[i]桶节点的key与查找的key相同，则直接返回\n\t\tif ((eh = e.hash) == h) {\n            if ((ek = e.key) == key || (ek != null && key.equals(ek)))\n                return e.val;\n        }\n\t\t// 3. 当前节点hash小于0说明为树节点，在红黑树中查找即可\n        else if (eh < 0)\n            return (p = e.find(h, key)) != null ? p.val : null;\n        while ((e = e.next) != null) {\n\t\t//4. 从链表中查找，查找到则返回该节点的value，否则就返回null即可\n            if (e.hash == h &&\n                ((ek = e.key) == key || (ek != null && key.equals(ek))))\n                return e.val;\n        }\n    }\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n代码的逻辑请看注释，首先先看当前的hash桶数组节点即table[i]是否为查找的节点，若是则直接返回；若不是，则继续再看当前是不是树节点？通过看节点的hash值是否为小于0，如果小于0则为树节点。如果是树节点在红黑树中查找节点；如果不是树节点，那就只剩下为链表的形式的一种可能性了，就向后遍历查找节点，若查找到则返回节点的value即可，若没有找到就返回null。\n\n\n# 3.5 transfer方法\n\n当concurrenthashmap容量不足的时候，需要对table进行扩容。这个方法的基本思想跟hashmap是很像的，但是由于它是支持并发扩容的，所以要复杂的多。原因是它支持多线程进行扩容操作，而并没有加锁。我想这样做的目的不仅仅是为了满足concurrent的要求，而是希望利用并发处理去减少扩容带来的时间影响。transfer方法源码为：\n\nprivate final void transfer(node<k,v>[] tab, node<k,v>[] nexttab) {\n    int n = tab.length, stride;\n    if ((stride = (ncpu > 1) ? (n >>> 3) / ncpu : n) < min_transfer_stride)\n        stride = min_transfer_stride; // subdivide range\n    //1. 新建node数组，容量为之前的两倍\n    if (nexttab == null) {            // initiating\n        try {\n            @suppresswarnings("unchecked")\n            node<k,v>[] nt = (node<k,v>[])new node<?,?>[n << 1];\n            nexttab = nt;\n        } catch (throwable ex) {      // try to cope with oome\n            sizectl = integer.max_value;\n            return;\n        }\n        nexttable = nexttab;\n        transferindex = n;\n    }\n    int nextn = nexttab.length;\n    //2. 新建forwardingnode引用，在之后会用到\n    forwardingnode<k,v> fwd = new forwardingnode<k,v>(nexttab);\n    boolean advance = true;\n    boolean finishing = false; // to ensure sweep before committing nexttab\n    for (int i = 0, bound = 0;;) {\n        node<k,v> f; int fh;\n        // 3. 确定遍历中的索引i\n        while (advance) {\n            int nextindex, nextbound;\n            if (--i >= bound || finishing)\n                advance = false;\n            else if ((nextindex = transferindex) <= 0) {\n                i = -1;\n                advance = false;\n            }\n            else if (u.compareandswapint(this, transferindex, nextindex,\n                                         nextbound = (nextindex > stride ? nextindex - stride : 0))) {\n                bound = nextbound;\n                i = nextindex - 1;\n                advance = false;\n            }\n        }\n        //4.将原数组中的元素复制到新数组中去\n        //4.5 for循环退出，扩容结束修改sizectl属性\n        if (i < 0 || i >= n || i + n >= nextn) {\n            int sc;\n            if (finishing) {\n                nexttable = null;\n                table = nexttab;\n                sizectl = (n << 1) - (n >>> 1);\n                return;\n            }\n            if (u.compareandswapint(this, sizectl, sc = sizectl, sc - 1)) {\n                if ((sc - 2) != resizestamp(n) << resize_stamp_shift)\n                    return;\n                finishing = advance = true;\n                i = n; // recheck before commit\n            }\n        }\n        //4.1 当前数组中第i个元素为null，用cas设置成特殊节点forwardingnode(可以理解成占位符)\n        else if ((f = tabat(tab, i)) == null)\n            advance = castabat(tab, i, null, fwd);\n        //4.2 如果遍历到forwardingnode节点，说明这个点已经被处理过了，直接跳过，这里是控制并发扩容的核心\n        else if ((fh = f.hash) == moved)\n            advance = true; // already processed\n        else {\n            synchronized (f) {\n                if (tabat(tab, i) == f) {\n                    node<k,v> ln, hn;\n                    if (fh >= 0) {\n                        //4.3 处理当前节点为链表的头结点的情况，构造两个链表，一个是原链表，另一个是原链表的反序排列\n                        int runbit = fh & n;\n                        node<k,v> lastrun = f;\n                        for (node<k,v> p = f.next; p != null; p = p.next) {\n                            int b = p.hash & n;\n                            if (b != runbit) {\n                                runbit = b;\n                                lastrun = p;\n                            }\n                        }\n                        if (runbit == 0) {\n                            ln = lastrun;\n                            hn = null;\n                        }\n                        else {\n                            hn = lastrun;\n                            ln = null;\n                        }\n                        for (node<k,v> p = f; p != lastrun; p = p.next) {\n                            int ph = p.hash; k pk = p.key; v pv = p.val;\n                            if ((ph & n) == 0)\n                                ln = new node<k,v>(ph, pk, pv, ln);\n                            else\n                                hn = new node<k,v>(ph, pk, pv, hn);\n                        }\n                        //在nexttable的i位置上插入一个链表\n                        settabat(nexttab, i, ln);\n                        //在nexttable的i+n的位置上插入另一个链表\n                        settabat(nexttab, i + n, hn);\n                        //在table的i位置上插入forwardnode节点  表示已经处理过该节点\n                        settabat(tab, i, fwd);\n                        //设置advance为true 返回到上面的while循环中 就可以执行i--操作\n                        advance = true;\n                    }\n                    //4.4 处理当前节点是treebin时的情况，操作和上面的类似\n                    else if (f instanceof treebin) {\n                        treebin<k,v> t = (treebin<k,v>)f;\n                        treenode<k,v> lo = null, lotail = null;\n                        treenode<k,v> hi = null, hitail = null;\n                        int lc = 0, hc = 0;\n                        for (node<k,v> e = t.first; e != null; e = e.next) {\n                            int h = e.hash;\n                            treenode<k,v> p = new treenode<k,v>\n                                (h, e.key, e.val, null, null);\n                            if ((h & n) == 0) {\n                                if ((p.prev = lotail) == null)\n                                    lo = p;\n                                else\n                                    lotail.next = p;\n                                lotail = p;\n                                ++lc;\n                            }\n                            else {\n                                if ((p.prev = hitail) == null)\n                                    hi = p;\n                                else\n                                    hitail.next = p;\n                                hitail = p;\n                                ++hc;\n                            }\n                        }\n                        ln = (lc <= untreeify_threshold) ? untreeify(lo) :\n                        (hc != 0) ? new treebin<k,v>(lo) : t;\n                        hn = (hc <= untreeify_threshold) ? untreeify(hi) :\n                        (lc != 0) ? new treebin<k,v>(hi) : t;\n                        settabat(nexttab, i, ln);\n                        settabat(nexttab, i + n, hn);\n                        settabat(tab, i, fwd);\n                        advance = true;\n                    }\n                }\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n\n\n代码逻辑请看注释，整个扩容操作分为两个部分：\n\n第一部分是构建一个nexttable，它的容量是原来的两倍，这个操作是单线程完成的。新建table数组的代码为:node<k,v>[] nt = (node<k,v>[])new node<?,?>[n << 1]，在原容量大小的基础上右移一位。\n\n第二个部分就是将原来table中的元素复制到nexttable中，主要是遍历复制的过程。 根据运算得到当前遍历的数组的位置i，然后利用tabat方法获得i位置的元素再进行判断：\n\n 1. 如果这个位置为空，就在原table中的i位置放入forwardnode节点，这个也是触发并发扩容的关键点；\n\n 2. 如果这个位置是node节点（fh>=0），如果它是一个链表的头节点，就构造一个反序链表，把他们分别放在nexttable的i和i+n的位置上\n\n 3. 如果这个位置是treebin节点（fh<0），也做一个反序处理，并且判断是否需要untreefi，把处理的结果分别放在nexttable的i和i+n的位置上\n\n 4. 遍历过所有的节点以后就完成了复制工作，这时让nexttable作为新的table，并且更新sizectl为新容量的0.75倍 ，完成扩容。设置为新容量的0.75倍代码为 sizectl = (n << 1) - (n >>> 1)，仔细体会下是不是很巧妙，n<<1相当于n左移一位表示n的两倍即2n，n>>>1右移一位相当于n除以2即0.5n，然后两者相减为2n-0.5n=1.5n，就刚好等于新容量的0.75倍即2n*0.75=1.5n。最后用一个示意图来进行总结（图片摘自网络）：\n    \n    \n\n\n# 3.6 与size相关的一些方法\n\n对于concurrenthashmap来说，这个table里到底装了多少东西其实是个不确定的数量，因为不可能在调用size()方法的时候像gc的“stop the world”一样让其他线程都停下来让你去统计，因此只能说这个数量是个估计值。对于这个估计值，concurrenthashmap也是大费周章才计算出来的。\n\n为了统计元素个数，concurrenthashmap定义了一些变量和一个内部类：\n\n/**\n * a padded cell for distributing counts.  adapted from longadder\n * and striped64.  see their internal docs for explanation.\n */\n@sun.misc.contended static final class countercell {\n    volatile long value;\n    countercell(long x) {\n        value = x;\n    }\n}\n\n/******************************************/\n\n/**\n * 实际上保存的是hashmap中的元素个数，利用cas锁进行更新但它并不用返回当前hashmap的元素个数\n */\nprivate transient volatile long basecount;\n\n/**\n * spinlock (locked via cas) used when resizing and/or creating countercells.\n */\nprivate transient volatile int cellsbusy;\n\n/**\n * table of counter cells. when non-null, size is a power of 2.\n */\nprivate transient volatile countercell[] countercells;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n> mappingcount与size方法\n\nmappingcount与size方法类似，从给出的注释来看，应该使用mappingcount代替size方法，两个方法都没有直接返回 basecount 而是统计一次这个值，而这个值其实也是一个大概的数值，因此可能在统计的时候有其他线程正在执行插入或删除操作。\n\npublic int size() {\n    long n = sumcount();\n    return ((n < 0l) ? 0 :\n            (n > (long)integer.max_value) ? integer.max_value :\n            (int)n);\n}\n/**\n * returns the number of mappings. this method should be used\n * instead of {@link #size} because a concurrenthashmap may\n * contain more mappings than can be represented as an int. the\n * value returned is an estimate; the actual count may differ if\n * there are concurrent insertions or removals.\n *\n * @return the number of mappings\n * @since 1.8\n */\npublic long mappingcount() {\n    long n = sumcount();\n    return (n < 0l) ? 0l : n; // ignore transient negative values\n}\n\nfinal long sumcount() {\n    countercell[] as = countercells; countercell a;\n    long sum = basecount;\n    if (as != null) {\n        for (int i = 0; i < as.length; ++i) {\n            if ((a = as[i]) != null)\n                sum += a.value;//所有counter的值求和\n        }\n    }\n    return sum;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n> addcount方法\n\n在put方法结尾处调用了addcount方法，把当前concurrenthashmap的元素个数+1这个方法一共做了两件事：更新basecount的值，检测是否进行扩容。\n\nprivate final void addcount(long x, int check) {\n    countercell[] as; long b, s;\n    //利用cas方法更新basecount的值\n    if ((as = countercells) != null ||\n        !u.compareandswaplong(this, basecount, b = basecount, s = b + x)) {\n        countercell a; long v; int m;\n        boolean uncontended = true;\n        if (as == null || (m = as.length - 1) < 0 ||\n            (a = as[threadlocalrandom.getprobe() & m]) == null ||\n            !(uncontended =\n              u.compareandswaplong(a, cellvalue, v = a.value, v + x))) {\n            fulladdcount(x, uncontended);\n            return;\n        }\n        if (check <= 1)\n            return;\n        s = sumcount();\n    }\n    //如果check值大于等于0 则需要检验是否需要进行扩容操作\n    if (check >= 0) {\n        node<k,v>[] tab, nt; int n, sc;\n        while (s >= (long)(sc = sizectl) && (tab = table) != null &&\n               (n = tab.length) < maximum_capacity) {\n            int rs = resizestamp(n);\n            //\n            if (sc < 0) {\n                if ((sc >>> resize_stamp_shift) != rs || sc == rs + 1 ||\n                    sc == rs + max_resizers || (nt = nexttable) == null ||\n                    transferindex <= 0)\n                    break;\n                //如果已经有其他线程在执行扩容操作\n                if (u.compareandswapint(this, sizectl, sc, sc + 1))\n                    transfer(tab, nt);\n            }\n            //当前线程是唯一的或是第一个发起扩容的线程  此时nexttable=null\n            else if (u.compareandswapint(this, sizectl, sc,\n                                         (rs << resize_stamp_shift) + 2))\n                transfer(tab, null);\n            s = sumcount();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 4、总结\n\nconcurrenthashmap 是一个并发散列映射表的实现，它允许完全并发的读取，并且支持给定数量的并发更新。相比于 hashtable 和同步包装器包装的 hashmap，使用一个全局的锁来同步不同线程间的并发访问，同一时间点，只能有一个线程持有锁，也就是说在同一时间点，只能有一个线程能访问容器，这虽然保证多线程间的安全并发访问，但同时也导致对容器的访问变成串行化的了。\n\njdk6,7中的concurrenthashmap主要使用segment来实现减小锁粒度，分割成若干个segment，在put的时候需要锁住segment，get时候不加锁，使用volatile来保证可见性，当要统计全局时（比如size），首先会尝试多次计算modcount来确定，这几次尝试中，是否有其他线程进行了修改操作，如果没有，则直接返回size。如果有，则需要依次锁住所有的segment来计算。\n\n1.8之前put定位节点时要先定位到具体的segment，然后再在segment中定位到具体的桶。而在1.8的时候摒弃了segment臃肿的设计，直接针对的是node[] tale数组中的每一个桶，进一步减小了锁粒度。并且防止拉链过长导致性能下降，当链表长度大于8的时候采用红黑树的设计。\n\n主要设计上的变化有以下几点：\n\n 1. 不采用segment而采用node，锁住node来实现减小锁粒度。\n 2. 设计了moved状态，当resize的过程中，线程2还在put数据，线程2会帮助resize。\n 3. 使用3个cas操作来确保node的一些操作的原子性，这种方式代替了锁。\n 4. sizectl的不同值来代表不同含义，起到了控制的作用。\n 5. 采用synchronized而不是reentrantlock（莫非是因为1.8的虚拟机对内置锁已经优化的足够快了？）。\n\n更多关于1.7版本与1.8版本的concurrenthashmap的实现对比，可以参考这篇文章。\n\n> 参考文章\n\njava-concurrency/并发容器之concurrenthashmap(jdk 1.8版本)',charsets:{cjk:!0},createdTime:1655628697e3},{title:"并发容器之BlockingQueue",frontmatter:{title:"并发容器之BlockingQueue",description:"并发容器之BlockingQueue",date:"2022-04-09T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/18%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BBlockingQueue.html",relativePath:"Java/Java并发编程的艺术/18、并发容器之BlockingQueue.md",key:"v-a9c98eb6",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/18%E3%80%81%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E4%B9%8BBlockingQueue.html",headers:[{level:2,title:"1、BlockingQueue简介",slug:"_1、blockingqueue简介",normalizedTitle:"1、blockingqueue简介",charIndex:29},{level:2,title:"2、基本操作",slug:"_2、基本操作",normalizedTitle:"2、基本操作",charIndex:50},{level:2,title:"3、常用的BlockingQueue",slug:"_3、常用的blockingqueue",normalizedTitle:"3、常用的blockingqueue",charIndex:60},{level:2,title:"4、ArrayBlockingQueue",slug:"_4、arrayblockingqueue",normalizedTitle:"4、arrayblockingqueue",charIndex:82},{level:3,title:"4.1 ArrayBlockingQueue简介",slug:"_4-1-arrayblockingqueue简介",normalizedTitle:"4.1 arrayblockingqueue简介",charIndex:108},{level:3,title:"4.2 ArrayBlockingQueue实现原理",slug:"_4-2-arrayblockingqueue实现原理",normalizedTitle:"4.2 arrayblockingqueue实现原理",charIndex:138},{level:3,title:"4.3 ArrayBlockingQueue的主要属性",slug:"_4-3-arrayblockingqueue的主要属性",normalizedTitle:"4.3 arrayblockingqueue的主要属性",charIndex:170},{level:3,title:"4.4 put方法详解",slug:"_4-4-put方法详解",normalizedTitle:"4.4 put方法详解",charIndex:203},{level:3,title:"4.5 take方法详解",slug:"_4-5-take方法详解",normalizedTitle:"4.5 take方法详解",charIndex:220},{level:2,title:"5、LinkedBlockingQueue",slug:"_5、linkedblockingqueue",normalizedTitle:"5、linkedblockingqueue",charIndex:236},{level:3,title:"5.1 LinkedBlockingQueue的主要属性",slug:"_5-1-linkedblockingqueue的主要属性",normalizedTitle:"5.1 linkedblockingqueue的主要属性",charIndex:263},{level:3,title:"5.2 put方法详解",slug:"_5-2-put方法详解",normalizedTitle:"5.2 put方法详解",charIndex:297},{level:2,title:"6、两个阻塞队列的比较",slug:"_6、两个阻塞队列的比较",normalizedTitle:"6、两个阻塞队列的比较",charIndex:312}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>并发容器之BlockingQueue</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"1、BlockingQueue简介 2、基本操作 3、常用的BlockingQueue 4、ArrayBlockingQueue 4.1 ArrayBlockingQueue简介 4.2 ArrayBlockingQueue实现原理 4.3 ArrayBlockingQueue的主要属性 4.4 put方法详解 4.5 take方法详解 5、LinkedBlockingQueue 5.1 LinkedBlockingQueue的主要属性 5.2 put方法详解 6、两个阻塞队列的比较",content:'说明\n\n并发容器之BlockingQueue\n\n\n\n * 1、BlockingQueue简介\n * 2、基本操作\n * 3、常用的BlockingQueue\n * 4、ArrayBlockingQueue\n   * 4.1 ArrayBlockingQueue简介\n   * 4.2 ArrayBlockingQueue实现原理\n   * 4.3 ArrayBlockingQueue的主要属性\n   * 4.4 put方法详解\n   * 4.5 take方法详解\n * 5、LinkedBlockingQueue\n   * 5.1 LinkedBlockingQueue的主要属性\n   * 5.2 put方法详解\n * 6、两个阻塞队列的比较\n\n\n\n\n# 并发容器之BlockingQueue\n\n\n# 1、BlockingQueue简介\n\n在实际编程中，会经常使用到JDK中Collection集合框架中的各种容器类如实现List,Map,Queue接口的容器类，但是这些容器类基本上不是线程安全的，除了使用Collections可以将其转换为线程安全的容器，Doug Lea大师为我们都准备了对应的线程安全的容器，如实现List接口的CopyOnWriteArrayList，实现Map接口的ConcurrentHashMap，实现Queue接口的ConcurrentLinkedQueue。\n\n最常用的"生产者-消费者"问题中，队列通常被视作线程间操作的数据容器，这样，可以对各个模块的业务功能进行解耦，生产者将“生产”出来的数据放置在数据容器中，而消费者仅仅只需要在“数据容器”中进行获取数据即可，这样生产者线程和消费者线程就能够进行解耦，只专注于自己的业务功能即可。阻塞队列（BlockingQueue）被广泛使用在“生产者-消费者”问题中，其原因是BlockingQueue提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。\n\n\n# 2、基本操作\n\n插入和移除操作的4种处理方式：\n\n\n\n * 抛出异常：当队列满时，如果再往队列里插入元素，会抛出IllegalStateException（"Queue full"）异常。当队列空时，从队列里获取元素会抛出NoSuchElementException异常。\n * 返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。\n * 一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。\n * 超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。\n\n\n# 3、常用的BlockingQueue\n\n实现BlockingQueue接口的有ArrayBlockingQueue, DelayQueue, LinkedBlockingDeque, LinkedBlockingQueue, LinkedTransferQueue, PriorityBlockingQueue, SynchronousQueue，而这几种常见的阻塞队列也是在实际编程中会常用的，下面对这几种常见的阻塞队列进行说明：\n\n> ArrayBlockingQueue\n\nArrayBlockingQueue是由数组实现的有界阻塞队列。该队列命令元素FIFO（先进先出）。因此，队头元素是队列中存在时间最长的数据元素，而对尾数据则是当前队列最新的数据元素。ArrayBlockingQueue可作为“有界数据缓冲区”，生产者插入数据到队列容器中，并由消费者提取。ArrayBlockingQueue一旦创建，容量不能改变。\n\n当队列容量满时，尝试将元素放入队列将导致操作阻塞；尝试从一个空队列中取一个元素也会同样阻塞。\n\nArrayBlockingQueue默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到ArrayBlockingQueue。而非公平性则是指访问ArrayBlockingQueue的顺序不是遵守严格的时间顺序，有可能存在，一旦ArrayBlockingQueue可以被访问时，长时间阻塞的线程依然无法访问到ArrayBlockingQueue。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的ArrayBlockingQueue，可采用如下代码：\n\nprivate static ArrayBlockingQueue<Integer> blockingQueue = new ArrayBlockingQueue<Integer>(10,true);\n\n\n1\n\n\n访问者的公平性是使用可重入锁实现的，代码如下：\n\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n    if (capacity <= 0)\n        throw new IllegalArgumentException();\n    this.items = new Object[capacity];\n    lock = new ReentrantLock(fair);\n    notEmpty = lock.newCondition();\n    notFull = lock.newCondition();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n关于ArrayBlockingQueue的实现原理，可以看这篇文章。\n\n> LinkedBlockingQueue\n\nLinkedBlockingQueue是用链表实现的有界阻塞队列，同样满足FIFO的特性，与ArrayBlockingQueue相比起来具有更高的吞吐量，为了防止LinkedBlockingQueue容量迅速增，损耗大量内存。通常在创建LinkedBlockingQueue对象时，会指定其大小，如果未指定，容量等于Integer.MAX_VALUE\n\n> PriorityBlockingQueue\n\nPriorityBlockingQueue是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现compareTo()方法来指定元素排序规则，或者初始化时通过构造器参数Comparator来指定排序规则。\n\n> SynchronousQueue\n\nSynchronousQueue每个插入操作必须等待另一个线程进行相应的删除操作，因此，SynchronousQueue实际上没有存储任何数据元素，因为只有线程在删除数据时，其他线程才能插入数据，同样的，如果当前有线程在插入数据时，线程才能删除数据。SynchronousQueue也可以通过构造器参数来为其指定公平性。\n\n> LinkedTransferQueue\n\nLinkedTransferQueue是一个由链表数据结构构成的无界阻塞队列，由于该队列实现了TransferQueue接口，与其他阻塞队列相比主要有以下不同的方法：\n\n * transfer(E e)：如果当前有线程（消费者）正在调用take()方法或者可延时的poll()方法进行消费数据时，生产者线程可以调用transfer方法将数据传递给消费者线程。如果当前没有消费者线程的话，生产者线程就会将数据插入到队尾，直到有消费者能够进行消费才能退出；\n * tryTransfer(E e)：tryTransfer方法如果当前有消费者线程（调用take方法或者具有超时特性的poll方法）正在消费数据的话，该方法可以将数据立即传送给消费者线程，如果当前没有消费者线程消费数据的话，就立即返回false。因此，与transfer方法相比，transfer方法是必须等到有消费者线程消费数据时，生产者线程才能够返回。而tryTransfer方法能够立即返回结果退出。\n * tryTransfer(E e,long timeout,imeUnit unit)：与transfer基本功能一样，只是增加了超时特性，如果数据才规定的超时时间内没有消费者进行消费的话，就返回false。\n\n> LinkedBlockingDeque\n\nLinkedBlockingDeque是基于链表数据结构的有界阻塞双端队列，如果在创建对象时为指定大小时，其默认大小为Integer.MAX_VALUE。与LinkedBlockingQueue相比，主要的不同点在于，LinkedBlockingDeque具有双端队列的特性。LinkedBlockingDeque基本操作如下图所示：\n\n\n\n如上图所示，LinkedBlockingDeque的基本操作可以分为四种类型：1.特殊情况，抛出异常；2.特殊情况，返回特殊值如null或者false；3.当线程不满足操作条件时，线程会被阻塞直至条件满足；4. 操作具有超时特性。\n\n另外，LinkedBlockingDeque实现了BlockingDueue接口而LinkedBlockingQueue实现的是BlockingQueue，这两个接口的主要区别如下图所示：\n\n\n\n从上图可以看出，两个接口的功能是可以等价使用的，比如BlockingQueue的add方法和BlockingDeque的addLast方法的功能是一样的。\n\n> DelayQueue\n\nDelayQueue是一个存放实现Delayed接口的数据的无界阻塞队列，只有当数据对象的延时时间达到时才能插入到队列进行存储。如果当前所有的数据都还没有达到创建时所指定的延时期，则队列没有队头，并且线程通过poll等方法获取数据元素则返回null。所谓数据延时期满时，则是通过Delayed接口的getDelay(TimeUnit.NANOSECONDS)来进行判定，如果该方法返回的是小于等于0则说明该数据元素的延时期已满。\n\n\n# 4、ArrayBlockingQueue\n\n\n# 4.1 ArrayBlockingQueue简介\n\n在多线程编程过程中，为了业务解耦和架构设计，经常会使用并发容器用于存储多线程间的共享数据，这样不仅可以保证线程安全，还可以简化各个线程操作。例如在“生产者-消费者”问题中，会使用阻塞队列（BlockingQueue）作为数据容器。为了加深对阻塞队列的理解，唯一的方式是对其实验原理进行理解，这篇文章就主要来看看ArrayBlockingQueue和LinkedBlockingQueue的实现原理。\n\n\n# 4.2 ArrayBlockingQueue实现原理\n\n阻塞队列最核心的功能是，能够可阻塞式的插入和删除队列元素。当前队列为空时，会阻塞消费数据的线程，直至队列非空时，通知被阻塞的线程；当队列满时，会阻塞插入数据的线程，直至队列未满时，通知插入数据的线程（生产者线程）。那么，多线程中消息通知机制最常用的是lock的condition机制，关于condition可以看前面文章的详细介绍。那么ArrayBlockingQueue的实现是不是也会采用Condition的通知机制呢？下面来看看。\n\n\n# 4.3 ArrayBlockingQueue的主要属性\n\nArrayBlockingQueue的主要属性如下:\n\n/** The queued items */\nfinal Object[] items;\n\n/** items index for next take, poll, peek or remove */\nint takeIndex;\n\n/** items index for next put, offer, or add */\nint putIndex;\n\n/** Number of elements in the queue */\nint count;\n\n/*\n * Concurrency control uses the classic two-condition algorithm\n * found in any textbook.\n */\n\n/** Main lock guarding all access */\nfinal ReentrantLock lock;\n\n/** Condition for waiting takes */\nprivate final Condition notEmpty;\n\n/** Condition for waiting puts */\nprivate final Condition notFull;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n从源码中可以看出ArrayBlockingQueue内部是采用数组进行数据存储的（items），为了保证线程安全，采用的是ReentrantLock lock，为了保证可阻塞式的插入删除数据利用的是Condition，当获取数据的消费者线程被阻塞时会将该线程放置到notEmpty等待队列中，当插入数据的生产者线程被阻塞时，会将该线程放置到notFull等待队列中。而notEmpty和notFull等中要属性在构造方法中进行创建：\n\npublic ArrayBlockingQueue(int capacity, boolean fair) {\n    if (capacity <= 0)\n        throw new IllegalArgumentException();\n    this.items = new Object[capacity];\n    lock = new ReentrantLock(fair);\n    notEmpty = lock.newCondition();\n    notFull =  lock.newCondition();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n接下来，主要看看可阻塞式的put和take方法是怎样实现的。\n\n\n# 4.4 put方法详解\n\nput(E e)方法源码如下：\n\npublic void put(E e) throws InterruptedException {\n    checkNotNull(e);\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n\t\t//如果当前队列已满，将线程移入到notFull等待队列中\n        while (count == items.length)\n            notFull.await();\n\t\t//满足插入数据的要求，直接进行入队操作\n        enqueue(e);\n    } finally {\n        lock.unlock();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n该方法的逻辑很简单，当队列已满时（count == items.length）将线程移入到notFull等待队列中，如果当前满足插入数据的条件，就可以直接调用enqueue(e)插入数据元素。enqueue方法源码为：\n\nprivate void enqueue(E x) {\n    // assert lock.getHoldCount() == 1;\n    // assert items[putIndex] == null;\n    final Object[] items = this.items;\n\t//插入数据\n    items[putIndex] = x;\n    if (++putIndex == items.length)\n        putIndex = 0;\n    count++;\n\t//通知消费者线程，当前队列中有数据可供消费\n    notEmpty.signal();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nenqueue方法的逻辑同样也很简单，先完成插入数据，即往数组中添加数据（items[putIndex] = x），然后通知被阻塞的消费者线程，当前队列中有数据可供消费（notEmpty.signal()）。\n\n\n# 4.5 take方法详解\n\ntake方法源码如下：\n\npublic E take() throws InterruptedException {\n    final ReentrantLock lock = this.lock;\n    lock.lockInterruptibly();\n    try {\n\t\t//如果队列为空，没有数据，将消费者线程移入等待队列中\n        while (count == 0)\n            notEmpty.await();\n\t\t//获取数据\n        return dequeue();\n    } finally {\n        lock.unlock();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\ntake方法也主要做了两步：1. 如果当前队列为空的话，则将获取数据的消费者线程移入到等待队列中；2. 若队列不为空则获取数据，即完成出队操作dequeue。dequeue方法源码为：\n\nprivate E dequeue() {\n    // assert lock.getHoldCount() == 1;\n    // assert items[takeIndex] != null;\n    final Object[] items = this.items;\n    @SuppressWarnings("unchecked")\n\t//获取数据\n    E x = (E) items[takeIndex];\n    items[takeIndex] = null;\n    if (++takeIndex == items.length)\n        takeIndex = 0;\n    count--;\n    if (itrs != null)\n        itrs.elementDequeued();\n    //通知被阻塞的生产者线程\n\tnotFull.signal();\n    return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\ndequeue方法也主要做了两件事情：1. 获取队列中的数据，即获取数组中的数据元素（(E) items[takeIndex]）；2. 通知notFull等待队列中的线程，使其由等待队列移入到同步队列中，使其能够有机会获得lock，并执行完成功退出。\n\n从以上分析，可以看出put和take方法主要是通过condition的通知机制来完成可阻塞式的插入数据和获取数据。在理解ArrayBlockingQueue后再去理解LinkedBlockingQueue就很容易了。\n\n\n# 5、LinkedBlockingQueue\n\nLinkedBlockingQueue是用链表实现的有界阻塞队列，当构造对象时为指定队列大小时，队列默认大小为Integer.MAX_VALUE。从它的构造方法可以看出：\n\npublic LinkedBlockingQueue() {\n    this(Integer.MAX_VALUE);\n}\n\n\n1\n2\n3\n\n\n\n# 5.1 LinkedBlockingQueue的主要属性\n\nLinkedBlockingQueue的主要属性有：\n\n/** Current number of elements */\nprivate final AtomicInteger count = new AtomicInteger();\n\n/**\n * Head of linked list.\n * Invariant: head.item == null\n */\ntransient Node<E> head;\n\n/**\n * Tail of linked list.\n * Invariant: last.next == null\n */\nprivate transient Node<E> last;\n\n/** Lock held by take, poll, etc */\nprivate final ReentrantLock takeLock = new ReentrantLock();\n\n/** Wait queue for waiting takes */\nprivate final Condition notEmpty = takeLock.newCondition();\n\n/** Lock held by put, offer, etc */\nprivate final ReentrantLock putLock = new ReentrantLock();\n\n/** Wait queue for waiting puts */\nprivate final Condition notFull = putLock.newCondition();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n可以看出与ArrayBlockingQueue主要的区别是，LinkedBlockingQueue在插入数据和删除数据时分别是由两个不同的lock（takeLock和putLock）来控制线程安全的，因此，也由这两个lock生成了两个对应的condition（notEmpty和notFull）来实现可阻塞的插入和删除数据。并且，采用了链表的数据结构来实现队列，Node结点的定义为：\n\nstatic class Node<E> {\n    E item;\n\n    /**\n     * One of:\n     * - the real successor Node\n     * - this Node, meaning the successor is head.next\n     * - null, meaning there is no successor (this is the last node)\n     */\n    Node<E> next;\n\n    Node(E x) { item = x; }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n接下来，我们也同样来看看put方法和take方法的实现。\n\n\n# 5.2 put方法详解\n\nput方法源码为:\n\npublic void put(E e) throws InterruptedException {\n    if (e == null) throw new NullPointerException();\n    // Note: convention in all put/take/etc is to preset local var\n    // holding count negative to indicate failure unless set.\n    int c = -1;\n    Node<E> node = new Node<E>(e);\n    final ReentrantLock putLock = this.putLock;\n    final AtomicInteger count = this.count;\n    putLock.lockInterruptibly();\n    try {\n        /*\n         * Note that count is used in wait guard even though it is\n         * not protected by lock. This works because count can\n         * only decrease at this point (all other puts are shut\n         * out by lock), and we (or some other waiting put) are\n         * signalled if it ever changes from capacity. Similarly\n         * for all other uses of count in other wait guards.\n         */\n\t\t//如果队列已满，则阻塞当前线程，将其移入等待队列\n        while (count.get() == capacity) {\n            notFull.await();\n        }\n\t\t//入队操作，插入数据\n        enqueue(node);\n        c = count.getAndIncrement();\n\t\t//若队列满足插入数据的条件，则通知被阻塞的生产者线程\n        if (c + 1 < capacity)\n            notFull.signal();\n    } finally {\n        putLock.unlock();\n    }\n    if (c == 0)\n        signalNotEmpty();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\nput方法的逻辑也同样很容易理解，可见注释。基本上和ArrayBlockingQueue的put方法一样。take方法的源码如下：\n\npublic E take() throws InterruptedException {\n    E x;\n    int c = -1;\n    final AtomicInteger count = this.count;\n    final ReentrantLock takeLock = this.takeLock;\n    takeLock.lockInterruptibly();\n    try {\n\t\t//当前队列为空，则阻塞当前线程，将其移入到等待队列中，直至满足条件\n        while (count.get() == 0) {\n            notEmpty.await();\n        }\n\t\t//移除队头元素，获取数据\n        x = dequeue();\n        c = count.getAndDecrement();\n        //如果当前满足移除元素的条件，则通知被阻塞的消费者线程\n\t\tif (c > 1)\n            notEmpty.signal();\n    } finally {\n        takeLock.unlock();\n    }\n    if (c == capacity)\n        signalNotFull();\n    return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\ntake方法的主要逻辑请见于注释，也很容易理解。\n\n\n# 6、两个阻塞队列的比较\n\n相同点：\n\nArrayBlockingQueue和LinkedBlockingQueue都是通过condition通知机制来实现可阻塞式插入和删除元素，并满足线程安全的特性；\n\n不同点：\n\n 1. ArrayBlockingQueue底层是采用的数组进行实现，而LinkedBlockingQueue则是采用链表数据结构；\n 2. ArrayBlockingQueue插入和删除数据，只采用了一个lock，而LinkedBlockingQueue则是在插入和删除分别采用了putLock和takeLock，这样可以降低线程由于线程无法获取到lock而进入WAITING状态的可能性，从而提高了线程并发执行的效率。\n\n> 参考文献\n\n《Java并发编程的艺术》',normalizedContent:'说明\n\n并发容器之blockingqueue\n\n\n\n * 1、blockingqueue简介\n * 2、基本操作\n * 3、常用的blockingqueue\n * 4、arrayblockingqueue\n   * 4.1 arrayblockingqueue简介\n   * 4.2 arrayblockingqueue实现原理\n   * 4.3 arrayblockingqueue的主要属性\n   * 4.4 put方法详解\n   * 4.5 take方法详解\n * 5、linkedblockingqueue\n   * 5.1 linkedblockingqueue的主要属性\n   * 5.2 put方法详解\n * 6、两个阻塞队列的比较\n\n\n\n\n# 并发容器之blockingqueue\n\n\n# 1、blockingqueue简介\n\n在实际编程中，会经常使用到jdk中collection集合框架中的各种容器类如实现list,map,queue接口的容器类，但是这些容器类基本上不是线程安全的，除了使用collections可以将其转换为线程安全的容器，doug lea大师为我们都准备了对应的线程安全的容器，如实现list接口的copyonwritearraylist，实现map接口的concurrenthashmap，实现queue接口的concurrentlinkedqueue。\n\n最常用的"生产者-消费者"问题中，队列通常被视作线程间操作的数据容器，这样，可以对各个模块的业务功能进行解耦，生产者将“生产”出来的数据放置在数据容器中，而消费者仅仅只需要在“数据容器”中进行获取数据即可，这样生产者线程和消费者线程就能够进行解耦，只专注于自己的业务功能即可。阻塞队列（blockingqueue）被广泛使用在“生产者-消费者”问题中，其原因是blockingqueue提供了可阻塞的插入和移除的方法。当队列容器已满，生产者线程会被阻塞，直到队列未满；当队列容器为空时，消费者线程会被阻塞，直至队列非空时为止。\n\n\n# 2、基本操作\n\n插入和移除操作的4种处理方式：\n\n\n\n * 抛出异常：当队列满时，如果再往队列里插入元素，会抛出illegalstateexception（"queue full"）异常。当队列空时，从队列里获取元素会抛出nosuchelementexception异常。\n * 返回特殊值：当往队列插入元素时，会返回元素是否插入成功，成功返回true。如果是移除方法，则是从队列里取出一个元素，如果没有则返回null。\n * 一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到队列可用或者响应中断退出。当队列空时，如果消费者线程从队列里take元素，队列会阻塞住消费者线程，直到队列不为空。\n * 超时退出：当阻塞队列满时，如果生产者线程往队列里插入元素，队列会阻塞生产者线程一段时间，如果超过了指定的时间，生产者线程就会退出。\n\n\n# 3、常用的blockingqueue\n\n实现blockingqueue接口的有arrayblockingqueue, delayqueue, linkedblockingdeque, linkedblockingqueue, linkedtransferqueue, priorityblockingqueue, synchronousqueue，而这几种常见的阻塞队列也是在实际编程中会常用的，下面对这几种常见的阻塞队列进行说明：\n\n> arrayblockingqueue\n\narrayblockingqueue是由数组实现的有界阻塞队列。该队列命令元素fifo（先进先出）。因此，队头元素是队列中存在时间最长的数据元素，而对尾数据则是当前队列最新的数据元素。arrayblockingqueue可作为“有界数据缓冲区”，生产者插入数据到队列容器中，并由消费者提取。arrayblockingqueue一旦创建，容量不能改变。\n\n当队列容量满时，尝试将元素放入队列将导致操作阻塞；尝试从一个空队列中取一个元素也会同样阻塞。\n\narrayblockingqueue默认情况下不能保证线程访问队列的公平性，所谓公平性是指严格按照线程等待的绝对时间顺序，即最先等待的线程能够最先访问到arrayblockingqueue。而非公平性则是指访问arrayblockingqueue的顺序不是遵守严格的时间顺序，有可能存在，一旦arrayblockingqueue可以被访问时，长时间阻塞的线程依然无法访问到arrayblockingqueue。如果保证公平性，通常会降低吞吐量。如果需要获得公平性的arrayblockingqueue，可采用如下代码：\n\nprivate static arrayblockingqueue<integer> blockingqueue = new arrayblockingqueue<integer>(10,true);\n\n\n1\n\n\n访问者的公平性是使用可重入锁实现的，代码如下：\n\npublic arrayblockingqueue(int capacity, boolean fair) {\n    if (capacity <= 0)\n        throw new illegalargumentexception();\n    this.items = new object[capacity];\n    lock = new reentrantlock(fair);\n    notempty = lock.newcondition();\n    notfull = lock.newcondition();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n关于arrayblockingqueue的实现原理，可以看这篇文章。\n\n> linkedblockingqueue\n\nlinkedblockingqueue是用链表实现的有界阻塞队列，同样满足fifo的特性，与arrayblockingqueue相比起来具有更高的吞吐量，为了防止linkedblockingqueue容量迅速增，损耗大量内存。通常在创建linkedblockingqueue对象时，会指定其大小，如果未指定，容量等于integer.max_value\n\n> priorityblockingqueue\n\npriorityblockingqueue是一个支持优先级的无界阻塞队列。默认情况下元素采用自然顺序进行排序，也可以通过自定义类实现compareto()方法来指定元素排序规则，或者初始化时通过构造器参数comparator来指定排序规则。\n\n> synchronousqueue\n\nsynchronousqueue每个插入操作必须等待另一个线程进行相应的删除操作，因此，synchronousqueue实际上没有存储任何数据元素，因为只有线程在删除数据时，其他线程才能插入数据，同样的，如果当前有线程在插入数据时，线程才能删除数据。synchronousqueue也可以通过构造器参数来为其指定公平性。\n\n> linkedtransferqueue\n\nlinkedtransferqueue是一个由链表数据结构构成的无界阻塞队列，由于该队列实现了transferqueue接口，与其他阻塞队列相比主要有以下不同的方法：\n\n * transfer(e e)：如果当前有线程（消费者）正在调用take()方法或者可延时的poll()方法进行消费数据时，生产者线程可以调用transfer方法将数据传递给消费者线程。如果当前没有消费者线程的话，生产者线程就会将数据插入到队尾，直到有消费者能够进行消费才能退出；\n * trytransfer(e e)：trytransfer方法如果当前有消费者线程（调用take方法或者具有超时特性的poll方法）正在消费数据的话，该方法可以将数据立即传送给消费者线程，如果当前没有消费者线程消费数据的话，就立即返回false。因此，与transfer方法相比，transfer方法是必须等到有消费者线程消费数据时，生产者线程才能够返回。而trytransfer方法能够立即返回结果退出。\n * trytransfer(e e,long timeout,imeunit unit)：与transfer基本功能一样，只是增加了超时特性，如果数据才规定的超时时间内没有消费者进行消费的话，就返回false。\n\n> linkedblockingdeque\n\nlinkedblockingdeque是基于链表数据结构的有界阻塞双端队列，如果在创建对象时为指定大小时，其默认大小为integer.max_value。与linkedblockingqueue相比，主要的不同点在于，linkedblockingdeque具有双端队列的特性。linkedblockingdeque基本操作如下图所示：\n\n\n\n如上图所示，linkedblockingdeque的基本操作可以分为四种类型：1.特殊情况，抛出异常；2.特殊情况，返回特殊值如null或者false；3.当线程不满足操作条件时，线程会被阻塞直至条件满足；4. 操作具有超时特性。\n\n另外，linkedblockingdeque实现了blockingdueue接口而linkedblockingqueue实现的是blockingqueue，这两个接口的主要区别如下图所示：\n\n\n\n从上图可以看出，两个接口的功能是可以等价使用的，比如blockingqueue的add方法和blockingdeque的addlast方法的功能是一样的。\n\n> delayqueue\n\ndelayqueue是一个存放实现delayed接口的数据的无界阻塞队列，只有当数据对象的延时时间达到时才能插入到队列进行存储。如果当前所有的数据都还没有达到创建时所指定的延时期，则队列没有队头，并且线程通过poll等方法获取数据元素则返回null。所谓数据延时期满时，则是通过delayed接口的getdelay(timeunit.nanoseconds)来进行判定，如果该方法返回的是小于等于0则说明该数据元素的延时期已满。\n\n\n# 4、arrayblockingqueue\n\n\n# 4.1 arrayblockingqueue简介\n\n在多线程编程过程中，为了业务解耦和架构设计，经常会使用并发容器用于存储多线程间的共享数据，这样不仅可以保证线程安全，还可以简化各个线程操作。例如在“生产者-消费者”问题中，会使用阻塞队列（blockingqueue）作为数据容器。为了加深对阻塞队列的理解，唯一的方式是对其实验原理进行理解，这篇文章就主要来看看arrayblockingqueue和linkedblockingqueue的实现原理。\n\n\n# 4.2 arrayblockingqueue实现原理\n\n阻塞队列最核心的功能是，能够可阻塞式的插入和删除队列元素。当前队列为空时，会阻塞消费数据的线程，直至队列非空时，通知被阻塞的线程；当队列满时，会阻塞插入数据的线程，直至队列未满时，通知插入数据的线程（生产者线程）。那么，多线程中消息通知机制最常用的是lock的condition机制，关于condition可以看前面文章的详细介绍。那么arrayblockingqueue的实现是不是也会采用condition的通知机制呢？下面来看看。\n\n\n# 4.3 arrayblockingqueue的主要属性\n\narrayblockingqueue的主要属性如下:\n\n/** the queued items */\nfinal object[] items;\n\n/** items index for next take, poll, peek or remove */\nint takeindex;\n\n/** items index for next put, offer, or add */\nint putindex;\n\n/** number of elements in the queue */\nint count;\n\n/*\n * concurrency control uses the classic two-condition algorithm\n * found in any textbook.\n */\n\n/** main lock guarding all access */\nfinal reentrantlock lock;\n\n/** condition for waiting takes */\nprivate final condition notempty;\n\n/** condition for waiting puts */\nprivate final condition notfull;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n从源码中可以看出arrayblockingqueue内部是采用数组进行数据存储的（items），为了保证线程安全，采用的是reentrantlock lock，为了保证可阻塞式的插入删除数据利用的是condition，当获取数据的消费者线程被阻塞时会将该线程放置到notempty等待队列中，当插入数据的生产者线程被阻塞时，会将该线程放置到notfull等待队列中。而notempty和notfull等中要属性在构造方法中进行创建：\n\npublic arrayblockingqueue(int capacity, boolean fair) {\n    if (capacity <= 0)\n        throw new illegalargumentexception();\n    this.items = new object[capacity];\n    lock = new reentrantlock(fair);\n    notempty = lock.newcondition();\n    notfull =  lock.newcondition();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n接下来，主要看看可阻塞式的put和take方法是怎样实现的。\n\n\n# 4.4 put方法详解\n\nput(e e)方法源码如下：\n\npublic void put(e e) throws interruptedexception {\n    checknotnull(e);\n    final reentrantlock lock = this.lock;\n    lock.lockinterruptibly();\n    try {\n\t\t//如果当前队列已满，将线程移入到notfull等待队列中\n        while (count == items.length)\n            notfull.await();\n\t\t//满足插入数据的要求，直接进行入队操作\n        enqueue(e);\n    } finally {\n        lock.unlock();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n该方法的逻辑很简单，当队列已满时（count == items.length）将线程移入到notfull等待队列中，如果当前满足插入数据的条件，就可以直接调用enqueue(e)插入数据元素。enqueue方法源码为：\n\nprivate void enqueue(e x) {\n    // assert lock.getholdcount() == 1;\n    // assert items[putindex] == null;\n    final object[] items = this.items;\n\t//插入数据\n    items[putindex] = x;\n    if (++putindex == items.length)\n        putindex = 0;\n    count++;\n\t//通知消费者线程，当前队列中有数据可供消费\n    notempty.signal();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nenqueue方法的逻辑同样也很简单，先完成插入数据，即往数组中添加数据（items[putindex] = x），然后通知被阻塞的消费者线程，当前队列中有数据可供消费（notempty.signal()）。\n\n\n# 4.5 take方法详解\n\ntake方法源码如下：\n\npublic e take() throws interruptedexception {\n    final reentrantlock lock = this.lock;\n    lock.lockinterruptibly();\n    try {\n\t\t//如果队列为空，没有数据，将消费者线程移入等待队列中\n        while (count == 0)\n            notempty.await();\n\t\t//获取数据\n        return dequeue();\n    } finally {\n        lock.unlock();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\ntake方法也主要做了两步：1. 如果当前队列为空的话，则将获取数据的消费者线程移入到等待队列中；2. 若队列不为空则获取数据，即完成出队操作dequeue。dequeue方法源码为：\n\nprivate e dequeue() {\n    // assert lock.getholdcount() == 1;\n    // assert items[takeindex] != null;\n    final object[] items = this.items;\n    @suppresswarnings("unchecked")\n\t//获取数据\n    e x = (e) items[takeindex];\n    items[takeindex] = null;\n    if (++takeindex == items.length)\n        takeindex = 0;\n    count--;\n    if (itrs != null)\n        itrs.elementdequeued();\n    //通知被阻塞的生产者线程\n\tnotfull.signal();\n    return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\ndequeue方法也主要做了两件事情：1. 获取队列中的数据，即获取数组中的数据元素（(e) items[takeindex]）；2. 通知notfull等待队列中的线程，使其由等待队列移入到同步队列中，使其能够有机会获得lock，并执行完成功退出。\n\n从以上分析，可以看出put和take方法主要是通过condition的通知机制来完成可阻塞式的插入数据和获取数据。在理解arrayblockingqueue后再去理解linkedblockingqueue就很容易了。\n\n\n# 5、linkedblockingqueue\n\nlinkedblockingqueue是用链表实现的有界阻塞队列，当构造对象时为指定队列大小时，队列默认大小为integer.max_value。从它的构造方法可以看出：\n\npublic linkedblockingqueue() {\n    this(integer.max_value);\n}\n\n\n1\n2\n3\n\n\n\n# 5.1 linkedblockingqueue的主要属性\n\nlinkedblockingqueue的主要属性有：\n\n/** current number of elements */\nprivate final atomicinteger count = new atomicinteger();\n\n/**\n * head of linked list.\n * invariant: head.item == null\n */\ntransient node<e> head;\n\n/**\n * tail of linked list.\n * invariant: last.next == null\n */\nprivate transient node<e> last;\n\n/** lock held by take, poll, etc */\nprivate final reentrantlock takelock = new reentrantlock();\n\n/** wait queue for waiting takes */\nprivate final condition notempty = takelock.newcondition();\n\n/** lock held by put, offer, etc */\nprivate final reentrantlock putlock = new reentrantlock();\n\n/** wait queue for waiting puts */\nprivate final condition notfull = putlock.newcondition();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n可以看出与arrayblockingqueue主要的区别是，linkedblockingqueue在插入数据和删除数据时分别是由两个不同的lock（takelock和putlock）来控制线程安全的，因此，也由这两个lock生成了两个对应的condition（notempty和notfull）来实现可阻塞的插入和删除数据。并且，采用了链表的数据结构来实现队列，node结点的定义为：\n\nstatic class node<e> {\n    e item;\n\n    /**\n     * one of:\n     * - the real successor node\n     * - this node, meaning the successor is head.next\n     * - null, meaning there is no successor (this is the last node)\n     */\n    node<e> next;\n\n    node(e x) { item = x; }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n接下来，我们也同样来看看put方法和take方法的实现。\n\n\n# 5.2 put方法详解\n\nput方法源码为:\n\npublic void put(e e) throws interruptedexception {\n    if (e == null) throw new nullpointerexception();\n    // note: convention in all put/take/etc is to preset local var\n    // holding count negative to indicate failure unless set.\n    int c = -1;\n    node<e> node = new node<e>(e);\n    final reentrantlock putlock = this.putlock;\n    final atomicinteger count = this.count;\n    putlock.lockinterruptibly();\n    try {\n        /*\n         * note that count is used in wait guard even though it is\n         * not protected by lock. this works because count can\n         * only decrease at this point (all other puts are shut\n         * out by lock), and we (or some other waiting put) are\n         * signalled if it ever changes from capacity. similarly\n         * for all other uses of count in other wait guards.\n         */\n\t\t//如果队列已满，则阻塞当前线程，将其移入等待队列\n        while (count.get() == capacity) {\n            notfull.await();\n        }\n\t\t//入队操作，插入数据\n        enqueue(node);\n        c = count.getandincrement();\n\t\t//若队列满足插入数据的条件，则通知被阻塞的生产者线程\n        if (c + 1 < capacity)\n            notfull.signal();\n    } finally {\n        putlock.unlock();\n    }\n    if (c == 0)\n        signalnotempty();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\nput方法的逻辑也同样很容易理解，可见注释。基本上和arrayblockingqueue的put方法一样。take方法的源码如下：\n\npublic e take() throws interruptedexception {\n    e x;\n    int c = -1;\n    final atomicinteger count = this.count;\n    final reentrantlock takelock = this.takelock;\n    takelock.lockinterruptibly();\n    try {\n\t\t//当前队列为空，则阻塞当前线程，将其移入到等待队列中，直至满足条件\n        while (count.get() == 0) {\n            notempty.await();\n        }\n\t\t//移除队头元素，获取数据\n        x = dequeue();\n        c = count.getanddecrement();\n        //如果当前满足移除元素的条件，则通知被阻塞的消费者线程\n\t\tif (c > 1)\n            notempty.signal();\n    } finally {\n        takelock.unlock();\n    }\n    if (c == capacity)\n        signalnotfull();\n    return x;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\ntake方法的主要逻辑请见于注释，也很容易理解。\n\n\n# 6、两个阻塞队列的比较\n\n相同点：\n\narrayblockingqueue和linkedblockingqueue都是通过condition通知机制来实现可阻塞式插入和删除元素，并满足线程安全的特性；\n\n不同点：\n\n 1. arrayblockingqueue底层是采用的数组进行实现，而linkedblockingqueue则是采用链表数据结构；\n 2. arrayblockingqueue插入和删除数据，只采用了一个lock，而linkedblockingqueue则是在插入和删除分别采用了putlock和takelock，这样可以降低线程由于线程无法获取到lock而进入waiting状态的可能性，从而提高了线程并发执行的效率。\n\n> 参考文献\n\n《java并发编程的艺术》',charsets:{cjk:!0},createdTime:1655628697e3},{title:"线程池ThreadPoolExecutor实现原理",frontmatter:{title:"线程池ThreadPoolExecutor实现原理",description:"线程池ThreadPoolExecutor实现原理",date:"2022-04-10T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/19%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html",relativePath:"Java/Java并发编程的艺术/19、线程池ThreadPoolExecutor实现原理.md",key:"v-54d6b646",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/19%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html",headers:[{level:2,title:"2.1 Executor框架的两级调度模型",slug:"_2-1-executor框架的两级调度模型",normalizedTitle:"2.1 executor框架的两级调度模型",charIndex:36},{level:2,title:"2.2 Executor框架的结构",slug:"_2-2-executor框架的结构",normalizedTitle:"2.2 executor框架的结构",charIndex:61}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>线程池ThreadPoolExecutor实现原理</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"2.1 Executor框架的两级调度模型 2.2 Executor框架的结构",content:"说明\n\n线程池ThreadPoolExecutor实现原理\n\n\n\n * 2.1 Executor框架的两级调度模型\n * 2.2 Executor框架的结构\n\n\n\n\n# 线程池ThreadPoolExecutor实现原理\n\n\n# 1、为什么要使用线程池\n\n在实际使用中，线程是很占用系统资源的，如果对线程管理不善很容易导致系统问题。因此，在大多数并发框架中都会使用线程池来管理线程，使用线程池管理线程主要有如下好处：\n\n * 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n * 第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n * 第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。\n\n\n# 2、Executor框架简介\n\n\n# 2.1 Executor框架的两级调度模型\n\n在HotSpot VM的线程模型中，Java线程（java.lang.Thread）被一对一映射为本地操作系统线程。Java线程启动时会创建一个本地操作系统线程；当该Java线程终止时，这个操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用的CPU。\n\n在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。这种两级调度模型的示意图如图所示：\n\n\n\n\n# 2.2 Executor框架的结构\n\nExecutor框架主要由3大部分组成如下。\n\n * 任务：包括被执行任务需要实现的接口：Runnable接口或Callable接口。\n * 任务的执行：包括任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口（ThreadPoolExecutor和ScheduledThreadPoolExecutor）。\n * 异步计算的结果：包括接口Future和实现Future接口的FutureTask类。\n\n\n\n下面是这些类和接口的简介：\n\n * Executor是一个接口，它是Executor框架的基础，它将任务的提交与任务的执行分离开来。\n * ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务。\n * ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。ScheduledThreadPoolExecutor比Timer更灵活，功能更强大。\n * Future接口和实现Future接口的FutureTask类，代表异步计算的结果。\n * Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行。\n\n\n\n主线程首先要创建实现Runnable或者Callable接口的任务对象。工具类Executors可以把一个Runnable对象封装为一个Callable对象（Executors.callable（Runnable task）或Executors.callable（Runnable task，Object resule））。\n\n然后可以把Runnable对象直接交给ExecutorService执行（ExecutorService.execute（Runnable command））；或者也可以把Runnable对象或Callable对象提交给ExecutorService执行（ExecutorService.submit（Runnable task）或ExecutorService.submit(Callable<T> task)）。\n\n如果执行ExecutorService.submit（…），ExecutorService将返回一个实现Future接口的对象（到目前为止的JDK中，返回的是FutureTask对象）。由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService执行。\n\n最后，主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行FutureTask.cancel（boolean mayInterruptIfRunning）来取消此任务的执行。\n\n\n# 3、几个重要的字段\n\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nctl是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，这里可以看到，使用了Integer类型来保存，高3位保存runState，低29位保存workerCount。COUNT_BITS 就是29，CAPACITY就是1左移29位减1（29个1），这个常量表示workerCount的上限值，大约是5亿。\n\n下面再介绍下线程池的运行状态，线程池一共有五种状态, 分别是：\n\n 1. RUNNING ：能接受新提交的任务，并且也能处理阻塞队列中的任务；\n 2. SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）；\n 3. STOP：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态；\n 4. TIDYING：如果所有的任务都已终止了，workerCount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。\n 5. TERMINATED：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。 进入TERMINATED的条件如下：\n    * 线程池不是RUNNING状态；\n    * 线程池状态不是TIDYING状态或TERMINATED状态；\n    * 如果线程池状态是SHUTDOWN并且workerQueue为空；\n    * workerCount为0；\n    * 设置TIDYING状态成功。\n\n下图为线程池的状态转换过程：\n\n\n\n\n# 4、ctl相关方法\n\n这里还有几个对ctl进行计算的方法：\n\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; }\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }\n\n\n1\n2\n3\n\n * runStateOf：获取运行状态；\n * workerCountOf：获取活动线程数；\n * ctlOf：获取运行状态和活动线程数的值。\n\n\n# 5、ThreadPoolExecutor构造方法\n\n创建线程池主要是ThreadPoolExecutor类来完成，ThreadPoolExecutor的有许多重载的构造方法，通过参数最多的构造方法来理解创建线程池有哪些需要配置的参数。ThreadPoolExecutor的构造方法为：\n\nThreadPoolExecutor(int corePoolSize,\n                              int maximumPoolSize,\n                              long keepAliveTime,\n                              TimeUnit unit,\n                              BlockingQueue<Runnable> workQueue,\n                              ThreadFactory threadFactory,\n                              RejectedExecutionHandler handler)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n下面对参数进行说明：\n\n 1. corePoolSize：表示核心线程池的大小。当提交一个任务时，如果当前核心线程池的线程个数没有达到corePoolSize，则会创建新的线程来执行所提交的任务，即使当前核心线程池有空闲的线程。如果当前核心线程池的线程个数已经达到了corePoolSize，则不再重新创建线程。如果调用了prestartCoreThread()或者 prestartAllCoreThreads()，线程池创建的时候所有的核心线程都会被创建并且启动。\n 2. maximumPoolSize：表示线程池能创建线程的最大个数。如果当阻塞队列已满时，并且当前线程池线程个数没有超过maximumPoolSize的话，就会创建新的线程来执行任务。\n 3. keepAliveTime：空闲线程存活时间。如果当前线程池的线程个数已经超过了corePoolSize，并且线程空闲时间超过了keepAliveTime的话，就会将这些空闲线程销毁，这样可以尽可能降低系统资源消耗。\n 4. unit：时间单位。为keepAliveTime指定时间单位。\n 5. workQueue：阻塞队列。用于保存任务的阻塞队列，关于阻塞队列可以看上面的文章。可以使用ArrayBlockingQueue, LinkedBlockingQueue, SynchronousQueue, PriorityBlockingQueue。\n 6. threadFactory：创建线程的工程类。可以通过指定线程工厂为每个创建出来的线程设置更有意义的名字，如果出现并发问题，也方便查找问题原因。\n 7. handler：饱和策略。当线程池的阻塞队列已满和指定的线程都已经开启，说明当前线程池已经处于饱和状态了，那么就需要采用一种策略来处理这种情况。采用的策略有这几种：\n    1. AbortPolicy： 直接拒绝所提交的任务，并抛出RejectedExecutionException异常；\n    2. CallerRunsPolicy：只用调用者所在的线程来执行任务；\n    3. DiscardPolicy：不处理直接丢弃掉任务；\n    4. DiscardOldestPolicy：丢弃掉阻塞队列中存放时间最久的任务，执行当前任务。\n\n\n# 6、execute方法\n\nexecute()方法用来提交任务，代码如下：\n\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n    /*\n     * clt记录着runState和workerCount\n     */\n    int c = ctl.get();\n    /*\n     * workerCountOf方法取出低29位的值，表示当前活动的线程数；\n     * 如果当前活动线程数小于corePoolSize，则新建一个线程放入线程池中；\n     * 并把任务添加到该线程中。\n     */\n    if (workerCountOf(c) < corePoolSize) {\n        /*\n         * addWorker中的第二个参数表示限制添加线程的数量是根据corePoolSize来判断还是maximumPoolSize来判断；\n         * 如果为true，根据corePoolSize来判断；\n         * 如果为false，则根据maximumPoolSize来判断\n         */\n        if (addWorker(command, true))\n            return;\n        /*\n         * 如果添加失败，则重新获取ctl值\n         */\n        c = ctl.get();\n    }\n    /*\n     * 如果当前线程池是运行状态并且任务添加到队列成功\n     */\n    if (isRunning(c) && workQueue.offer(command)) {\n        // 重新获取ctl值\n        int recheck = ctl.get();\n        // 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workQueue中了，\n        // 这时需要移除该command\n        // 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回\n        if (! isRunning(recheck) && remove(command))\n            reject(command);\n        /*\n         * 获取线程池中的有效线程数，如果数量是0，则执行addWorker方法\n         * 这里传入的参数表示：\n         * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；\n         * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumPoolSize，添加线程时根据maximumPoolSize来判断；\n         * 如果判断workerCount大于0，则直接返回，在workQueue中新增的command会在将来的某个时刻被执行。\n         */\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    /*\n     * 如果执行到这里，有两种情况：\n     * 1. 线程池已经不是RUNNING状态；\n     * 2. 线程池是RUNNING状态，但workerCount >= corePoolSize并且workQueue已满。\n     * 这时，再次调用addWorker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumPoolSize；\n     * 如果失败则拒绝该任务\n     */\n    else if (!addWorker(command, false))\n        reject(command);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n简单来说，在执行execute()方法时如果状态一直是RUNNING时，的执行过程如下：\n\n 1. 如果workerCount < corePoolSize，则创建并启动一个线程来执行新提交的任务；\n 2. 如果workerCount >= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；\n 3. 如果workerCount >= corePoolSize && workerCount < maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；\n 4. 如果workerCount >= maximumPoolSize，并且线程池内的阻塞队列已满，则根据拒绝策略来处理该任务，默认的处理方式是直接抛异常。\n\n这里要注意一下addWorker(null, false);，也就是创建一个线程，但并没有传入任务，因为任务已经被添加到workQueue中了，所以worker在执行的时候，会直接从workQueue中获取任务。所以，在workerCountOf(recheck) == 0时执行addWorker(null, false);也是为了保证线程池在RUNNING状态下必须要有一个线程来执行任务。\n\nexecute方法执行流程如下：\n\n\n\n线程池的设计思想就是使用了核心线程池corePoolSize，阻塞队列workQueue和线程池maximumPoolSize，这样的缓存策略来处理任务，实际上这样的设计思想在需要框架中都会使用。\n\n\n# 7、addWorker方法\n\naddWorker方法的主要工作是在线程池中创建一个新的线程并执行，firstTask参数 用于指定新增的线程执行的第一个任务，core参数为true表示在新增线程时会判断当前活动线程数是否少于corePoolSize，false表示新增线程前需要判断当前活动线程数是否少于maximumPoolSize，代码如下：\n\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        // 获取运行状态\n        int rs = runStateOf(c);\n\n        /*\n         * 这个if判断\n         * 如果rs >= SHUTDOWN，则表示此时不再接收新任务；\n         * 接着判断以下3个条件，只要有1个不满足，则返回false：\n         * 1. rs == SHUTDOWN，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务\n         * 2. firsTask为空\n         * 3. 阻塞队列不为空\n         *\n         * 首先考虑rs == SHUTDOWN的情况\n         * 这种情况下不会接受新提交的任务，所以在firstTask不为空的时候会返回false；\n         * 然后，如果firstTask为空，并且workQueue也为空，则返回false，\n         * 因为队列中已经没有任务了，不需要再添加线程了\n         */\n        // Check if queue empty only if necessary.\n        if (rs >= SHUTDOWN &&\n            ! (rs == SHUTDOWN &&\n               firstTask == null &&\n               ! workQueue.isEmpty()))\n            return false;\n\n        for (;;) {\n            // 获取线程数\n            int wc = workerCountOf(c);\n            // 如果wc超过CAPACITY，也就是ctl的低29位的最大值（二进制是29个1），返回false；\n            // 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，\n            // 如果为false则根据maximumPoolSize来比较。\n            if (wc >= CAPACITY ||\n                wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            // 尝试增加workerCount，如果成功，则跳出第一个for循环\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            // 如果增加workerCount失败，则重新获取ctl的值\n            c = ctl.get();  // Re-read ctl\n            // 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行\n            if (runStateOf(c) != rs)\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n\n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        // 根据firstTask来创建Worker对象\n        w = new Worker(firstTask);\n        // 每一个Worker对象都会创建一个线程\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                // Recheck while holding lock.\n                // Back out on ThreadFactory failure or if\n                // shut down before lock acquired.\n                int rs = runStateOf(ctl.get());\n                // rs < SHUTDOWN表示是RUNNING状态；\n                // 如果rs是RUNNING状态或者rs是SHUTDOWN状态并且firstTask为null，向线程池中添加线程。\n                // 因为在SHUTDOWN时不会在添加新的任务，但还是会执行workQueue中的任务\n                if (rs < SHUTDOWN ||\n                    (rs == SHUTDOWN && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    // workers是一个HashSet\n                    workers.add(w);\n                    int s = workers.size();\n                    // largestPoolSize记录着线程池中出现过的最大线程数量\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                // 启动线程\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n注意一下这里的t.start()这个语句，启动时会调用Worker类中的run方法，Worker本身实现了Runnable接口，所以一个Worker类型的对象也是一个线程。\n\n\n# 8、Worker类\n\n线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象，看一下Worker的定义：\n\nprivate final class Worker\n        extends AbstractQueuedSynchronizer\n        implements Runnable\n{\n    /**\n     * This class will never be serialized, but we provide a\n     * serialVersionUID to suppress a javac warning.\n     */\n    private static final long serialVersionUID = 6138294804551838833L;\n\n    /** Thread this worker is running in.  Null if factory fails. */\n    final Thread thread;\n    /** Initial task to run.  Possibly null. */\n    Runnable firstTask;\n    /** Per-thread task counter */\n    volatile long completedTasks;\n\n    /**\n     * Creates with given first task and thread from ThreadFactory.\n     * @param firstTask the first task (null if none)\n     */\n    Worker(Runnable firstTask) {\n        setState(-1); // inhibit interrupts until runWorker\n        this.firstTask = firstTask;\n        this.thread = getThreadFactory().newThread(this);\n    }\n\n    /** Delegates main run loop to outer runWorker  */\n    public void run() {\n        runWorker(this);\n    }\n\n    // Lock methods\n    //\n    // The value 0 represents the unlocked state.\n    // The value 1 represents the locked state.\n\n    protected boolean isHeldExclusively() {\n        return getState() != 0;\n    }\n\n    protected boolean tryAcquire(int unused) {\n        if (compareAndSetState(0, 1)) {\n            setExclusiveOwnerThread(Thread.currentThread());\n            return true;\n        }\n        return false;\n    }\n\n    protected boolean tryRelease(int unused) {\n        setExclusiveOwnerThread(null);\n        setState(0);\n        return true;\n    }\n\n    public void lock()        { acquire(1); }\n    public boolean tryLock()  { return tryAcquire(1); }\n    public void unlock()      { release(1); }\n    public boolean isLocked() { return isHeldExclusively(); }\n\n    void interruptIfStarted() {\n        Thread t;\n        if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {\n            try {\n                t.interrupt();\n            } catch (SecurityException ignore) {\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\nWorker类继承了AQS，并实现了Runnable接口，注意其中的firstTask和thread属性：firstTask用它来保存传入的任务；thread是在调用构造方法时通过ThreadFactory来创建的线程，是用来处理任务的线程。\n\n在调用构造方法时，需要把任务传入，这里通过getThreadFactory().newThread(this);来新建一个线程，newThread方法传入的参数是this，因为Worker本身继承了Runnable接口，也就是一个线程，所以一个Worker对象在启动的时候会调用Worker类中的run方法。\n\nWorker继承了AQS，使用AQS来实现独占锁的功能。为什么不使用ReentrantLock来实现呢？可以看到tryAcquire方法，它是不允许重入的，而ReentrantLock是允许重入的：\n\n 1. lock方法一旦获取了独占锁，表示当前线程正在执行任务中；\n 2. 如果正在执行任务，则不应该中断线程；\n 3. 如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；\n 4. 线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；\n 5. 之所以设置为不可重入，是因为我们不希望任务在调用像setCorePoolSize这样的线程池控制方法时重新获取锁。如果使用ReentrantLock，它是可重入的，这样如果在任务中调用了如setCorePoolSize这类线程池控制的方法，会中断正在运行的线程。\n\n所以，Worker继承自AQS，用于判断线程是否空闲以及是否可以被中断。\n\n此外，在构造方法中执行了setState(-1);，把state变量设置为-1，为什么这么做呢？是因为AQS中默认的state是0，如果刚创建了一个Worker对象，还没有执行任务时，这时就不应该被中断，看一下tryAquire方法：\n\nprotected boolean tryAcquire(int unused) {\n    if (compareAndSetState(0, 1)) {\n        setExclusiveOwnerThread(Thread.currentThread());\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ntryAcquire方法是根据state是否是0来判断的，所以，setState(-1);将state设置为-1是为了禁止在执行任务前对线程进行中断。\n\n正因为如此，在runWorker方法中会先调用Worker对象的unlock方法将state设置为0。\n\n\n# 9、runWorker方法\n\n在Worker类中的run方法调用了ThreadPoolExecutor的runWorker方法来执行任务，runWorker方法的代码如下：\n\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    // 获取第一个任务\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    // 允许中断\n    w.unlock(); // allow interrupts\n    // 是否因为异常退出循环\n    boolean completedAbruptly = true;\n    try {\n        // 如果task为空，则通过getTask来获取任务\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n            // If pool is stopping, ensure thread is interrupted;\n            // if not, ensure thread is not interrupted.  This\n            // requires a recheck in second case to deal with\n            // shutdownNow race while clearing interrupt\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    task.run();\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n这里说明一下第一个if判断，目的是：\n\n * 如果线程池正在停止，那么要保证当前线程是中断状态；\n * 如果不是的话，则要保证当前线程不是中断状态；\n\n这里要考虑在执行该if语句期间可能也执行了shutdownNow方法，shutdownNow方法会把状态设置为STOP，回顾一下STOP状态：\n\n> 不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态。\n\nSTOP状态要中断线程池中的所有线程，而这里使用Thread.interrupted()来判断是否中断是为了确保在RUNNING或者SHUTDOWN状态时线程是非中断状态的，因为Thread.interrupted()方法会复位中断的状态。\n\n总结一下runWorker方法的执行过程：\n\n 1. while循环不断地通过getTask()方法获取任务；\n 2. getTask()方法从阻塞队列中取任务；\n 3. 如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态；\n 4. 调用task.run()执行任务；\n 5. 如果task为null则跳出循环，执行processWorkerExit()方法；\n 6. runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。\n\n这里的beforeExecute方法和afterExecute方法在ThreadPoolExecutor类中是空的，留给子类来实现。\n\ncompletedAbruptly变量来表示在执行任务过程中是否出现了异常，在processWorkerExit方法中会对该变量的值进行判断。\n\n\n# 10、getTask方法\n\ngetTask方法用来从阻塞队列中取任务，代码如下：\n\nprivate Runnable getTask() {\n    // timeOut变量的值表示上次从阻塞队列中取任务时是否超时\n    boolean timedOut = false; // Did the last poll() time out?\n\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        /*\n         * 如果线程池状态rs >= SHUTDOWN，也就是非RUNNING状态，再进行以下判断：\n         * 1. rs >= STOP，线程池是否正在stop；\n         * 2. 阻塞队列是否为空。\n         * 如果以上条件满足，则将workerCount减1并返回null。\n         * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。\n         */\n        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n            decrementWorkerCount();\n            return null;\n        }\n\n        int wc = workerCountOf(c);\n\n        // Are workers subject to culling?\n        // timed变量用于判断是否需要进行超时控制。\n        // allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超时；\n        // wc > corePoolSize，表示当前线程池中的线程数量大于核心线程数量；\n        // 对于超过核心线程数量的这些线程，需要进行超时控制\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n        /*\n         * wc > maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法；\n         * timed && timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时\n         * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1；\n         * 如果减1失败，则返回重试。\n         * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。\n         */\n        if ((wc > maximumPoolSize || (timed && timedOut))\n            && (wc > 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n\n        try {\n            /*\n             * 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null；\n             * 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。\n             *\n             */\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            // 如果 r == null，说明已经超时，timedOut设置为true\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            // 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试\n            timedOut = false;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n这里重要的地方是第二个if判断，目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize且小于maximumPoolSize，并且workQueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。\n\n什么时候会销毁？当然是runWorker方法执行完之后，也就是Worker中的run方法执行完，由JVM自动回收。\n\ngetTask方法返回null时，在runWorker方法中会跳出while循环，然后会执行processWorkerExit方法。\n\n\n# 11、processWorkerExit方法\n\nprivate void processWorkerExit(Worker w, boolean completedAbruptly) {\n    // 如果completedAbruptly值为true，则说明线程执行时出现了异常，需要将workerCount减1；\n    // 如果线程执行时没有出现异常，说明在getTask()方法中已经已经对workerCount进行了减1操作，这里就不必再减了。\n    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted\n        decrementWorkerCount();\n\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        //统计完成的任务数\n        completedTaskCount += w.completedTasks;\n        // 从workers中移除，也就表示着从线程池中移除了一个工作线程\n        workers.remove(w);\n    } finally {\n        mainLock.unlock();\n    }\n\n    // 根据线程池状态进行判断是否结束线程池\n    tryTerminate();\n\n    int c = ctl.get();\n    /*\n     * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接addWorker；\n     * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个worker；\n     * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。\n     */\n    if (runStateLessThan(c, STOP)) {\n        if (!completedAbruptly) {\n            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n            if (min == 0 && ! workQueue.isEmpty())\n                min = 1;\n            if (workerCountOf(c) >= min)\n                return; // replacement not needed\n        }\n        addWorker(null, false);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n至此，processWorkerExit执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用ThreadFactory创建新的工作线程，runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入processWorkerExit方法，整个线程结束，如图所示：\n\n\n\n\n# 12、tryTerminate方法\n\ntryTerminate方法根据线程池状态进行判断是否结束线程池，代码如下：\n\nfinal void tryTerminate() {\n    for (;;) {\n        int c = ctl.get();\n        /*\n         * 当前线程池的状态为以下几种情况时，直接返回：\n         * 1. RUNNING，因为还在运行中，不能停止；\n         * 2. TIDYING或TERMINATED，因为线程池中已经没有正在运行的线程了；\n         * 3. SHUTDOWN并且等待队列非空，这时要执行完workQueue中的task；\n         */\n        if (isRunning(c) ||\n            runStateAtLeast(c, TIDYING) ||\n            (runStateOf(c) == SHUTDOWN && ! workQueue.isEmpty()))\n            return;\n        // 如果线程数量不为0，则中断一个空闲的工作线程，并返回\n        if (workerCountOf(c) != 0) { // Eligible to terminate\n            interruptIdleWorkers(ONLY_ONE);\n            return;\n        }\n\n        final ReentrantLock mainLock = this.mainLock;\n        mainLock.lock();\n        try {\n            // 这里尝试设置状态为TIDYING，如果设置成功，则调用terminated方法\n            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {\n                try {\n                    // terminated方法默认什么都不做，留给子类实现\n                    terminated();\n                } finally {\n                    // 设置状态为TERMINATED\n                    ctl.set(ctlOf(TERMINATED, 0));\n                    termination.signalAll();\n                }\n                return;\n            }\n        } finally {\n            mainLock.unlock();\n        }\n        // else retry on failed CAS\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\ninterruptIdleWorkers(ONLY_ONE);的作用是因为在getTask方法中执行workQueue.take()时，如果不执行中断会一直阻塞。在下面介绍的shutdown方法中，会中断所有空闲的工作线程，如果在执行shutdown时工作线程没有空闲，然后又去调用了getTask方法，这时如果workQueue中没有任务了，调用workQueue.take()时就会一直阻塞。所以每次在工作线程结束时调用tryTerminate方法来尝试中断一个空闲工作线程，避免在队列为空时取任务一直阻塞的情况。\n\n\n# 13、shutdown方法\n\n关闭线程池，可以通过shutdown和shutdownNow这两个方法。它们的原理都是遍历线程池中所有的线程，然后依次中断线程。shutdown和shutdownNow还是有不一样的地方：\n\n 1. shutdownNow首先将线程池的状态设置为STOP，然后尝试停止所有的正在执行和未执行任务的线程，并返回等待执行任务的列表；\n 2. shutdown只是将线程池的状态设置为SHUTDOWN状态，然后中断所有没有正在执行任务的线程\n\n可以看出shutdown方法会将正在执行的任务继续执行完，而shutdownNow会直接中断正在执行的任务。调用了这两个方法的任意一个，isShutdown方法都会返回true，当所有的线程都关闭成功，才表示线程池成功关闭，这时调用isTerminated方法才会返回true。\n\nshutdown方法要将线程池切换到SHUTDOWN状态，并调用interruptIdleWorkers方法请求中断所有空闲的worker，最后调用tryTerminate尝试结束线程池。\n\npublic void shutdown() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        // 安全策略判断\n        checkShutdownAccess();\n        // 切换状态为SHUTDOWN\n        advanceRunState(SHUTDOWN);\n        // 中断空闲线程\n        interruptIdleWorkers();\n        onShutdown(); // hook for ScheduledThreadPoolExecutor\n    } finally {\n        mainLock.unlock();\n    }\n    // 尝试结束线程池\n    tryTerminate();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这里思考一个问题：在runWorker方法中，执行任务时对Worker对象w进行了lock操作，为什么要在执行任务的时候对每个工作线程都加锁呢？\n\n下面仔细分析一下：\n\n * 在getTask方法中，如果这时线程池的状态是SHUTDOWN并且workQueue为空，那么就应该返回null来结束这个工作线程，而使线程池进入SHUTDOWN状态需要调用shutdown方法；\n * shutdown方法会调用interruptIdleWorkers来中断空闲的线程，interruptIdleWorkers持有mainLock，会遍历workers来逐个判断工作线程是否空闲。但getTask方法中没有mainLock；\n * 在getTask中，如果判断当前线程池状态是RUNNING，并且阻塞队列为空，那么会调用workQueue.take()进行阻塞；\n * 如果在判断当前线程池状态是RUNNING后，这时调用了shutdown方法把状态改为了SHUTDOWN，这时如果不进行中断，那么当前的工作线程在调用了workQueue.take()后会一直阻塞而不会被销毁，因为在SHUTDOWN状态下不允许再有新的任务添加到workQueue中，这样一来线程池永远都关闭不了了；\n * 由上可知，shutdown方法与getTask方法（从队列中获取任务时）存在竞态条件；\n * 解决这一问题就需要用到线程的中断，也就是为什么要用interruptIdleWorkers方法。在调用workQueue.take()时，如果发现当前线程在执行之前或者执行期间是中断状态，则会抛出InterruptedException，解除阻塞的状态；\n * 但是要中断工作线程，还要判断工作线程是否是空闲的，如果工作线程正在处理任务，就不应该发生中断；\n * 所以Worker继承自AQS，在工作线程处理任务时会进行lock，interruptIdleWorkers在进行中断时会使用tryLock来判断该工作线程是否正在处理任务，如果tryLock返回true，说明该工作线程当前未执行任务，这时才可以被中断。\n\n下面就来分析一下interruptIdleWorkers方法。\n\n\n# 14、interruptIdleWorkers方法\n\nprivate void interruptIdleWorkers() {\n    interruptIdleWorkers(false);\n}\n\nprivate void interruptIdleWorkers(boolean onlyOne) {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        for (Worker w : workers) {\n            Thread t = w.thread;\n            if (!t.isInterrupted() && w.tryLock()) {\n                try {\n                    t.interrupt();\n                } catch (SecurityException ignore) {\n                } finally {\n                    w.unlock();\n                }\n            }\n            if (onlyOne)\n                break;\n        }\n    } finally {\n        mainLock.unlock();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\ninterruptIdleWorkers遍历workers中所有的工作线程，若线程没有被中断tryLock成功，就中断该线程。\n\n为什么需要持有mainLock？因为workers是HashSet类型的，不能保证线程安全。\n\n\n# 15、shutdownNow方法\n\npublic List<Runnable> shutdownNow() {\n    List<Runnable> tasks;\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        advanceRunState(STOP);\n        // 中断所有工作线程，无论是否空闲\n        interruptWorkers();\n        // 取出队列中没有被执行的任务\n        tasks = drainQueue();\n    } finally {\n        mainLock.unlock();\n    }\n    tryTerminate();\n    return tasks;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nshutdownNow方法与shutdown方法类似，不同的地方在于：\n\n 1. 设置状态为STOP；\n 2. 中断所有工作线程，无论是否是空闲的；\n 3. 取出阻塞队列中没有被执行的任务并返回。\n\nshutdownNow方法执行完之后调用tryTerminate方法，该方法在上文已经分析过了，目的就是使线程池的状态设置为TERMINATED。\n\n\n# 16、线程池的监控\n\n通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用：\n\n * getTaskCount：线程池已经执行的和未执行的任务总数；\n * getCompletedTaskCount：线程池已完成的任务数量，该值小于等于taskCount；\n * getLargestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumPoolSize；\n * getPoolSize：线程池当前的线程数量；\n * getActiveCount：当前线程池中正在执行任务的线程数量。\n\n通过这些方法，可以对线程池进行监控，在ThreadPoolExecutor类中提供了几个空方法，如beforeExecute方法，afterExecute方法和terminated方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自ThreadPoolExecutor来进行扩展。\n\n\n# 17、如何合理配置线程池参数？\n\n要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：\n\n 1. 任务的性质：CPU密集型任务，IO密集型任务和混合型任务。\n 2. 任务的优先级：高，中和低。\n 3. 任务的执行时间：长，中和短。\n 4. 任务的依赖性：是否依赖其他系统资源，如数据库连接。\n\n任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能少的线程数量，如配置Ncpu+1个线程的线程池。IO密集型任务则由于需要等待IO操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2xNcpu。混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。\n\n优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。\n\n执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。\n\n依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。\n\n并且，阻塞队列最好是使用有界队列，如果采用无界队列的话，一旦任务积压在阻塞队列中的话就会占用过多的内存资源，甚至会使得系统崩溃。\n\n> 参考文献\n\n《Java并发编程的艺术》\n\n深入理解Java线程池：ThreadPoolExecutor",normalizedContent:"说明\n\n线程池threadpoolexecutor实现原理\n\n\n\n * 2.1 executor框架的两级调度模型\n * 2.2 executor框架的结构\n\n\n\n\n# 线程池threadpoolexecutor实现原理\n\n\n# 1、为什么要使用线程池\n\n在实际使用中，线程是很占用系统资源的，如果对线程管理不善很容易导致系统问题。因此，在大多数并发框架中都会使用线程池来管理线程，使用线程池管理线程主要有如下好处：\n\n * 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n * 第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。\n * 第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。\n\n\n# 2、executor框架简介\n\n\n# 2.1 executor框架的两级调度模型\n\n在hotspot vm的线程模型中，java线程（java.lang.thread）被一对一映射为本地操作系统线程。java线程启动时会创建一个本地操作系统线程；当该java线程终止时，这个操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用的cpu。\n\n在上层，java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。这种两级调度模型的示意图如图所示：\n\n\n\n\n# 2.2 executor框架的结构\n\nexecutor框架主要由3大部分组成如下。\n\n * 任务：包括被执行任务需要实现的接口：runnable接口或callable接口。\n * 任务的执行：包括任务执行机制的核心接口executor，以及继承自executor的executorservice接口。executor框架有两个关键类实现了executorservice接口（threadpoolexecutor和scheduledthreadpoolexecutor）。\n * 异步计算的结果：包括接口future和实现future接口的futuretask类。\n\n\n\n下面是这些类和接口的简介：\n\n * executor是一个接口，它是executor框架的基础，它将任务的提交与任务的执行分离开来。\n * threadpoolexecutor是线程池的核心实现类，用来执行被提交的任务。\n * scheduledthreadpoolexecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。scheduledthreadpoolexecutor比timer更灵活，功能更强大。\n * future接口和实现future接口的futuretask类，代表异步计算的结果。\n * runnable接口和callable接口的实现类，都可以被threadpoolexecutor或scheduledthreadpoolexecutor执行。\n\n\n\n主线程首先要创建实现runnable或者callable接口的任务对象。工具类executors可以把一个runnable对象封装为一个callable对象（executors.callable（runnable task）或executors.callable（runnable task，object resule））。\n\n然后可以把runnable对象直接交给executorservice执行（executorservice.execute（runnable command））；或者也可以把runnable对象或callable对象提交给executorservice执行（executorservice.submit（runnable task）或executorservice.submit(callable<t> task)）。\n\n如果执行executorservice.submit（…），executorservice将返回一个实现future接口的对象（到目前为止的jdk中，返回的是futuretask对象）。由于futuretask实现了runnable，程序员也可以创建futuretask，然后直接交给executorservice执行。\n\n最后，主线程可以执行futuretask.get()方法来等待任务执行完成。主线程也可以执行futuretask.cancel（boolean mayinterruptifrunning）来取消此任务的执行。\n\n\n# 3、几个重要的字段\n\nprivate final atomicinteger ctl = new atomicinteger(ctlof(running, 0));\nprivate static final int count_bits = integer.size - 3;\nprivate static final int capacity   = (1 << count_bits) - 1;\n\n// runstate is stored in the high-order bits\nprivate static final int running    = -1 << count_bits;\nprivate static final int shutdown   =  0 << count_bits;\nprivate static final int stop       =  1 << count_bits;\nprivate static final int tidying    =  2 << count_bits;\nprivate static final int terminated =  3 << count_bits;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nctl是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它包含两部分的信息：线程池的运行状态 (runstate) 和线程池内有效线程的数量 (workercount)，这里可以看到，使用了integer类型来保存，高3位保存runstate，低29位保存workercount。count_bits 就是29，capacity就是1左移29位减1（29个1），这个常量表示workercount的上限值，大约是5亿。\n\n下面再介绍下线程池的运行状态，线程池一共有五种状态, 分别是：\n\n 1. running ：能接受新提交的任务，并且也能处理阻塞队列中的任务；\n 2. shutdown：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 running 状态时，调用 shutdown()方法会使线程池进入到该状态。（finalize() 方法在执行过程中也会调用shutdown()方法进入该状态）；\n 3. stop：不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 running 或 shutdown 状态时，调用 shutdownnow() 方法会使线程池进入到该状态；\n 4. tidying：如果所有的任务都已终止了，workercount (有效线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入terminated 状态。\n 5. terminated：在terminated() 方法执行完后进入该状态，默认terminated()方法中什么也没有做。 进入terminated的条件如下：\n    * 线程池不是running状态；\n    * 线程池状态不是tidying状态或terminated状态；\n    * 如果线程池状态是shutdown并且workerqueue为空；\n    * workercount为0；\n    * 设置tidying状态成功。\n\n下图为线程池的状态转换过程：\n\n\n\n\n# 4、ctl相关方法\n\n这里还有几个对ctl进行计算的方法：\n\nprivate static int runstateof(int c)     { return c & ~capacity; }\nprivate static int workercountof(int c)  { return c & capacity; }\nprivate static int ctlof(int rs, int wc) { return rs | wc; }\n\n\n1\n2\n3\n\n * runstateof：获取运行状态；\n * workercountof：获取活动线程数；\n * ctlof：获取运行状态和活动线程数的值。\n\n\n# 5、threadpoolexecutor构造方法\n\n创建线程池主要是threadpoolexecutor类来完成，threadpoolexecutor的有许多重载的构造方法，通过参数最多的构造方法来理解创建线程池有哪些需要配置的参数。threadpoolexecutor的构造方法为：\n\nthreadpoolexecutor(int corepoolsize,\n                              int maximumpoolsize,\n                              long keepalivetime,\n                              timeunit unit,\n                              blockingqueue<runnable> workqueue,\n                              threadfactory threadfactory,\n                              rejectedexecutionhandler handler)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n下面对参数进行说明：\n\n 1. corepoolsize：表示核心线程池的大小。当提交一个任务时，如果当前核心线程池的线程个数没有达到corepoolsize，则会创建新的线程来执行所提交的任务，即使当前核心线程池有空闲的线程。如果当前核心线程池的线程个数已经达到了corepoolsize，则不再重新创建线程。如果调用了prestartcorethread()或者 prestartallcorethreads()，线程池创建的时候所有的核心线程都会被创建并且启动。\n 2. maximumpoolsize：表示线程池能创建线程的最大个数。如果当阻塞队列已满时，并且当前线程池线程个数没有超过maximumpoolsize的话，就会创建新的线程来执行任务。\n 3. keepalivetime：空闲线程存活时间。如果当前线程池的线程个数已经超过了corepoolsize，并且线程空闲时间超过了keepalivetime的话，就会将这些空闲线程销毁，这样可以尽可能降低系统资源消耗。\n 4. unit：时间单位。为keepalivetime指定时间单位。\n 5. workqueue：阻塞队列。用于保存任务的阻塞队列，关于阻塞队列可以看上面的文章。可以使用arrayblockingqueue, linkedblockingqueue, synchronousqueue, priorityblockingqueue。\n 6. threadfactory：创建线程的工程类。可以通过指定线程工厂为每个创建出来的线程设置更有意义的名字，如果出现并发问题，也方便查找问题原因。\n 7. handler：饱和策略。当线程池的阻塞队列已满和指定的线程都已经开启，说明当前线程池已经处于饱和状态了，那么就需要采用一种策略来处理这种情况。采用的策略有这几种：\n    1. abortpolicy： 直接拒绝所提交的任务，并抛出rejectedexecutionexception异常；\n    2. callerrunspolicy：只用调用者所在的线程来执行任务；\n    3. discardpolicy：不处理直接丢弃掉任务；\n    4. discardoldestpolicy：丢弃掉阻塞队列中存放时间最久的任务，执行当前任务。\n\n\n# 6、execute方法\n\nexecute()方法用来提交任务，代码如下：\n\npublic void execute(runnable command) {\n    if (command == null)\n        throw new nullpointerexception();\n    /*\n     * clt记录着runstate和workercount\n     */\n    int c = ctl.get();\n    /*\n     * workercountof方法取出低29位的值，表示当前活动的线程数；\n     * 如果当前活动线程数小于corepoolsize，则新建一个线程放入线程池中；\n     * 并把任务添加到该线程中。\n     */\n    if (workercountof(c) < corepoolsize) {\n        /*\n         * addworker中的第二个参数表示限制添加线程的数量是根据corepoolsize来判断还是maximumpoolsize来判断；\n         * 如果为true，根据corepoolsize来判断；\n         * 如果为false，则根据maximumpoolsize来判断\n         */\n        if (addworker(command, true))\n            return;\n        /*\n         * 如果添加失败，则重新获取ctl值\n         */\n        c = ctl.get();\n    }\n    /*\n     * 如果当前线程池是运行状态并且任务添加到队列成功\n     */\n    if (isrunning(c) && workqueue.offer(command)) {\n        // 重新获取ctl值\n        int recheck = ctl.get();\n        // 再次判断线程池的运行状态，如果不是运行状态，由于之前已经把command添加到workqueue中了，\n        // 这时需要移除该command\n        // 执行过后通过handler使用拒绝策略对该任务进行处理，整个方法返回\n        if (! isrunning(recheck) && remove(command))\n            reject(command);\n        /*\n         * 获取线程池中的有效线程数，如果数量是0，则执行addworker方法\n         * 这里传入的参数表示：\n         * 1. 第一个参数为null，表示在线程池中创建一个线程，但不去启动；\n         * 2. 第二个参数为false，将线程池的有限线程数量的上限设置为maximumpoolsize，添加线程时根据maximumpoolsize来判断；\n         * 如果判断workercount大于0，则直接返回，在workqueue中新增的command会在将来的某个时刻被执行。\n         */\n        else if (workercountof(recheck) == 0)\n            addworker(null, false);\n    }\n    /*\n     * 如果执行到这里，有两种情况：\n     * 1. 线程池已经不是running状态；\n     * 2. 线程池是running状态，但workercount >= corepoolsize并且workqueue已满。\n     * 这时，再次调用addworker方法，但第二个参数传入为false，将线程池的有限线程数量的上限设置为maximumpoolsize；\n     * 如果失败则拒绝该任务\n     */\n    else if (!addworker(command, false))\n        reject(command);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n简单来说，在执行execute()方法时如果状态一直是running时，的执行过程如下：\n\n 1. 如果workercount < corepoolsize，则创建并启动一个线程来执行新提交的任务；\n 2. 如果workercount >= corepoolsize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中；\n 3. 如果workercount >= corepoolsize && workercount < maximumpoolsize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务；\n 4. 如果workercount >= maximumpoolsize，并且线程池内的阻塞队列已满，则根据拒绝策略来处理该任务，默认的处理方式是直接抛异常。\n\n这里要注意一下addworker(null, false);，也就是创建一个线程，但并没有传入任务，因为任务已经被添加到workqueue中了，所以worker在执行的时候，会直接从workqueue中获取任务。所以，在workercountof(recheck) == 0时执行addworker(null, false);也是为了保证线程池在running状态下必须要有一个线程来执行任务。\n\nexecute方法执行流程如下：\n\n\n\n线程池的设计思想就是使用了核心线程池corepoolsize，阻塞队列workqueue和线程池maximumpoolsize，这样的缓存策略来处理任务，实际上这样的设计思想在需要框架中都会使用。\n\n\n# 7、addworker方法\n\naddworker方法的主要工作是在线程池中创建一个新的线程并执行，firsttask参数 用于指定新增的线程执行的第一个任务，core参数为true表示在新增线程时会判断当前活动线程数是否少于corepoolsize，false表示新增线程前需要判断当前活动线程数是否少于maximumpoolsize，代码如下：\n\nprivate boolean addworker(runnable firsttask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        // 获取运行状态\n        int rs = runstateof(c);\n\n        /*\n         * 这个if判断\n         * 如果rs >= shutdown，则表示此时不再接收新任务；\n         * 接着判断以下3个条件，只要有1个不满足，则返回false：\n         * 1. rs == shutdown，这时表示关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务\n         * 2. firstask为空\n         * 3. 阻塞队列不为空\n         *\n         * 首先考虑rs == shutdown的情况\n         * 这种情况下不会接受新提交的任务，所以在firsttask不为空的时候会返回false；\n         * 然后，如果firsttask为空，并且workqueue也为空，则返回false，\n         * 因为队列中已经没有任务了，不需要再添加线程了\n         */\n        // check if queue empty only if necessary.\n        if (rs >= shutdown &&\n            ! (rs == shutdown &&\n               firsttask == null &&\n               ! workqueue.isempty()))\n            return false;\n\n        for (;;) {\n            // 获取线程数\n            int wc = workercountof(c);\n            // 如果wc超过capacity，也就是ctl的低29位的最大值（二进制是29个1），返回false；\n            // 这里的core是addworker方法的第二个参数，如果为true表示根据corepoolsize来比较，\n            // 如果为false则根据maximumpoolsize来比较。\n            if (wc >= capacity ||\n                wc >= (core ? corepoolsize : maximumpoolsize))\n                return false;\n            // 尝试增加workercount，如果成功，则跳出第一个for循环\n            if (compareandincrementworkercount(c))\n                break retry;\n            // 如果增加workercount失败，则重新获取ctl的值\n            c = ctl.get();  // re-read ctl\n            // 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环继续执行\n            if (runstateof(c) != rs)\n                continue retry;\n            // else cas failed due to workercount change; retry inner loop\n        }\n    }\n\n    boolean workerstarted = false;\n    boolean workeradded = false;\n    worker w = null;\n    try {\n        // 根据firsttask来创建worker对象\n        w = new worker(firsttask);\n        // 每一个worker对象都会创建一个线程\n        final thread t = w.thread;\n        if (t != null) {\n            final reentrantlock mainlock = this.mainlock;\n            mainlock.lock();\n            try {\n                // recheck while holding lock.\n                // back out on threadfactory failure or if\n                // shut down before lock acquired.\n                int rs = runstateof(ctl.get());\n                // rs < shutdown表示是running状态；\n                // 如果rs是running状态或者rs是shutdown状态并且firsttask为null，向线程池中添加线程。\n                // 因为在shutdown时不会在添加新的任务，但还是会执行workqueue中的任务\n                if (rs < shutdown ||\n                    (rs == shutdown && firsttask == null)) {\n                    if (t.isalive()) // precheck that t is startable\n                        throw new illegalthreadstateexception();\n                    // workers是一个hashset\n                    workers.add(w);\n                    int s = workers.size();\n                    // largestpoolsize记录着线程池中出现过的最大线程数量\n                    if (s > largestpoolsize)\n                        largestpoolsize = s;\n                    workeradded = true;\n                }\n            } finally {\n                mainlock.unlock();\n            }\n            if (workeradded) {\n                // 启动线程\n                t.start();\n                workerstarted = true;\n            }\n        }\n    } finally {\n        if (! workerstarted)\n            addworkerfailed(w);\n    }\n    return workerstarted;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n\n\n注意一下这里的t.start()这个语句，启动时会调用worker类中的run方法，worker本身实现了runnable接口，所以一个worker类型的对象也是一个线程。\n\n\n# 8、worker类\n\n线程池中的每一个线程被封装成一个worker对象，threadpool维护的其实就是一组worker对象，看一下worker的定义：\n\nprivate final class worker\n        extends abstractqueuedsynchronizer\n        implements runnable\n{\n    /**\n     * this class will never be serialized, but we provide a\n     * serialversionuid to suppress a javac warning.\n     */\n    private static final long serialversionuid = 6138294804551838833l;\n\n    /** thread this worker is running in.  null if factory fails. */\n    final thread thread;\n    /** initial task to run.  possibly null. */\n    runnable firsttask;\n    /** per-thread task counter */\n    volatile long completedtasks;\n\n    /**\n     * creates with given first task and thread from threadfactory.\n     * @param firsttask the first task (null if none)\n     */\n    worker(runnable firsttask) {\n        setstate(-1); // inhibit interrupts until runworker\n        this.firsttask = firsttask;\n        this.thread = getthreadfactory().newthread(this);\n    }\n\n    /** delegates main run loop to outer runworker  */\n    public void run() {\n        runworker(this);\n    }\n\n    // lock methods\n    //\n    // the value 0 represents the unlocked state.\n    // the value 1 represents the locked state.\n\n    protected boolean isheldexclusively() {\n        return getstate() != 0;\n    }\n\n    protected boolean tryacquire(int unused) {\n        if (compareandsetstate(0, 1)) {\n            setexclusiveownerthread(thread.currentthread());\n            return true;\n        }\n        return false;\n    }\n\n    protected boolean tryrelease(int unused) {\n        setexclusiveownerthread(null);\n        setstate(0);\n        return true;\n    }\n\n    public void lock()        { acquire(1); }\n    public boolean trylock()  { return tryacquire(1); }\n    public void unlock()      { release(1); }\n    public boolean islocked() { return isheldexclusively(); }\n\n    void interruptifstarted() {\n        thread t;\n        if (getstate() >= 0 && (t = thread) != null && !t.isinterrupted()) {\n            try {\n                t.interrupt();\n            } catch (securityexception ignore) {\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\nworker类继承了aqs，并实现了runnable接口，注意其中的firsttask和thread属性：firsttask用它来保存传入的任务；thread是在调用构造方法时通过threadfactory来创建的线程，是用来处理任务的线程。\n\n在调用构造方法时，需要把任务传入，这里通过getthreadfactory().newthread(this);来新建一个线程，newthread方法传入的参数是this，因为worker本身继承了runnable接口，也就是一个线程，所以一个worker对象在启动的时候会调用worker类中的run方法。\n\nworker继承了aqs，使用aqs来实现独占锁的功能。为什么不使用reentrantlock来实现呢？可以看到tryacquire方法，它是不允许重入的，而reentrantlock是允许重入的：\n\n 1. lock方法一旦获取了独占锁，表示当前线程正在执行任务中；\n 2. 如果正在执行任务，则不应该中断线程；\n 3. 如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；\n 4. 线程池在执行shutdown方法或tryterminate方法时会调用interruptidleworkers方法来中断空闲的线程，interruptidleworkers方法会使用trylock方法来判断线程池中的线程是否是空闲状态；\n 5. 之所以设置为不可重入，是因为我们不希望任务在调用像setcorepoolsize这样的线程池控制方法时重新获取锁。如果使用reentrantlock，它是可重入的，这样如果在任务中调用了如setcorepoolsize这类线程池控制的方法，会中断正在运行的线程。\n\n所以，worker继承自aqs，用于判断线程是否空闲以及是否可以被中断。\n\n此外，在构造方法中执行了setstate(-1);，把state变量设置为-1，为什么这么做呢？是因为aqs中默认的state是0，如果刚创建了一个worker对象，还没有执行任务时，这时就不应该被中断，看一下tryaquire方法：\n\nprotected boolean tryacquire(int unused) {\n    if (compareandsetstate(0, 1)) {\n        setexclusiveownerthread(thread.currentthread());\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\ntryacquire方法是根据state是否是0来判断的，所以，setstate(-1);将state设置为-1是为了禁止在执行任务前对线程进行中断。\n\n正因为如此，在runworker方法中会先调用worker对象的unlock方法将state设置为0。\n\n\n# 9、runworker方法\n\n在worker类中的run方法调用了threadpoolexecutor的runworker方法来执行任务，runworker方法的代码如下：\n\nfinal void runworker(worker w) {\n    thread wt = thread.currentthread();\n    // 获取第一个任务\n    runnable task = w.firsttask;\n    w.firsttask = null;\n    // 允许中断\n    w.unlock(); // allow interrupts\n    // 是否因为异常退出循环\n    boolean completedabruptly = true;\n    try {\n        // 如果task为空，则通过gettask来获取任务\n        while (task != null || (task = gettask()) != null) {\n            w.lock();\n            // if pool is stopping, ensure thread is interrupted;\n            // if not, ensure thread is not interrupted.  this\n            // requires a recheck in second case to deal with\n            // shutdownnow race while clearing interrupt\n            if ((runstateatleast(ctl.get(), stop) ||\n                 (thread.interrupted() &&\n                  runstateatleast(ctl.get(), stop))) &&\n                !wt.isinterrupted())\n                wt.interrupt();\n            try {\n                beforeexecute(wt, task);\n                throwable thrown = null;\n                try {\n                    task.run();\n                } catch (runtimeexception x) {\n                    thrown = x; throw x;\n                } catch (error x) {\n                    thrown = x; throw x;\n                } catch (throwable x) {\n                    thrown = x; throw new error(x);\n                } finally {\n                    afterexecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedtasks++;\n                w.unlock();\n            }\n        }\n        completedabruptly = false;\n    } finally {\n        processworkerexit(w, completedabruptly);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n这里说明一下第一个if判断，目的是：\n\n * 如果线程池正在停止，那么要保证当前线程是中断状态；\n * 如果不是的话，则要保证当前线程不是中断状态；\n\n这里要考虑在执行该if语句期间可能也执行了shutdownnow方法，shutdownnow方法会把状态设置为stop，回顾一下stop状态：\n\n> 不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。在线程池处于 running 或 shutdown 状态时，调用 shutdownnow() 方法会使线程池进入到该状态。\n\nstop状态要中断线程池中的所有线程，而这里使用thread.interrupted()来判断是否中断是为了确保在running或者shutdown状态时线程是非中断状态的，因为thread.interrupted()方法会复位中断的状态。\n\n总结一下runworker方法的执行过程：\n\n 1. while循环不断地通过gettask()方法获取任务；\n 2. gettask()方法从阻塞队列中取任务；\n 3. 如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态；\n 4. 调用task.run()执行任务；\n 5. 如果task为null则跳出循环，执行processworkerexit()方法；\n 6. runworker方法执行完毕，也代表着worker中的run方法执行完毕，销毁线程。\n\n这里的beforeexecute方法和afterexecute方法在threadpoolexecutor类中是空的，留给子类来实现。\n\ncompletedabruptly变量来表示在执行任务过程中是否出现了异常，在processworkerexit方法中会对该变量的值进行判断。\n\n\n# 10、gettask方法\n\ngettask方法用来从阻塞队列中取任务，代码如下：\n\nprivate runnable gettask() {\n    // timeout变量的值表示上次从阻塞队列中取任务时是否超时\n    boolean timedout = false; // did the last poll() time out?\n\n    for (;;) {\n        int c = ctl.get();\n        int rs = runstateof(c);\n\n        // check if queue empty only if necessary.\n        /*\n         * 如果线程池状态rs >= shutdown，也就是非running状态，再进行以下判断：\n         * 1. rs >= stop，线程池是否正在stop；\n         * 2. 阻塞队列是否为空。\n         * 如果以上条件满足，则将workercount减1并返回null。\n         * 因为如果当前线程池状态的值是shutdown或以上时，不允许再向阻塞队列中添加任务。\n         */\n        if (rs >= shutdown && (rs >= stop || workqueue.isempty())) {\n            decrementworkercount();\n            return null;\n        }\n\n        int wc = workercountof(c);\n\n        // are workers subject to culling?\n        // timed变量用于判断是否需要进行超时控制。\n        // allowcorethreadtimeout默认是false，也就是核心线程不允许进行超时；\n        // wc > corepoolsize，表示当前线程池中的线程数量大于核心线程数量；\n        // 对于超过核心线程数量的这些线程，需要进行超时控制\n        boolean timed = allowcorethreadtimeout || wc > corepoolsize;\n\n        /*\n         * wc > maximumpoolsize的情况是因为可能在此方法执行阶段同时执行了setmaximumpoolsize方法；\n         * timed && timedout 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时\n         * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workercount减1；\n         * 如果减1失败，则返回重试。\n         * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。\n         */\n        if ((wc > maximumpoolsize || (timed && timedout))\n            && (wc > 1 || workqueue.isempty())) {\n            if (compareanddecrementworkercount(c))\n                return null;\n            continue;\n        }\n\n        try {\n            /*\n             * 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepalivetime时间内没有获取到任务，则返回null；\n             * 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。\n             *\n             */\n            runnable r = timed ?\n                workqueue.poll(keepalivetime, timeunit.nanoseconds) :\n                workqueue.take();\n            if (r != null)\n                return r;\n            // 如果 r == null，说明已经超时，timedout设置为true\n            timedout = true;\n        } catch (interruptedexception retry) {\n            // 如果获取任务时当前线程发生了中断，则设置timedout为false并返回循环重试\n            timedout = false;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n这里重要的地方是第二个if判断，目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corepoolsize且小于maximumpoolsize，并且workqueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedout为true的情况，说明workqueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corepoolsize数量的线程销毁掉，保持线程数量在corepoolsize即可。\n\n什么时候会销毁？当然是runworker方法执行完之后，也就是worker中的run方法执行完，由jvm自动回收。\n\ngettask方法返回null时，在runworker方法中会跳出while循环，然后会执行processworkerexit方法。\n\n\n# 11、processworkerexit方法\n\nprivate void processworkerexit(worker w, boolean completedabruptly) {\n    // 如果completedabruptly值为true，则说明线程执行时出现了异常，需要将workercount减1；\n    // 如果线程执行时没有出现异常，说明在gettask()方法中已经已经对workercount进行了减1操作，这里就不必再减了。\n    if (completedabruptly) // if abrupt, then workercount wasn't adjusted\n        decrementworkercount();\n\n    final reentrantlock mainlock = this.mainlock;\n    mainlock.lock();\n    try {\n        //统计完成的任务数\n        completedtaskcount += w.completedtasks;\n        // 从workers中移除，也就表示着从线程池中移除了一个工作线程\n        workers.remove(w);\n    } finally {\n        mainlock.unlock();\n    }\n\n    // 根据线程池状态进行判断是否结束线程池\n    tryterminate();\n\n    int c = ctl.get();\n    /*\n     * 当线程池是running或shutdown状态时，如果worker是异常结束，那么会直接addworker；\n     * 如果allowcorethreadtimeout=true，并且等待队列有任务，至少保留一个worker；\n     * 如果allowcorethreadtimeout=false，workercount不少于corepoolsize。\n     */\n    if (runstatelessthan(c, stop)) {\n        if (!completedabruptly) {\n            int min = allowcorethreadtimeout ? 0 : corepoolsize;\n            if (min == 0 && ! workqueue.isempty())\n                min = 1;\n            if (workercountof(c) >= min)\n                return; // replacement not needed\n        }\n        addworker(null, false);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n至此，processworkerexit执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，worker使用threadfactory创建新的工作线程，runworker通过gettask获取任务，然后执行任务，如果gettask返回null，进入processworkerexit方法，整个线程结束，如图所示：\n\n\n\n\n# 12、tryterminate方法\n\ntryterminate方法根据线程池状态进行判断是否结束线程池，代码如下：\n\nfinal void tryterminate() {\n    for (;;) {\n        int c = ctl.get();\n        /*\n         * 当前线程池的状态为以下几种情况时，直接返回：\n         * 1. running，因为还在运行中，不能停止；\n         * 2. tidying或terminated，因为线程池中已经没有正在运行的线程了；\n         * 3. shutdown并且等待队列非空，这时要执行完workqueue中的task；\n         */\n        if (isrunning(c) ||\n            runstateatleast(c, tidying) ||\n            (runstateof(c) == shutdown && ! workqueue.isempty()))\n            return;\n        // 如果线程数量不为0，则中断一个空闲的工作线程，并返回\n        if (workercountof(c) != 0) { // eligible to terminate\n            interruptidleworkers(only_one);\n            return;\n        }\n\n        final reentrantlock mainlock = this.mainlock;\n        mainlock.lock();\n        try {\n            // 这里尝试设置状态为tidying，如果设置成功，则调用terminated方法\n            if (ctl.compareandset(c, ctlof(tidying, 0))) {\n                try {\n                    // terminated方法默认什么都不做，留给子类实现\n                    terminated();\n                } finally {\n                    // 设置状态为terminated\n                    ctl.set(ctlof(terminated, 0));\n                    termination.signalall();\n                }\n                return;\n            }\n        } finally {\n            mainlock.unlock();\n        }\n        // else retry on failed cas\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\ninterruptidleworkers(only_one);的作用是因为在gettask方法中执行workqueue.take()时，如果不执行中断会一直阻塞。在下面介绍的shutdown方法中，会中断所有空闲的工作线程，如果在执行shutdown时工作线程没有空闲，然后又去调用了gettask方法，这时如果workqueue中没有任务了，调用workqueue.take()时就会一直阻塞。所以每次在工作线程结束时调用tryterminate方法来尝试中断一个空闲工作线程，避免在队列为空时取任务一直阻塞的情况。\n\n\n# 13、shutdown方法\n\n关闭线程池，可以通过shutdown和shutdownnow这两个方法。它们的原理都是遍历线程池中所有的线程，然后依次中断线程。shutdown和shutdownnow还是有不一样的地方：\n\n 1. shutdownnow首先将线程池的状态设置为stop，然后尝试停止所有的正在执行和未执行任务的线程，并返回等待执行任务的列表；\n 2. shutdown只是将线程池的状态设置为shutdown状态，然后中断所有没有正在执行任务的线程\n\n可以看出shutdown方法会将正在执行的任务继续执行完，而shutdownnow会直接中断正在执行的任务。调用了这两个方法的任意一个，isshutdown方法都会返回true，当所有的线程都关闭成功，才表示线程池成功关闭，这时调用isterminated方法才会返回true。\n\nshutdown方法要将线程池切换到shutdown状态，并调用interruptidleworkers方法请求中断所有空闲的worker，最后调用tryterminate尝试结束线程池。\n\npublic void shutdown() {\n    final reentrantlock mainlock = this.mainlock;\n    mainlock.lock();\n    try {\n        // 安全策略判断\n        checkshutdownaccess();\n        // 切换状态为shutdown\n        advancerunstate(shutdown);\n        // 中断空闲线程\n        interruptidleworkers();\n        onshutdown(); // hook for scheduledthreadpoolexecutor\n    } finally {\n        mainlock.unlock();\n    }\n    // 尝试结束线程池\n    tryterminate();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n这里思考一个问题：在runworker方法中，执行任务时对worker对象w进行了lock操作，为什么要在执行任务的时候对每个工作线程都加锁呢？\n\n下面仔细分析一下：\n\n * 在gettask方法中，如果这时线程池的状态是shutdown并且workqueue为空，那么就应该返回null来结束这个工作线程，而使线程池进入shutdown状态需要调用shutdown方法；\n * shutdown方法会调用interruptidleworkers来中断空闲的线程，interruptidleworkers持有mainlock，会遍历workers来逐个判断工作线程是否空闲。但gettask方法中没有mainlock；\n * 在gettask中，如果判断当前线程池状态是running，并且阻塞队列为空，那么会调用workqueue.take()进行阻塞；\n * 如果在判断当前线程池状态是running后，这时调用了shutdown方法把状态改为了shutdown，这时如果不进行中断，那么当前的工作线程在调用了workqueue.take()后会一直阻塞而不会被销毁，因为在shutdown状态下不允许再有新的任务添加到workqueue中，这样一来线程池永远都关闭不了了；\n * 由上可知，shutdown方法与gettask方法（从队列中获取任务时）存在竞态条件；\n * 解决这一问题就需要用到线程的中断，也就是为什么要用interruptidleworkers方法。在调用workqueue.take()时，如果发现当前线程在执行之前或者执行期间是中断状态，则会抛出interruptedexception，解除阻塞的状态；\n * 但是要中断工作线程，还要判断工作线程是否是空闲的，如果工作线程正在处理任务，就不应该发生中断；\n * 所以worker继承自aqs，在工作线程处理任务时会进行lock，interruptidleworkers在进行中断时会使用trylock来判断该工作线程是否正在处理任务，如果trylock返回true，说明该工作线程当前未执行任务，这时才可以被中断。\n\n下面就来分析一下interruptidleworkers方法。\n\n\n# 14、interruptidleworkers方法\n\nprivate void interruptidleworkers() {\n    interruptidleworkers(false);\n}\n\nprivate void interruptidleworkers(boolean onlyone) {\n    final reentrantlock mainlock = this.mainlock;\n    mainlock.lock();\n    try {\n        for (worker w : workers) {\n            thread t = w.thread;\n            if (!t.isinterrupted() && w.trylock()) {\n                try {\n                    t.interrupt();\n                } catch (securityexception ignore) {\n                } finally {\n                    w.unlock();\n                }\n            }\n            if (onlyone)\n                break;\n        }\n    } finally {\n        mainlock.unlock();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\ninterruptidleworkers遍历workers中所有的工作线程，若线程没有被中断trylock成功，就中断该线程。\n\n为什么需要持有mainlock？因为workers是hashset类型的，不能保证线程安全。\n\n\n# 15、shutdownnow方法\n\npublic list<runnable> shutdownnow() {\n    list<runnable> tasks;\n    final reentrantlock mainlock = this.mainlock;\n    mainlock.lock();\n    try {\n        checkshutdownaccess();\n        advancerunstate(stop);\n        // 中断所有工作线程，无论是否空闲\n        interruptworkers();\n        // 取出队列中没有被执行的任务\n        tasks = drainqueue();\n    } finally {\n        mainlock.unlock();\n    }\n    tryterminate();\n    return tasks;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nshutdownnow方法与shutdown方法类似，不同的地方在于：\n\n 1. 设置状态为stop；\n 2. 中断所有工作线程，无论是否是空闲的；\n 3. 取出阻塞队列中没有被执行的任务并返回。\n\nshutdownnow方法执行完之后调用tryterminate方法，该方法在上文已经分析过了，目的就是使线程池的状态设置为terminated。\n\n\n# 16、线程池的监控\n\n通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用：\n\n * gettaskcount：线程池已经执行的和未执行的任务总数；\n * getcompletedtaskcount：线程池已完成的任务数量，该值小于等于taskcount；\n * getlargestpoolsize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过，也就是达到了maximumpoolsize；\n * getpoolsize：线程池当前的线程数量；\n * getactivecount：当前线程池中正在执行任务的线程数量。\n\n通过这些方法，可以对线程池进行监控，在threadpoolexecutor类中提供了几个空方法，如beforeexecute方法，afterexecute方法和terminated方法，可以扩展这些方法在执行前或执行后增加一些新的操作，例如统计线程池的执行任务的时间等，可以继承自threadpoolexecutor来进行扩展。\n\n\n# 17、如何合理配置线程池参数？\n\n要想合理的配置线程池，就必须首先分析任务特性，可以从以下几个角度来进行分析：\n\n 1. 任务的性质：cpu密集型任务，io密集型任务和混合型任务。\n 2. 任务的优先级：高，中和低。\n 3. 任务的执行时间：长，中和短。\n 4. 任务的依赖性：是否依赖其他系统资源，如数据库连接。\n\n任务性质不同的任务可以用不同规模的线程池分开处理。cpu密集型任务配置尽可能少的线程数量，如配置ncpu+1个线程的线程池。io密集型任务则由于需要等待io操作，线程并不是一直在执行任务，则配置尽可能多的线程，如2xncpu。混合型的任务，如果可以拆分，则将其拆分成一个cpu密集型任务和一个io密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过runtime.getruntime().availableprocessors()方法获得当前设备的cpu个数。\n\n优先级不同的任务可以使用优先级队列priorityblockingqueue来处理。它可以让优先级高的任务先得到执行，需要注意的是如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。\n\n执行时间不同的任务可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。\n\n依赖数据库连接池的任务，因为线程提交sql后需要等待数据库返回结果，如果等待的时间越长cpu空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用cpu。\n\n并且，阻塞队列最好是使用有界队列，如果采用无界队列的话，一旦任务积压在阻塞队列中的话就会占用过多的内存资源，甚至会使得系统崩溃。\n\n> 参考文献\n\n《java并发编程的艺术》\n\n深入理解java线程池：threadpoolexecutor",charsets:{cjk:!0},createdTime:1655628697e3},{title:"Java中atomic包中的原子操作类总结",frontmatter:{title:"Java中atomic包中的原子操作类总结",description:"Java中atomic包中的原子操作类总结",date:"2022-04-13T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/22%E3%80%81Java%E4%B8%ADatomic%E5%8C%85%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%E6%80%BB%E7%BB%93.html",relativePath:"Java/Java并发编程的艺术/22、Java中atomic包中的原子操作类总结.md",key:"v-0de9a35d",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/22%E3%80%81Java%E4%B8%ADatomic%E5%8C%85%E4%B8%AD%E7%9A%84%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%E6%80%BB%E7%BB%93.html",excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>Java中atomic包中的原子操作类总结</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:null,content:"说明\n\nJava中atomic包中的原子操作类总结\n\n\n\n\n\n\n\n\n# Java中atomic包中的原子操作类总结\n\n\n# 1、原子操作类介绍\n\n在并发编程中很容易出现并发安全的问题，有一个很简单的例子就是多线程更新变量i=1，比如多个线程执行i++操作，就有可能获取不到正确的值，而这个问题，最常用的方法是通过Synchronized进行控制来达到线程安全的目的（关于synchronized可以看前面的文章）。但是由于synchronized是采用的是悲观锁策略，并不是特别高效的一种解决方案。实际上，在J.U.C下的atomic包提供了一系列的操作简单，性能高效，并能保证线程安全的类去更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都是采用的是乐观锁策略去原子更新数据，在java中则是使用CAS操作具体实现。\n\n\n# 2、预备知识--CAS操作\n\n能够弄懂atomic包下这些原子操作类的实现原理，就要先明白什么是CAS操作。\n\n> 什么是CAS?\n\n使用锁时，线程获取锁是一种悲观锁策略，即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。而CAS操作（又称为无锁操作）是一种乐观锁策略，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。因此，线程就不会出现阻塞停顿的状态。那么，如果出现冲突了怎么办？无锁操作是使用CAS(compare and swap)又叫做比较交换来鉴别线程是否出现冲突，出现冲突就重试当前操作直到没有冲突为止。\n\n> CAS的操作过程\n\n * V：内存地址存放的实际值\n * O：预期的值（旧值）\n * N：更新的新值\n\nCAS比较交换的过程可以通俗的理解为CAS(V,O,N)，包含三个值分别为：V 内存地址存放的实际值；O 预期的值（旧值）；N 更新的新值。当V和O相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值O就是目前来说最新的值了，自然而然可以将新值N赋值给V。反之，V和O不相同，表明该值已经被其他线程改过了则该旧值O不是最新版本的值了，所以不能将新值N赋给V，返回V即可。当多个线程使用CAS操作一个变量是，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试，当然也可以选择挂起线程\n\nCAS的实现需要硬件指令集的支撑，在JDK1.5后虚拟机才可以使用处理器提供的CMPXCHG指令实现。\n\nSynchronized VS CAS\n\n元老级的Synchronized(未优化前)最主要的问题是：在存在线程竞争的情况下会出现线程阻塞和唤醒锁带来的性能问题，因为这是一种互斥同步（阻塞同步）。而CAS并不是武断的间线程挂起，当CAS操作失败后会进行一定的尝试，而非进行耗时的挂起唤醒的操作，因此也叫做非阻塞同步。这是两者主要的区别。\n\n> CAS的问题\n\n 1. ABA问题 因为CAS会检查旧值有没有变化，这里存在这样一个有意思的问题。比如一个旧值A变为了成B，然后再变成A，刚好在做CAS时检查发现旧值并没有变化依然为A，但是实际上的确发生了变化。解决方案可以沿袭数据库中常用的乐观锁方式，添加一个版本号可以解决。原来的变化路径A->B->A就变成了1A->2B->3C。\n 2. 自旋时间过长\n\n使用CAS时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。如果JVM能支持处理器提供的pause指令，那么在效率上会有一定的提升。\n\n\n# 3、原子更新基本类型\n\natomic包提高原子更新基本类型的工具类，主要有这些：\n\n 1. AtomicBoolean：以原子更新的方式更新boolean；\n 2. AtomicInteger：以原子更新的方式更新Integer;\n 3. AtomicLong：以原子更新的方式更新Long；\n\n这几个类的用法基本一致，这里以AtomicInteger为例总结常用的方法\n\n 1. addAndGet(int delta) ：以原子方式将输入的数值与实例中原本的值相加，并返回最后的结果；\n 2. incrementAndGet() ：以原子的方式将实例中的原值进行加1操作，并返回最终相加后的结果；\n 3. getAndSet(int newValue)：将实例中的值更新为新值，并返回旧值；\n 4. getAndIncrement()：以原子的方式将实例中的原值加1，返回的是自增前的旧值；\n\n还有一些方法，可以查看API，不再赘述。为了能够弄懂AtomicInteger的实现原理，以getAndIncrement方法为例，来看下源码：\n\npublic final int getAndIncrement() {\n    return unsafe.getAndAddInt(this, valueOffset, 1);\n}\n\n\n1\n2\n3\n\n\n可以看出，该方法实际上是调用了unsafe实例的getAndAddInt方法，unsafe实例的获取时通过UnSafe类的静态方法getUnsafe获取：\n\nprivate static final Unsafe unsafe = Unsafe.getUnsafe();\n\n\n1\n\n\nUnsafe类在sun.misc包下，Unsafer类提供了一些底层操作，atomic包下的原子操作类的也主要是通过Unsafe类提供的compareAndSwapInt，compareAndSwapLong等一系列提供CAS操作的方法来进行实现。下面用一个简单的例子来说明AtomicInteger的用法：\n\npublic class AtomicDemo {\n    private static AtomicInteger atomicInteger = new AtomicInteger(1);\n\n    public static void main(String[] args) {\n        System.out.println(atomicInteger.getAndIncrement());\n        System.out.println(atomicInteger.get());\n    }\n}\n输出结果：\n1\n2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n例子很简单，就是新建了一个atomicInteger对象，而atomicInteger的构造方法也就是传入一个基本类型数据即可，对其进行了封装。对基本变量的操作比如自增，自减，相加，更新等操作，atomicInteger也提供了相应的方法进行这些操作。但是，因为atomicInteger借助了UnSafe提供的CAS操作能够保证数据更新的时候是线程安全的，并且由于CAS是采用乐观锁策略，因此，这种数据更新的方法也具有高效性。\n\nAtomicLong的实现原理和AtomicInteger一致，只不过一个针对的是long变量，一个针对的是int变量。而boolean变量的更新类AtomicBoolean类是怎样实现更新的呢?核心方法是compareAndSett方法，其源码如下：\n\npublic final boolean compareAndSet(boolean expect, boolean update) {\n    int e = expect ? 1 : 0;\n    int u = update ? 1 : 0;\n    return unsafe.compareAndSwapInt(this, valueOffset, e, u);\n}\n\n\n1\n2\n3\n4\n5\n\n\n可以看出，compareAndSet方法的实际上也是先转换成0，1的整型变量，然后是通过针对int型变量的原子更新方法compareAndSwapInt来实现的。可以看出atomic包中只提供了对boolean，int，long这三种基本类型的原子更新的方法，参考对boolean更新的方式，原子更新char，doule，float也可以采用类似的思路进行实现。\n\n\n# 4、原子更新数组类型\n\natomic包下提供能原子更新数组中元素的类有：\n\n 1. AtomicIntegerArray：原子更新整型数组中的元素；\n 2. AtomicLongArray：原子更新长整型数组中的元素；\n 3. AtomicReferenceArray：原子更新引用类型数组中的元素\n\n这几个类的用法一致，就以AtomicIntegerArray来总结下常用的方法：\n\n 1. addAndGet(int i, int delta) ：以原子更新的方式将数组中索引为i的元素与输入值相加；\n 2. getAndIncrement(int i) ：以原子更新的方式将数组中索引为i的元素自增加1；\n 3. compareAndSet(int i, int expect, int update) ：将数组中索引为i的位置的元素进行更新。\n\n可以看出，AtomicIntegerArray与AtomicInteger的方法基本一致，只不过在AtomicIntegerArray的方法中会多一个指定数组索引位i。下面举一个简单的例子：\n\npublic class AtomicDemo {\n    //    private static AtomicInteger atomicInteger = new AtomicInteger(1);\n    private static int[] value = new int[]{1, 2, 3};\n    private static AtomicIntegerArray integerArray = new AtomicIntegerArray(value);\n\n    public static void main(String[] args) {\n        //对数组中索引为1的位置的元素加5\n        int result = integerArray.getAndAdd(1, 5);\n        System.out.println(integerArray.get(1));\n        System.out.println(result);\n    }\n}\n输出结果：\n7\n2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n通过getAndAdd方法将位置为1的元素加5，从结果可以看出索引为1的元素变成了7，该方法返回的也是相加之前的数为2。\n\n\n# 5、原子更新引用类型\n\n如果需要原子更新引用类型变量的话，为了保证线程安全，atomic也提供了相关的类：\n\n 1. AtomicReference：原子更新引用类型；\n 2. AtomicReferenceFieldUpdater：原子更新引用类型里的字段；\n 3. AtomicMarkableReference：原子更新带有标记位的引用类型；\n\n这几个类的使用方法也是基本一样的，以AtomicReference为例，来说明这些类的基本用法。下面是一个demo\n\npublic class AtomicDemo {\n\n    private static AtomicReference<User> reference = new AtomicReference<>();\n\n    public static void main(String[] args) {\n        User user1 = new User(\"a\", 1);\n        reference.set(user1);\n        User user2 = new User(\"b\",2);\n        User user = reference.getAndSet(user2);\n        System.out.println(user);\n        System.out.println(reference.get());\n    }\n\n    static class User {\n        private String userName;\n        private int age;\n\n        public User(String userName, int age) {\n            this.userName = userName;\n            this.age = age;\n        }\n\n        @Override\n        public String toString() {\n            return \"User{\" +\n                    \"userName='\" + userName + '\\'' +\n                    \", age=\" + age +\n                    '}';\n        }\n    }\n}\n\n输出结果：\nUser{userName='a', age=1}\nUser{userName='b', age=2}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n首先将对象User1用AtomicReference进行封装，然后调用getAndSet方法，从结果可以看出，该方法会原子更新引用的user对象，变为User{userName='b', age=2}，返回的是原来的user对象User{userName='a', age=1}。\n\n\n# 6、原子更新字段类型\n\n如果需要更新对象的某个字段，并在多线程的情况下，能够保证线程安全，atomic同样也提供了相应的原子操作类：\n\n 1. AtomicIntegeFieldUpdater：原子更新整型字段类；\n 2. AtomicLongFieldUpdater：原子更新长整型字段类；\n 3. AtomicStampedReference：原子更新引用类型，这种更新方式会带有版本号。而为什么在更新的时候会带有版本号，是为了解决CAS的ABA问题；\n\n要想使用原子更新字段需要两步操作：\n\n 1. 原子更新字段类都是抽象类，只能通过静态方法newUpdater来创建一个更新器，并且需要设置想要更新的类和属性；\n 2. 更新类的属性必须使用public volatile进行修饰；\n\n这几个类提供的方法基本一致，以AtomicIntegerFieldUpdater为例来看看具体的使用：\n\npublic class AtomicDemo {\n\n    private static AtomicIntegerFieldUpdater updater = AtomicIntegerFieldUpdater.newUpdater(User.class,\"age\");\n    public static void main(String[] args) {\n        User user = new User(\"a\", 1);\n        int oldValue = updater.getAndAdd(user, 5);\n        System.out.println(oldValue);\n        System.out.println(updater.get(user));\n    }\n\n    static class User {\n        private String userName;\n        public volatile int age;\n\n        public User(String userName, int age) {\n            this.userName = userName;\n            this.age = age;\n        }\n\n        @Override\n        public String toString() {\n            return \"User{\" +\n                    \"userName='\" + userName + '\\'' +\n                    \", age=\" + age +\n                    '}';\n        }\n    }\n}\n\n输出结果：\n1\n6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n从示例中可以看出，创建AtomicIntegerFieldUpdater是通过它提供的静态方法进行创建，getAndAdd方法会将指定的字段加上输入的值，并且返回相加之前的值。user对象中age字段原值为1，加5之后，可以看出user对象中的age字段的值已经变成了6。",normalizedContent:"说明\n\njava中atomic包中的原子操作类总结\n\n\n\n\n\n\n\n\n# java中atomic包中的原子操作类总结\n\n\n# 1、原子操作类介绍\n\n在并发编程中很容易出现并发安全的问题，有一个很简单的例子就是多线程更新变量i=1，比如多个线程执行i++操作，就有可能获取不到正确的值，而这个问题，最常用的方法是通过synchronized进行控制来达到线程安全的目的（关于synchronized可以看前面的文章）。但是由于synchronized是采用的是悲观锁策略，并不是特别高效的一种解决方案。实际上，在j.u.c下的atomic包提供了一系列的操作简单，性能高效，并能保证线程安全的类去更新基本类型变量，数组元素，引用类型以及更新对象中的字段类型。atomic包下的这些类都是采用的是乐观锁策略去原子更新数据，在java中则是使用cas操作具体实现。\n\n\n# 2、预备知识--cas操作\n\n能够弄懂atomic包下这些原子操作类的实现原理，就要先明白什么是cas操作。\n\n> 什么是cas?\n\n使用锁时，线程获取锁是一种悲观锁策略，即假设每一次执行临界区代码都会产生冲突，所以当前线程获取到锁的时候同时也会阻塞其他线程获取该锁。而cas操作（又称为无锁操作）是一种乐观锁策略，它假设所有线程访问共享资源的时候不会出现冲突，既然不会出现冲突自然而然就不会阻塞其他线程的操作。因此，线程就不会出现阻塞停顿的状态。那么，如果出现冲突了怎么办？无锁操作是使用cas(compare and swap)又叫做比较交换来鉴别线程是否出现冲突，出现冲突就重试当前操作直到没有冲突为止。\n\n> cas的操作过程\n\n * v：内存地址存放的实际值\n * o：预期的值（旧值）\n * n：更新的新值\n\ncas比较交换的过程可以通俗的理解为cas(v,o,n)，包含三个值分别为：v 内存地址存放的实际值；o 预期的值（旧值）；n 更新的新值。当v和o相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值o就是目前来说最新的值了，自然而然可以将新值n赋值给v。反之，v和o不相同，表明该值已经被其他线程改过了则该旧值o不是最新版本的值了，所以不能将新值n赋给v，返回v即可。当多个线程使用cas操作一个变量是，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试，当然也可以选择挂起线程\n\ncas的实现需要硬件指令集的支撑，在jdk1.5后虚拟机才可以使用处理器提供的cmpxchg指令实现。\n\nsynchronized vs cas\n\n元老级的synchronized(未优化前)最主要的问题是：在存在线程竞争的情况下会出现线程阻塞和唤醒锁带来的性能问题，因为这是一种互斥同步（阻塞同步）。而cas并不是武断的间线程挂起，当cas操作失败后会进行一定的尝试，而非进行耗时的挂起唤醒的操作，因此也叫做非阻塞同步。这是两者主要的区别。\n\n> cas的问题\n\n 1. aba问题 因为cas会检查旧值有没有变化，这里存在这样一个有意思的问题。比如一个旧值a变为了成b，然后再变成a，刚好在做cas时检查发现旧值并没有变化依然为a，但是实际上的确发生了变化。解决方案可以沿袭数据库中常用的乐观锁方式，添加一个版本号可以解决。原来的变化路径a->b->a就变成了1a->2b->3c。\n 2. 自旋时间过长\n\n使用cas时非阻塞同步，也就是说不会将线程挂起，会自旋（无非就是一个死循环）进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。如果jvm能支持处理器提供的pause指令，那么在效率上会有一定的提升。\n\n\n# 3、原子更新基本类型\n\natomic包提高原子更新基本类型的工具类，主要有这些：\n\n 1. atomicboolean：以原子更新的方式更新boolean；\n 2. atomicinteger：以原子更新的方式更新integer;\n 3. atomiclong：以原子更新的方式更新long；\n\n这几个类的用法基本一致，这里以atomicinteger为例总结常用的方法\n\n 1. addandget(int delta) ：以原子方式将输入的数值与实例中原本的值相加，并返回最后的结果；\n 2. incrementandget() ：以原子的方式将实例中的原值进行加1操作，并返回最终相加后的结果；\n 3. getandset(int newvalue)：将实例中的值更新为新值，并返回旧值；\n 4. getandincrement()：以原子的方式将实例中的原值加1，返回的是自增前的旧值；\n\n还有一些方法，可以查看api，不再赘述。为了能够弄懂atomicinteger的实现原理，以getandincrement方法为例，来看下源码：\n\npublic final int getandincrement() {\n    return unsafe.getandaddint(this, valueoffset, 1);\n}\n\n\n1\n2\n3\n\n\n可以看出，该方法实际上是调用了unsafe实例的getandaddint方法，unsafe实例的获取时通过unsafe类的静态方法getunsafe获取：\n\nprivate static final unsafe unsafe = unsafe.getunsafe();\n\n\n1\n\n\nunsafe类在sun.misc包下，unsafer类提供了一些底层操作，atomic包下的原子操作类的也主要是通过unsafe类提供的compareandswapint，compareandswaplong等一系列提供cas操作的方法来进行实现。下面用一个简单的例子来说明atomicinteger的用法：\n\npublic class atomicdemo {\n    private static atomicinteger atomicinteger = new atomicinteger(1);\n\n    public static void main(string[] args) {\n        system.out.println(atomicinteger.getandincrement());\n        system.out.println(atomicinteger.get());\n    }\n}\n输出结果：\n1\n2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n例子很简单，就是新建了一个atomicinteger对象，而atomicinteger的构造方法也就是传入一个基本类型数据即可，对其进行了封装。对基本变量的操作比如自增，自减，相加，更新等操作，atomicinteger也提供了相应的方法进行这些操作。但是，因为atomicinteger借助了unsafe提供的cas操作能够保证数据更新的时候是线程安全的，并且由于cas是采用乐观锁策略，因此，这种数据更新的方法也具有高效性。\n\natomiclong的实现原理和atomicinteger一致，只不过一个针对的是long变量，一个针对的是int变量。而boolean变量的更新类atomicboolean类是怎样实现更新的呢?核心方法是compareandsett方法，其源码如下：\n\npublic final boolean compareandset(boolean expect, boolean update) {\n    int e = expect ? 1 : 0;\n    int u = update ? 1 : 0;\n    return unsafe.compareandswapint(this, valueoffset, e, u);\n}\n\n\n1\n2\n3\n4\n5\n\n\n可以看出，compareandset方法的实际上也是先转换成0，1的整型变量，然后是通过针对int型变量的原子更新方法compareandswapint来实现的。可以看出atomic包中只提供了对boolean，int，long这三种基本类型的原子更新的方法，参考对boolean更新的方式，原子更新char，doule，float也可以采用类似的思路进行实现。\n\n\n# 4、原子更新数组类型\n\natomic包下提供能原子更新数组中元素的类有：\n\n 1. atomicintegerarray：原子更新整型数组中的元素；\n 2. atomiclongarray：原子更新长整型数组中的元素；\n 3. atomicreferencearray：原子更新引用类型数组中的元素\n\n这几个类的用法一致，就以atomicintegerarray来总结下常用的方法：\n\n 1. addandget(int i, int delta) ：以原子更新的方式将数组中索引为i的元素与输入值相加；\n 2. getandincrement(int i) ：以原子更新的方式将数组中索引为i的元素自增加1；\n 3. compareandset(int i, int expect, int update) ：将数组中索引为i的位置的元素进行更新。\n\n可以看出，atomicintegerarray与atomicinteger的方法基本一致，只不过在atomicintegerarray的方法中会多一个指定数组索引位i。下面举一个简单的例子：\n\npublic class atomicdemo {\n    //    private static atomicinteger atomicinteger = new atomicinteger(1);\n    private static int[] value = new int[]{1, 2, 3};\n    private static atomicintegerarray integerarray = new atomicintegerarray(value);\n\n    public static void main(string[] args) {\n        //对数组中索引为1的位置的元素加5\n        int result = integerarray.getandadd(1, 5);\n        system.out.println(integerarray.get(1));\n        system.out.println(result);\n    }\n}\n输出结果：\n7\n2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n通过getandadd方法将位置为1的元素加5，从结果可以看出索引为1的元素变成了7，该方法返回的也是相加之前的数为2。\n\n\n# 5、原子更新引用类型\n\n如果需要原子更新引用类型变量的话，为了保证线程安全，atomic也提供了相关的类：\n\n 1. atomicreference：原子更新引用类型；\n 2. atomicreferencefieldupdater：原子更新引用类型里的字段；\n 3. atomicmarkablereference：原子更新带有标记位的引用类型；\n\n这几个类的使用方法也是基本一样的，以atomicreference为例，来说明这些类的基本用法。下面是一个demo\n\npublic class atomicdemo {\n\n    private static atomicreference<user> reference = new atomicreference<>();\n\n    public static void main(string[] args) {\n        user user1 = new user(\"a\", 1);\n        reference.set(user1);\n        user user2 = new user(\"b\",2);\n        user user = reference.getandset(user2);\n        system.out.println(user);\n        system.out.println(reference.get());\n    }\n\n    static class user {\n        private string username;\n        private int age;\n\n        public user(string username, int age) {\n            this.username = username;\n            this.age = age;\n        }\n\n        @override\n        public string tostring() {\n            return \"user{\" +\n                    \"username='\" + username + '\\'' +\n                    \", age=\" + age +\n                    '}';\n        }\n    }\n}\n\n输出结果：\nuser{username='a', age=1}\nuser{username='b', age=2}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n首先将对象user1用atomicreference进行封装，然后调用getandset方法，从结果可以看出，该方法会原子更新引用的user对象，变为user{username='b', age=2}，返回的是原来的user对象user{username='a', age=1}。\n\n\n# 6、原子更新字段类型\n\n如果需要更新对象的某个字段，并在多线程的情况下，能够保证线程安全，atomic同样也提供了相应的原子操作类：\n\n 1. atomicintegefieldupdater：原子更新整型字段类；\n 2. atomiclongfieldupdater：原子更新长整型字段类；\n 3. atomicstampedreference：原子更新引用类型，这种更新方式会带有版本号。而为什么在更新的时候会带有版本号，是为了解决cas的aba问题；\n\n要想使用原子更新字段需要两步操作：\n\n 1. 原子更新字段类都是抽象类，只能通过静态方法newupdater来创建一个更新器，并且需要设置想要更新的类和属性；\n 2. 更新类的属性必须使用public volatile进行修饰；\n\n这几个类提供的方法基本一致，以atomicintegerfieldupdater为例来看看具体的使用：\n\npublic class atomicdemo {\n\n    private static atomicintegerfieldupdater updater = atomicintegerfieldupdater.newupdater(user.class,\"age\");\n    public static void main(string[] args) {\n        user user = new user(\"a\", 1);\n        int oldvalue = updater.getandadd(user, 5);\n        system.out.println(oldvalue);\n        system.out.println(updater.get(user));\n    }\n\n    static class user {\n        private string username;\n        public volatile int age;\n\n        public user(string username, int age) {\n            this.username = username;\n            this.age = age;\n        }\n\n        @override\n        public string tostring() {\n            return \"user{\" +\n                    \"username='\" + username + '\\'' +\n                    \", age=\" + age +\n                    '}';\n        }\n    }\n}\n\n输出结果：\n1\n6\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n从示例中可以看出，创建atomicintegerfieldupdater是通过它提供的静态方法进行创建，getandadd方法会将指定的字段加上输入的值，并且返回相加之前的值。user对象中age字段原值为1，加5之后，可以看出user对象中的age字段的值已经变成了6。",charsets:{cjk:!0},createdTime:1655628697e3},{title:"线程池之ScheduledThreadPoolExecutor",frontmatter:{title:"线程池之ScheduledThreadPoolExecutor",description:"线程池之ScheduledThreadPoolExecutor",date:"2022-04-11T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/20%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BScheduledThreadPoolExecutor.html",relativePath:"Java/Java并发编程的艺术/20、线程池之ScheduledThreadPoolExecutor.md",key:"v-464f68c4",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/20%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BScheduledThreadPoolExecutor.html",headers:[{level:2,title:"1.1 构造方法",slug:"_1-1-构造方法",normalizedTitle:"1.1 构造方法",charIndex:42},{level:2,title:"1.2 特有方法",slug:"_1-2-特有方法",normalizedTitle:"1.2 特有方法",charIndex:54}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>线程池之ScheduledThreadPoolExecutor</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"1.1 构造方法 1.2 特有方法",content:"说明\n\n线程池之ScheduledThreadPoolExecutor\n\n\n\n * 1.1 构造方法\n * 1.2 特有方法\n\n\n\n\n# 线程池之ScheduledThreadPoolExecutor\n\n\n# 1、ScheduledThreadPoolExecutor简介\n\nScheduledThreadPoolExecutor可以用来在给定延时后执行异步任务或者周期性执行任务，相对于任务调度的Timer来说，其功能更加强大，Timer只能使用一个后台线程执行任务，而ScheduledThreadPoolExecutor则可以通过构造函数来指定后台线程的个数。ScheduledThreadPoolExecutor类的UML图如下：\n\n\n\n 1. 从UML图可以看出，ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，也就是说ScheduledThreadPoolExecutor拥有execute()和submit()提交异步任务的基础功能，关于ThreadPoolExecutor可以看上面的文章。但是，ScheduledThreadPoolExecutor类实现了ScheduledExecutorService，该接口定义了ScheduledThreadPoolExecutor能够延时执行任务和周期执行任务的功能；\n 2. ScheduledThreadPoolExecutor也两个重要的内部类：DelayedWorkQueue和ScheduledFutureTask。可以看出DelayedWorkQueue实现了BlockingQueue接口，也就是一个阻塞队列，ScheduledFutureTask则是继承了FutureTask类，也表示该类用于返回异步任务的结果。这两个关键类，下面会具体详细来看。\n\n\n# 1.1 构造方法\n\nScheduledThreadPoolExecutor有如下几个构造方法：\n\npublic ScheduledThreadPoolExecutor(int corePoolSize) {\n    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n          new DelayedWorkQueue());\n}；\n\npublic ScheduledThreadPoolExecutor(int corePoolSize,\n                                   ThreadFactory threadFactory) {\n    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n          new DelayedWorkQueue(), threadFactory);\n}；\npublic ScheduledThreadPoolExecutor(int corePoolSize,\n                                   RejectedExecutionHandler handler) {\n    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n          new DelayedWorkQueue(), handler);\n}；\n\npublic ScheduledThreadPoolExecutor(int corePoolSize,\n                                   ThreadFactory threadFactory,\n                                   RejectedExecutionHandler handler) {\n    super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS,\n          new DelayedWorkQueue(), threadFactory, handler);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n可以看出由于ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，它的构造方法实际上是调用了ThreadPoolExecutor，理解ThreadPoolExecutor构造方法的几个参数的意义后，理解这就很容易了。可以看出，ScheduledThreadPoolExecutor的核心线程池的线程个数为指定的corePoolSize，当核心线程池的线程个数达到corePoolSize后，就会将任务提交给有界阻塞队列DelayedWorkQueue，对DelayedWorkQueue在下面进行详细介绍，线程池允许最大的线程个数为Integer.MAX_VALUE，也就是说理论上这是一个大小无界的线程池。\n\n\n# 1.2 特有方法\n\nScheduledThreadPoolExecutor实现了ScheduledExecutorService接口，该接口定义了可延时执行异步任务和可周期执行异步任务的特有功能，相应的方法分别为：\n\n//达到给定的延时时间后，执行任务。这里传入的是实现Runnable接口的任务，\n//因此通过ScheduledFuture.get()获取结果为null\npublic ScheduledFuture<?> schedule(Runnable command,\n                                       long delay, TimeUnit unit);\n//达到给定的延时时间后，执行任务。这里传入的是实现Callable接口的任务，\n//因此，返回的是任务的最终计算结果\n public <V> ScheduledFuture<V> schedule(Callable<V> callable,\n                                           long delay, TimeUnit unit);\n\n//是以上一个任务开始的时间计时，period时间过去后，\n//检测上一个任务是否执行完毕，如果上一个任务执行完毕，\n//则当前任务立即执行，如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行\npublic ScheduledFuture<?> scheduleAtFixedRate(Runnable command,\n                                                  long initialDelay,\n                                                  long period,\n                                                  TimeUnit unit);\n//当达到延时时间initialDelay后，任务开始执行。上一个任务执行结束后到下一次\n//任务执行，中间延时时间间隔为delay。以这种方式，周期性执行任务。\npublic ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,\n                                                     long initialDelay,\n                                                     long delay,\n                                                     TimeUnit unit);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 2、ScheduledFutureTask\n\nScheduledThreadPoolExecutor（可周期性执行的任务）最大的特色是能够周期性执行异步任务，当调用schedule，scheduleAtFixedRate和scheduleWithFixedDelay方法时，实际上是将提交的任务转换成的ScheduledFutureTask类，从源码就可以看出。以schedule方法为例：\n\npublic ScheduledFuture<?> schedule(Runnable command,\n                                   long delay,\n                                   TimeUnit unit) {\n    if (command == null || unit == null)\n        throw new NullPointerException();\n    RunnableScheduledFuture<?> t = decorateTask(command,\n        new ScheduledFutureTask<Void>(command, null,\n                                      triggerTime(delay, unit)));\n    delayedExecute(t);\n    return t;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n可以看出，通过decorateTask会将传入的Runnable转换成ScheduledFutureTask类。线程池最大作用是将任务和线程进行解耦，线程主要是任务的执行者，而任务也就是现在所说的ScheduledFutureTask。紧接着，会想到任何线程执行任务，总会调用run()方法。为了保证ScheduledThreadPoolExecutor能够延时执行任务以及能够周期性执行任务，ScheduledFutureTask重写了run方法：\n\npublic void run() {\n    boolean periodic = isPeriodic();\n    if (!canRunInCurrentRunState(periodic))\n        cancel(false);\n    else if (!periodic)\n\t\t//如果不是周期性执行任务，则直接调用run方法\n        ScheduledFutureTask.super.run();\n\t\t//如果是周期性执行任务的话，需要重设下一次执行任务的时间\n    else if (ScheduledFutureTask.super.runAndReset()) {\n        setNextRunTime();\n        reExecutePeriodic(outerTask);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n从源码可以很明显的看出，在重写的run方法中会先if (!periodic)判断当前任务是否是周期性任务，如果不是的话就直接调用run()方法；否则的话执行setNextRunTime()方法重设下一次任务执行的时间，并通过reExecutePeriodic(outerTask)方法将下一次待执行的任务放置到DelayedWorkQueue中。\n\n因此，可以得出结论：ScheduledFutureTask最主要的功能是根据当前任务是否具有周期性，对异步任务进行进一步封装。如果不是周期性任务（调用schedule方法）则直接通过run()执行，若是周期性任务，则需要在每一次执行完后，重设下一次执行的时间，然后将下一次任务继续放入到阻塞队列中。\n\n\n# 3、DelayedWorkQueue\n\n在ScheduledThreadPoolExecutor中还有另外的一个重要的类就是DelayedWorkQueue。为了实现其ScheduledThreadPoolExecutor能够延时执行异步任务以及能够周期执行任务，DelayedWorkQueue进行相应的封装。DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面。\n\n> 为什么要使用DelayedWorkQueue呢？\n\n定时任务执行时需要取出最近要执行的任务，所以任务在队列中每次出队时一定要是当前队列中执行时间最靠前的，所以自然要使用优先级队列。\n\nDelayedWorkQueue是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的，由于它是基于堆结构的队列，堆结构在执行插入和删除操作时的最坏时间复杂度是 O(logN)。\n\n> DelayedWorkQueue的数据结构\n\n//初始大小\nprivate static final int INITIAL_CAPACITY = 16;\n//DelayedWorkQueue是由一个大小为16的数组组成，数组元素为实现RunnableScheduleFuture接口的类\n//实际上为ScheduledFutureTask\nprivate RunnableScheduledFuture<?>[] queue =\n    new RunnableScheduledFuture<?>[INITIAL_CAPACITY];\nprivate final ReentrantLock lock = new ReentrantLock();\nprivate int size = 0;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n可以看出DelayedWorkQueue底层是采用数组构成的，关于DelayedWorkQueue可以看这篇博主的文章，很详细。\n\n关于DelayedWorkQueue我们可以得出这样的结论：DelayedWorkQueue是基于堆的数据结构，按照时间顺序将每个任务进行排序，将待执行时间越近的任务放在在队列的队头位置，以便于最先进行执行。\n\n\n# 4、ScheduledThreadPoolExecutor执行过程\n\n现在我们对ScheduledThreadPoolExecutor的两个内部类ScheduledFutueTask和DelayedWorkQueue进行了了解，实际上这也是线程池工作流程中最重要的两个关键因素：任务以及阻塞队列。现在我们来看下ScheduledThreadPoolExecutor提交一个任务后，整体的执行过程。以ScheduledThreadPoolExecutor的schedule方法为例，具体源码为：\n\npublic ScheduledFuture<?> schedule(Runnable command,\n                                   long delay,\n                                   TimeUnit unit) {\n    if (command == null || unit == null)\n        throw new NullPointerException();\n\t//将提交的任务转换成ScheduledFutureTask\n    RunnableScheduledFuture<?> t = decorateTask(command,\n        new ScheduledFutureTask<Void>(command, null,\n                                      triggerTime(delay, unit)));\n    //延时执行任务ScheduledFutureTask\n\tdelayedExecute(t);\n    return t;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n方法很容易理解，为了满足ScheduledThreadPoolExecutor能够延时执行任务和能周期执行任务的特性，会先将实现Runnable接口的类转换成ScheduledFutureTask。然后会调用delayedExecute方法进行执行任务，这个方法也是关键方法，来看下源码：\n\nprivate void delayedExecute(RunnableScheduledFuture<?> task) {\n    if (isShutdown())\n\t\t//如果当前线程池已经关闭，则拒绝任务\n        reject(task);\n    else {\n\t\t//将任务放入阻塞队列中\n        super.getQueue().add(task);\n        if (isShutdown() &&\n            !canRunInCurrentRunState(task.isPeriodic()) &&\n            remove(task))\n            task.cancel(false);\n        else\n\t\t\t//保证至少有一个线程启动，即使corePoolSize=0\n            ensurePrestart();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\ndelayedExecute方法的主要逻辑请看注释，可以看出该方法的重要逻辑会是在ensurePrestart()方法中，它的源码为：\n\nvoid ensurePrestart() {\n    int wc = workerCountOf(ctl.get());\n    if (wc < corePoolSize)\n        addWorker(null, true);\n    else if (wc == 0)\n        addWorker(null, false);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看出该方法逻辑很简单，关键在于它所调用的addWorker()方法，该方法主要功能：新建Worker类，当执行任务时，就会调用被Worker所重写的run方法，进而会继续执行runWorker方法。在runWorker方法中会调用getTask方法从阻塞队列中不断的去获取任务进行执行，直到从阻塞队列中获取的任务为null的话，线程结束终止。addWorker方法是ThreadPoolExecutor类中的方法，对ThreadPoolExecutor的源码分析可以看上面的文章。\n\n\n# 5、总结\n\nScheduledThreadPoolExecutor继承了ThreadPoolExecutor类，因此，整体上功能一致，线程池主要负责创建线程（Worker类），线程从阻塞队列中不断获取新的异步任务，直到阻塞队列中已经没有了异步任务为止。但是相较于ThreadPoolExecutor来说，ScheduledThreadPoolExecutor具有延时执行任务和可周期性执行任务的特性，ScheduledThreadPoolExecutor重新设计了任务类ScheduleFutureTask，ScheduleFutureTask重写了run方法使其具有可延时执行和可周期性执行任务的特性。另外，阻塞队列DelayedWorkQueue是可根据优先级排序的队列，采用了堆的底层数据结构，使得与当前时间相比，待执行时间越靠近的任务放置队头，以便线程能够获取到任务进行执行；\n\n线程池无论是ThreadPoolExecutor还是ScheduledThreadPoolExecutor，在设计时的三个关键要素是：任务，执行者以及任务结果。它们的设计思想也是完全将这三个关键要素进行了解耦。\n\n * 执行者\n   \n   任务的执行机制，完全交由Worker类，也就是进一步了封装了Thread。向线程池提交任务，无论为ThreadPoolExecutor的execute方法和submit方法，还是ScheduledThreadPoolExecutor的schedule方法，都是先将任务移入到阻塞队列中，然后通过addWork方法新建了Work类，并通过runWorker方法启动线程，并不断的从阻塞对列中获取异步任务执行交给Worker执行，直至阻塞队列中无法取到任务为止。\n\n * 任务\n   \n   在ThreadPoolExecutor和ScheduledThreadPoolExecutor中任务是指实现了Runnable接口和Callable接口的实现类。ThreadPoolExecutor中会将任务转换成FutureTask类，而在ScheduledThreadPoolExecutor中为了实现可延时执行任务和周期性执行任务的特性，任务会被转换成ScheduledFutureTask类，该类继承了FutureTask，并重写了run方法。\n\n * 任务结果\n   \n   在ThreadPoolExecutor中提交任务后，获取任务结果可以通过Future接口的类，在ThreadPoolExecutor中实际上为FutureTask类，而在ScheduledThreadPoolExecutor中则是ScheduledFutureTask类\n\n> 参考文献\n\n《Java并发编程的艺术》",normalizedContent:"说明\n\n线程池之scheduledthreadpoolexecutor\n\n\n\n * 1.1 构造方法\n * 1.2 特有方法\n\n\n\n\n# 线程池之scheduledthreadpoolexecutor\n\n\n# 1、scheduledthreadpoolexecutor简介\n\nscheduledthreadpoolexecutor可以用来在给定延时后执行异步任务或者周期性执行任务，相对于任务调度的timer来说，其功能更加强大，timer只能使用一个后台线程执行任务，而scheduledthreadpoolexecutor则可以通过构造函数来指定后台线程的个数。scheduledthreadpoolexecutor类的uml图如下：\n\n\n\n 1. 从uml图可以看出，scheduledthreadpoolexecutor继承了threadpoolexecutor，也就是说scheduledthreadpoolexecutor拥有execute()和submit()提交异步任务的基础功能，关于threadpoolexecutor可以看上面的文章。但是，scheduledthreadpoolexecutor类实现了scheduledexecutorservice，该接口定义了scheduledthreadpoolexecutor能够延时执行任务和周期执行任务的功能；\n 2. scheduledthreadpoolexecutor也两个重要的内部类：delayedworkqueue和scheduledfuturetask。可以看出delayedworkqueue实现了blockingqueue接口，也就是一个阻塞队列，scheduledfuturetask则是继承了futuretask类，也表示该类用于返回异步任务的结果。这两个关键类，下面会具体详细来看。\n\n\n# 1.1 构造方法\n\nscheduledthreadpoolexecutor有如下几个构造方法：\n\npublic scheduledthreadpoolexecutor(int corepoolsize) {\n    super(corepoolsize, integer.max_value, 0, nanoseconds,\n          new delayedworkqueue());\n}；\n\npublic scheduledthreadpoolexecutor(int corepoolsize,\n                                   threadfactory threadfactory) {\n    super(corepoolsize, integer.max_value, 0, nanoseconds,\n          new delayedworkqueue(), threadfactory);\n}；\npublic scheduledthreadpoolexecutor(int corepoolsize,\n                                   rejectedexecutionhandler handler) {\n    super(corepoolsize, integer.max_value, 0, nanoseconds,\n          new delayedworkqueue(), handler);\n}；\n\npublic scheduledthreadpoolexecutor(int corepoolsize,\n                                   threadfactory threadfactory,\n                                   rejectedexecutionhandler handler) {\n    super(corepoolsize, integer.max_value, 0, nanoseconds,\n          new delayedworkqueue(), threadfactory, handler);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n可以看出由于scheduledthreadpoolexecutor继承了threadpoolexecutor，它的构造方法实际上是调用了threadpoolexecutor，理解threadpoolexecutor构造方法的几个参数的意义后，理解这就很容易了。可以看出，scheduledthreadpoolexecutor的核心线程池的线程个数为指定的corepoolsize，当核心线程池的线程个数达到corepoolsize后，就会将任务提交给有界阻塞队列delayedworkqueue，对delayedworkqueue在下面进行详细介绍，线程池允许最大的线程个数为integer.max_value，也就是说理论上这是一个大小无界的线程池。\n\n\n# 1.2 特有方法\n\nscheduledthreadpoolexecutor实现了scheduledexecutorservice接口，该接口定义了可延时执行异步任务和可周期执行异步任务的特有功能，相应的方法分别为：\n\n//达到给定的延时时间后，执行任务。这里传入的是实现runnable接口的任务，\n//因此通过scheduledfuture.get()获取结果为null\npublic scheduledfuture<?> schedule(runnable command,\n                                       long delay, timeunit unit);\n//达到给定的延时时间后，执行任务。这里传入的是实现callable接口的任务，\n//因此，返回的是任务的最终计算结果\n public <v> scheduledfuture<v> schedule(callable<v> callable,\n                                           long delay, timeunit unit);\n\n//是以上一个任务开始的时间计时，period时间过去后，\n//检测上一个任务是否执行完毕，如果上一个任务执行完毕，\n//则当前任务立即执行，如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行\npublic scheduledfuture<?> scheduleatfixedrate(runnable command,\n                                                  long initialdelay,\n                                                  long period,\n                                                  timeunit unit);\n//当达到延时时间initialdelay后，任务开始执行。上一个任务执行结束后到下一次\n//任务执行，中间延时时间间隔为delay。以这种方式，周期性执行任务。\npublic scheduledfuture<?> schedulewithfixeddelay(runnable command,\n                                                     long initialdelay,\n                                                     long delay,\n                                                     timeunit unit);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 2、scheduledfuturetask\n\nscheduledthreadpoolexecutor（可周期性执行的任务）最大的特色是能够周期性执行异步任务，当调用schedule，scheduleatfixedrate和schedulewithfixeddelay方法时，实际上是将提交的任务转换成的scheduledfuturetask类，从源码就可以看出。以schedule方法为例：\n\npublic scheduledfuture<?> schedule(runnable command,\n                                   long delay,\n                                   timeunit unit) {\n    if (command == null || unit == null)\n        throw new nullpointerexception();\n    runnablescheduledfuture<?> t = decoratetask(command,\n        new scheduledfuturetask<void>(command, null,\n                                      triggertime(delay, unit)));\n    delayedexecute(t);\n    return t;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n可以看出，通过decoratetask会将传入的runnable转换成scheduledfuturetask类。线程池最大作用是将任务和线程进行解耦，线程主要是任务的执行者，而任务也就是现在所说的scheduledfuturetask。紧接着，会想到任何线程执行任务，总会调用run()方法。为了保证scheduledthreadpoolexecutor能够延时执行任务以及能够周期性执行任务，scheduledfuturetask重写了run方法：\n\npublic void run() {\n    boolean periodic = isperiodic();\n    if (!canrunincurrentrunstate(periodic))\n        cancel(false);\n    else if (!periodic)\n\t\t//如果不是周期性执行任务，则直接调用run方法\n        scheduledfuturetask.super.run();\n\t\t//如果是周期性执行任务的话，需要重设下一次执行任务的时间\n    else if (scheduledfuturetask.super.runandreset()) {\n        setnextruntime();\n        reexecuteperiodic(outertask);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n从源码可以很明显的看出，在重写的run方法中会先if (!periodic)判断当前任务是否是周期性任务，如果不是的话就直接调用run()方法；否则的话执行setnextruntime()方法重设下一次任务执行的时间，并通过reexecuteperiodic(outertask)方法将下一次待执行的任务放置到delayedworkqueue中。\n\n因此，可以得出结论：scheduledfuturetask最主要的功能是根据当前任务是否具有周期性，对异步任务进行进一步封装。如果不是周期性任务（调用schedule方法）则直接通过run()执行，若是周期性任务，则需要在每一次执行完后，重设下一次执行的时间，然后将下一次任务继续放入到阻塞队列中。\n\n\n# 3、delayedworkqueue\n\n在scheduledthreadpoolexecutor中还有另外的一个重要的类就是delayedworkqueue。为了实现其scheduledthreadpoolexecutor能够延时执行异步任务以及能够周期执行任务，delayedworkqueue进行相应的封装。delayedworkqueue是一个基于堆的数据结构，类似于delayqueue和priorityqueue。在执行定时任务的时候，每个任务的执行时间都不同，所以delayedworkqueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近的任务在队列的前面。\n\n> 为什么要使用delayedworkqueue呢？\n\n定时任务执行时需要取出最近要执行的任务，所以任务在队列中每次出队时一定要是当前队列中执行时间最靠前的，所以自然要使用优先级队列。\n\ndelayedworkqueue是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的，由于它是基于堆结构的队列，堆结构在执行插入和删除操作时的最坏时间复杂度是 o(logn)。\n\n> delayedworkqueue的数据结构\n\n//初始大小\nprivate static final int initial_capacity = 16;\n//delayedworkqueue是由一个大小为16的数组组成，数组元素为实现runnableschedulefuture接口的类\n//实际上为scheduledfuturetask\nprivate runnablescheduledfuture<?>[] queue =\n    new runnablescheduledfuture<?>[initial_capacity];\nprivate final reentrantlock lock = new reentrantlock();\nprivate int size = 0;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n可以看出delayedworkqueue底层是采用数组构成的，关于delayedworkqueue可以看这篇博主的文章，很详细。\n\n关于delayedworkqueue我们可以得出这样的结论：delayedworkqueue是基于堆的数据结构，按照时间顺序将每个任务进行排序，将待执行时间越近的任务放在在队列的队头位置，以便于最先进行执行。\n\n\n# 4、scheduledthreadpoolexecutor执行过程\n\n现在我们对scheduledthreadpoolexecutor的两个内部类scheduledfutuetask和delayedworkqueue进行了了解，实际上这也是线程池工作流程中最重要的两个关键因素：任务以及阻塞队列。现在我们来看下scheduledthreadpoolexecutor提交一个任务后，整体的执行过程。以scheduledthreadpoolexecutor的schedule方法为例，具体源码为：\n\npublic scheduledfuture<?> schedule(runnable command,\n                                   long delay,\n                                   timeunit unit) {\n    if (command == null || unit == null)\n        throw new nullpointerexception();\n\t//将提交的任务转换成scheduledfuturetask\n    runnablescheduledfuture<?> t = decoratetask(command,\n        new scheduledfuturetask<void>(command, null,\n                                      triggertime(delay, unit)));\n    //延时执行任务scheduledfuturetask\n\tdelayedexecute(t);\n    return t;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n方法很容易理解，为了满足scheduledthreadpoolexecutor能够延时执行任务和能周期执行任务的特性，会先将实现runnable接口的类转换成scheduledfuturetask。然后会调用delayedexecute方法进行执行任务，这个方法也是关键方法，来看下源码：\n\nprivate void delayedexecute(runnablescheduledfuture<?> task) {\n    if (isshutdown())\n\t\t//如果当前线程池已经关闭，则拒绝任务\n        reject(task);\n    else {\n\t\t//将任务放入阻塞队列中\n        super.getqueue().add(task);\n        if (isshutdown() &&\n            !canrunincurrentrunstate(task.isperiodic()) &&\n            remove(task))\n            task.cancel(false);\n        else\n\t\t\t//保证至少有一个线程启动，即使corepoolsize=0\n            ensureprestart();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\ndelayedexecute方法的主要逻辑请看注释，可以看出该方法的重要逻辑会是在ensureprestart()方法中，它的源码为：\n\nvoid ensureprestart() {\n    int wc = workercountof(ctl.get());\n    if (wc < corepoolsize)\n        addworker(null, true);\n    else if (wc == 0)\n        addworker(null, false);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以看出该方法逻辑很简单，关键在于它所调用的addworker()方法，该方法主要功能：新建worker类，当执行任务时，就会调用被worker所重写的run方法，进而会继续执行runworker方法。在runworker方法中会调用gettask方法从阻塞队列中不断的去获取任务进行执行，直到从阻塞队列中获取的任务为null的话，线程结束终止。addworker方法是threadpoolexecutor类中的方法，对threadpoolexecutor的源码分析可以看上面的文章。\n\n\n# 5、总结\n\nscheduledthreadpoolexecutor继承了threadpoolexecutor类，因此，整体上功能一致，线程池主要负责创建线程（worker类），线程从阻塞队列中不断获取新的异步任务，直到阻塞队列中已经没有了异步任务为止。但是相较于threadpoolexecutor来说，scheduledthreadpoolexecutor具有延时执行任务和可周期性执行任务的特性，scheduledthreadpoolexecutor重新设计了任务类schedulefuturetask，schedulefuturetask重写了run方法使其具有可延时执行和可周期性执行任务的特性。另外，阻塞队列delayedworkqueue是可根据优先级排序的队列，采用了堆的底层数据结构，使得与当前时间相比，待执行时间越靠近的任务放置队头，以便线程能够获取到任务进行执行；\n\n线程池无论是threadpoolexecutor还是scheduledthreadpoolexecutor，在设计时的三个关键要素是：任务，执行者以及任务结果。它们的设计思想也是完全将这三个关键要素进行了解耦。\n\n * 执行者\n   \n   任务的执行机制，完全交由worker类，也就是进一步了封装了thread。向线程池提交任务，无论为threadpoolexecutor的execute方法和submit方法，还是scheduledthreadpoolexecutor的schedule方法，都是先将任务移入到阻塞队列中，然后通过addwork方法新建了work类，并通过runworker方法启动线程，并不断的从阻塞对列中获取异步任务执行交给worker执行，直至阻塞队列中无法取到任务为止。\n\n * 任务\n   \n   在threadpoolexecutor和scheduledthreadpoolexecutor中任务是指实现了runnable接口和callable接口的实现类。threadpoolexecutor中会将任务转换成futuretask类，而在scheduledthreadpoolexecutor中为了实现可延时执行任务和周期性执行任务的特性，任务会被转换成scheduledfuturetask类，该类继承了futuretask，并重写了run方法。\n\n * 任务结果\n   \n   在threadpoolexecutor中提交任务后，获取任务结果可以通过future接口的类，在threadpoolexecutor中实际上为futuretask类，而在scheduledthreadpoolexecutor中则是scheduledfuturetask类\n\n> 参考文献\n\n《java并发编程的艺术》",charsets:{cjk:!0},createdTime:1655628697e3},{title:"java并发工具类-Semaphore，Exchanger",frontmatter:{title:"java并发工具类-Semaphore，Exchanger",description:"java并发工具类-Semaphore，Exchanger",date:"2022-04-15T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/24%E3%80%81java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-Semaphore%EF%BC%8CExchanger.html",relativePath:"Java/Java并发编程的艺术/24、java并发工具类-Semaphore，Exchanger.md",key:"v-6edd8a2c",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/24%E3%80%81java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-Semaphore%EF%BC%8CExchanger.html",excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>java并发工具类-Semaphore，Exchanger</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:null,content:'说明\n\njava并发工具类-Semaphore，Exchanger\n\n\n\n\n\n\n\n\n# java并发工具类-Semaphore，Exchanger\n\n\n# 1、控制资源并发访问--Semaphore\n\nSemaphore可以理解为信号量，用于控制资源能够被并发访问的线程数量，以保证多个线程能够合理的使用特定资源。Semaphore就相当于一个许可证，线程需要先通过acquire方法获取该许可证，该线程才能继续往下执行，否则只能在该方法出阻塞等待。当执行完业务功能后，需要通过release()方法将许可证归还，以便其他线程能够获得许可证继续执行。\n\nSemaphore可以用于做流量控制，特别是公共资源有限的应用场景，比如数据库连接。假如有多个线程读取数据后，需要将数据保存在数据库中，而可用的最大数据库连接只有10个，这时候就需要使用Semaphore来控制能够并发访问到数据库连接资源的线程个数最多只有10个。在限制资源使用的应用场景下，Semaphore是特别合适的。\n\n下面来看下Semaphore的主要方法：\n\n//获取许可，如果无法获取到，则阻塞等待直至能够获取为止\nvoid acquire() throws InterruptedException\n\n//同acquire方法功能基本一样，只不过该方法可以一次获取多个许可\nvoid acquire(int permits) throws InterruptedException\n\n//释放许可\nvoid release()\n\n//释放指定个数的许可\nvoid release(int permits)\n\n//尝试获取许可，如果能够获取成功则立即返回true，否则，则返回false\nboolean tryAcquire()\n\n//与tryAcquire方法一致，只不过这里可以指定获取多个许可\nboolean tryAcquire(int permits)\n\n//尝试获取许可，如果能够立即获取到或者在指定时间内能够获取到，则返回true，否则返回false\nboolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException\n\n//与上一个方法一致，只不过这里能够获取多个许可\nboolean tryAcquire(int permits, long timeout, TimeUnit unit)\n\n//返回当前可用的许可证个数\nint availablePermits()\n\n//返回正在等待获取许可证的线程数\nint getQueueLength()\n\n//是否有线程正在等待获取许可证\nboolean hasQueuedThreads()\n\n//获取所有正在等待许可的线程集合\nCollection<Thread> getQueuedThreads()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n另外，在Semaphore的构造方法中还支持指定是够具有公平性，默认的是非公平性，这样也是为了保证吞吐量。\n\n> 一个例子\n\n下面用一个简单的例子来说明Semaphore的具体使用。我们来模拟这样一样场景。有一天，班主任需要班上10个同学到讲台上来填写一个表格，但是老师只准备了5支笔，因此，只能保证同时只有5个同学能够拿到笔并填写表格，没有获取到笔的同学只能够等前面的同学用完之后，才能拿到笔去填写表格。该示例代码如下：\n\npublic class SemaphoreDemo {\n\n    //表示老师只有10支笔\n    private static Semaphore semaphore = new Semaphore(5);\n\n    public static void main(String[] args) {\n\n        //表示50个学生\n        ExecutorService service = Executors.newFixedThreadPool(10);\n        for (int i = 0; i < 10; i++) {\n            service.execute(() -> {\n                try {\n                    System.out.println(Thread.currentThread().getName() + "  同学准备获取笔......");\n                    semaphore.acquire();\n                    System.out.println(Thread.currentThread().getName() + "  同学获取到笔");\n                    System.out.println(Thread.currentThread().getName() + "  填写表格ing.....");\n                    TimeUnit.SECONDS.sleep(3);\n                    semaphore.release();\n                    System.out.println(Thread.currentThread().getName() + "  填写完表格，归还了笔！！！！！！");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n        service.shutdown();\n    }\n\n}\n输出结果：\n\npool-1-thread-1  同学准备获取笔......\npool-1-thread-1  同学获取到笔\npool-1-thread-1  填写表格ing.....\npool-1-thread-2  同学准备获取笔......\npool-1-thread-2  同学获取到笔\npool-1-thread-2  填写表格ing.....\npool-1-thread-3  同学准备获取笔......\npool-1-thread-4  同学准备获取笔......\npool-1-thread-3  同学获取到笔\npool-1-thread-4  同学获取到笔\npool-1-thread-4  填写表格ing.....\npool-1-thread-3  填写表格ing.....\npool-1-thread-5  同学准备获取笔......\npool-1-thread-5  同学获取到笔\npool-1-thread-5  填写表格ing.....\n\n\npool-1-thread-6  同学准备获取笔......\npool-1-thread-7  同学准备获取笔......\npool-1-thread-8  同学准备获取笔......\npool-1-thread-9  同学准备获取笔......\npool-1-thread-10  同学准备获取笔......\n\n\npool-1-thread-4  填写完表格，归还了笔！！！！！！\npool-1-thread-9  同学获取到笔\npool-1-thread-9  填写表格ing.....\npool-1-thread-5  填写完表格，归还了笔！！！！！！\npool-1-thread-7  同学获取到笔\npool-1-thread-7  填写表格ing.....\npool-1-thread-8  同学获取到笔\npool-1-thread-8  填写表格ing.....\npool-1-thread-1  填写完表格，归还了笔！！！！！！\npool-1-thread-6  同学获取到笔\npool-1-thread-6  填写表格ing.....\npool-1-thread-3  填写完表格，归还了笔！！！！！！\npool-1-thread-2  填写完表格，归还了笔！！！！！！\npool-1-thread-10  同学获取到笔\npool-1-thread-10  填写表格ing.....\npool-1-thread-7  填写完表格，归还了笔！！！！！！\npool-1-thread-9  填写完表格，归还了笔！！！！！！\npool-1-thread-8  填写完表格，归还了笔！！！！！！\npool-1-thread-6  填写完表格，归还了笔！！！！！！\npool-1-thread-10  填写完表格，归还了笔！！！！！！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n根据输出结果进行分析，Semaphore允许的最大许可数为5，也就是允许的最大并发执行的线程个数为5，可以看出，前5个线程（前5个学生）先获取到笔，然后填写表格，而6-10这5个线程，由于获取不到许可，只能阻塞等待。当线程pool-1-thread-4释放了许可之后，pool-1-thread-9就可以获取到许可，继续往下执行。对其他线程的执行过程，也是同样的道理。从这个例子就可以看出，Semaphore用来做特殊资源的并发访问控制是相当合适的，如果有业务场景需要进行流量控制，可以优先考虑Semaphore。\n\n\n# 2、线程间交换数据的工具--Exchanger\n\nExchanger是一个用于线程间协作的工具类，用于两个线程间能够交换。它提供了一个交换的同步点，在这个同步点两个线程能够交换数据。具体交换数据是通过exchange方法来实现的，如果一个线程先执行exchange方法，那么它会同步等待另一个线程也执行exchange方法，这个时候两个线程就都达到了同步点，两个线程就可以交换数据。\n\nExchanger除了一个无参的构造方法外，主要方法也很简单：\n\n//当一个线程执行该方法的时候，会等待另一个线程也执行该方法，因此两个线程就都达到了同步点\n//将数据交换给另一个线程，同时返回获取的数据\nV exchange(V x) throws InterruptedException\n\n//同上一个方法功能基本一样，只不过这个方法同步等待的时候，增加了超时时间\nV exchange(V x, long timeout, TimeUnit unit)\n    throws InterruptedException, TimeoutException\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 一个例子\n\nExchanger理解起来很容易，这里用一个简单的例子来看下它的具体使用。我们来模拟这样一个情景，在青春洋溢的中学时代，下课期间，男生经常会给走廊里为自己喜欢的女孩子送情书，相信大家都做过这样的事情吧 。男孩会先到女孩教室门口，然后等女孩出来，教室那里就是一个同步点，然后彼此交换信物，也就是彼此交换了数据。现在，就来模拟这个情景。\n\npublic class ExchangerDemo {\n    private static Exchanger<String> exchanger = new Exchanger();\n\n    public static void main(String[] args) {\n\n        //代表男生和女生\n        ExecutorService service = Executors.newFixedThreadPool(2);\n\n        service.execute(() -> {\n            try {\n                //男生对女生说的话\n                String girl = exchanger.exchange("我其实暗恋你很久了......");\n                System.out.println("男孩儿说：" + girl);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n        service.execute(() -> {\n            try {\n                System.out.println("女生慢慢的从教室你走出来......");\n                TimeUnit.SECONDS.sleep(3);\n                //女生对男生说的话\n                String boy = exchanger.exchange("我也很喜欢你......");\n                System.out.println("女孩儿说：" + boy);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n\n    }\n}\n\n输出结果：\n\n女生慢慢的从教室你走出来......\n男孩儿说：我其实暗恋你很久了......\n女孩儿说：我也很喜欢你......\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n这个例子很简单，也很能说明Exchanger的基本使用。当两个线程都到达调用exchange方法的同步点的时候，两个线程就能交换彼此的数据。',normalizedContent:'说明\n\njava并发工具类-semaphore，exchanger\n\n\n\n\n\n\n\n\n# java并发工具类-semaphore，exchanger\n\n\n# 1、控制资源并发访问--semaphore\n\nsemaphore可以理解为信号量，用于控制资源能够被并发访问的线程数量，以保证多个线程能够合理的使用特定资源。semaphore就相当于一个许可证，线程需要先通过acquire方法获取该许可证，该线程才能继续往下执行，否则只能在该方法出阻塞等待。当执行完业务功能后，需要通过release()方法将许可证归还，以便其他线程能够获得许可证继续执行。\n\nsemaphore可以用于做流量控制，特别是公共资源有限的应用场景，比如数据库连接。假如有多个线程读取数据后，需要将数据保存在数据库中，而可用的最大数据库连接只有10个，这时候就需要使用semaphore来控制能够并发访问到数据库连接资源的线程个数最多只有10个。在限制资源使用的应用场景下，semaphore是特别合适的。\n\n下面来看下semaphore的主要方法：\n\n//获取许可，如果无法获取到，则阻塞等待直至能够获取为止\nvoid acquire() throws interruptedexception\n\n//同acquire方法功能基本一样，只不过该方法可以一次获取多个许可\nvoid acquire(int permits) throws interruptedexception\n\n//释放许可\nvoid release()\n\n//释放指定个数的许可\nvoid release(int permits)\n\n//尝试获取许可，如果能够获取成功则立即返回true，否则，则返回false\nboolean tryacquire()\n\n//与tryacquire方法一致，只不过这里可以指定获取多个许可\nboolean tryacquire(int permits)\n\n//尝试获取许可，如果能够立即获取到或者在指定时间内能够获取到，则返回true，否则返回false\nboolean tryacquire(long timeout, timeunit unit) throws interruptedexception\n\n//与上一个方法一致，只不过这里能够获取多个许可\nboolean tryacquire(int permits, long timeout, timeunit unit)\n\n//返回当前可用的许可证个数\nint availablepermits()\n\n//返回正在等待获取许可证的线程数\nint getqueuelength()\n\n//是否有线程正在等待获取许可证\nboolean hasqueuedthreads()\n\n//获取所有正在等待许可的线程集合\ncollection<thread> getqueuedthreads()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n另外，在semaphore的构造方法中还支持指定是够具有公平性，默认的是非公平性，这样也是为了保证吞吐量。\n\n> 一个例子\n\n下面用一个简单的例子来说明semaphore的具体使用。我们来模拟这样一样场景。有一天，班主任需要班上10个同学到讲台上来填写一个表格，但是老师只准备了5支笔，因此，只能保证同时只有5个同学能够拿到笔并填写表格，没有获取到笔的同学只能够等前面的同学用完之后，才能拿到笔去填写表格。该示例代码如下：\n\npublic class semaphoredemo {\n\n    //表示老师只有10支笔\n    private static semaphore semaphore = new semaphore(5);\n\n    public static void main(string[] args) {\n\n        //表示50个学生\n        executorservice service = executors.newfixedthreadpool(10);\n        for (int i = 0; i < 10; i++) {\n            service.execute(() -> {\n                try {\n                    system.out.println(thread.currentthread().getname() + "  同学准备获取笔......");\n                    semaphore.acquire();\n                    system.out.println(thread.currentthread().getname() + "  同学获取到笔");\n                    system.out.println(thread.currentthread().getname() + "  填写表格ing.....");\n                    timeunit.seconds.sleep(3);\n                    semaphore.release();\n                    system.out.println(thread.currentthread().getname() + "  填写完表格，归还了笔！！！！！！");\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            });\n        }\n        service.shutdown();\n    }\n\n}\n输出结果：\n\npool-1-thread-1  同学准备获取笔......\npool-1-thread-1  同学获取到笔\npool-1-thread-1  填写表格ing.....\npool-1-thread-2  同学准备获取笔......\npool-1-thread-2  同学获取到笔\npool-1-thread-2  填写表格ing.....\npool-1-thread-3  同学准备获取笔......\npool-1-thread-4  同学准备获取笔......\npool-1-thread-3  同学获取到笔\npool-1-thread-4  同学获取到笔\npool-1-thread-4  填写表格ing.....\npool-1-thread-3  填写表格ing.....\npool-1-thread-5  同学准备获取笔......\npool-1-thread-5  同学获取到笔\npool-1-thread-5  填写表格ing.....\n\n\npool-1-thread-6  同学准备获取笔......\npool-1-thread-7  同学准备获取笔......\npool-1-thread-8  同学准备获取笔......\npool-1-thread-9  同学准备获取笔......\npool-1-thread-10  同学准备获取笔......\n\n\npool-1-thread-4  填写完表格，归还了笔！！！！！！\npool-1-thread-9  同学获取到笔\npool-1-thread-9  填写表格ing.....\npool-1-thread-5  填写完表格，归还了笔！！！！！！\npool-1-thread-7  同学获取到笔\npool-1-thread-7  填写表格ing.....\npool-1-thread-8  同学获取到笔\npool-1-thread-8  填写表格ing.....\npool-1-thread-1  填写完表格，归还了笔！！！！！！\npool-1-thread-6  同学获取到笔\npool-1-thread-6  填写表格ing.....\npool-1-thread-3  填写完表格，归还了笔！！！！！！\npool-1-thread-2  填写完表格，归还了笔！！！！！！\npool-1-thread-10  同学获取到笔\npool-1-thread-10  填写表格ing.....\npool-1-thread-7  填写完表格，归还了笔！！！！！！\npool-1-thread-9  填写完表格，归还了笔！！！！！！\npool-1-thread-8  填写完表格，归还了笔！！！！！！\npool-1-thread-6  填写完表格，归还了笔！！！！！！\npool-1-thread-10  填写完表格，归还了笔！！！！！！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n根据输出结果进行分析，semaphore允许的最大许可数为5，也就是允许的最大并发执行的线程个数为5，可以看出，前5个线程（前5个学生）先获取到笔，然后填写表格，而6-10这5个线程，由于获取不到许可，只能阻塞等待。当线程pool-1-thread-4释放了许可之后，pool-1-thread-9就可以获取到许可，继续往下执行。对其他线程的执行过程，也是同样的道理。从这个例子就可以看出，semaphore用来做特殊资源的并发访问控制是相当合适的，如果有业务场景需要进行流量控制，可以优先考虑semaphore。\n\n\n# 2、线程间交换数据的工具--exchanger\n\nexchanger是一个用于线程间协作的工具类，用于两个线程间能够交换。它提供了一个交换的同步点，在这个同步点两个线程能够交换数据。具体交换数据是通过exchange方法来实现的，如果一个线程先执行exchange方法，那么它会同步等待另一个线程也执行exchange方法，这个时候两个线程就都达到了同步点，两个线程就可以交换数据。\n\nexchanger除了一个无参的构造方法外，主要方法也很简单：\n\n//当一个线程执行该方法的时候，会等待另一个线程也执行该方法，因此两个线程就都达到了同步点\n//将数据交换给另一个线程，同时返回获取的数据\nv exchange(v x) throws interruptedexception\n\n//同上一个方法功能基本一样，只不过这个方法同步等待的时候，增加了超时时间\nv exchange(v x, long timeout, timeunit unit)\n    throws interruptedexception, timeoutexception\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 一个例子\n\nexchanger理解起来很容易，这里用一个简单的例子来看下它的具体使用。我们来模拟这样一个情景，在青春洋溢的中学时代，下课期间，男生经常会给走廊里为自己喜欢的女孩子送情书，相信大家都做过这样的事情吧 。男孩会先到女孩教室门口，然后等女孩出来，教室那里就是一个同步点，然后彼此交换信物，也就是彼此交换了数据。现在，就来模拟这个情景。\n\npublic class exchangerdemo {\n    private static exchanger<string> exchanger = new exchanger();\n\n    public static void main(string[] args) {\n\n        //代表男生和女生\n        executorservice service = executors.newfixedthreadpool(2);\n\n        service.execute(() -> {\n            try {\n                //男生对女生说的话\n                string girl = exchanger.exchange("我其实暗恋你很久了......");\n                system.out.println("男孩儿说：" + girl);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        });\n        service.execute(() -> {\n            try {\n                system.out.println("女生慢慢的从教室你走出来......");\n                timeunit.seconds.sleep(3);\n                //女生对男生说的话\n                string boy = exchanger.exchange("我也很喜欢你......");\n                system.out.println("女孩儿说：" + boy);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        });\n\n    }\n}\n\n输出结果：\n\n女生慢慢的从教室你走出来......\n男孩儿说：我其实暗恋你很久了......\n女孩儿说：我也很喜欢你......\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n这个例子很简单，也很能说明exchanger的基本使用。当两个线程都到达调用exchange方法的同步点的时候，两个线程就能交换彼此的数据。',charsets:{cjk:!0},createdTime:1655628697e3},{title:"Java并发编程的艺术",frontmatter:{title:"Java并发编程的艺术",date:"2022-03-27T13:44:15.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],publish:!1,readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/",relativePath:"Java/Java并发编程的艺术/README.md",key:"v-36962f7c",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/",lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:null,content:"说明\n\nJava并发编程部分主要参考了《Java并发编程的艺术》一书，并写了以下博客（见侧边栏）。\n\n * 并发编程面临的挑战\n * 线程的状态转换以及基本操作\n * Java内存模型以及happens-before\n * 彻底理解synchronized\n * 彻底理解volatile\n * 你真的了解final吗？\n * 三大性质总结：原子性、可见性以及有序性\n * 初识Lock与AbstractQueuedSynchronizer(AQS)\n * 深入理解AbstractQueuedSynchronizer(AQS)\n * ReentrantLock的重入性与公平性\n * 深入理解读写锁ReentrantReadWriteLock\n * 详解Condition的线程通信机制\n * LockSupport工具\n * 并发容器之ConcurrentHashMap(JDK1.8)\n * 并发容器之ConcurrentLinkedQueue\n * 并发容器之CopyOnWriteArrayList\n * 并发容器之ThreadLocal\n * 并发容器之BlockingQueue\n * 线程池ThreadPoolExecutor实现原理\n * 线程池之ScheduledThreadPoolExecutor\n * FutureTask源码解析\n * Java中atomic包中的原子操作类总结\n * CountDownLatch与CyclicBarrier计数器\n * java并发工具类-Semaphore，Exchanger\n * 彻底弄懂生产者--消费者问题",normalizedContent:"说明\n\njava并发编程部分主要参考了《java并发编程的艺术》一书，并写了以下博客（见侧边栏）。\n\n * 并发编程面临的挑战\n * 线程的状态转换以及基本操作\n * java内存模型以及happens-before\n * 彻底理解synchronized\n * 彻底理解volatile\n * 你真的了解final吗？\n * 三大性质总结：原子性、可见性以及有序性\n * 初识lock与abstractqueuedsynchronizer(aqs)\n * 深入理解abstractqueuedsynchronizer(aqs)\n * reentrantlock的重入性与公平性\n * 深入理解读写锁reentrantreadwritelock\n * 详解condition的线程通信机制\n * locksupport工具\n * 并发容器之concurrenthashmap(jdk1.8)\n * 并发容器之concurrentlinkedqueue\n * 并发容器之copyonwritearraylist\n * 并发容器之threadlocal\n * 并发容器之blockingqueue\n * 线程池threadpoolexecutor实现原理\n * 线程池之scheduledthreadpoolexecutor\n * futuretask源码解析\n * java中atomic包中的原子操作类总结\n * countdownlatch与cyclicbarrier计数器\n * java并发工具类-semaphore，exchanger\n * 彻底弄懂生产者--消费者问题",charsets:{cjk:!0},createdTime:1655628697e3},{title:"彻底弄懂生产者--消费者问题",frontmatter:{title:"彻底弄懂生产者--消费者问题",description:"彻底弄懂生产者--消费者问题",date:"2022-04-16T14:15:00.000Z",next:!1,tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/25%E3%80%81%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%E7%94%9F%E4%BA%A7%E8%80%85--%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98.html",relativePath:"Java/Java并发编程的艺术/25、彻底弄懂生产者--消费者问题.md",key:"v-008512f6",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/25%E3%80%81%E5%BD%BB%E5%BA%95%E5%BC%84%E6%87%82%E7%94%9F%E4%BA%A7%E8%80%85--%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98.html",headers:[{level:2,title:"1.1 预备知识",slug:"_1-1-预备知识",normalizedTitle:"1.1 预备知识",charIndex:25},{level:2,title:"1.2 wait/notify消息通知潜在的一些问题",slug:"_1-2-wait-notify消息通知潜在的一些问题",normalizedTitle:"1.2 wait/notify消息通知潜在的一些问题",charIndex:37},{level:3,title:"notify过早通知",slug:"notify过早通知",normalizedTitle:"notify过早通知",charIndex:69},{level:3,title:"等待wait的条件发生变化",slug:"等待wait的条件发生变化",normalizedTitle:"等待wait的条件发生变化",charIndex:85},{level:3,title:"“假死”状态",slug:"假死-状态",normalizedTitle:"“假死”状态",charIndex:104},{level:2,title:"1.3 wait/notifyAll实现生产者-消费者",slug:"_1-3-wait-notifyall实现生产者-消费者",normalizedTitle:"1.3 wait/notifyall实现生产者-消费者",charIndex:114}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>彻底弄懂生产者--消费者问题</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"1.1 预备知识 1.2 wait/notify消息通知潜在的一些问题 notify过早通知 等待wait的条件发生变化 “假死”状态 1.3 wait/notifyAll实现生产者-消费者",content:'说明\n\n彻底弄懂生产者--消费者问题\n\n\n\n * 1.1 预备知识\n * 1.2 wait/notify消息通知潜在的一些问题\n   * notify过早通知\n   * 等待wait的条件发生变化\n   * “假死”状态\n * 1.3 wait/notifyAll实现生产者-消费者\n\n\n\n\n# 彻底弄懂生产者--消费者问题\n\n生产者-消费者模式是一个十分经典的多线程并发协作的模式，弄懂生产者-消费者问题能够让我们对并发编程的理解加深。所谓生产者-消费者问题，实际上主要是包含了两类线程，一种是生产者线程用于生产数据，另一种是消费者线程用于消费数据，为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库，生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为；而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。但是，这个共享数据区域中应该具备这样的线程间并发协作的功能：\n\n 1. 如果共享数据区已满的话，阻塞生产者继续生产数据放置入内；\n 2. 如果共享数据区为空的话，阻塞消费者继续消费数据；\n\n在实现生产者消费者问题时，可以采用三种方式：\n\n 1. 使用Object的wait/notify的消息通知机制；\n\n 2. 使用Lock的Condition的await/signal的消息通知机制；\n\n 3. 使用BlockingQueue实现。\n\n本文主要将这三种实现方式进行总结归纳。\n\n\n# 1、wait/notify的消息通知机制\n\n\n# 1.1 预备知识\n\nJava 中，可以通过配合调用 Object 对象的 wait() 方法和 notify()方法或 notifyAll() 方法来实现线程间的通信。在线程中调用 wait() 方法，将阻塞当前线程，直至等到其他线程调用了调用 notify() 方法或 notifyAll() 方法进行通知之后，当前线程才能从wait()方法出返回，继续执行下面的操作。\n\n 1. wait\n    \n    该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。在调用wait()之前，线程必须要获得该对象的对象监视器锁，即只能在同步方法或同步块中调用 wait()方法。调用wait()方法之后，当前线程会释放锁。如果调用wait()方法时，线程并未获取到锁的话，则会抛出IllegalMonitorStateException异常，这是以个RuntimeException。如果再次获取到锁的话，当前线程才能从wait()方法处成功返回。\n\n 2. notify\n    \n    该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，如果调用 notify()时没有持有适当的锁，也会抛出 IllegalMonitorStateException。 该方法任意从WAITTING状态的线程中挑选一个进行通知，使得调用wait()方法的线程从等待队列移入到同步队列中，等待有机会再一次获取到锁，从而使得调用wait()方法的线程能够从wait()方法处退出。调用notify后，当前线程不会马上释放该对象锁，要等到程序退出同步块后，当前线程才会释放锁。\n\n 3. notifyAll 该方法与 notify ()方法的工作方式相同，重要的一点差异是： notifyAll 使所有原来在该对象上 wait 的线程统统退出WAITTING状态，使得他们全部从等待队列中移入到同步队列中去，等待下一次能够有机会获取到对象监视器锁。\n\n\n# 1.2 wait/notify消息通知潜在的一些问题\n\n\n# notify过早通知\n\nnotify 通知的遗漏很容易理解，即 threadA 还没开始 wait 的时候，threadB 已经 notify 了，这样，threadB 通知是没有任何响应的，当 threadB 退出 synchronized 代码块后，threadA 再开始 wait，便会一直阻塞等待，直到被别的线程打断。比如在下面的示例代码中，就模拟出notify早期通知带来的问题：\n\npublic class EarlyNotify {\n\n    private static String lockObject = "";\n\n    public static void main(String[] args) {\n        WaitThread waitThread = new WaitThread(lockObject);\n        NotifyThread notifyThread = new NotifyThread(lockObject);\n        notifyThread.start();\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        waitThread.start();\n    }\n\n    static class WaitThread extends Thread {\n        private String lock;\n\n        public WaitThread(String lock) {\n            this.lock = lock;\n        }\n\n        @Override\n        public void run() {\n            synchronized (lock) {\n                try {\n                    System.out.println(Thread.currentThread().getName() + "  进去代码块");\n                    System.out.println(Thread.currentThread().getName() + "  开始wait");\n                    lock.wait();\n                    System.out.println(Thread.currentThread().getName() + "   结束wait");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class NotifyThread extends Thread {\n        private String lock;\n\n        public NotifyThread(String lock) {\n            this.lock = lock;\n        }\n\n        @Override\n        public void run() {\n            synchronized (lock) {\n                System.out.println(Thread.currentThread().getName() + "  进去代码块");\n                System.out.println(Thread.currentThread().getName() + "  开始notify");\n                lock.notify();\n                System.out.println(Thread.currentThread().getName() + "   结束开始notify");\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n示例中开启了**两个线程，一个是WaitThread，另一个是NotifyThread。NotifyThread会先启动，先调用notify方法。然后WaitThread线程才启动，调用wait方法，但是由于通知过了，wait方法就无法再获取到相应的通知，因此WaitThread会一直在wait方法出阻塞，这种现象就是通知过早的现象。**针对这种现象，解决方法，一般是添加一个状态标志，让waitThread调用wait方法前先判断状态是否已经改变了没，如果通知早已发出的话，WaitThread就不再去wait。对上面的代码进行更正：\n\npublic class EarlyNotify {\n\n    private static String lockObject = "";\n    private static boolean isWait = true;\n\n    public static void main(String[] args) {\n        WaitThread waitThread = new WaitThread(lockObject);\n        NotifyThread notifyThread = new NotifyThread(lockObject);\n        notifyThread.start();\n        try {\n            Thread.sleep(3000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        waitThread.start();\n    }\n\n    static class WaitThread extends Thread {\n        private String lock;\n\n        public WaitThread(String lock) {\n            this.lock = lock;\n        }\n\n        @Override\n        public void run() {\n            synchronized (lock) {\n                try {\n                    while (isWait) {\n                        System.out.println(Thread.currentThread().getName() + "  进去代码块");\n                        System.out.println(Thread.currentThread().getName() + "  开始wait");\n                        lock.wait();\n                        System.out.println(Thread.currentThread().getName() + "   结束wait");\n                    }\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    static class NotifyThread extends Thread {\n        private String lock;\n\n        public NotifyThread(String lock) {\n            this.lock = lock;\n        }\n\n        @Override\n        public void run() {\n            synchronized (lock) {\n                System.out.println(Thread.currentThread().getName() + "  进去代码块");\n                System.out.println(Thread.currentThread().getName() + "  开始notify");\n                lock.notifyAll();\n                isWait = false;\n                System.out.println(Thread.currentThread().getName() + "   结束开始notify");\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n这段代码只是增加了一个isWait状态变量，NotifyThread调用notify方法后会对状态变量进行更新，在WaitThread中调用wait方法之前会先对状态变量进行判断，在该示例中，调用notify后将状态变量isWait改变为false，因此，在WaitThread中while对isWait判断后就不会执行wait方法，从而避免了Notify过早通知造成遗漏的情况。\n\n总结：在使用线程的等待/通知机制时，一般都要配合一个 boolean 变量值（或者其他能够判断真假的条件），在 notify 之前改变该 boolean 变量的值，让 wait 返回后能够退出 while 循环（一般都要在 wait 方法外围加一层 while 循环，以防止早期通知），或在通知被遗漏后，不会被阻塞在 wait 方法处。这样便保证了程序的正确性。\n\n\n# 等待wait的条件发生变化\n\n如果线程在等待时接受到了通知，但是之后等待的条件发生了变化，并没有再次对等待条件进行判断，也会导致程序出现错误。\n\n下面用一个例子来说明这种情况\n\npublic class ConditionChange {\nprivate static List<String> lockObject = new ArrayList();\n\n\npublic static void main(String[] args) {\n    Consumer consumer1 = new Consumer(lockObject);\n    Consumer consumer2 = new Consumer(lockObject);\n    Productor productor = new Productor(lockObject);\n    consumer1.start();\n    consumer2.start();\n    productor.start();\n}\n\n\nstatic class Consumer extends Thread {\n    private List<String> lock;\n\n    public Consumer(List lock) {\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lock) {\n            try {\n                //这里使用if的话，就会存在wait条件变化造成程序错误的问题\n                if (lock.isEmpty()) {\n                    System.out.println(Thread.currentThread().getName() + " list为空");\n                    System.out.println(Thread.currentThread().getName() + " 调用wait方法");\n                    lock.wait();\n                    System.out.println(Thread.currentThread().getName() + "  wait方法结束");\n                }\n                String element = lock.remove(0);\n                System.out.println(Thread.currentThread().getName() + " 取出第一个元素为：" + element);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n\n\nstatic class Productor extends Thread {\n    private List<String> lock;\n\n    public Productor(List lock) {\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lock) {\n            System.out.println(Thread.currentThread().getName() + " 开始添加元素");\n            lock.add(Thread.currentThread().getName());\n            lock.notifyAll();\n        }\n    }\n\n}\n\n会报异常：\n\nException in thread "Thread-1" Thread-0 list为空\nThread-0 调用wait方法\nThread-1 list为空\nThread-1 调用wait方法\nThread-2 开始添加元素\nThread-1  wait方法结束\njava.lang.IndexOutOfBoundsException: Index: 0, Size: 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n异常原因分析：在这个例子中一共开启了3个线程：Consumer1，Consumer2以及Productor。首先Consumer1调用了wait方法后，线程处于了WAITTING状态，并且将对象锁释放出来。因此，Consumer2能够获取对象锁，从而进入到同步代块中，当执行到wait方法时，同样的也会释放对象锁。因此，productor能够获取到对象锁，进入到同步代码块中，向list中插入数据后，通过notifyAll方法通知处于WAITING状态的Consumer1和Consumer2线程。consumer1得到对象锁后，从wait方法出退出，删除了一个元素让List为空，方法执行结束，退出同步块，释放掉对象锁。这个时候Consumer2获取到对象锁后，从wait方法退出，继续往下执行，这个时候Consumer2再执行lock.remove(0);就会出错，因为List由于Consumer1删除一个元素之后已经为空了。\n\n**解决方案：**通过上面的分析，可以看出Consumer2报异常是因为线程从wait方法退出之后没有再次对wait条件进行判断，因此，此时的wait条件已经发生了变化。解决办法就是，在wait退出之后再对条件进行判断即可。\n\npublic class ConditionChange {\nprivate static List<String> lockObject = new ArrayList();\n\n\npublic static void main(String[] args) {\n    Consumer consumer1 = new Consumer(lockObject);\n    Consumer consumer2 = new Consumer(lockObject);\n    Productor productor = new Productor(lockObject);\n    consumer1.start();\n    consumer2.start();\n    productor.start();\n}\n\n\nstatic class Consumer extends Thread {\n    private List<String> lock;\n\n    public Consumer(List lock) {\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lock) {\n            try {\n                //这里使用if的话，就会存在wait条件变化造成程序错误的问题\n                while (lock.isEmpty()) {\n                    System.out.println(Thread.currentThread().getName() + " list为空");\n                    System.out.println(Thread.currentThread().getName() + " 调用wait方法");\n                    lock.wait();\n                    System.out.println(Thread.currentThread().getName() + "  wait方法结束");\n                }\n                String element = lock.remove(0);\n                System.out.println(Thread.currentThread().getName() + " 取出第一个元素为：" + element);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n\n\nstatic class Productor extends Thread {\n    private List<String> lock;\n\n    public Productor(List lock) {\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        synchronized (lock) {\n            System.out.println(Thread.currentThread().getName() + " 开始添加元素");\n            lock.add(Thread.currentThread().getName());\n            lock.notifyAll();\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n上面的代码与之前的代码仅仅只是将 wait 外围的 if 语句改为 while 循环即可，这样当 list 为空时，线程便会继续等待，而不会继续去执行删除 list 中元素的代码。\n\n总结：在使用线程的等待/通知机制时，一般都要在 while 循环中调用 wait()方法，因此配合使用一个 boolean 变量（或其他能判断真假的条件，如本文中的 list.isEmpty()），满足 while 循环的条件时，进入 while 循环，执行 wait()方法，不满足 while 循环的条件时，跳出循环，执行后面的代码。\n\n\n# “假死”状态\n\n现象：如果是多消费者和多生产者情况，如果使用notify方法可能会出现“假死”的情况，即唤醒的是同类线程。\n\n原因分析：假设当前多个生产者线程会调用wait方法阻塞等待，当其中的生产者线程获取到对象锁之后使用notify通知处于WAITTING状态的线程，如果唤醒的仍然是生产者线程，就会造成所有的生产者线程都处于等待状态。\n\n解决办法：将notify方法替换成notifyAll方法，如果使用的是lock的话，就将signal方法替换成signalAll方法。\n\n> [!tip]在Object提供的消息通知机制应该遵循如下这些条件：\n> \n>  1. 永远在while循环中对条件进行判断而不是if语句中进行wait条件的判断；\n>  2. 使用NotifyAll而不是使用notify。\n\n基本的使用范式如下：\n\n// The standard idiom for calling the wait method in Java\nsynchronized (sharedObject) {\n    while (condition) {\n    sharedObject.wait();\n        // (Releases lock, and reacquires on wakeup)\n    }\n    // do action based upon condition e.g. take or put into queue\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 1.3 wait/notifyAll实现生产者-消费者\n\n利用wait/notifyAll实现生产者和消费者代码如下：\n\npublic class ProductorConsumer {\n\n\npublic static void main(String[] args) {\n\n    LinkedList linkedList = new LinkedList();\n    ExecutorService service = Executors.newFixedThreadPool(15);\n    for (int i = 0; i < 5; i++) {\n        service.submit(new Productor(linkedList, 8));\n    }\n\n    for (int i = 0; i < 10; i++) {\n        service.submit(new Consumer(linkedList));\n    }\n\n}\n\nstatic class Productor implements Runnable {\n\n    private List<Integer> list;\n    private int maxLength;\n\n    public Productor(List list, int maxLength) {\n        this.list = list;\n        this.maxLength = maxLength;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            synchronized (list) {\n                try {\n                    while (list.size() == maxLength) {\n                        System.out.println("生产者" + Thread.currentThread().getName() + "  list已达到最大容量，进行wait");\n                        list.wait();\n                        System.out.println("生产者" + Thread.currentThread().getName() + "  退出wait");\n                    }\n                    Random random = new Random();\n                    int i = random.nextInt();\n                    System.out.println("生产者" + Thread.currentThread().getName() + " 生产数据" + i);\n                    list.add(i);\n                    list.notifyAll();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n\n        }\n    }\n}\n\n\nstatic class Consumer implements Runnable {\n\n    private List<Integer> list;\n\n    public Consumer(List list) {\n        this.list = list;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            synchronized (list) {\n                try {\n                    while (list.isEmpty()) {\n                        System.out.println("消费者" + Thread.currentThread().getName() + "  list为空，进行wait");\n                        list.wait();\n                        System.out.println("消费者" + Thread.currentThread().getName() + "  退出wait");\n                    }\n                    Integer element = list.remove(0);\n                    System.out.println("消费者" + Thread.currentThread().getName() + "  消费数据：" + element);\n                    list.notifyAll();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n\n}\n\n输出结果：\n\n生产者pool-1-thread-1 生产数据-232820990\n生产者pool-1-thread-1 生产数据1432164130\n生产者pool-1-thread-1 生产数据1057090222\n生产者pool-1-thread-1 生产数据1201395916\n生产者pool-1-thread-1 生产数据482766516\n生产者pool-1-thread-1  list以达到最大容量，进行wait\n消费者pool-1-thread-15  退出wait\n消费者pool-1-thread-15  消费数据：1237535349\n消费者pool-1-thread-15  消费数据：-1617438932\n消费者pool-1-thread-15  消费数据：-535396055\n消费者pool-1-thread-15  消费数据：-232820990\n消费者pool-1-thread-15  消费数据：1432164130\n消费者pool-1-thread-15  消费数据：1057090222\n消费者pool-1-thread-15  消费数据：1201395916\n消费者pool-1-thread-15  消费数据：482766516\n消费者pool-1-thread-15  list为空，进行wait\n生产者pool-1-thread-5  退出wait\n生产者pool-1-thread-5 生产数据1442969724\n生产者pool-1-thread-5 生产数据1177554422\n生产者pool-1-thread-5 生产数据-133137235\n生产者pool-1-thread-5 生产数据324882560\n生产者pool-1-thread-5 生产数据2065211573\n生产者pool-1-thread-5 生产数据253569900\n生产者pool-1-thread-5 生产数据571277922\n生产者pool-1-thread-5 生产数据1622323863\n生产者pool-1-thread-5  list以达到最大容量，进行wait\n消费者pool-1-thread-10  退出wait\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n\n\n\n# 2、使用await/signalAll实现生产者-消费者\n\n参照Object的wait和notify/notifyAll方法，Condition也提供了同样的方法：\n\n> 针对Object的wait方法\n\n 1. void await() throws InterruptedException：当前线程进入等待状态，如果其他线程调用condition的signal或者signalAll方法并且当前线程被选中唤醒；如果在等待状态中被中断会抛出被中断异常，如果当前等待线程从await()方法返回，那么表明该线程已经获取了Condition对象所对应的锁。\n 2. long awaitNanos(long nanosTimeout)：当前线程进入等待状态直到被通知，中断或者超时；\n 3. boolean await(long time, TimeUnit unit)throws InterruptedException：同第二种，支持自定义时间单位\n 4. boolean awaitUntil(Date deadline) throws InterruptedException：当前线程进入等待状态直到被通知，中断或者到了某个时间\n\n> 针对Object的notify/notifyAll方法\n\n 1. void signal()：唤醒一个等待在condition上的线程，将该线程从等待队列中转移到同步队列中，如果在同步队列中能够竞争到Lock则可以从等待方法中返回。\n 2. void signalAll()：与1的区别在于能够唤醒所有等待在condition上的线程\n\n如果采用lock中Conditon的消息通知原理来实现生产者-消费者问题，原理同使用wait/notifyAll一样。直接上代码：\n\npublic class ProductorConsumer {\n\nprivate static ReentrantLock lock = new ReentrantLock();\nprivate static Condition full = lock.newCondition();\nprivate static Condition empty = lock.newCondition();\n\npublic static void main(String[] args) {\n    LinkedList linkedList = new LinkedList();\n    ExecutorService service = Executors.newFixedThreadPool(15);\n    for (int i = 0; i < 5; i++) {\n        service.submit(new Productor(linkedList, 8, lock));\n    }\n    for (int i = 0; i < 10; i++) {\n        service.submit(new Consumer(linkedList, lock));\n    }\n\n}\n\nstatic class Productor implements Runnable {\n\n    private List<Integer> list;\n    private int maxLength;\n    private Lock lock;\n\n    public Productor(List list, int maxLength, Lock lock) {\n        this.list = list;\n        this.maxLength = maxLength;\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            lock.lock();\n            try {\n                while (list.size() == maxLength) {\n                    System.out.println("生产者" + Thread.currentThread().getName() + "  list以达到最大容量，进行wait");\n                    full.await();\n                    System.out.println("生产者" + Thread.currentThread().getName() + "  退出wait");\n                }\n                Random random = new Random();\n                int i = random.nextInt();\n                System.out.println("生产者" + Thread.currentThread().getName() + " 生产数据" + i);\n                list.add(i);\n                empty.signalAll();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n}\n\n\nstatic class Consumer implements Runnable {\n\n    private List<Integer> list;\n    private Lock lock;\n\n    public Consumer(List list, Lock lock) {\n        this.list = list;\n        this.lock = lock;\n    }\n\n    @Override\n    public void run() {\n        while (true) {\n            lock.lock();\n            try {\n                while (list.isEmpty()) {\n                    System.out.println("消费者" + Thread.currentThread().getName() + "  list为空，进行wait");\n                    empty.await();\n                    System.out.println("消费者" + Thread.currentThread().getName() + "  退出wait");\n                }\n                Integer element = list.remove(0);\n                System.out.println("消费者" + Thread.currentThread().getName() + "  消费数据：" + element);\n                full.signalAll();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n}\n\n输出结果：\n\n消费者pool-1-thread-9  消费数据：1146627506\n消费者pool-1-thread-9  消费数据：1508001019\n消费者pool-1-thread-9  消费数据：-600080565\n消费者pool-1-thread-9  消费数据：-1000305429\n消费者pool-1-thread-9  消费数据：-1270658620\n消费者pool-1-thread-9  消费数据：1961046169\n消费者pool-1-thread-9  消费数据：-307680655\n消费者pool-1-thread-9  list为空，进行wait\n消费者pool-1-thread-13  退出wait\n消费者pool-1-thread-13  list为空，进行wait\n消费者pool-1-thread-10  退出wait\n生产者pool-1-thread-5  退出wait\n生产者pool-1-thread-5 生产数据-892558288\n生产者pool-1-thread-5 生产数据-1917220008\n生产者pool-1-thread-5 生产数据2146351766\n生产者pool-1-thread-5 生产数据452445380\n生产者pool-1-thread-5 生产数据1695168334\n生产者pool-1-thread-5 生产数据1979746693\n生产者pool-1-thread-5 生产数据-1905436249\n生产者pool-1-thread-5 生产数据-101410137\n生产者pool-1-thread-5  list以达到最大容量，进行wait\n生产者pool-1-thread-1  退出wait\n生产者pool-1-thread-1  list以达到最大容量，进行wait\n生产者pool-1-thread-4  退出wait\n生产者pool-1-thread-4  list以达到最大容量，进行wait\n生产者pool-1-thread-2  退出wait\n生产者pool-1-thread-2  list以达到最大容量，进行wait\n生产者pool-1-thread-3  退出wait\n生产者pool-1-thread-3  list以达到最大容量，进行wait\n消费者pool-1-thread-9  退出wait\n消费者pool-1-thread-9  消费数据：-892558288\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n\n\n\n# 3、使用BlockingQueue实现生产者-消费者\n\n由于BlockingQueue内部实现就附加了两个阻塞操作。即当队列已满时，阻塞向队列中插入数据的线程，直至队列中未满；当队列为空时，阻塞从队列中获取数据的线程，直至队列非空时为止。关于BlockingQueue更多细节可以看之前的文章。可以利用BlockingQueue实现生产者-消费者为题，阻塞队列完全可以充当共享数据区域，就可以很好的完成生产者和消费者线程之间的协作。\n\npublic class ProductorConsumer {\n\n    private static LinkedBlockingQueue<Integer> queue = new LinkedBlockingQueue<>();\n\n    public static void main(String[] args) {\n        ExecutorService service = Executors.newFixedThreadPool(15);\n        for (int i = 0; i < 5; i++) {\n            service.submit(new Productor(queue));\n        }\n        for (int i = 0; i < 10; i++) {\n            service.submit(new Consumer(queue));\n        }\n    }\n\n\n    static class Productor implements Runnable {\n\n        private BlockingQueue queue;\n\n        public Productor(BlockingQueue queue) {\n            this.queue = queue;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    Random random = new Random();\n                    int i = random.nextInt();\n                    System.out.println("生产者" + Thread.currentThread().getName() + "生产数据" + i);\n                    queue.put(i);\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    static class Consumer implements Runnable {\n        private BlockingQueue queue;\n\n        public Consumer(BlockingQueue queue) {\n            this.queue = queue;\n        }\n\n        @Override\n        public void run() {\n            try {\n                while (true) {\n                    Integer element = (Integer) queue.take();\n                    System.out.println("消费者" + Thread.currentThread().getName() + "正在消费数据" + element);\n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n}\n\n\n输出结果：\n\n消费者pool-1-thread-7正在消费数据1520577501\n生产者pool-1-thread-4生产数据-127809610\n消费者pool-1-thread-8正在消费数据504316513\n生产者pool-1-thread-2生产数据1994678907\n消费者pool-1-thread-11正在消费数据1967302829\n生产者pool-1-thread-1生产数据369331507\n消费者pool-1-thread-9正在消费数据1994678907\n生产者pool-1-thread-2生产数据-919544017\n消费者pool-1-thread-12正在消费数据-127809610\n生产者pool-1-thread-4生产数据1475197572\n消费者pool-1-thread-14正在消费数据-893487914\n生产者pool-1-thread-3生产数据906921688\n消费者pool-1-thread-6正在消费数据-1292015016\n生产者pool-1-thread-5生产数据-652105379\n生产者pool-1-thread-5生产数据-1622505717\n生产者pool-1-thread-3生产数据-1350268764\n消费者pool-1-thread-7正在消费数据906921688\n生产者pool-1-thread-4生产数据2091628867\n消费者pool-1-thread-13正在消费数据1475197572\n消费者pool-1-thread-15正在消费数据-919544017\n生产者pool-1-thread-2生产数据564860122\n生产者pool-1-thread-2生产数据822954707\n消费者pool-1-thread-14正在消费数据564860122\n消费者pool-1-thread-10正在消费数据369331507\n生产者pool-1-thread-1生产数据-245820912\n消费者pool-1-thread-6正在消费数据822954707\n生产者pool-1-thread-2生产数据1724595968\n生产者pool-1-thread-2生产数据-1151855115\n消费者pool-1-thread-12正在消费数据2091628867\n生产者pool-1-thread-4生产数据-1774364499\n生产者pool-1-thread-4生产数据2006106757\n消费者pool-1-thread-14正在消费数据-1774364499\n生产者pool-1-thread-3生产数据-1070853639\n消费者pool-1-thread-9正在消费数据-1350268764\n消费者pool-1-thread-11正在消费数据-1622505717\n生产者pool-1-thread-5生产数据355412953\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n\n\n可以看出，使用BlockingQueue来实现生产者-消费者很简洁，这正是利用了BlockingQueue插入和获取数据附加阻塞操作的特性。',normalizedContent:'说明\n\n彻底弄懂生产者--消费者问题\n\n\n\n * 1.1 预备知识\n * 1.2 wait/notify消息通知潜在的一些问题\n   * notify过早通知\n   * 等待wait的条件发生变化\n   * “假死”状态\n * 1.3 wait/notifyall实现生产者-消费者\n\n\n\n\n# 彻底弄懂生产者--消费者问题\n\n生产者-消费者模式是一个十分经典的多线程并发协作的模式，弄懂生产者-消费者问题能够让我们对并发编程的理解加深。所谓生产者-消费者问题，实际上主要是包含了两类线程，一种是生产者线程用于生产数据，另一种是消费者线程用于消费数据，为了解耦生产者和消费者的关系，通常会采用共享的数据区域，就像是一个仓库，生产者生产数据之后直接放置在共享数据区中，并不需要关心消费者的行为；而消费者只需要从共享数据区中去获取数据，就不再需要关心生产者的行为。但是，这个共享数据区域中应该具备这样的线程间并发协作的功能：\n\n 1. 如果共享数据区已满的话，阻塞生产者继续生产数据放置入内；\n 2. 如果共享数据区为空的话，阻塞消费者继续消费数据；\n\n在实现生产者消费者问题时，可以采用三种方式：\n\n 1. 使用object的wait/notify的消息通知机制；\n\n 2. 使用lock的condition的await/signal的消息通知机制；\n\n 3. 使用blockingqueue实现。\n\n本文主要将这三种实现方式进行总结归纳。\n\n\n# 1、wait/notify的消息通知机制\n\n\n# 1.1 预备知识\n\njava 中，可以通过配合调用 object 对象的 wait() 方法和 notify()方法或 notifyall() 方法来实现线程间的通信。在线程中调用 wait() 方法，将阻塞当前线程，直至等到其他线程调用了调用 notify() 方法或 notifyall() 方法进行通知之后，当前线程才能从wait()方法出返回，继续执行下面的操作。\n\n 1. wait\n    \n    该方法用来将当前线程置入休眠状态，直到接到通知或被中断为止。在调用wait()之前，线程必须要获得该对象的对象监视器锁，即只能在同步方法或同步块中调用 wait()方法。调用wait()方法之后，当前线程会释放锁。如果调用wait()方法时，线程并未获取到锁的话，则会抛出illegalmonitorstateexception异常，这是以个runtimeexception。如果再次获取到锁的话，当前线程才能从wait()方法处成功返回。\n\n 2. notify\n    \n    该方法也要在同步方法或同步块中调用，即在调用前，线程也必须要获得该对象的对象级别锁，如果调用 notify()时没有持有适当的锁，也会抛出 illegalmonitorstateexception。 该方法任意从waitting状态的线程中挑选一个进行通知，使得调用wait()方法的线程从等待队列移入到同步队列中，等待有机会再一次获取到锁，从而使得调用wait()方法的线程能够从wait()方法处退出。调用notify后，当前线程不会马上释放该对象锁，要等到程序退出同步块后，当前线程才会释放锁。\n\n 3. notifyall 该方法与 notify ()方法的工作方式相同，重要的一点差异是： notifyall 使所有原来在该对象上 wait 的线程统统退出waitting状态，使得他们全部从等待队列中移入到同步队列中去，等待下一次能够有机会获取到对象监视器锁。\n\n\n# 1.2 wait/notify消息通知潜在的一些问题\n\n\n# notify过早通知\n\nnotify 通知的遗漏很容易理解，即 threada 还没开始 wait 的时候，threadb 已经 notify 了，这样，threadb 通知是没有任何响应的，当 threadb 退出 synchronized 代码块后，threada 再开始 wait，便会一直阻塞等待，直到被别的线程打断。比如在下面的示例代码中，就模拟出notify早期通知带来的问题：\n\npublic class earlynotify {\n\n    private static string lockobject = "";\n\n    public static void main(string[] args) {\n        waitthread waitthread = new waitthread(lockobject);\n        notifythread notifythread = new notifythread(lockobject);\n        notifythread.start();\n        try {\n            thread.sleep(3000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        waitthread.start();\n    }\n\n    static class waitthread extends thread {\n        private string lock;\n\n        public waitthread(string lock) {\n            this.lock = lock;\n        }\n\n        @override\n        public void run() {\n            synchronized (lock) {\n                try {\n                    system.out.println(thread.currentthread().getname() + "  进去代码块");\n                    system.out.println(thread.currentthread().getname() + "  开始wait");\n                    lock.wait();\n                    system.out.println(thread.currentthread().getname() + "   结束wait");\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }\n    }\n\n    static class notifythread extends thread {\n        private string lock;\n\n        public notifythread(string lock) {\n            this.lock = lock;\n        }\n\n        @override\n        public void run() {\n            synchronized (lock) {\n                system.out.println(thread.currentthread().getname() + "  进去代码块");\n                system.out.println(thread.currentthread().getname() + "  开始notify");\n                lock.notify();\n                system.out.println(thread.currentthread().getname() + "   结束开始notify");\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n示例中开启了**两个线程，一个是waitthread，另一个是notifythread。notifythread会先启动，先调用notify方法。然后waitthread线程才启动，调用wait方法，但是由于通知过了，wait方法就无法再获取到相应的通知，因此waitthread会一直在wait方法出阻塞，这种现象就是通知过早的现象。**针对这种现象，解决方法，一般是添加一个状态标志，让waitthread调用wait方法前先判断状态是否已经改变了没，如果通知早已发出的话，waitthread就不再去wait。对上面的代码进行更正：\n\npublic class earlynotify {\n\n    private static string lockobject = "";\n    private static boolean iswait = true;\n\n    public static void main(string[] args) {\n        waitthread waitthread = new waitthread(lockobject);\n        notifythread notifythread = new notifythread(lockobject);\n        notifythread.start();\n        try {\n            thread.sleep(3000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n        waitthread.start();\n    }\n\n    static class waitthread extends thread {\n        private string lock;\n\n        public waitthread(string lock) {\n            this.lock = lock;\n        }\n\n        @override\n        public void run() {\n            synchronized (lock) {\n                try {\n                    while (iswait) {\n                        system.out.println(thread.currentthread().getname() + "  进去代码块");\n                        system.out.println(thread.currentthread().getname() + "  开始wait");\n                        lock.wait();\n                        system.out.println(thread.currentthread().getname() + "   结束wait");\n                    }\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }\n    }\n\n    static class notifythread extends thread {\n        private string lock;\n\n        public notifythread(string lock) {\n            this.lock = lock;\n        }\n\n        @override\n        public void run() {\n            synchronized (lock) {\n                system.out.println(thread.currentthread().getname() + "  进去代码块");\n                system.out.println(thread.currentthread().getname() + "  开始notify");\n                lock.notifyall();\n                iswait = false;\n                system.out.println(thread.currentthread().getname() + "   结束开始notify");\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n这段代码只是增加了一个iswait状态变量，notifythread调用notify方法后会对状态变量进行更新，在waitthread中调用wait方法之前会先对状态变量进行判断，在该示例中，调用notify后将状态变量iswait改变为false，因此，在waitthread中while对iswait判断后就不会执行wait方法，从而避免了notify过早通知造成遗漏的情况。\n\n总结：在使用线程的等待/通知机制时，一般都要配合一个 boolean 变量值（或者其他能够判断真假的条件），在 notify 之前改变该 boolean 变量的值，让 wait 返回后能够退出 while 循环（一般都要在 wait 方法外围加一层 while 循环，以防止早期通知），或在通知被遗漏后，不会被阻塞在 wait 方法处。这样便保证了程序的正确性。\n\n\n# 等待wait的条件发生变化\n\n如果线程在等待时接受到了通知，但是之后等待的条件发生了变化，并没有再次对等待条件进行判断，也会导致程序出现错误。\n\n下面用一个例子来说明这种情况\n\npublic class conditionchange {\nprivate static list<string> lockobject = new arraylist();\n\n\npublic static void main(string[] args) {\n    consumer consumer1 = new consumer(lockobject);\n    consumer consumer2 = new consumer(lockobject);\n    productor productor = new productor(lockobject);\n    consumer1.start();\n    consumer2.start();\n    productor.start();\n}\n\n\nstatic class consumer extends thread {\n    private list<string> lock;\n\n    public consumer(list lock) {\n        this.lock = lock;\n    }\n\n    @override\n    public void run() {\n        synchronized (lock) {\n            try {\n                //这里使用if的话，就会存在wait条件变化造成程序错误的问题\n                if (lock.isempty()) {\n                    system.out.println(thread.currentthread().getname() + " list为空");\n                    system.out.println(thread.currentthread().getname() + " 调用wait方法");\n                    lock.wait();\n                    system.out.println(thread.currentthread().getname() + "  wait方法结束");\n                }\n                string element = lock.remove(0);\n                system.out.println(thread.currentthread().getname() + " 取出第一个元素为：" + element);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n\n}\n\n\nstatic class productor extends thread {\n    private list<string> lock;\n\n    public productor(list lock) {\n        this.lock = lock;\n    }\n\n    @override\n    public void run() {\n        synchronized (lock) {\n            system.out.println(thread.currentthread().getname() + " 开始添加元素");\n            lock.add(thread.currentthread().getname());\n            lock.notifyall();\n        }\n    }\n\n}\n\n会报异常：\n\nexception in thread "thread-1" thread-0 list为空\nthread-0 调用wait方法\nthread-1 list为空\nthread-1 调用wait方法\nthread-2 开始添加元素\nthread-1  wait方法结束\njava.lang.indexoutofboundsexception: index: 0, size: 0\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n异常原因分析：在这个例子中一共开启了3个线程：consumer1，consumer2以及productor。首先consumer1调用了wait方法后，线程处于了waitting状态，并且将对象锁释放出来。因此，consumer2能够获取对象锁，从而进入到同步代块中，当执行到wait方法时，同样的也会释放对象锁。因此，productor能够获取到对象锁，进入到同步代码块中，向list中插入数据后，通过notifyall方法通知处于waiting状态的consumer1和consumer2线程。consumer1得到对象锁后，从wait方法出退出，删除了一个元素让list为空，方法执行结束，退出同步块，释放掉对象锁。这个时候consumer2获取到对象锁后，从wait方法退出，继续往下执行，这个时候consumer2再执行lock.remove(0);就会出错，因为list由于consumer1删除一个元素之后已经为空了。\n\n**解决方案：**通过上面的分析，可以看出consumer2报异常是因为线程从wait方法退出之后没有再次对wait条件进行判断，因此，此时的wait条件已经发生了变化。解决办法就是，在wait退出之后再对条件进行判断即可。\n\npublic class conditionchange {\nprivate static list<string> lockobject = new arraylist();\n\n\npublic static void main(string[] args) {\n    consumer consumer1 = new consumer(lockobject);\n    consumer consumer2 = new consumer(lockobject);\n    productor productor = new productor(lockobject);\n    consumer1.start();\n    consumer2.start();\n    productor.start();\n}\n\n\nstatic class consumer extends thread {\n    private list<string> lock;\n\n    public consumer(list lock) {\n        this.lock = lock;\n    }\n\n    @override\n    public void run() {\n        synchronized (lock) {\n            try {\n                //这里使用if的话，就会存在wait条件变化造成程序错误的问题\n                while (lock.isempty()) {\n                    system.out.println(thread.currentthread().getname() + " list为空");\n                    system.out.println(thread.currentthread().getname() + " 调用wait方法");\n                    lock.wait();\n                    system.out.println(thread.currentthread().getname() + "  wait方法结束");\n                }\n                string element = lock.remove(0);\n                system.out.println(thread.currentthread().getname() + " 取出第一个元素为：" + element);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n\n}\n\n\nstatic class productor extends thread {\n    private list<string> lock;\n\n    public productor(list lock) {\n        this.lock = lock;\n    }\n\n    @override\n    public void run() {\n        synchronized (lock) {\n            system.out.println(thread.currentthread().getname() + " 开始添加元素");\n            lock.add(thread.currentthread().getname());\n            lock.notifyall();\n        }\n    }\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n上面的代码与之前的代码仅仅只是将 wait 外围的 if 语句改为 while 循环即可，这样当 list 为空时，线程便会继续等待，而不会继续去执行删除 list 中元素的代码。\n\n总结：在使用线程的等待/通知机制时，一般都要在 while 循环中调用 wait()方法，因此配合使用一个 boolean 变量（或其他能判断真假的条件，如本文中的 list.isempty()），满足 while 循环的条件时，进入 while 循环，执行 wait()方法，不满足 while 循环的条件时，跳出循环，执行后面的代码。\n\n\n# “假死”状态\n\n现象：如果是多消费者和多生产者情况，如果使用notify方法可能会出现“假死”的情况，即唤醒的是同类线程。\n\n原因分析：假设当前多个生产者线程会调用wait方法阻塞等待，当其中的生产者线程获取到对象锁之后使用notify通知处于waitting状态的线程，如果唤醒的仍然是生产者线程，就会造成所有的生产者线程都处于等待状态。\n\n解决办法：将notify方法替换成notifyall方法，如果使用的是lock的话，就将signal方法替换成signalall方法。\n\n> [!tip]在object提供的消息通知机制应该遵循如下这些条件：\n> \n>  1. 永远在while循环中对条件进行判断而不是if语句中进行wait条件的判断；\n>  2. 使用notifyall而不是使用notify。\n\n基本的使用范式如下：\n\n// the standard idiom for calling the wait method in java\nsynchronized (sharedobject) {\n    while (condition) {\n    sharedobject.wait();\n        // (releases lock, and reacquires on wakeup)\n    }\n    // do action based upon condition e.g. take or put into queue\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 1.3 wait/notifyall实现生产者-消费者\n\n利用wait/notifyall实现生产者和消费者代码如下：\n\npublic class productorconsumer {\n\n\npublic static void main(string[] args) {\n\n    linkedlist linkedlist = new linkedlist();\n    executorservice service = executors.newfixedthreadpool(15);\n    for (int i = 0; i < 5; i++) {\n        service.submit(new productor(linkedlist, 8));\n    }\n\n    for (int i = 0; i < 10; i++) {\n        service.submit(new consumer(linkedlist));\n    }\n\n}\n\nstatic class productor implements runnable {\n\n    private list<integer> list;\n    private int maxlength;\n\n    public productor(list list, int maxlength) {\n        this.list = list;\n        this.maxlength = maxlength;\n    }\n\n    @override\n    public void run() {\n        while (true) {\n            synchronized (list) {\n                try {\n                    while (list.size() == maxlength) {\n                        system.out.println("生产者" + thread.currentthread().getname() + "  list已达到最大容量，进行wait");\n                        list.wait();\n                        system.out.println("生产者" + thread.currentthread().getname() + "  退出wait");\n                    }\n                    random random = new random();\n                    int i = random.nextint();\n                    system.out.println("生产者" + thread.currentthread().getname() + " 生产数据" + i);\n                    list.add(i);\n                    list.notifyall();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n\n        }\n    }\n}\n\n\nstatic class consumer implements runnable {\n\n    private list<integer> list;\n\n    public consumer(list list) {\n        this.list = list;\n    }\n\n    @override\n    public void run() {\n        while (true) {\n            synchronized (list) {\n                try {\n                    while (list.isempty()) {\n                        system.out.println("消费者" + thread.currentthread().getname() + "  list为空，进行wait");\n                        list.wait();\n                        system.out.println("消费者" + thread.currentthread().getname() + "  退出wait");\n                    }\n                    integer element = list.remove(0);\n                    system.out.println("消费者" + thread.currentthread().getname() + "  消费数据：" + element);\n                    list.notifyall();\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }\n    }\n}\n\n}\n\n输出结果：\n\n生产者pool-1-thread-1 生产数据-232820990\n生产者pool-1-thread-1 生产数据1432164130\n生产者pool-1-thread-1 生产数据1057090222\n生产者pool-1-thread-1 生产数据1201395916\n生产者pool-1-thread-1 生产数据482766516\n生产者pool-1-thread-1  list以达到最大容量，进行wait\n消费者pool-1-thread-15  退出wait\n消费者pool-1-thread-15  消费数据：1237535349\n消费者pool-1-thread-15  消费数据：-1617438932\n消费者pool-1-thread-15  消费数据：-535396055\n消费者pool-1-thread-15  消费数据：-232820990\n消费者pool-1-thread-15  消费数据：1432164130\n消费者pool-1-thread-15  消费数据：1057090222\n消费者pool-1-thread-15  消费数据：1201395916\n消费者pool-1-thread-15  消费数据：482766516\n消费者pool-1-thread-15  list为空，进行wait\n生产者pool-1-thread-5  退出wait\n生产者pool-1-thread-5 生产数据1442969724\n生产者pool-1-thread-5 生产数据1177554422\n生产者pool-1-thread-5 生产数据-133137235\n生产者pool-1-thread-5 生产数据324882560\n生产者pool-1-thread-5 生产数据2065211573\n生产者pool-1-thread-5 生产数据253569900\n生产者pool-1-thread-5 生产数据571277922\n生产者pool-1-thread-5 生产数据1622323863\n生产者pool-1-thread-5  list以达到最大容量，进行wait\n消费者pool-1-thread-10  退出wait\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n\n\n\n# 2、使用await/signalall实现生产者-消费者\n\n参照object的wait和notify/notifyall方法，condition也提供了同样的方法：\n\n> 针对object的wait方法\n\n 1. void await() throws interruptedexception：当前线程进入等待状态，如果其他线程调用condition的signal或者signalall方法并且当前线程被选中唤醒；如果在等待状态中被中断会抛出被中断异常，如果当前等待线程从await()方法返回，那么表明该线程已经获取了condition对象所对应的锁。\n 2. long awaitnanos(long nanostimeout)：当前线程进入等待状态直到被通知，中断或者超时；\n 3. boolean await(long time, timeunit unit)throws interruptedexception：同第二种，支持自定义时间单位\n 4. boolean awaituntil(date deadline) throws interruptedexception：当前线程进入等待状态直到被通知，中断或者到了某个时间\n\n> 针对object的notify/notifyall方法\n\n 1. void signal()：唤醒一个等待在condition上的线程，将该线程从等待队列中转移到同步队列中，如果在同步队列中能够竞争到lock则可以从等待方法中返回。\n 2. void signalall()：与1的区别在于能够唤醒所有等待在condition上的线程\n\n如果采用lock中conditon的消息通知原理来实现生产者-消费者问题，原理同使用wait/notifyall一样。直接上代码：\n\npublic class productorconsumer {\n\nprivate static reentrantlock lock = new reentrantlock();\nprivate static condition full = lock.newcondition();\nprivate static condition empty = lock.newcondition();\n\npublic static void main(string[] args) {\n    linkedlist linkedlist = new linkedlist();\n    executorservice service = executors.newfixedthreadpool(15);\n    for (int i = 0; i < 5; i++) {\n        service.submit(new productor(linkedlist, 8, lock));\n    }\n    for (int i = 0; i < 10; i++) {\n        service.submit(new consumer(linkedlist, lock));\n    }\n\n}\n\nstatic class productor implements runnable {\n\n    private list<integer> list;\n    private int maxlength;\n    private lock lock;\n\n    public productor(list list, int maxlength, lock lock) {\n        this.list = list;\n        this.maxlength = maxlength;\n        this.lock = lock;\n    }\n\n    @override\n    public void run() {\n        while (true) {\n            lock.lock();\n            try {\n                while (list.size() == maxlength) {\n                    system.out.println("生产者" + thread.currentthread().getname() + "  list以达到最大容量，进行wait");\n                    full.await();\n                    system.out.println("生产者" + thread.currentthread().getname() + "  退出wait");\n                }\n                random random = new random();\n                int i = random.nextint();\n                system.out.println("生产者" + thread.currentthread().getname() + " 生产数据" + i);\n                list.add(i);\n                empty.signalall();\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n}\n\n\nstatic class consumer implements runnable {\n\n    private list<integer> list;\n    private lock lock;\n\n    public consumer(list list, lock lock) {\n        this.list = list;\n        this.lock = lock;\n    }\n\n    @override\n    public void run() {\n        while (true) {\n            lock.lock();\n            try {\n                while (list.isempty()) {\n                    system.out.println("消费者" + thread.currentthread().getname() + "  list为空，进行wait");\n                    empty.await();\n                    system.out.println("消费者" + thread.currentthread().getname() + "  退出wait");\n                }\n                integer element = list.remove(0);\n                system.out.println("消费者" + thread.currentthread().getname() + "  消费数据：" + element);\n                full.signalall();\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            } finally {\n                lock.unlock();\n            }\n        }\n    }\n}\n\n输出结果：\n\n消费者pool-1-thread-9  消费数据：1146627506\n消费者pool-1-thread-9  消费数据：1508001019\n消费者pool-1-thread-9  消费数据：-600080565\n消费者pool-1-thread-9  消费数据：-1000305429\n消费者pool-1-thread-9  消费数据：-1270658620\n消费者pool-1-thread-9  消费数据：1961046169\n消费者pool-1-thread-9  消费数据：-307680655\n消费者pool-1-thread-9  list为空，进行wait\n消费者pool-1-thread-13  退出wait\n消费者pool-1-thread-13  list为空，进行wait\n消费者pool-1-thread-10  退出wait\n生产者pool-1-thread-5  退出wait\n生产者pool-1-thread-5 生产数据-892558288\n生产者pool-1-thread-5 生产数据-1917220008\n生产者pool-1-thread-5 生产数据2146351766\n生产者pool-1-thread-5 生产数据452445380\n生产者pool-1-thread-5 生产数据1695168334\n生产者pool-1-thread-5 生产数据1979746693\n生产者pool-1-thread-5 生产数据-1905436249\n生产者pool-1-thread-5 生产数据-101410137\n生产者pool-1-thread-5  list以达到最大容量，进行wait\n生产者pool-1-thread-1  退出wait\n生产者pool-1-thread-1  list以达到最大容量，进行wait\n生产者pool-1-thread-4  退出wait\n生产者pool-1-thread-4  list以达到最大容量，进行wait\n生产者pool-1-thread-2  退出wait\n生产者pool-1-thread-2  list以达到最大容量，进行wait\n生产者pool-1-thread-3  退出wait\n生产者pool-1-thread-3  list以达到最大容量，进行wait\n消费者pool-1-thread-9  退出wait\n消费者pool-1-thread-9  消费数据：-892558288\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n\n\n\n# 3、使用blockingqueue实现生产者-消费者\n\n由于blockingqueue内部实现就附加了两个阻塞操作。即当队列已满时，阻塞向队列中插入数据的线程，直至队列中未满；当队列为空时，阻塞从队列中获取数据的线程，直至队列非空时为止。关于blockingqueue更多细节可以看之前的文章。可以利用blockingqueue实现生产者-消费者为题，阻塞队列完全可以充当共享数据区域，就可以很好的完成生产者和消费者线程之间的协作。\n\npublic class productorconsumer {\n\n    private static linkedblockingqueue<integer> queue = new linkedblockingqueue<>();\n\n    public static void main(string[] args) {\n        executorservice service = executors.newfixedthreadpool(15);\n        for (int i = 0; i < 5; i++) {\n            service.submit(new productor(queue));\n        }\n        for (int i = 0; i < 10; i++) {\n            service.submit(new consumer(queue));\n        }\n    }\n\n\n    static class productor implements runnable {\n\n        private blockingqueue queue;\n\n        public productor(blockingqueue queue) {\n            this.queue = queue;\n        }\n\n        @override\n        public void run() {\n            try {\n                while (true) {\n                    random random = new random();\n                    int i = random.nextint();\n                    system.out.println("生产者" + thread.currentthread().getname() + "生产数据" + i);\n                    queue.put(i);\n                }\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n\n    static class consumer implements runnable {\n        private blockingqueue queue;\n\n        public consumer(blockingqueue queue) {\n            this.queue = queue;\n        }\n\n        @override\n        public void run() {\n            try {\n                while (true) {\n                    integer element = (integer) queue.take();\n                    system.out.println("消费者" + thread.currentthread().getname() + "正在消费数据" + element);\n                }\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n\n}\n\n\n输出结果：\n\n消费者pool-1-thread-7正在消费数据1520577501\n生产者pool-1-thread-4生产数据-127809610\n消费者pool-1-thread-8正在消费数据504316513\n生产者pool-1-thread-2生产数据1994678907\n消费者pool-1-thread-11正在消费数据1967302829\n生产者pool-1-thread-1生产数据369331507\n消费者pool-1-thread-9正在消费数据1994678907\n生产者pool-1-thread-2生产数据-919544017\n消费者pool-1-thread-12正在消费数据-127809610\n生产者pool-1-thread-4生产数据1475197572\n消费者pool-1-thread-14正在消费数据-893487914\n生产者pool-1-thread-3生产数据906921688\n消费者pool-1-thread-6正在消费数据-1292015016\n生产者pool-1-thread-5生产数据-652105379\n生产者pool-1-thread-5生产数据-1622505717\n生产者pool-1-thread-3生产数据-1350268764\n消费者pool-1-thread-7正在消费数据906921688\n生产者pool-1-thread-4生产数据2091628867\n消费者pool-1-thread-13正在消费数据1475197572\n消费者pool-1-thread-15正在消费数据-919544017\n生产者pool-1-thread-2生产数据564860122\n生产者pool-1-thread-2生产数据822954707\n消费者pool-1-thread-14正在消费数据564860122\n消费者pool-1-thread-10正在消费数据369331507\n生产者pool-1-thread-1生产数据-245820912\n消费者pool-1-thread-6正在消费数据822954707\n生产者pool-1-thread-2生产数据1724595968\n生产者pool-1-thread-2生产数据-1151855115\n消费者pool-1-thread-12正在消费数据2091628867\n生产者pool-1-thread-4生产数据-1774364499\n生产者pool-1-thread-4生产数据2006106757\n消费者pool-1-thread-14正在消费数据-1774364499\n生产者pool-1-thread-3生产数据-1070853639\n消费者pool-1-thread-9正在消费数据-1350268764\n消费者pool-1-thread-11正在消费数据-1622505717\n生产者pool-1-thread-5生产数据355412953\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n\n\n可以看出，使用blockingqueue来实现生产者-消费者很简洁，这正是利用了blockingqueue插入和获取数据附加阻塞操作的特性。',charsets:{cjk:!0},createdTime:1655628697e3},{title:"CountDownLatch与CyclicBarrier计数器",frontmatter:{title:"CountDownLatch与CyclicBarrier计数器",description:"CountDownLatch与CyclicBarrier计数器",date:"2022-04-14T14:15:00.000Z",tags:["Java","Java并发编程","JUC"],categories:["技术"],readingShow:"top"},regularPath:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/23%E3%80%81CountDownLatch%E4%B8%8ECyclicBarrier%E8%AE%A1%E6%95%B0%E5%99%A8.html",relativePath:"Java/Java并发编程的艺术/23、CountDownLatch与CyclicBarrier计数器.md",key:"v-1252c4e0",path:"/Java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/23%E3%80%81CountDownLatch%E4%B8%8ECyclicBarrier%E8%AE%A1%E6%95%B0%E5%99%A8.html",headers:[{level:2,title:"CountDownLatch构造方法",slug:"countdownlatch构造方法",normalizedTitle:"countdownlatch构造方法",charIndex:42},{level:2,title:"CountDownLatch的await方法",slug:"countdownlatch的await方法",normalizedTitle:"countdownlatch的await方法",charIndex:64},{level:2,title:"acquireSharedInterruptibly方法",slug:"acquiresharedinterruptibly方法",normalizedTitle:"acquiresharedinterruptibly方法",charIndex:90},{level:2,title:"CountDownLatch的tryAcquireShared方法",slug:"countdownlatch的tryacquireshared方法",normalizedTitle:"countdownlatch的tryacquireshared方法",charIndex:122},{level:2,title:"doAcquireSharedInterruptibly方法",slug:"doacquiresharedinterruptibly方法",normalizedTitle:"doacquiresharedinterruptibly方法",charIndex:159},{level:2,title:"setHeadAndPropagate方法",slug:"setheadandpropagate方法",normalizedTitle:"setheadandpropagate方法",charIndex:193},{level:2,title:"doReleaseShared方法",slug:"doreleaseshared方法",normalizedTitle:"doreleaseshared方法",charIndex:218},{level:2,title:"CountDownLatch的countDown方法",slug:"countdownlatch的countdown方法",normalizedTitle:"countdownlatch的countdown方法",charIndex:239},{level:2,title:"releaseShared方法",slug:"releaseshared方法",normalizedTitle:"releaseshared方法",charIndex:269},{level:2,title:"CountDownLatch的tryReleaseShared方法",slug:"countdownlatch的tryreleaseshared方法",normalizedTitle:"countdownlatch的tryreleaseshared方法",charIndex:288},{level:2,title:"超时控制的await方法",slug:"超时控制的await方法",normalizedTitle:"超时控制的await方法",charIndex:325}],excerpt:'<div class="custom-block tip"><p class="custom-block-title">说明</p>\n<p>CountDownLatch与CyclicBarrier计数器</p>\n</div>\n',lastUpdated:"6/19/2022, 4:51:37 PM",lastUpdatedTimestamp:1655628697e3,headersStr:"CountDownLatch构造方法 CountDownLatch的await方法 acquireSharedInterruptibly方法 CountDownLatch的tryAcquireShared方法 doAcquireSharedInterruptibly方法 setHeadAndPropagate方法 doReleaseShared方法 CountDownLatch的countDown方法 releaseShared方法 CountDownLatch的tryReleaseShared方法 超时控制的await方法",content:'说明\n\nCountDownLatch与CyclicBarrier计数器\n\n\n\n * CountDownLatch构造方法\n * CountDownLatch的await方法\n * acquireSharedInterruptibly方法\n * CountDownLatch的tryAcquireShared方法\n * doAcquireSharedInterruptibly方法\n * setHeadAndPropagate方法\n * doReleaseShared方法\n * CountDownLatch的countDown方法\n * releaseShared方法\n * CountDownLatch的tryReleaseShared方法\n * 超时控制的await方法\n\n\n\n\n# CountDownLatch与CyclicBarrier计数器\n\n\n# 1、CountDownLatch是什么\n\nCountDownLatch是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、ConcurrentHashMap和BlockingQueue，它们都存在于java.util.concurrent包下。CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。\n\nCountDownLatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。\n\n执行过程如下图所示：\n\n\n\n\n# 2、CountDownLatch的使用\n\nCountDownLatch的方法不是很多，将它们一个个列举出来：\n\n 1. await() throws InterruptedException ：调用该方法的线程等到构造方法传入的N减到0的时候，才能继续往下执行；\n 2. await(long timeout, TimeUnit unit) ：与上面的await方法功能一致，只不过这里有了时间限制，调用该方法的线程等到指定的timeout时间后，不管N是否减至为0，都会继续往下执行；\n 3. countDown() ：使CountDownLatch初始值N减1；\n 4. long getCount() ：获取当前CountDownLatch维护的值；\n\n下面通过一个例子来说明一下CountDownLatch的使用，代码如下：\n\npublic class CountDownLatchDemo {\nprivate static CountDownLatch startSignal = new CountDownLatch(1);\n//用来表示裁判员需要维护的是6个运动员\nprivate static CountDownLatch endSignal = new CountDownLatch(6);\n\npublic static void main(String[] args) throws InterruptedException {\n    ExecutorService executorService = Executors.newFixedThreadPool(6);\n    for (int i = 0; i < 6; i++) {\n        executorService.execute(() -> {\n            try {\n                System.out.println(Thread.currentThread().getName() + " 运动员等待裁判员响哨！！！");\n                startSignal.await();\n                System.out.println(Thread.currentThread().getName() + "正在全力冲刺");\n                endSignal.countDown();\n                System.out.println(Thread.currentThread().getName() + "  到达终点");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n    }\n    System.out.println("裁判员发号施令啦！！！");\n    startSignal.countDown();\n    endSignal.await();\n    System.out.println("所有运动员到达终点，比赛结束！");\n    executorService.shutdown();\n}\n\n输出结果：\n\npool-1-thread-2 运动员等待裁判员响哨！！！\npool-1-thread-3 运动员等待裁判员响哨！！！\npool-1-thread-1 运动员等待裁判员响哨！！！\npool-1-thread-4 运动员等待裁判员响哨！！！\npool-1-thread-5 运动员等待裁判员响哨！！！\npool-1-thread-6 运动员等待裁判员响哨！！！\n裁判员发号施令啦！！！\npool-1-thread-2正在全力冲刺\npool-1-thread-2  到达终点\npool-1-thread-3正在全力冲刺\npool-1-thread-3  到达终点\npool-1-thread-1正在全力冲刺\npool-1-thread-1  到达终点\npool-1-thread-4正在全力冲刺\npool-1-thread-4  到达终点\npool-1-thread-5正在全力冲刺\npool-1-thread-5  到达终点\npool-1-thread-6正在全力冲刺\npool-1-thread-6  到达终点\n所有运动员到达终点，比赛结束！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n该示例代码中设置了两个CountDownLatch，第一个endSignal用于控制让main线程（裁判员）必须等到其他线程（运动员）让CountDownLatch维护的数值N减到0为止。另一个startSignal用于让main线程对其他线程进行“发号施令”，startSignal引用的CountDownLatch初始值为1，而其他线程执行的run方法中都会先通过 startSignal.await()让这些线程都被阻塞，直到main线程通过调用startSignal.countDown();，将值N减1，CountDownLatch维护的数值N为0后，其他线程才能往下执行，并且，每个线程执行的run方法中都会通过endSignal.countDown();对endSignal维护的数值进行减一，由于往线程池提交了6个任务，会被减6次，所以endSignal维护的值最终会变为0，因此main线程在latch.await();阻塞结束，才能继续往下执行。\n\n另外，需要注意的是，当调用CountDownLatch的countDown方法时，当前线程是不会被阻塞，会继续往下执行，比如在该例中会继续输出pool-1-thread-4 到达终点。\n\n\n# 3、AQS共享模式的实现\n\n\n# CountDownLatch构造方法\n\nCountDownLatch的构造方法如下：\n\npublic CountDownLatch(int count) {\n    if (count < 0) throw new IllegalArgumentException("count < 0");\n    this.sync = new Sync(count);\n}\n\n\n1\n2\n3\n4\n\n\n传入一个参数count，CountDownLatch也使用了内部类Sync来实现，Sync继承自AQS：\n\nprivate static final class Sync extends AbstractQueuedSynchronizer {\n    private static final long serialVersionUID = 4982264981922014374L;\n\n    Sync(int count) {\n        setState(count);\n    }\n\n    int getCount() {\n        return getState();\n    }\n\n    protected int tryAcquireShared(int acquires) {\n        return (getState() == 0) ? 1 : -1;\n    }\n\n    protected boolean tryReleaseShared(int releases) {\n        // Decrement count; signal when transition to zero\n        for (;;) {\n            int c = getState();\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            if (compareAndSetState(c, nextc))\n                return nextc == 0;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n这里调用了AQS类中的setState方法来设置count，AQS的state属性在之前的文章已经提到，它是AQS中的状态标识，具体的含义由子类来定义，可见这里把state定义为数量。\n\n\n# CountDownLatch的await方法\n\npublic void await() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n\n\n1\n2\n3\n\n\n直接调用了AQS类中的acquireSharedInterruptibly方法。\n\n\n# acquireSharedInterruptibly方法\n\npublic final void acquireSharedInterruptibly(int arg)\n            throws InterruptedException {\n    // 如果线程被中断则抛出异常\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    // 尝试获取共享锁，该方法在Sync类中实现\n    if (tryAcquireShared(arg) < 0)\n        // 如果获取失败，需要根据当前线程创建一个mode为SHARE的的Node放入队列中并循环获取\n        doAcquireSharedInterruptibly(arg);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这里的tryAcquireShared方法在Sync中被重写。\n\n\n# CountDownLatch的tryAcquireShared方法\n\nprotected int tryAcquireShared(int acquires) {\n    return (getState() == 0) ? 1 : -1;\n}\n\n\n1\n2\n3\n\n\n仅仅是根据状态来判断，如果state等于0的时候，说明计数器为0了，返回1表示成功，否则返回-1表示失败。\n\n\n# doAcquireSharedInterruptibly方法\n\nprivate void doAcquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n    // 创建一个共享模式的节点\n    final Node node = addWaiter(Node.SHARED);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final Node p = node.predecessor();\n            if (p == head) {\n                // 如果 p == head 表示是队列的第一个节点，尝试获取\n                int r = tryAcquireShared(arg);\n                if (r >= 0) {\n                    // 设置当前节点为head，并向后面的节点传播\n                    setHeadAndPropagate(node, r);\n                    p.next = null; // help GC\n                    failed = false;\n                    return;\n                }\n            }\n            if (shouldParkAfterFailedAcquire(p, node) &&\n                parkAndCheckInterrupt())\n                throw new InterruptedException();\n        }\n    } finally {\n        if (failed)\n            cancelAcquire(node);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n这里的重点是setHeadAndPropagate方法。\n\n\n# setHeadAndPropagate方法\n\nprivate void setHeadAndPropagate(Node node, int propagate) {\n    Node h = head; // Record old head for check below\n    setHead(node);\n    /*\n     * Try to signal next queued node if:\n     *   Propagation was indicated by caller,\n     *     or was recorded (as h.waitStatus either before\n     *     or after setHead) by a previous operation\n     *     (note: this uses sign-check of waitStatus because\n     *      PROPAGATE status may transition to SIGNAL.)\n     * and\n     *   The next node is waiting in shared mode,\n     *     or we don\'t know, because it appears null\n     *\n     * The conservatism in both of these checks may cause\n     * unnecessary wake-ups, but only when there are multiple\n     * racing acquires/releases, so most need signals now or soon\n     * anyway.\n     */\n    if (propagate > 0 || h == null || h.waitStatus < 0 ||\n        (h = head) == null || h.waitStatus < 0) {\n        Node s = node.next;\n        if (s == null || s.isShared())\n            doReleaseShared();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n首先先将之前的head记录一下，用于下面的判断；然后设置当前节点为头节点；最后再判断是否需要唤醒。这里的propagate值是根据tryAcquireShared方法的返回值传入的，所以对于CountDownLatch来说，如果获取成功，则应该是1。\n\n这里的if判断条件比较多，这里用了之前保存的head节点变量h来进行判断，让我疑惑的地方是，什么时候h会等于null？这个地方目前还没想明白。\n\n如果h.waitStatus >= 0，表示是初始状态或者是取消状态，那么当propagate <= 0时将不唤醒节点。\n\n获取node的下一个节点s，如果s == null || s.isShared()则释放节点并唤醒。为什么下一个节点为null的时候也需要唤醒操作呢？仔细理解一下这句话：\n\n> The conservatism in both of these checks may cause unnecessary wake-ups, but only when there are multiple racing acquires/releases, so most need signals now or soon anyway.\n\n这种保守的检查方式可能会引起多次不必要的线程唤醒操作，但这些情况仅存在于多线程并发的acquires/releases操作，所以大多线程数需要立即或者很快地一个信号。这个信号就是执行unpark方法。因为LockSupport在unpark的时候，相当于给了一个信号，即使这时候没有线程在park状态，之后有线程执行park的时候也会读到这个信号就不会被挂起。\n\n在简单点说，就是线程在执行时，如果之前没有unpark操作，在执行park时会阻塞该线程；但如果在park之前执行过一次或多次unpark（unpark调用多次和一次是一样的，结果不会累加）这时执行park时并不会阻塞该线程。\n\n所以，如果在唤醒node的时候下一个节点刚好添加到队列中，就可能避免了一次阻塞的操作。\n\n所以这里的propagate表示传播，传播的过程就是只要成功的获取到共享所就唤醒下一个节点。\n\n\n# doReleaseShared方法\n\nprivate void doReleaseShared() {\n    /*\n     * Ensure that a release propagates, even if there are other\n     * in-progress acquires/releases.  This proceeds in the usual\n     * way of trying to unparkSuccessor of head if it needs\n     * signal. But if it does not, status is set to PROPAGATE to\n     * ensure that upon release, propagation continues.\n     * Additionally, we must loop in case a new node is added\n     * while we are doing this. Also, unlike other uses of\n     * unparkSuccessor, we need to know if CAS to reset status\n     * fails, if so rechecking.\n     */\n    for (;;) {\n        Node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitStatus;\n            // 如果head的状态是SIGNAL，证明是等待一个信号，这时尝试将状态复位；\n            // 如果复位成功，则唤醒下一节点，否则继续循环。\n            if (ws == Node.SIGNAL) {\n                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                    continue;            // loop to recheck cases\n                unparkSuccessor(h);\n            }\n            // 如果状态是0，尝试设置状态为传播状态，表示节点向后传播；\n            // 如果不成功则继续循环。\n            else if (ws == 0 &&\n                     !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                continue;                // loop on failed CAS\n        }\n        // 如果头节点有变化，则继续循环\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n什么时候状态会是SIGNAL呢？回顾一下shouldParkAfterFailedAcquire方法：\n\nprivate static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n    int ws = pred.waitStatus;\n    if (ws == Node.SIGNAL)\n        /*\n         * This node has already set status asking a release\n         * to signal it, so it can safely park.\n         */\n        return true;\n    if (ws > 0) {\n        /*\n         * Predecessor was cancelled. Skip over predecessors and\n         * indicate retry.\n         */\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitStatus > 0);\n        pred.next = node;\n    } else {\n        /*\n         * waitStatus must be 0 or PROPAGATE.  Indicate that we\n         * need a signal, but don\'t park yet.  Caller will need to\n         * retry to make sure it cannot acquire before parking.\n         */\n        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n当状态不为CANCEL或者是SIGNAL时，为了保险起见，这里把状态都设置成了SIGNAL，然后会再次循环进行判断是否需要阻塞。\n\n回到doReleaseShared方法，这里为什么不直接把SIGNAL设置为PROPAGATE，而是先把SIGNAL设置为0，然后再设置为PROPAGATE呢？\n\n原因在于unparkSuccessor方法，该方法会判断当前节点的状态是否小于0，如果小于0则将h的状态设置为0，如果在这里直接设置为PROPAGATE状态的话，则相当于多做了一次CAS操作。unparkSuccessor中的代码如下：\n\nint ws = node.waitStatus;\nif (ws < 0)\n    compareAndSetWaitStatus(node, ws, 0);\n\n\n1\n2\n3\n\n\n其实这里只判断状态为SIGNAL和0还有另一个原因，那就是当前执行doReleaseShared循环时的状态只可能为SIGNAL和0，因为如果这时没有后继节点的话，当前节点状态没有被修改，是初始的0；如果在执行setHead方法之前，这时刚好有后继节点被添加到队列中的话，因为这时后继节点判断p == head为false，所以会执行shouldParkAfterFailedAcquire方法，将当前节点的状态设置为SIGNAL。当状态为0时设置状态为PROPAGATE成功，则判断h == head结果为true，表示当前节点是队列中的唯一一个节点，所以直接就返回了；如果为false，则说明已经有后继节点的线程设置了head，这时不返回继续循环，但刚才获取的h已经用不到了，等待着被回收。\n\n\n# CountDownLatch的countDown方法\n\npublic void countDown() {\n    sync.releaseShared(1);\n}\n\n\n1\n2\n3\n\n\n这里是调用了AQS中的releaseShared方法。\n\n\n# releaseShared方法\n\npublic final boolean releaseShared(int arg) {\n    // 尝试释放共享节点，如果成功则执行释放和唤醒操作\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这里调用的tryReleaseShared方法是在CountDownLatch中的Sync类重写的，而doReleaseShared方法已在上文中介绍过了。\n\n\n# CountDownLatch的tryReleaseShared方法\n\nprotected boolean tryReleaseShared(int releases) {\n    // Decrement count; signal when transition to zero\n    for (;;) {\n        // 获取计数器数量\n        int c = getState();\n        // 为0是返回false表示不需要释放\n        if (c == 0)\n            return false;\n        // 否则将计数器减1\n        int nextc = c-1;\n        if (compareAndSetState(c, nextc))\n            return nextc == 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这里设置state的操作需要循环来设置以确保成功。\n\n\n# 超时控制的await方法\n\n对应于上文中提到的doAcquireSharedInterruptibly方法，还有一个提供了超时控制的doAcquireSharedNanos方法，代码如下：\n\nprivate boolean doAcquireSharedNanos(int arg, long nanosTimeout)\n            throws InterruptedException {\n\tif (nanosTimeout <= 0L)\n\t    return false;\n\tfinal long deadline = System.nanoTime() + nanosTimeout;\n\tfinal Node node = addWaiter(Node.SHARED);\n\tboolean failed = true;\n\ttry {\n\t    for (;;) {\n\t        final Node p = node.predecessor();\n\t        if (p == head) {\n\t            int r = tryAcquireShared(arg);\n\t            if (r >= 0) {\n\t                setHeadAndPropagate(node, r);\n\t                p.next = null; // help GC\n\t                failed = false;\n\t                return true;\n\t            }\n\t        }\n\t        nanosTimeout = deadline - System.nanoTime();\n\t        if (nanosTimeout <= 0L)\n\t            return false;\n\t        if (shouldParkAfterFailedAcquire(p, node) &&\n\t            nanosTimeout > spinForTimeoutThreshold)\n\t            LockSupport.parkNanos(this, nanosTimeout);\n\t        if (Thread.interrupted())\n\t            throw new InterruptedException();\n\t    }\n\t} finally {\n\t    if (failed)\n\t        cancelAcquire(node);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n与doAcquireSharedInterruptibly方法新增了以下功能：\n\n * 增加了一个deadline变量表示超时的截止时间，根据当前时间与传入的nanosTimeout计算得出；\n * 每次循环判断是否已经超出截止时间，即deadline - System.nanoTime()是否大于0，大于0表示已经超时，返回false，小于0表示还未超时；\n * 如果未超时通过调用shouldParkAfterFailedAcquire方法判断是否需要park，如果返回true则再判断nanosTimeout > spinForTimeoutThreshold，spinForTimeoutThreshold是自旋的最小阈值，这里被Doug Lea设置成了1000，表示1000纳秒，也就是说如果剩余的时间不足1000纳秒，则不需要park。\n\n\n# 4、CountDownLatch总结\n\n本文分析了CountDownLatch的实现同时也是对AQS共享模式的分析，实现方式如下：\n\n调用await时\n\n * 共享锁获取失败（计数器还不为0），则将该线程封装为一个Node对象放入队列中，并阻塞该线程；\n * 共享锁获取成功（计数器为0），则从第一个节点开始依次唤醒后继节点，实现共享状态的传播。\n\n调用countDown时\n\n * 如果计数器不为0，则不释放，继续阻塞，并把state的值减1；\n * 如果计数器为0，则唤醒节点，解除线程的阻塞状态。\n\n> 在这里再对比一下独占模式和共享模式的相同点和不同点：\n\n相同点\n\n * 锁的获取和释放的判断都是由子类来实现的。\n\n不同点\n\n * 独占功能在获取节点之后并且还未释放时，其他的节点会一直阻塞，直到第一个节点被释放才会唤醒；\n * 共享功能在获取节点之后会立即唤醒队列中的后继节点，每一个节点都会唤醒自己的后继节点，这就是共享状态的传播。\n\n根据以上的总结可以看出，AQS不关心state具体是什么，含义由子类去定义，子类则根据该变量来进行获取和释放的判断，AQS只是维护了该变量，并且实现了一系列用来判断资源是否可以访问的API，它提供了对线程的入队和出队的操作，它还负责处理线程对资源的访问方式，例如：什么时候可以对资源进行访问，什么时候阻塞线程，什么时候唤醒线程，线程被取消后如何处理等。而子类则用来实现资源是否可以被访问的判断。\n\n\n# 5、循环栅栏：CyclicBarrier\n\nCyclicBarrier也是一种多线程并发控制的实用工具，和CountDownLatch一样具有等待计数的功能，但是相比于CountDownLatch功能更加强大。\n\n为了理解CyclicBarrier，这里举一个通俗的例子。开运动会时，会有跑步这一项运动，我们来模拟下运动员入场时的情况，假设有6条跑道，在比赛开始时，就需要6个运动员在比赛开始的时候都站在起点了，裁判员吹哨后才能开始跑步。跑道起点就相当于“barrier”，是临界点，而这6个运动员就类比成线程的话，就是这6个线程都必须到达指定点了，意味着凑齐了一波，然后才能继续执行，否则每个线程都得阻塞等待，直至凑齐一波即可。cyclic是循环的意思，也就是说CyclicBarrier当多个线程凑齐了一波之后，仍然有效，可以继续凑齐下一波。CyclicBarrier的执行示意图如下：\n\n\n\n当多个线程都达到了指定点后，才能继续往下继续执行。这就有点像报数的感觉，假设6个线程就相当于6个运动员，到赛道起点时会报数进行统计，如果刚好是6的话，这一波就凑齐了，才能往下执行。CyclicBarrier在使用一次后，下面依然有效，可以继续当做计数器使用，这是与CountDownLatch的区别之一。这里的6个线程，也就是计数器的初始值6，是通过CyclicBarrier的构造方法传入的。\n\n下面来看下CyclicBarrier的主要方法：\n\n//等到所有的线程都到达指定的临界点\nawait() throws InterruptedException, BrokenBarrierException\n\n//与上面的await方法功能基本一致，只不过这里有超时限制，阻塞等待直至到达超时时间为止\nawait(long timeout, TimeUnit unit) throws InterruptedException,\nBrokenBarrierException, TimeoutException\n\n//获取当前有多少个线程阻塞等待在临界点上\nint getNumberWaiting()\n\n//用于查询阻塞等待的线程是否被中断\nboolean isBroken()\n\n\n//将屏障重置为初始状态。如果当前有线程正在临界点等待的话，将抛出BrokenBarrierException。\nvoid reset()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n另外需要注意的是，CyclicBarrier提供了这样的构造方法：\n\npublic CyclicBarrier(int parties, Runnable barrierAction)\n\n\n1\n\n\n可以用来，当指定的线程都到达了指定的临界点的时，接下来执行的操作可以由barrierAction传入即可。\n\n> 一个例子\n\n下面用一个简单的例子，来看下CyclicBarrier的用法，我们来模拟下上面的运动员的例子。\n\npublic class CyclicBarrierDemo {\n    //指定必须有6个运动员到达才行\n    private static CyclicBarrier barrier = new CyclicBarrier(6, () -> {\n        System.out.println("所有运动员入场，裁判员一声令下！！！！！");\n    });\n    public static void main(String[] args) {\n        System.out.println("运动员准备进场，全场欢呼............");\n\n        ExecutorService service = Executors.newFixedThreadPool(6);\n        for (int i = 0; i < 6; i++) {\n            service.execute(() -> {\n                try {\n                    System.out.println(Thread.currentThread().getName() + " 运动员，进场");\n                    barrier.await();\n                    System.out.println(Thread.currentThread().getName() + "  运动员出发");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } catch (BrokenBarrierException e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n    }\n\n}\n\n输出结果：\n运动员准备进场，全场欢呼............\npool-1-thread-2 运动员，进场\npool-1-thread-1 运动员，进场\npool-1-thread-3 运动员，进场\npool-1-thread-4 运动员，进场\npool-1-thread-5 运动员，进场\npool-1-thread-6 运动员，进场\n所有运动员入场，裁判员一声令下！！！！！\npool-1-thread-6  运动员出发\npool-1-thread-1  运动员出发\npool-1-thread-5  运动员出发\npool-1-thread-4  运动员出发\npool-1-thread-3  运动员出发\npool-1-thread-2  运动员出发\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n从输出结果可以看出，当6个运动员（线程）都到达了指定的临界点（barrier）时候，才能继续往下执行，否则，则会阻塞等待在调用await()处\n\n\n# 6、CountDownLatch与CyclicBarrier的比较\n\nCountDownLatch与CyclicBarrier都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：\n\n 1. CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行；而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；CountDownLatch强调一个线程等多个线程完成某件事情。CyclicBarrier是多个线程互等，等大家都完成，再携手共进。\n 2. 调用CountDownLatch的countDown方法后，当前线程并不会阻塞，会继续往下执行；而调用CyclicBarrier的await方法，会阻塞当前线程，直到CyclicBarrier指定的线程全部都到达了指定点的时候，才能继续往下执行；\n 3. CountDownLatch方法比较少，操作比较简单，而CyclicBarrier提供的方法更多，比如能够通过getNumberWaiting()，isBroken()这些方法获取当前多个线程的状态，并且CyclicBarrier的构造方法可以传入barrierAction，指定当所有线程都到达时执行的业务功能；\n 4. CountDownLatch是不能复用的，而CyclicLatch是可以复用的。',normalizedContent:'说明\n\ncountdownlatch与cyclicbarrier计数器\n\n\n\n * countdownlatch构造方法\n * countdownlatch的await方法\n * acquiresharedinterruptibly方法\n * countdownlatch的tryacquireshared方法\n * doacquiresharedinterruptibly方法\n * setheadandpropagate方法\n * doreleaseshared方法\n * countdownlatch的countdown方法\n * releaseshared方法\n * countdownlatch的tryreleaseshared方法\n * 超时控制的await方法\n\n\n\n\n# countdownlatch与cyclicbarrier计数器\n\n\n# 1、countdownlatch是什么\n\ncountdownlatch是在java1.5被引入的，跟它一起被引入的并发工具类还有cyclicbarrier、semaphore、concurrenthashmap和blockingqueue，它们都存在于java.util.concurrent包下。countdownlatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。\n\ncountdownlatch是通过一个计数器来实现的，计数器的初始值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就会减1。当计数器值到达0时，它表示所有的线程已经完成了任务，然后在闭锁上等待的线程就可以恢复执行任务。\n\n执行过程如下图所示：\n\n\n\n\n# 2、countdownlatch的使用\n\ncountdownlatch的方法不是很多，将它们一个个列举出来：\n\n 1. await() throws interruptedexception ：调用该方法的线程等到构造方法传入的n减到0的时候，才能继续往下执行；\n 2. await(long timeout, timeunit unit) ：与上面的await方法功能一致，只不过这里有了时间限制，调用该方法的线程等到指定的timeout时间后，不管n是否减至为0，都会继续往下执行；\n 3. countdown() ：使countdownlatch初始值n减1；\n 4. long getcount() ：获取当前countdownlatch维护的值；\n\n下面通过一个例子来说明一下countdownlatch的使用，代码如下：\n\npublic class countdownlatchdemo {\nprivate static countdownlatch startsignal = new countdownlatch(1);\n//用来表示裁判员需要维护的是6个运动员\nprivate static countdownlatch endsignal = new countdownlatch(6);\n\npublic static void main(string[] args) throws interruptedexception {\n    executorservice executorservice = executors.newfixedthreadpool(6);\n    for (int i = 0; i < 6; i++) {\n        executorservice.execute(() -> {\n            try {\n                system.out.println(thread.currentthread().getname() + " 运动员等待裁判员响哨！！！");\n                startsignal.await();\n                system.out.println(thread.currentthread().getname() + "正在全力冲刺");\n                endsignal.countdown();\n                system.out.println(thread.currentthread().getname() + "  到达终点");\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        });\n    }\n    system.out.println("裁判员发号施令啦！！！");\n    startsignal.countdown();\n    endsignal.await();\n    system.out.println("所有运动员到达终点，比赛结束！");\n    executorservice.shutdown();\n}\n\n输出结果：\n\npool-1-thread-2 运动员等待裁判员响哨！！！\npool-1-thread-3 运动员等待裁判员响哨！！！\npool-1-thread-1 运动员等待裁判员响哨！！！\npool-1-thread-4 运动员等待裁判员响哨！！！\npool-1-thread-5 运动员等待裁判员响哨！！！\npool-1-thread-6 运动员等待裁判员响哨！！！\n裁判员发号施令啦！！！\npool-1-thread-2正在全力冲刺\npool-1-thread-2  到达终点\npool-1-thread-3正在全力冲刺\npool-1-thread-3  到达终点\npool-1-thread-1正在全力冲刺\npool-1-thread-1  到达终点\npool-1-thread-4正在全力冲刺\npool-1-thread-4  到达终点\npool-1-thread-5正在全力冲刺\npool-1-thread-5  到达终点\npool-1-thread-6正在全力冲刺\npool-1-thread-6  到达终点\n所有运动员到达终点，比赛结束！\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n该示例代码中设置了两个countdownlatch，第一个endsignal用于控制让main线程（裁判员）必须等到其他线程（运动员）让countdownlatch维护的数值n减到0为止。另一个startsignal用于让main线程对其他线程进行“发号施令”，startsignal引用的countdownlatch初始值为1，而其他线程执行的run方法中都会先通过 startsignal.await()让这些线程都被阻塞，直到main线程通过调用startsignal.countdown();，将值n减1，countdownlatch维护的数值n为0后，其他线程才能往下执行，并且，每个线程执行的run方法中都会通过endsignal.countdown();对endsignal维护的数值进行减一，由于往线程池提交了6个任务，会被减6次，所以endsignal维护的值最终会变为0，因此main线程在latch.await();阻塞结束，才能继续往下执行。\n\n另外，需要注意的是，当调用countdownlatch的countdown方法时，当前线程是不会被阻塞，会继续往下执行，比如在该例中会继续输出pool-1-thread-4 到达终点。\n\n\n# 3、aqs共享模式的实现\n\n\n# countdownlatch构造方法\n\ncountdownlatch的构造方法如下：\n\npublic countdownlatch(int count) {\n    if (count < 0) throw new illegalargumentexception("count < 0");\n    this.sync = new sync(count);\n}\n\n\n1\n2\n3\n4\n\n\n传入一个参数count，countdownlatch也使用了内部类sync来实现，sync继承自aqs：\n\nprivate static final class sync extends abstractqueuedsynchronizer {\n    private static final long serialversionuid = 4982264981922014374l;\n\n    sync(int count) {\n        setstate(count);\n    }\n\n    int getcount() {\n        return getstate();\n    }\n\n    protected int tryacquireshared(int acquires) {\n        return (getstate() == 0) ? 1 : -1;\n    }\n\n    protected boolean tryreleaseshared(int releases) {\n        // decrement count; signal when transition to zero\n        for (;;) {\n            int c = getstate();\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            if (compareandsetstate(c, nextc))\n                return nextc == 0;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n这里调用了aqs类中的setstate方法来设置count，aqs的state属性在之前的文章已经提到，它是aqs中的状态标识，具体的含义由子类来定义，可见这里把state定义为数量。\n\n\n# countdownlatch的await方法\n\npublic void await() throws interruptedexception {\n    sync.acquiresharedinterruptibly(1);\n}\n\n\n1\n2\n3\n\n\n直接调用了aqs类中的acquiresharedinterruptibly方法。\n\n\n# acquiresharedinterruptibly方法\n\npublic final void acquiresharedinterruptibly(int arg)\n            throws interruptedexception {\n    // 如果线程被中断则抛出异常\n    if (thread.interrupted())\n        throw new interruptedexception();\n    // 尝试获取共享锁，该方法在sync类中实现\n    if (tryacquireshared(arg) < 0)\n        // 如果获取失败，需要根据当前线程创建一个mode为share的的node放入队列中并循环获取\n        doacquiresharedinterruptibly(arg);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n这里的tryacquireshared方法在sync中被重写。\n\n\n# countdownlatch的tryacquireshared方法\n\nprotected int tryacquireshared(int acquires) {\n    return (getstate() == 0) ? 1 : -1;\n}\n\n\n1\n2\n3\n\n\n仅仅是根据状态来判断，如果state等于0的时候，说明计数器为0了，返回1表示成功，否则返回-1表示失败。\n\n\n# doacquiresharedinterruptibly方法\n\nprivate void doacquiresharedinterruptibly(int arg)\n        throws interruptedexception {\n    // 创建一个共享模式的节点\n    final node node = addwaiter(node.shared);\n    boolean failed = true;\n    try {\n        for (;;) {\n            final node p = node.predecessor();\n            if (p == head) {\n                // 如果 p == head 表示是队列的第一个节点，尝试获取\n                int r = tryacquireshared(arg);\n                if (r >= 0) {\n                    // 设置当前节点为head，并向后面的节点传播\n                    setheadandpropagate(node, r);\n                    p.next = null; // help gc\n                    failed = false;\n                    return;\n                }\n            }\n            if (shouldparkafterfailedacquire(p, node) &&\n                parkandcheckinterrupt())\n                throw new interruptedexception();\n        }\n    } finally {\n        if (failed)\n            cancelacquire(node);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n这里的重点是setheadandpropagate方法。\n\n\n# setheadandpropagate方法\n\nprivate void setheadandpropagate(node node, int propagate) {\n    node h = head; // record old head for check below\n    sethead(node);\n    /*\n     * try to signal next queued node if:\n     *   propagation was indicated by caller,\n     *     or was recorded (as h.waitstatus either before\n     *     or after sethead) by a previous operation\n     *     (note: this uses sign-check of waitstatus because\n     *      propagate status may transition to signal.)\n     * and\n     *   the next node is waiting in shared mode,\n     *     or we don\'t know, because it appears null\n     *\n     * the conservatism in both of these checks may cause\n     * unnecessary wake-ups, but only when there are multiple\n     * racing acquires/releases, so most need signals now or soon\n     * anyway.\n     */\n    if (propagate > 0 || h == null || h.waitstatus < 0 ||\n        (h = head) == null || h.waitstatus < 0) {\n        node s = node.next;\n        if (s == null || s.isshared())\n            doreleaseshared();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n首先先将之前的head记录一下，用于下面的判断；然后设置当前节点为头节点；最后再判断是否需要唤醒。这里的propagate值是根据tryacquireshared方法的返回值传入的，所以对于countdownlatch来说，如果获取成功，则应该是1。\n\n这里的if判断条件比较多，这里用了之前保存的head节点变量h来进行判断，让我疑惑的地方是，什么时候h会等于null？这个地方目前还没想明白。\n\n如果h.waitstatus >= 0，表示是初始状态或者是取消状态，那么当propagate <= 0时将不唤醒节点。\n\n获取node的下一个节点s，如果s == null || s.isshared()则释放节点并唤醒。为什么下一个节点为null的时候也需要唤醒操作呢？仔细理解一下这句话：\n\n> the conservatism in both of these checks may cause unnecessary wake-ups, but only when there are multiple racing acquires/releases, so most need signals now or soon anyway.\n\n这种保守的检查方式可能会引起多次不必要的线程唤醒操作，但这些情况仅存在于多线程并发的acquires/releases操作，所以大多线程数需要立即或者很快地一个信号。这个信号就是执行unpark方法。因为locksupport在unpark的时候，相当于给了一个信号，即使这时候没有线程在park状态，之后有线程执行park的时候也会读到这个信号就不会被挂起。\n\n在简单点说，就是线程在执行时，如果之前没有unpark操作，在执行park时会阻塞该线程；但如果在park之前执行过一次或多次unpark（unpark调用多次和一次是一样的，结果不会累加）这时执行park时并不会阻塞该线程。\n\n所以，如果在唤醒node的时候下一个节点刚好添加到队列中，就可能避免了一次阻塞的操作。\n\n所以这里的propagate表示传播，传播的过程就是只要成功的获取到共享所就唤醒下一个节点。\n\n\n# doreleaseshared方法\n\nprivate void doreleaseshared() {\n    /*\n     * ensure that a release propagates, even if there are other\n     * in-progress acquires/releases.  this proceeds in the usual\n     * way of trying to unparksuccessor of head if it needs\n     * signal. but if it does not, status is set to propagate to\n     * ensure that upon release, propagation continues.\n     * additionally, we must loop in case a new node is added\n     * while we are doing this. also, unlike other uses of\n     * unparksuccessor, we need to know if cas to reset status\n     * fails, if so rechecking.\n     */\n    for (;;) {\n        node h = head;\n        if (h != null && h != tail) {\n            int ws = h.waitstatus;\n            // 如果head的状态是signal，证明是等待一个信号，这时尝试将状态复位；\n            // 如果复位成功，则唤醒下一节点，否则继续循环。\n            if (ws == node.signal) {\n                if (!compareandsetwaitstatus(h, node.signal, 0))\n                    continue;            // loop to recheck cases\n                unparksuccessor(h);\n            }\n            // 如果状态是0，尝试设置状态为传播状态，表示节点向后传播；\n            // 如果不成功则继续循环。\n            else if (ws == 0 &&\n                     !compareandsetwaitstatus(h, 0, node.propagate))\n                continue;                // loop on failed cas\n        }\n        // 如果头节点有变化，则继续循环\n        if (h == head)                   // loop if head changed\n            break;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n什么时候状态会是signal呢？回顾一下shouldparkafterfailedacquire方法：\n\nprivate static boolean shouldparkafterfailedacquire(node pred, node node) {\n    int ws = pred.waitstatus;\n    if (ws == node.signal)\n        /*\n         * this node has already set status asking a release\n         * to signal it, so it can safely park.\n         */\n        return true;\n    if (ws > 0) {\n        /*\n         * predecessor was cancelled. skip over predecessors and\n         * indicate retry.\n         */\n        do {\n            node.prev = pred = pred.prev;\n        } while (pred.waitstatus > 0);\n        pred.next = node;\n    } else {\n        /*\n         * waitstatus must be 0 or propagate.  indicate that we\n         * need a signal, but don\'t park yet.  caller will need to\n         * retry to make sure it cannot acquire before parking.\n         */\n        compareandsetwaitstatus(pred, ws, node.signal);\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n当状态不为cancel或者是signal时，为了保险起见，这里把状态都设置成了signal，然后会再次循环进行判断是否需要阻塞。\n\n回到doreleaseshared方法，这里为什么不直接把signal设置为propagate，而是先把signal设置为0，然后再设置为propagate呢？\n\n原因在于unparksuccessor方法，该方法会判断当前节点的状态是否小于0，如果小于0则将h的状态设置为0，如果在这里直接设置为propagate状态的话，则相当于多做了一次cas操作。unparksuccessor中的代码如下：\n\nint ws = node.waitstatus;\nif (ws < 0)\n    compareandsetwaitstatus(node, ws, 0);\n\n\n1\n2\n3\n\n\n其实这里只判断状态为signal和0还有另一个原因，那就是当前执行doreleaseshared循环时的状态只可能为signal和0，因为如果这时没有后继节点的话，当前节点状态没有被修改，是初始的0；如果在执行sethead方法之前，这时刚好有后继节点被添加到队列中的话，因为这时后继节点判断p == head为false，所以会执行shouldparkafterfailedacquire方法，将当前节点的状态设置为signal。当状态为0时设置状态为propagate成功，则判断h == head结果为true，表示当前节点是队列中的唯一一个节点，所以直接就返回了；如果为false，则说明已经有后继节点的线程设置了head，这时不返回继续循环，但刚才获取的h已经用不到了，等待着被回收。\n\n\n# countdownlatch的countdown方法\n\npublic void countdown() {\n    sync.releaseshared(1);\n}\n\n\n1\n2\n3\n\n\n这里是调用了aqs中的releaseshared方法。\n\n\n# releaseshared方法\n\npublic final boolean releaseshared(int arg) {\n    // 尝试释放共享节点，如果成功则执行释放和唤醒操作\n    if (tryreleaseshared(arg)) {\n        doreleaseshared();\n        return true;\n    }\n    return false;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这里调用的tryreleaseshared方法是在countdownlatch中的sync类重写的，而doreleaseshared方法已在上文中介绍过了。\n\n\n# countdownlatch的tryreleaseshared方法\n\nprotected boolean tryreleaseshared(int releases) {\n    // decrement count; signal when transition to zero\n    for (;;) {\n        // 获取计数器数量\n        int c = getstate();\n        // 为0是返回false表示不需要释放\n        if (c == 0)\n            return false;\n        // 否则将计数器减1\n        int nextc = c-1;\n        if (compareandsetstate(c, nextc))\n            return nextc == 0;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n这里设置state的操作需要循环来设置以确保成功。\n\n\n# 超时控制的await方法\n\n对应于上文中提到的doacquiresharedinterruptibly方法，还有一个提供了超时控制的doacquiresharednanos方法，代码如下：\n\nprivate boolean doacquiresharednanos(int arg, long nanostimeout)\n            throws interruptedexception {\n\tif (nanostimeout <= 0l)\n\t    return false;\n\tfinal long deadline = system.nanotime() + nanostimeout;\n\tfinal node node = addwaiter(node.shared);\n\tboolean failed = true;\n\ttry {\n\t    for (;;) {\n\t        final node p = node.predecessor();\n\t        if (p == head) {\n\t            int r = tryacquireshared(arg);\n\t            if (r >= 0) {\n\t                setheadandpropagate(node, r);\n\t                p.next = null; // help gc\n\t                failed = false;\n\t                return true;\n\t            }\n\t        }\n\t        nanostimeout = deadline - system.nanotime();\n\t        if (nanostimeout <= 0l)\n\t            return false;\n\t        if (shouldparkafterfailedacquire(p, node) &&\n\t            nanostimeout > spinfortimeoutthreshold)\n\t            locksupport.parknanos(this, nanostimeout);\n\t        if (thread.interrupted())\n\t            throw new interruptedexception();\n\t    }\n\t} finally {\n\t    if (failed)\n\t        cancelacquire(node);\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n与doacquiresharedinterruptibly方法新增了以下功能：\n\n * 增加了一个deadline变量表示超时的截止时间，根据当前时间与传入的nanostimeout计算得出；\n * 每次循环判断是否已经超出截止时间，即deadline - system.nanotime()是否大于0，大于0表示已经超时，返回false，小于0表示还未超时；\n * 如果未超时通过调用shouldparkafterfailedacquire方法判断是否需要park，如果返回true则再判断nanostimeout > spinfortimeoutthreshold，spinfortimeoutthreshold是自旋的最小阈值，这里被doug lea设置成了1000，表示1000纳秒，也就是说如果剩余的时间不足1000纳秒，则不需要park。\n\n\n# 4、countdownlatch总结\n\n本文分析了countdownlatch的实现同时也是对aqs共享模式的分析，实现方式如下：\n\n调用await时\n\n * 共享锁获取失败（计数器还不为0），则将该线程封装为一个node对象放入队列中，并阻塞该线程；\n * 共享锁获取成功（计数器为0），则从第一个节点开始依次唤醒后继节点，实现共享状态的传播。\n\n调用countdown时\n\n * 如果计数器不为0，则不释放，继续阻塞，并把state的值减1；\n * 如果计数器为0，则唤醒节点，解除线程的阻塞状态。\n\n> 在这里再对比一下独占模式和共享模式的相同点和不同点：\n\n相同点\n\n * 锁的获取和释放的判断都是由子类来实现的。\n\n不同点\n\n * 独占功能在获取节点之后并且还未释放时，其他的节点会一直阻塞，直到第一个节点被释放才会唤醒；\n * 共享功能在获取节点之后会立即唤醒队列中的后继节点，每一个节点都会唤醒自己的后继节点，这就是共享状态的传播。\n\n根据以上的总结可以看出，aqs不关心state具体是什么，含义由子类去定义，子类则根据该变量来进行获取和释放的判断，aqs只是维护了该变量，并且实现了一系列用来判断资源是否可以访问的api，它提供了对线程的入队和出队的操作，它还负责处理线程对资源的访问方式，例如：什么时候可以对资源进行访问，什么时候阻塞线程，什么时候唤醒线程，线程被取消后如何处理等。而子类则用来实现资源是否可以被访问的判断。\n\n\n# 5、循环栅栏：cyclicbarrier\n\ncyclicbarrier也是一种多线程并发控制的实用工具，和countdownlatch一样具有等待计数的功能，但是相比于countdownlatch功能更加强大。\n\n为了理解cyclicbarrier，这里举一个通俗的例子。开运动会时，会有跑步这一项运动，我们来模拟下运动员入场时的情况，假设有6条跑道，在比赛开始时，就需要6个运动员在比赛开始的时候都站在起点了，裁判员吹哨后才能开始跑步。跑道起点就相当于“barrier”，是临界点，而这6个运动员就类比成线程的话，就是这6个线程都必须到达指定点了，意味着凑齐了一波，然后才能继续执行，否则每个线程都得阻塞等待，直至凑齐一波即可。cyclic是循环的意思，也就是说cyclicbarrier当多个线程凑齐了一波之后，仍然有效，可以继续凑齐下一波。cyclicbarrier的执行示意图如下：\n\n\n\n当多个线程都达到了指定点后，才能继续往下继续执行。这就有点像报数的感觉，假设6个线程就相当于6个运动员，到赛道起点时会报数进行统计，如果刚好是6的话，这一波就凑齐了，才能往下执行。cyclicbarrier在使用一次后，下面依然有效，可以继续当做计数器使用，这是与countdownlatch的区别之一。这里的6个线程，也就是计数器的初始值6，是通过cyclicbarrier的构造方法传入的。\n\n下面来看下cyclicbarrier的主要方法：\n\n//等到所有的线程都到达指定的临界点\nawait() throws interruptedexception, brokenbarrierexception\n\n//与上面的await方法功能基本一致，只不过这里有超时限制，阻塞等待直至到达超时时间为止\nawait(long timeout, timeunit unit) throws interruptedexception,\nbrokenbarrierexception, timeoutexception\n\n//获取当前有多少个线程阻塞等待在临界点上\nint getnumberwaiting()\n\n//用于查询阻塞等待的线程是否被中断\nboolean isbroken()\n\n\n//将屏障重置为初始状态。如果当前有线程正在临界点等待的话，将抛出brokenbarrierexception。\nvoid reset()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n另外需要注意的是，cyclicbarrier提供了这样的构造方法：\n\npublic cyclicbarrier(int parties, runnable barrieraction)\n\n\n1\n\n\n可以用来，当指定的线程都到达了指定的临界点的时，接下来执行的操作可以由barrieraction传入即可。\n\n> 一个例子\n\n下面用一个简单的例子，来看下cyclicbarrier的用法，我们来模拟下上面的运动员的例子。\n\npublic class cyclicbarrierdemo {\n    //指定必须有6个运动员到达才行\n    private static cyclicbarrier barrier = new cyclicbarrier(6, () -> {\n        system.out.println("所有运动员入场，裁判员一声令下！！！！！");\n    });\n    public static void main(string[] args) {\n        system.out.println("运动员准备进场，全场欢呼............");\n\n        executorservice service = executors.newfixedthreadpool(6);\n        for (int i = 0; i < 6; i++) {\n            service.execute(() -> {\n                try {\n                    system.out.println(thread.currentthread().getname() + " 运动员，进场");\n                    barrier.await();\n                    system.out.println(thread.currentthread().getname() + "  运动员出发");\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                } catch (brokenbarrierexception e) {\n                    e.printstacktrace();\n                }\n            });\n        }\n    }\n\n}\n\n输出结果：\n运动员准备进场，全场欢呼............\npool-1-thread-2 运动员，进场\npool-1-thread-1 运动员，进场\npool-1-thread-3 运动员，进场\npool-1-thread-4 运动员，进场\npool-1-thread-5 运动员，进场\npool-1-thread-6 运动员，进场\n所有运动员入场，裁判员一声令下！！！！！\npool-1-thread-6  运动员出发\npool-1-thread-1  运动员出发\npool-1-thread-5  运动员出发\npool-1-thread-4  运动员出发\npool-1-thread-3  运动员出发\npool-1-thread-2  运动员出发\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n从输出结果可以看出，当6个运动员（线程）都到达了指定的临界点（barrier）时候，才能继续往下执行，否则，则会阻塞等待在调用await()处\n\n\n# 6、countdownlatch与cyclicbarrier的比较\n\ncountdownlatch与cyclicbarrier都是用于控制并发的工具类，都可以理解成维护的就是一个计数器，但是这两者还是各有不同侧重点的：\n\n 1. countdownlatch一般用于某个线程a等待若干个其他线程执行完任务之后，它才执行；而cyclicbarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行；countdownlatch强调一个线程等多个线程完成某件事情。cyclicbarrier是多个线程互等，等大家都完成，再携手共进。\n 2. 调用countdownlatch的countdown方法后，当前线程并不会阻塞，会继续往下执行；而调用cyclicbarrier的await方法，会阻塞当前线程，直到cyclicbarrier指定的线程全部都到达了指定点的时候，才能继续往下执行；\n 3. countdownlatch方法比较少，操作比较简单，而cyclicbarrier提供的方法更多，比如能够通过getnumberwaiting()，isbroken()这些方法获取当前多个线程的状态，并且cyclicbarrier的构造方法可以传入barrieraction，指定当所有线程都到达时执行的业务功能；\n 4. countdownlatch是不能复用的，而cycliclatch是可以复用的。',charsets:{cjk:!0},createdTime:1655628697e3},{title:"Home",frontmatter:{home:!0,heroText:"萧瑟的个人博客",bgImage:"/img/5.jpg",bgImageStyle:{height:"500px"},faceImage:"/head.png",heroImage:"/hero_white.png",heroImageStyle:{maxHeight:"150px",display:"block",margin:"6rem auto 1.5rem",borderRadius:"5%",boxShadow:"0 5px 18px rgba(0,0,0,0.5)"},isShowTitleInHome:!0,actionText:"About Me",actionLink:"/views/personalInfo/",features:[{title:"Who am I？",details:"A programmer? A human being? Or a matter combination?"},{title:"Where am I？",details:"In a city? On earth? Or in a small part of space?"},{title:"What am I gona do？",details:"Work? Struggle? Or go to a destination I don't know?"}],readingShow:"top"},regularPath:"/",relativePath:"README.md",key:"v-399c8f76",path:"/",lastUpdated:"6/18/2022, 10:38:30 PM",lastUpdatedTimestamp:165556311e4,headersStr:null,content:"",normalizedContent:"",charsets:{},createdTime:1653125849e3},{title:"本站指南",frontmatter:{title:"本站指南",date:"2022-06-06T00:00:00.000Z",sidebar:"auto",isTimeLine:!1,isShowComment:!0,readingShow:"top"},regularPath:"/guide/",relativePath:"guide/README.md",key:"v-30eb6750",path:"/guide/",headers:[{level:2,title:"知识体系总览",slug:"知识体系总览",normalizedTitle:"知识体系总览",charIndex:2},{level:3,title:"初级教程类",slug:"初级教程类",normalizedTitle:"初级教程类",charIndex:13},{level:3,title:"高级框架类",slug:"高级框架类",normalizedTitle:"高级框架类",charIndex:137},{level:3,title:"架构设计类",slug:"架构设计类",normalizedTitle:"架构设计类",charIndex:274},{level:3,title:"大厂面试类",slug:"大厂面试类",normalizedTitle:"大厂面试类",charIndex:401},{level:2,title:"项目实战",slug:"项目实战",normalizedTitle:"项目实战",charIndex:451},{level:2,title:"书籍推荐",slug:"书籍推荐",normalizedTitle:"书籍推荐",charIndex:466}],lastUpdated:"5/21/2022, 5:37:29 PM",lastUpdatedTimestamp:1653125849e3,headersStr:"知识体系总览 初级教程类 高级框架类 架构设计类 大厂面试类 项目实战 书籍推荐",content:"# 知识体系总览\n\n\n# 初级教程类\n\n技术图谱\n\n涵盖面向对象、Java基础、网络编程、数据库基础、JavaWeb基础、前端框架、Mave、SSM框架、Redis\n\n目录更新中...\n\n适读人群\n\n本类适合未入门或刚入门的零基础学员阅读，同时课程体系配备视频讲解\n\n\n# 高级框架类\n\n技术图谱\n\n涵盖JUC并发编程、SpringBoot、SpringCloud、MQ、NoSQL、ES、Linux、Docker、K8S、Netty、Dubbo、ZK\n\n目录更新中...\n\n适读人群\n\n本类适合1年以上开发经验且想需要提升自身能力的同学\n\n\n# 架构设计类\n\n技术图谱\n\n涵盖源码解析、JVM剖析、设计模式、经典算法、海量数据解决方案、K8S、性能监控、服务化解决方案、ELK、云原生、服务网格\n\n目录更新中...\n\n适读人群\n\n本类适合3年以上开发经验且想从事架构、负责公司技术产线的同学\n\n\n# 大厂面试类\n\n说明\n\n涵盖从初级到高级架构所有技能面试点，并按照初级、高级、架构来进行区分\n\n\n# 项目实战\n\n内容书写\n\n\n# 书籍推荐\n\n内容书写",normalizedContent:"# 知识体系总览\n\n\n# 初级教程类\n\n技术图谱\n\n涵盖面向对象、java基础、网络编程、数据库基础、javaweb基础、前端框架、mave、ssm框架、redis\n\n目录更新中...\n\n适读人群\n\n本类适合未入门或刚入门的零基础学员阅读，同时课程体系配备视频讲解\n\n\n# 高级框架类\n\n技术图谱\n\n涵盖juc并发编程、springboot、springcloud、mq、nosql、es、linux、docker、k8s、netty、dubbo、zk\n\n目录更新中...\n\n适读人群\n\n本类适合1年以上开发经验且想需要提升自身能力的同学\n\n\n# 架构设计类\n\n技术图谱\n\n涵盖源码解析、jvm剖析、设计模式、经典算法、海量数据解决方案、k8s、性能监控、服务化解决方案、elk、云原生、服务网格\n\n目录更新中...\n\n适读人群\n\n本类适合3年以上开发经验且想从事架构、负责公司技术产线的同学\n\n\n# 大厂面试类\n\n说明\n\n涵盖从初级到高级架构所有技能面试点，并按照初级、高级、架构来进行区分\n\n\n# 项目实战\n\n内容书写\n\n\n# 书籍推荐\n\n内容书写",charsets:{cjk:!0},createdTime:1653125849e3},{frontmatter:{layout:"TimeLines",title:"Timeline",readingShow:"top"},regularPath:"/timeline/",key:"v-6319eb4e",path:"/timeline/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tags",title:"Tags",readingShow:"top"},regularPath:"/tag/",key:"v-b1564aac",path:"/tag/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"FrontmatterKey",title:"Categories",readingShow:"top"},regularPath:"/categories/",key:"v-ef9325c4",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Idea tags",readingShow:"top"},regularPath:"/tags/Idea/",key:"v-693be597",path:"/tags/Idea/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"爱情 tags",readingShow:"top"},regularPath:"/tags/%E7%88%B1%E6%83%85/",key:"v-121f755c",path:"/tags/爱情/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"青年节 tags",readingShow:"top"},regularPath:"/tags/%E9%9D%92%E5%B9%B4%E8%8A%82/",key:"v-e2cdd360",path:"/tags/青年节/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"人生境界 tags",readingShow:"top"},regularPath:"/tags/%E4%BA%BA%E7%94%9F%E5%A2%83%E7%95%8C/",key:"v-caf7c19c",path:"/tags/人生境界/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"王小波 tags",readingShow:"top"},regularPath:"/tags/%E7%8E%8B%E5%B0%8F%E6%B3%A2/",key:"v-7d08354a",path:"/tags/王小波/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Java tags",readingShow:"top"},regularPath:"/tags/Java/",key:"v-6948dfcc",path:"/tags/Java/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"Java并发编程 tags",readingShow:"top"},regularPath:"/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/",key:"v-e6ef0f30",path:"/tags/Java并发编程/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"JUC tags",readingShow:"top"},regularPath:"/tags/JUC/",key:"v-667e0558",path:"/tags/JUC/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Tag",title:"黄金时代 tags",readingShow:"top"},regularPath:"/tags/%E9%BB%84%E9%87%91%E6%97%B6%E4%BB%A3/",key:"v-8b58e252",path:"/tags/黄金时代/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Category",title:"Idea categories",readingShow:"top"},regularPath:"/categories/Idea/",key:"v-612ac59a",path:"/categories/Idea/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Category",title:"技术 categories",readingShow:"top"},regularPath:"/categories/%E6%8A%80%E6%9C%AF/",key:"v-5cfc18c5",path:"/categories/技术/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 1 - Java | tags",readingShow:"top"},regularPath:"/tags/Java/page/2/",key:"v-594fcf1e",path:"/tags/Java/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - Java | tags",readingShow:"top"},regularPath:"/tags/Java/page/3/",key:"v-594fcee0",path:"/tags/Java/page/3/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 1 - Java并发编程 | tags",readingShow:"top"},regularPath:"/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/page/2/",key:"v-5b14d855",path:"/tags/Java并发编程/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - Java并发编程 | tags",readingShow:"top"},regularPath:"/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/page/3/",key:"v-5b14d874",path:"/tags/Java并发编程/page/3/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 1 - JUC | tags",readingShow:"top"},regularPath:"/tags/JUC/page/2/",key:"v-49b84536",path:"/tags/JUC/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - JUC | tags",readingShow:"top"},regularPath:"/tags/JUC/page/3/",key:"v-49b844f8",path:"/tags/JUC/page/3/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 1 - 技术 | categories",readingShow:"top"},regularPath:"/categories/%E6%8A%80%E6%9C%AF/page/2/",key:"v-2c1a8558",path:"/categories/技术/page/2/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{frontmatter:{layout:"Layout",title:"Page 2 - 技术 | categories",readingShow:"top"},regularPath:"/categories/%E6%8A%80%E6%9C%AF/page/3/",key:"v-2c1a8577",path:"/categories/技术/page/3/",headersStr:null,content:"",normalizedContent:"",charsets:{}}],themeConfig:{type:"blog",smoothScroll:!0,blogConfig:{category:{location:2,text:"分类"},tag:{location:3,text:"标签"}},huawei:!0,authorAvatar:"/avatar.png",lastUpdated:"上次更新：",author:"萧瑟",startYear:"2022",nav:[{text:"首页",link:"/",icon:"reco-home"},{text:"Java",icon:"reco-api",items:[{text:"Java并发编程的艺术",link:"/Java/Java并发编程的艺术/"},{text:"前端",items:[{text:"前端基础",link:"/技术文章/vue/vue01"}]}]},{text:"Idea",icon:"reco-faq",items:[{text:"Idea",link:"/Idea/"},{text:"王小波",link:"/Idea/王小波/"}]},{text:"时间轴",link:"/timeline/",icon:"reco-date"},{text:"GitHub",icon:"reco-github",link:"https://github.com/my-GoldenAge"}],sidebarDepth:8,sidebar:"auto",subSidebar:"auto",search:!0,searchMaxSuggestions:10,series:"any",record:"苏ICP备2022022792号",recordLink:"https://beian.miit.gov.cn/",friendLink:[{title:"GitHub",desc:"my-GoldenAge",link:"https://github.com/my-GoldenAge"}]}},Ve=(t(278),t(279),t(96),t(280),t(92)),He={computed:{$recoPosts:function(){var n=this.$categories.list.reduce((function(n,e){return[].concat(Object(Zn.a)(n),Object(Zn.a)(e.pages))}),[]);return n=Object(Ve.a)(n),Object(Ve.c)(n),n},$recoPostsForTimeline:function(){var n=this.$recoPosts,e={},t=[];n=Object(Ve.a)(n,!0),this.pages=0==n.length?[]:n;for(var r=0,a=n.length;r<a;r++){var i=n[r],o=Ge(i.frontmatter.date,"year");e[o]?e[o].push(i):e[o]=[i]}for(var s in e){var l=e[s];Object(Ve.b)(l),t.unshift({year:s,data:l})}return t}}};function Ge(n,e){n=function(n){var e=new Date(n).toJSON();return new Date(+new Date(e)+288e5).toISOString().replace(/T/g," ").replace(/\.[\d]{3}Z/,"").replace(/-/g,"/")}(n);var t=new Date(n),r=t.getFullYear(),a=t.getMonth()+1,i=t.getDate();return"year"==e?r:"".concat(a,"-").concat(i)}t(440);i.default.component("Badge",(function(){return Promise.all([t.e(0),t.e(24)]).then(t.bind(null,775))}));var Ke={name:"BackToTop",data:function(){return{visible:!1,interval:null,isMoving:!1,customStyle:{right:"1rem",bottom:"6rem",width:"2.5rem",height:"2.5rem","border-radius":".25rem","line-height":"2.5rem"},visibilityHeight:400}},mounted:function(){window.addEventListener("scroll",this.handleScroll)},beforeDestroy:function(){window.removeEventListener("scroll",this.handleScroll),this.interval&&clearInterval(this.interval)},methods:{handleScroll:function(){this.visible=window.pageYOffset>this.visibilityHeight},backToTop:function(){var n=this;if(!this.isMoving){var e=window.pageYOffset,t=0;this.isMoving=!0,this.interval=setInterval((function(){var r=Math.floor(n.easeInOutQuad(10*t,e,-e,500));r<=0?(window.scrollTo(0,0),clearInterval(n.interval),n.isMoving=!1):window.scrollTo(0,r),t++}),16.7)}},easeInOutQuad:function(n,e,t,r){return(n/=r/2)<1?t/2*n*n+e:-t/2*(--n*(n-2)-1)+e}}},Ye=(t(441),Object(we.a)(Ke,(function(){var n=this.$createElement,e=this._self._c||n;return e("transition",{attrs:{name:"fade"}},[e("div",{directives:[{name:"show",rawName:"v-show",value:this.visible,expression:"visible"}],staticClass:"back-to-ceiling",style:this.customStyle,on:{click:this.backToTop}},[e("svg",{staticClass:"icon",attrs:{t:"1574745035067",viewBox:"0 0 1024 1024",version:"1.1",xmlns:"http://www.w3.org/2000/svg","p-id":"5404"}},[e("path",{attrs:{d:"M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z","p-id":"5405"}}),e("path",{attrs:{d:"M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z","p-id":"5406"}})])])])}),[],!1,null,"44bd5a18",null).exports),Xe=(t(98),{name:"Demo",props:{collapse:{type:Boolean,default:!1}},data:function(){return{showCode:!1,copied:!1,codeNavIndex:0,codeNavConfigs:[]}},created:function(){this.showCode=this.collapse,this.makeCodeNavConfigs()},methods:{toggleCode:function(){this.showCode=!this.showCode},copyCode:function(){var n=this,e=this.$el.querySelectorAll("pre")[this.codeNavIndex];e.setAttribute("contenteditable","true"),e.focus(),document.execCommand("selectAll",!1,null),this.copied=document.execCommand("copy"),e.removeAttribute("contenteditable"),setTimeout((function(){n.copied=!1}),1e3)},codeNavBtnHandler:function(n){this.codeNavIndex=n},makeCodeNavConfigs:function(){console.log(this.$slots);var n,e=this.$slots,t=[];for(var r in e)console.log(r.indexOf("code-")),0==r.indexOf("code-")&&(n=r.replace("code-","").replace(/^\S/,(function(n){return n.toUpperCase()})),t.push({title:n,slotName:r}));this.codeNavConfigs=t}}}),Ze=(t(442),Object(we.a)(Xe,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"demo-wrap"},[t("div",{staticClass:"demo-nav"},[t("i",{staticClass:"demo-nav-btn",on:{click:n.toggleCode}},[t("svg",{staticClass:"icon",attrs:{t:"1572515960134",viewBox:"0 0 1024 1024",version:"1.1",xmlns:"http://www.w3.org/2000/svg","p-id":"1097",width:"20",height:"20"}},[t("path",{attrs:{d:"M888 64H136q-30.016 0-51.008 20.992T64 136v752.992q0 28.992 20.992 50.496t51.008 21.504h752.992q28.992 0 50.496-21.504t21.504-50.496V136q0-30.016-21.504-51.008T888 64zM228.992 548.992q-15.008 0-25.504-10.496t-10.496-25.504 10.016-26.016l115.008-115.008-115.008-116.992q-10.016-11.008-10.016-25.504t10.496-24.992 25.504-10.496 24.992 10.016l140.992 142.016q10.016 11.008 10.016 26.016t-11.008 24.992l-140 140.992q-10.016 11.008-24.992 11.008z m389.024 0l-199.008-0.992q-15.008 0-25.504-10.496T383.008 512t10.496-25.504 25.504-10.496l199.008 0.992q15.008 0 25.504 10.496t10.496 25.504-11.008 25.504-24.992 10.496z","p-id":"1098"}})])]),n._v(" "),t("i",{class:n.showCode?"demo-icon-arrow active":"demo-icon-arrow"},[t("svg",{staticClass:"icon",attrs:{t:"1572587847226",viewBox:"0 0 1024 1024",version:"1.1",xmlns:"http://www.w3.org/2000/svg","p-id":"3297",width:"16",height:"16"}},[t("path",{attrs:{d:"M830.687738 603.071182c0 9.614985-3.933589 17.949814-11.799744 25.007557-7.867178 7.05672-17.222243 10.56052-28.065196 10.512425L232.716714 638.591163c-10.789741 0-20.144806-3.5038-28.064172-10.512425-7.919367-7.009647-11.852956-15.344476-11.799744-25.007557 0.053212-9.660011 3.986801-17.996886 11.799744-25.00551l279.05253-248.641917c7.867178-7.009647 17.22122-10.513448 28.065196-10.513448 10.842952 0 20.196994 3.504824 28.064172 10.513448l279.05253 248.641917C826.754149 585.074296 830.687738 593.411171 830.687738 603.071182z","p-id":"3298"}})])])]),n._v(" "),t("transition",{attrs:{name:"code-fade"}},[t("div",{directives:[{name:"show",rawName:"v-show",value:n.showCode,expression:"showCode"}],staticClass:"demo-code"},[t("div",{staticClass:"demo-code-nav"},n._l(n.codeNavConfigs,(function(e,r){return t("button",{key:r,class:["demo-code-btn",n.codeNavIndex===r?"active":""],on:{click:function(e){return n.codeNavBtnHandler(r)}}},[n._v(n._s(e.title))])})),0),n._v(" "),t("div",{staticClass:"demo-code-content"},[n._l(n.codeNavConfigs,(function(e,r){return t("div",{directives:[{name:"show",rawName:"v-show",value:n.codeNavIndex===r,expression:"codeNavIndex === index"}],key:r,staticClass:"demo-code-item"},[n._t(e.slotName)],2)})),n._v(" "),t("i",{staticClass:"demo-code-content-copy",on:{click:n.copyCode}},[t("svg",{staticClass:"icon",staticStyle:{fill:"#fff"},attrs:{t:"1572585974849",viewBox:"0 0 1024 1024",version:"1.1",xmlns:"http://www.w3.org/2000/svg","p-id":"1695",width:"20",height:"20"}},[t("path",{attrs:{d:"M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z","p-id":"1696"}})])]),n._v(" "),t("transition",{attrs:{name:"slide-fade"}},[n.copied?t("span",{staticClass:"demo-code-content-copied"},[n._v("Copied")]):n._e()])],2)])]),n._v(" "),t("div",{staticClass:"demo-main"},[n.$slots.demo?t("div",{staticClass:"demo-component-wrap"},[n._t("demo")],2):n._e()])],1)}),[],!1,null,null,null).exports),nt=(t(443),Object(we.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{attrs:{id:"loader-wrapper"}},[t("div",{staticClass:"loader-main"},n._l(4,(function(n){return t("div",{key:"out"+n})})),0),n._v(" "),n.$frontmatter.home?t("h3",{staticClass:"title"},[n._v(n._s(n.$site.title||n.$localeConfig.title))]):n._e(),n._v(" "),n.$frontmatter.home?t("p",{staticClass:"description"},[n._v(n._s(n.$site.description||n.$localeConfig.description))]):n._e()])}),[],!1,null,"1c4f0192",null).exports),et=(t(169),{data:function(){return{changePage:""}},props:{total:{type:Number,default:10},perPage:{type:Number,default:10},currentPage:{type:Number,default:1}},computed:{pages:function(){return Math.ceil(this.total/this.perPage)},show:function(){return this.pages&&1!=this.pages},efont:function(){return!(this.pages<=7)&&this.currentPage>5},indexs:function(){var n=1,e=this.pages,t=[];for(this.pages>=7&&(this.currentPage>5&&this.currentPage<this.pages-4?(n=Number(this.currentPage)-3,e=Number(this.currentPage)+3):this.currentPage<=5?(n=1,e=7):(e=this.pages,n=this.pages-6));n<=e;)t.push(n),n++;return t}},methods:{goPrev:function(){var n=this.currentPage;this.currentPage>1&&this.emit(--n)},goNext:function(){var n=this.currentPage;n<this.pages&&this.emit(++n)},jumpPage:function(n){var e=parseInt(n);e<=this.pages&&e>0?this.emit(e):alert("请输入大于0，并且小于".concat(this.pages,"的页码！"))},emit:function(n){this.$emit("getCurrentPage",n)}}}),tt=(t(445),Object(we.a)(et,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{directives:[{name:"show",rawName:"v-show",value:n.show,expression:"show"}],staticClass:"pagation"},[t("div",{staticClass:"pagation-list"},[t("span",{directives:[{name:"show",rawName:"v-show",value:n.currentPage>1,expression:"currentPage > 1"}],staticClass:"jump",attrs:{unselectable:"on"},on:{click:n.goPrev}},[n._v("Prev")]),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:n.efont,expression:"efont"}],staticClass:"jump",on:{click:function(e){return n.jumpPage(1)}}},[n._v("1")]),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:n.efont,expression:"efont"}],staticClass:"ellipsis"},[n._v("...")]),n._v(" "),n._l(n.indexs,(function(e){return t("span",{key:e,staticClass:"jump",class:{bgprimary:n.currentPage==e},on:{click:function(t){return n.jumpPage(e)}}},[n._v(n._s(e))])})),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:n.efont&&n.currentPage<n.pages-4,expression:"efont&&currentPage<pages-4"}],staticClass:"ellipsis"},[n._v("...")]),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:n.efont&&n.currentPage<n.pages-4,expression:"efont&&currentPage<pages-4"}],staticClass:"jump",on:{click:function(e){return n.jumpPage(n.pages)}}},[n._v(n._s(n.pages))]),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:n.currentPage<n.pages,expression:"currentPage < pages"}],staticClass:"jump",on:{click:n.goNext}},[n._v("Next")]),n._v(" "),t("span",{staticClass:"jumppoint"},[n._v("跳转到：")]),n._v(" "),t("span",{staticClass:"jumpinp"},[t("input",{directives:[{name:"model",rawName:"v-model",value:n.changePage,expression:"changePage"}],attrs:{type:"text"},domProps:{value:n.changePage},on:{input:function(e){e.target.composing||(n.changePage=e.target.value)}}})]),n._v(" "),t("span",{staticClass:"jump gobtn",on:{click:function(e){return n.jumpPage(n.changePage)}}},[n._v("GO")])],2)])}),[],!1,null,"dd29196a",null).exports),rt={name:"Valine",props:{options:{type:Object,default:function(){return{}}}},mounted:function(){this.initValine()},methods:{initValine:function(){var n=t(446),e=t(447),r=Object(Me.a)({el:"#valine",placeholder:"just go go",notify:!1,verify:!1,avatar:"retro",visitor:!0,recordIP:!1,path:window.location.pathname},this.options);"undefined"!=typeof window&&(this.window=window,window.AV=e),new n(r)}},watch:{$route:function(n,e){var t=this;n.path!==e.path&&setTimeout((function(){t.initValine()}),300)}}},at=(t(448),Object(we.a)(rt,(function(){var n=this.$createElement;this._self._c;return this._m(0)}),[function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"valine-wrapper"},[e("div",{attrs:{id:"valine"}})])}],!1,null,null,null).exports);
/**
  * vue-class-component v7.2.6
  * (c) 2015-present Evan You
  * @license MIT
  */
function it(n){return(it="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function ot(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function st(n){return function(n){if(Array.isArray(n)){for(var e=0,t=new Array(n.length);e<n.length;e++)t[e]=n[e];return t}}(n)||function(n){if(Symbol.iterator in Object(n)||"[object Arguments]"===Object.prototype.toString.call(n))return Array.from(n)}(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}()}function lt(){return"undefined"!=typeof Reflect&&Reflect.defineMetadata&&Reflect.getOwnMetadataKeys}function ct(n,e){ut(n,e),Object.getOwnPropertyNames(e.prototype).forEach((function(t){ut(n.prototype,e.prototype,t)})),Object.getOwnPropertyNames(e).forEach((function(t){ut(n,e,t)}))}function ut(n,e,t){(t?Reflect.getOwnMetadataKeys(e,t):Reflect.getOwnMetadataKeys(e)).forEach((function(r){var a=t?Reflect.getOwnMetadata(r,e,t):Reflect.getOwnMetadata(r,e);t?Reflect.defineMetadata(r,a,n,t):Reflect.defineMetadata(r,a,n)}))}var dt={__proto__:[]}instanceof Array;function pt(n){return function(e,t,r){var a="function"==typeof e?e:e.constructor;a.__decorators__||(a.__decorators__=[]),"number"!=typeof r&&(r=void 0),a.__decorators__.push((function(e){return n(e,t,r)}))}}function ht(n,e){var t=e.prototype._init;e.prototype._init=function(){var e=this,t=Object.getOwnPropertyNames(n);if(n.$options.props)for(var r in n.$options.props)n.hasOwnProperty(r)||t.push(r);t.forEach((function(t){Object.defineProperty(e,t,{get:function(){return n[t]},set:function(e){n[t]=e},configurable:!0})}))};var r=new e;e.prototype._init=t;var a={};return Object.keys(r).forEach((function(n){void 0!==r[n]&&(a[n]=r[n])})),a}var ft=["data","beforeCreate","created","beforeMount","mounted","beforeDestroy","destroyed","beforeUpdate","updated","activated","deactivated","render","errorCaptured","serverPrefetch"];function vt(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e.name=e.name||n._componentTag||n.name;var t=n.prototype;Object.getOwnPropertyNames(t).forEach((function(n){if("constructor"!==n)if(ft.indexOf(n)>-1)e[n]=t[n];else{var r=Object.getOwnPropertyDescriptor(t,n);void 0!==r.value?"function"==typeof r.value?(e.methods||(e.methods={}))[n]=r.value:(e.mixins||(e.mixins=[])).push({data:function(){return ot({},n,r.value)}}):(r.get||r.set)&&((e.computed||(e.computed={}))[n]={get:r.get,set:r.set})}})),(e.mixins||(e.mixins=[])).push({data:function(){return ht(this,n)}});var r=n.__decorators__;r&&(r.forEach((function(n){return n(e)})),delete n.__decorators__);var a=Object.getPrototypeOf(n.prototype),o=a instanceof i.default?a.constructor:i.default,s=o.extend(e);return gt(s,n,o),lt()&&ct(s,n),s}var mt={prototype:!0,arguments:!0,callee:!0,caller:!0};function gt(n,e,t){Object.getOwnPropertyNames(e).forEach((function(r){if(!mt[r]){var a=Object.getOwnPropertyDescriptor(n,r);if(!a||a.configurable){var i,o,s=Object.getOwnPropertyDescriptor(e,r);if(!dt){if("cid"===r)return;var l=Object.getOwnPropertyDescriptor(t,r);if(i=s.value,o=it(i),null!=i&&("object"===o||"function"===o)&&l&&l.value===s.value)return}0,Object.defineProperty(n,r,s)}}}))}function yt(n){return"function"==typeof n?vt(n):function(e){return vt(e,n)}}yt.registerHooks=function(n){ft.push.apply(ft,st(n))};var bt=yt;function wt(n){return pt((function(e,t){void 0===e.inject&&(e.inject={}),Array.isArray(e.inject)||(e.inject[t]=n||t)}))}function kt(n){var e=function(){var t=this,r="function"==typeof n?n.call(this):n;for(var a in(r=Object.create(r||null)).__reactiveInject__=this.__reactiveInject__||{},e.managed)r[e.managed[a]]=this[a];var i=function(n){r[e.managedReactive[n]]=o[n],Object.defineProperty(r.__reactiveInject__,e.managedReactive[n],{enumerable:!0,get:function(){return t[n]}})},o=this;for(var a in e.managedReactive)i(a);return r};return e.managed={},e.managedReactive={},e}function xt(n){return"function"!=typeof n||!n.managed&&!n.managedReactive}var Et="undefined"!=typeof Reflect&&void 0!==Reflect.getMetadata;function At(n,e,t){if(Et&&!Array.isArray(n)&&"function"!=typeof n&&void 0===n.type){var r=Reflect.getMetadata("design:type",e,t);r!==Object&&(n.type=r)}}function _t(n){return void 0===n&&(n={}),function(e,t){At(n,e,t),pt((function(e,t){(e.props||(e.props={}))[t]=n}))(e,t)}}function St(n,e){void 0===e&&(e={});var t=e.deep,r=void 0!==t&&t,a=e.immediate,i=void 0!==a&&a;return pt((function(e,t){"object"!=typeof e.watch&&(e.watch=Object.create(null));var a=e.watch;"object"!=typeof a[n]||Array.isArray(a[n])?void 0===a[n]&&(a[n]=[]):a[n]=[a[n]],a[n].push({handler:t,deep:r,immediate:i})}))}var Ct=t(73);const Tt=n=>Object(Ct.stringify)(n),Ot=(n,e)=>`${n}${Object(Ct.stringify)(e,{addQueryPrefix:!0})}`,jt=(n,e)=>`${n.replace(/\/$/,"")}/${e.replace(/^\//,"")}`;var Bt=t(270),It=t.n(Bt);const Lt=n=>It()(n,"YYYY-MM-DD HH:mm:ss"),Nt=n=>(n.split("#")[0]||"").split("?")[0]||"",Pt=n=>Object(Ct.parse)(n,{ignoreQueryPrefix:!0})
/*!
 * vue-i18n v8.27.1 
 * (c) 2022 kazuya kawaguchi
 * Released under the MIT License.
 */;var qt=["compactDisplay","currency","currencyDisplay","currencySign","localeMatcher","notation","numberingSystem","signDisplay","style","unit","unitDisplay","useGrouping","minimumIntegerDigits","minimumFractionDigits","maximumFractionDigits","minimumSignificantDigits","maximumSignificantDigits"];function Rt(n,e){"undefined"!=typeof console&&(console.warn("[vue-i18n] "+n),e&&console.warn(e.stack))}var Ft=Array.isArray;function Mt(n){return null!==n&&"object"==typeof n}function zt(n){return"string"==typeof n}var Dt=Object.prototype.toString;function Ut(n){return"[object Object]"===Dt.call(n)}function $t(n){return null==n}function Jt(n){return"function"==typeof n}function Wt(){for(var n=[],e=arguments.length;e--;)n[e]=arguments[e];var t=null,r=null;return 1===n.length?Mt(n[0])||Ft(n[0])?r=n[0]:"string"==typeof n[0]&&(t=n[0]):2===n.length&&("string"==typeof n[0]&&(t=n[0]),(Mt(n[1])||Ft(n[1]))&&(r=n[1])),{locale:t,params:r}}function Qt(n){return JSON.parse(JSON.stringify(n))}function Vt(n,e){return!!~n.indexOf(e)}var Ht=Object.prototype.hasOwnProperty;function Gt(n,e){return Ht.call(n,e)}function Kt(n){for(var e=arguments,t=Object(n),r=1;r<arguments.length;r++){var a=e[r];if(null!=a){var i=void 0;for(i in a)Gt(a,i)&&(Mt(a[i])?t[i]=Kt(t[i],a[i]):t[i]=a[i])}}return t}function Yt(n,e){if(n===e)return!0;var t=Mt(n),r=Mt(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Ft(n),i=Ft(e);if(a&&i)return n.length===e.length&&n.every((function(n,t){return Yt(n,e[t])}));if(a||i)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return Yt(n[t],e[t])}))}catch(n){return!1}}function Xt(n){return null!=n&&Object.keys(n).forEach((function(e){"string"==typeof n[e]&&(n[e]=n[e].replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&apos;"))})),n}var Zt={name:"i18n",functional:!0,props:{tag:{type:[String,Boolean,Object],default:"span"},path:{type:String,required:!0},locale:{type:String},places:{type:[Array,Object]}},render:function(n,e){var t=e.data,r=e.parent,a=e.props,i=e.slots,o=r.$i18n;if(o){var s=a.path,l=a.locale,c=a.places,u=i(),d=o.i(s,l,function(n){var e;for(e in n)if("default"!==e)return!1;return Boolean(e)}(u)||c?function(n,e){var t=e?function(n){0;return Array.isArray(n)?n.reduce(er,{}):Object.assign({},n)}(e):{};if(!n)return t;var r=(n=n.filter((function(n){return n.tag||""!==n.text.trim()}))).every(tr);0;return n.reduce(r?nr:er,t)}(u.default,c):u),p=a.tag&&!0!==a.tag||!1===a.tag?a.tag:"span";return p?n(p,t,d):d}}};function nr(n,e){return e.data&&e.data.attrs&&e.data.attrs.place&&(n[e.data.attrs.place]=e),n}function er(n,e,t){return n[t]=e,n}function tr(n){return Boolean(n.data&&n.data.attrs&&n.data.attrs.place)}var rr,ar={name:"i18n-n",functional:!0,props:{tag:{type:[String,Boolean,Object],default:"span"},value:{type:Number,required:!0},format:{type:[String,Object]},locale:{type:String}},render:function(n,e){var t=e.props,r=e.parent,a=e.data,i=r.$i18n;if(!i)return null;var o=null,s=null;zt(t.format)?o=t.format:Mt(t.format)&&(t.format.key&&(o=t.format.key),s=Object.keys(t.format).reduce((function(n,e){var r;return Vt(qt,e)?Object.assign({},n,((r={})[e]=t.format[e],r)):n}),null));var l=t.locale||i.locale,c=i._ntp(t.value,l,o,s),u=c.map((function(n,e){var t,r=a.scopedSlots&&a.scopedSlots[n.type];return r?r(((t={})[n.type]=n.value,t.index=e,t.parts=c,t)):n.value})),d=t.tag&&!0!==t.tag||!1===t.tag?t.tag:"span";return d?n(d,{attrs:a.attrs,class:a.class,staticClass:a.staticClass},u):u}};function ir(n,e,t){lr(n,t)&&cr(n,e,t)}function or(n,e,t,r){if(lr(n,t)){var a=t.context.$i18n;(function(n,e){var t=e.context;return n._locale===t.$i18n.locale})(n,t)&&Yt(e.value,e.oldValue)&&Yt(n._localeMessage,a.getLocaleMessage(a.locale))||cr(n,e,t)}}function sr(n,e,t,r){if(t.context){var a=t.context.$i18n||{};e.modifiers.preserve||a.preserveDirectiveContent||(n.textContent=""),n._vt=void 0,delete n._vt,n._locale=void 0,delete n._locale,n._localeMessage=void 0,delete n._localeMessage}else Rt("Vue instance does not exists in VNode context")}function lr(n,e){var t=e.context;return t?!!t.$i18n||(Rt("VueI18n instance does not exists in Vue instance"),!1):(Rt("Vue instance does not exists in VNode context"),!1)}function cr(n,e,t){var r,a,i=function(n){var e,t,r,a;zt(n)?e=n:Ut(n)&&(e=n.path,t=n.locale,r=n.args,a=n.choice);return{path:e,locale:t,args:r,choice:a}}(e.value),o=i.path,s=i.locale,l=i.args,c=i.choice;if(o||s||l)if(o){var u=t.context;n._vt=n.textContent=null!=c?(r=u.$i18n).tc.apply(r,[o,c].concat(ur(s,l))):(a=u.$i18n).t.apply(a,[o].concat(ur(s,l))),n._locale=u.$i18n.locale,n._localeMessage=u.$i18n.getLocaleMessage(u.$i18n.locale)}else Rt("`path` is required in v-t directive");else Rt("value type not supported")}function ur(n,e){var t=[];return n&&t.push(n),e&&(Array.isArray(e)||Ut(e))&&t.push(e),t}function dr(n,e){void 0===e&&(e={bridge:!1}),dr.installed=!0;var t;(rr=n).version&&Number(rr.version.split(".")[0]);(t=rr).prototype.hasOwnProperty("$i18n")||Object.defineProperty(t.prototype,"$i18n",{get:function(){return this._i18n}}),t.prototype.$t=function(n){for(var e=[],t=arguments.length-1;t-- >0;)e[t]=arguments[t+1];var r=this.$i18n;return r._t.apply(r,[n,r.locale,r._getMessages(),this].concat(e))},t.prototype.$tc=function(n,e){for(var t=[],r=arguments.length-2;r-- >0;)t[r]=arguments[r+2];var a=this.$i18n;return a._tc.apply(a,[n,a.locale,a._getMessages(),this,e].concat(t))},t.prototype.$te=function(n,e){var t=this.$i18n;return t._te(n,t.locale,t._getMessages(),e)},t.prototype.$d=function(n){for(var e,t=[],r=arguments.length-1;r-- >0;)t[r]=arguments[r+1];return(e=this.$i18n).d.apply(e,[n].concat(t))},t.prototype.$n=function(n){for(var e,t=[],r=arguments.length-1;r-- >0;)t[r]=arguments[r+1];return(e=this.$i18n).n.apply(e,[n].concat(t))},rr.mixin(function(n){function e(){this!==this.$root&&this.$options.__INTLIFY_META__&&this.$el&&this.$el.setAttribute("data-intlify",this.$options.__INTLIFY_META__)}return void 0===n&&(n=!1),n?{mounted:e}:{beforeCreate:function(){var n=this.$options;if(n.i18n=n.i18n||(n.__i18nBridge||n.__i18n?{}:null),n.i18n)if(n.i18n instanceof Cr){if(n.__i18nBridge||n.__i18n)try{var e=n.i18n&&n.i18n.messages?n.i18n.messages:{};(n.__i18nBridge||n.__i18n).forEach((function(n){e=Kt(e,JSON.parse(n))})),Object.keys(e).forEach((function(t){n.i18n.mergeLocaleMessage(t,e[t])}))}catch(n){0}this._i18n=n.i18n,this._i18nWatcher=this._i18n.watchI18nData()}else if(Ut(n.i18n)){var t=this.$root&&this.$root.$i18n&&this.$root.$i18n instanceof Cr?this.$root.$i18n:null;if(t&&(n.i18n.root=this.$root,n.i18n.formatter=t.formatter,n.i18n.fallbackLocale=t.fallbackLocale,n.i18n.formatFallbackMessages=t.formatFallbackMessages,n.i18n.silentTranslationWarn=t.silentTranslationWarn,n.i18n.silentFallbackWarn=t.silentFallbackWarn,n.i18n.pluralizationRules=t.pluralizationRules,n.i18n.preserveDirectiveContent=t.preserveDirectiveContent),n.__i18nBridge||n.__i18n)try{var r=n.i18n&&n.i18n.messages?n.i18n.messages:{};(n.__i18nBridge||n.__i18n).forEach((function(n){r=Kt(r,JSON.parse(n))})),n.i18n.messages=r}catch(n){0}var a=n.i18n.sharedMessages;a&&Ut(a)&&(n.i18n.messages=Kt(n.i18n.messages,a)),this._i18n=new Cr(n.i18n),this._i18nWatcher=this._i18n.watchI18nData(),(void 0===n.i18n.sync||n.i18n.sync)&&(this._localeWatcher=this.$i18n.watchLocale()),t&&t.onComponentInstanceCreated(this._i18n)}else 0;else this.$root&&this.$root.$i18n&&this.$root.$i18n instanceof Cr?this._i18n=this.$root.$i18n:n.parent&&n.parent.$i18n&&n.parent.$i18n instanceof Cr&&(this._i18n=n.parent.$i18n)},beforeMount:function(){var n=this.$options;n.i18n=n.i18n||(n.__i18nBridge||n.__i18n?{}:null),n.i18n?(n.i18n instanceof Cr||Ut(n.i18n))&&(this._i18n.subscribeDataChanging(this),this._subscribing=!0):(this.$root&&this.$root.$i18n&&this.$root.$i18n instanceof Cr||n.parent&&n.parent.$i18n&&n.parent.$i18n instanceof Cr)&&(this._i18n.subscribeDataChanging(this),this._subscribing=!0)},mounted:e,beforeDestroy:function(){if(this._i18n){var n=this;this.$nextTick((function(){n._subscribing&&(n._i18n.unsubscribeDataChanging(n),delete n._subscribing),n._i18nWatcher&&(n._i18nWatcher(),n._i18n.destroyVM(),delete n._i18nWatcher),n._localeWatcher&&(n._localeWatcher(),delete n._localeWatcher)}))}}}}(e.bridge)),rr.directive("t",{bind:ir,update:or,unbind:sr}),rr.component(Zt.name,Zt),rr.component(ar.name,ar),rr.config.optionMergeStrategies.i18n=function(n,e){return void 0===e?n:e}}var pr=function(){this._caches=Object.create(null)};pr.prototype.interpolate=function(n,e){if(!e)return[n];var t=this._caches[n];return t||(t=function(n){var e=[],t=0,r="";for(;t<n.length;){var a=n[t++];if("{"===a){r&&e.push({type:"text",value:r}),r="";var i="";for(a=n[t++];void 0!==a&&"}"!==a;)i+=a,a=n[t++];var o="}"===a,s=hr.test(i)?"list":o&&fr.test(i)?"named":"unknown";e.push({value:i,type:s})}else"%"===a?"{"!==n[t]&&(r+=a):r+=a}return r&&e.push({type:"text",value:r}),e}(n),this._caches[n]=t),function(n,e){var t=[],r=0,a=Array.isArray(e)?"list":Mt(e)?"named":"unknown";if("unknown"===a)return t;for(;r<n.length;){var i=n[r];switch(i.type){case"text":t.push(i.value);break;case"list":t.push(e[parseInt(i.value,10)]);break;case"named":"named"===a&&t.push(e[i.value]);break;case"unknown":0}r++}return t}(t,e)};var hr=/^(?:\d)+/,fr=/^(?:\w)+/;var vr=[];vr[0]={ws:[0],ident:[3,0],"[":[4],eof:[7]},vr[1]={ws:[1],".":[2],"[":[4],eof:[7]},vr[2]={ws:[2],ident:[3,0],0:[3,0],number:[3,0]},vr[3]={ident:[3,0],0:[3,0],number:[3,0],ws:[1,1],".":[2,1],"[":[4,1],eof:[7,1]},vr[4]={"'":[5,0],'"':[6,0],"[":[4,2],"]":[1,3],eof:8,else:[4,0]},vr[5]={"'":[4,0],eof:8,else:[5,0]},vr[6]={'"':[4,0],eof:8,else:[6,0]};var mr=/^\s?(?:true|false|-?[\d.]+|'[^']*'|"[^"]*")\s?$/;function gr(n){if(null==n)return"eof";switch(n.charCodeAt(0)){case 91:case 93:case 46:case 34:case 39:return n;case 95:case 36:case 45:return"ident";case 9:case 10:case 13:case 160:case 65279:case 8232:case 8233:return"ws"}return"ident"}function yr(n){var e,t,r,a=n.trim();return("0"!==n.charAt(0)||!isNaN(n))&&(r=a,mr.test(r)?(t=(e=a).charCodeAt(0))!==e.charCodeAt(e.length-1)||34!==t&&39!==t?e:e.slice(1,-1):"*"+a)}var br=function(){this._cache=Object.create(null)};br.prototype.parsePath=function(n){var e=this._cache[n];return e||(e=function(n){var e,t,r,a,i,o,s,l=[],c=-1,u=0,d=0,p=[];function h(){var e=n[c+1];if(5===u&&"'"===e||6===u&&'"'===e)return c++,r="\\"+e,p[0](),!0}for(p[1]=function(){void 0!==t&&(l.push(t),t=void 0)},p[0]=function(){void 0===t?t=r:t+=r},p[2]=function(){p[0](),d++},p[3]=function(){if(d>0)d--,u=4,p[0]();else{if(d=0,void 0===t)return!1;if(!1===(t=yr(t)))return!1;p[1]()}};null!==u;)if(c++,"\\"!==(e=n[c])||!h()){if(a=gr(e),8===(i=(s=vr[u])[a]||s.else||8))return;if(u=i[0],(o=p[i[1]])&&(r=void 0===(r=i[2])?e:r,!1===o()))return;if(7===u)return l}}(n))&&(this._cache[n]=e),e||[]},br.prototype.getPathValue=function(n,e){if(!Mt(n))return null;var t=this.parsePath(e);if(0===t.length)return null;for(var r=t.length,a=n,i=0;i<r;){var o=a[t[i]];if(null==o)return null;a=o,i++}return a};var wr,kr=/<\/?[\w\s="/.':;#-\/]+>/,xr=/(?:@(?:\.[a-z]+)?:(?:[\w\-_|./]+|\([\w\-_:|./]+\)))/g,Er=/^@(?:\.([a-z]+))?:/,Ar=/[()]/g,_r={upper:function(n){return n.toLocaleUpperCase()},lower:function(n){return n.toLocaleLowerCase()},capitalize:function(n){return""+n.charAt(0).toLocaleUpperCase()+n.substr(1)}},Sr=new pr,Cr=function(n){var e=this;void 0===n&&(n={}),!rr&&"undefined"!=typeof window&&window.Vue&&dr(window.Vue);var t=n.locale||"en-US",r=!1!==n.fallbackLocale&&(n.fallbackLocale||"en-US"),a=n.messages||{},i=n.dateTimeFormats||n.datetimeFormats||{},o=n.numberFormats||{};this._vm=null,this._formatter=n.formatter||Sr,this._modifiers=n.modifiers||{},this._missing=n.missing||null,this._root=n.root||null,this._sync=void 0===n.sync||!!n.sync,this._fallbackRoot=void 0===n.fallbackRoot||!!n.fallbackRoot,this._fallbackRootWithEmptyString=void 0===n.fallbackRootWithEmptyString||!!n.fallbackRootWithEmptyString,this._formatFallbackMessages=void 0!==n.formatFallbackMessages&&!!n.formatFallbackMessages,this._silentTranslationWarn=void 0!==n.silentTranslationWarn&&n.silentTranslationWarn,this._silentFallbackWarn=void 0!==n.silentFallbackWarn&&!!n.silentFallbackWarn,this._dateTimeFormatters={},this._numberFormatters={},this._path=new br,this._dataListeners=new Set,this._componentInstanceCreatedListener=n.componentInstanceCreatedListener||null,this._preserveDirectiveContent=void 0!==n.preserveDirectiveContent&&!!n.preserveDirectiveContent,this.pluralizationRules=n.pluralizationRules||{},this._warnHtmlInMessage=n.warnHtmlInMessage||"off",this._postTranslation=n.postTranslation||null,this._escapeParameterHtml=n.escapeParameterHtml||!1,"__VUE_I18N_BRIDGE__"in n&&(this.__VUE_I18N_BRIDGE__=n.__VUE_I18N_BRIDGE__),this.getChoiceIndex=function(n,t){var r=Object.getPrototypeOf(e);if(r&&r.getChoiceIndex)return r.getChoiceIndex.call(e,n,t);var a,i;return e.locale in e.pluralizationRules?e.pluralizationRules[e.locale].apply(e,[n,t]):(a=n,i=t,a=Math.abs(a),2===i?a?a>1?1:0:1:a?Math.min(a,2):0)},this._exist=function(n,t){return!(!n||!t)&&(!$t(e._path.getPathValue(n,t))||!!n[t])},"warn"!==this._warnHtmlInMessage&&"error"!==this._warnHtmlInMessage||Object.keys(a).forEach((function(n){e._checkLocaleMessage(n,e._warnHtmlInMessage,a[n])})),this._initVM({locale:t,fallbackLocale:r,messages:a,dateTimeFormats:i,numberFormats:o})},Tr={vm:{configurable:!0},messages:{configurable:!0},dateTimeFormats:{configurable:!0},numberFormats:{configurable:!0},availableLocales:{configurable:!0},locale:{configurable:!0},fallbackLocale:{configurable:!0},formatFallbackMessages:{configurable:!0},missing:{configurable:!0},formatter:{configurable:!0},silentTranslationWarn:{configurable:!0},silentFallbackWarn:{configurable:!0},preserveDirectiveContent:{configurable:!0},warnHtmlInMessage:{configurable:!0},postTranslation:{configurable:!0},sync:{configurable:!0}};Cr.prototype._checkLocaleMessage=function(n,e,t){var r=function(n,e,t,a){if(Ut(t))Object.keys(t).forEach((function(i){var o=t[i];Ut(o)?(a.push(i),a.push("."),r(n,e,o,a),a.pop(),a.pop()):(a.push(i),r(n,e,o,a),a.pop())}));else if(Ft(t))t.forEach((function(t,i){Ut(t)?(a.push("["+i+"]"),a.push("."),r(n,e,t,a),a.pop(),a.pop()):(a.push("["+i+"]"),r(n,e,t,a),a.pop())}));else if(zt(t)){if(kr.test(t)){var i="Detected HTML in message '"+t+"' of keypath '"+a.join("")+"' at '"+e+"'. Consider component interpolation with '<i18n>' to avoid XSS. See https://bit.ly/2ZqJzkp";"warn"===n?Rt(i):"error"===n&&function(n,e){"undefined"!=typeof console&&(console.error("[vue-i18n] "+n),e&&console.error(e.stack))}(i)}}};r(e,n,t,[])},Cr.prototype._initVM=function(n){var e=rr.config.silent;rr.config.silent=!0,this._vm=new rr({data:n,__VUE18N__INSTANCE__:!0}),rr.config.silent=e},Cr.prototype.destroyVM=function(){this._vm.$destroy()},Cr.prototype.subscribeDataChanging=function(n){this._dataListeners.add(n)},Cr.prototype.unsubscribeDataChanging=function(n){!function(n,e){if(n.delete(e));}(this._dataListeners,n)},Cr.prototype.watchI18nData=function(){var n=this;return this._vm.$watch("$data",(function(){for(var e,t,r=(e=n._dataListeners,t=[],e.forEach((function(n){return t.push(n)})),t),a=r.length;a--;)rr.nextTick((function(){r[a]&&r[a].$forceUpdate()}))}),{deep:!0})},Cr.prototype.watchLocale=function(n){if(n){if(!this.__VUE_I18N_BRIDGE__)return null;var e=this,t=this._vm;return this.vm.$watch("locale",(function(r){t.$set(t,"locale",r),e.__VUE_I18N_BRIDGE__&&n&&(n.locale.value=r),t.$forceUpdate()}),{immediate:!0})}if(!this._sync||!this._root)return null;var r=this._vm;return this._root.$i18n.vm.$watch("locale",(function(n){r.$set(r,"locale",n),r.$forceUpdate()}),{immediate:!0})},Cr.prototype.onComponentInstanceCreated=function(n){this._componentInstanceCreatedListener&&this._componentInstanceCreatedListener(n,this)},Tr.vm.get=function(){return this._vm},Tr.messages.get=function(){return Qt(this._getMessages())},Tr.dateTimeFormats.get=function(){return Qt(this._getDateTimeFormats())},Tr.numberFormats.get=function(){return Qt(this._getNumberFormats())},Tr.availableLocales.get=function(){return Object.keys(this.messages).sort()},Tr.locale.get=function(){return this._vm.locale},Tr.locale.set=function(n){this._vm.$set(this._vm,"locale",n)},Tr.fallbackLocale.get=function(){return this._vm.fallbackLocale},Tr.fallbackLocale.set=function(n){this._localeChainCache={},this._vm.$set(this._vm,"fallbackLocale",n)},Tr.formatFallbackMessages.get=function(){return this._formatFallbackMessages},Tr.formatFallbackMessages.set=function(n){this._formatFallbackMessages=n},Tr.missing.get=function(){return this._missing},Tr.missing.set=function(n){this._missing=n},Tr.formatter.get=function(){return this._formatter},Tr.formatter.set=function(n){this._formatter=n},Tr.silentTranslationWarn.get=function(){return this._silentTranslationWarn},Tr.silentTranslationWarn.set=function(n){this._silentTranslationWarn=n},Tr.silentFallbackWarn.get=function(){return this._silentFallbackWarn},Tr.silentFallbackWarn.set=function(n){this._silentFallbackWarn=n},Tr.preserveDirectiveContent.get=function(){return this._preserveDirectiveContent},Tr.preserveDirectiveContent.set=function(n){this._preserveDirectiveContent=n},Tr.warnHtmlInMessage.get=function(){return this._warnHtmlInMessage},Tr.warnHtmlInMessage.set=function(n){var e=this,t=this._warnHtmlInMessage;if(this._warnHtmlInMessage=n,t!==n&&("warn"===n||"error"===n)){var r=this._getMessages();Object.keys(r).forEach((function(n){e._checkLocaleMessage(n,e._warnHtmlInMessage,r[n])}))}},Tr.postTranslation.get=function(){return this._postTranslation},Tr.postTranslation.set=function(n){this._postTranslation=n},Tr.sync.get=function(){return this._sync},Tr.sync.set=function(n){this._sync=n},Cr.prototype._getMessages=function(){return this._vm.messages},Cr.prototype._getDateTimeFormats=function(){return this._vm.dateTimeFormats},Cr.prototype._getNumberFormats=function(){return this._vm.numberFormats},Cr.prototype._warnDefault=function(n,e,t,r,a,i){if(!$t(t))return t;if(this._missing){var o=this._missing.apply(null,[n,e,r,a]);if(zt(o))return o}else 0;if(this._formatFallbackMessages){var s=Wt.apply(void 0,a);return this._render(e,i,s.params,e)}return e},Cr.prototype._isFallbackRoot=function(n){return(this._fallbackRootWithEmptyString?!n:$t(n))&&!$t(this._root)&&this._fallbackRoot},Cr.prototype._isSilentFallbackWarn=function(n){return this._silentFallbackWarn instanceof RegExp?this._silentFallbackWarn.test(n):this._silentFallbackWarn},Cr.prototype._isSilentFallback=function(n,e){return this._isSilentFallbackWarn(e)&&(this._isFallbackRoot()||n!==this.fallbackLocale)},Cr.prototype._isSilentTranslationWarn=function(n){return this._silentTranslationWarn instanceof RegExp?this._silentTranslationWarn.test(n):this._silentTranslationWarn},Cr.prototype._interpolate=function(n,e,t,r,a,i,o){if(!e)return null;var s,l=this._path.getPathValue(e,t);if(Ft(l)||Ut(l))return l;if($t(l)){if(!Ut(e))return null;if(!zt(s=e[t])&&!Jt(s))return null}else{if(!zt(l)&&!Jt(l))return null;s=l}return zt(s)&&(s.indexOf("@:")>=0||s.indexOf("@.")>=0)&&(s=this._link(n,e,s,r,"raw",i,o)),this._render(s,a,i,t)},Cr.prototype._link=function(n,e,t,r,a,i,o){var s=t,l=s.match(xr);for(var c in l)if(l.hasOwnProperty(c)){var u=l[c],d=u.match(Er),p=d[0],h=d[1],f=u.replace(p,"").replace(Ar,"");if(Vt(o,f))return s;o.push(f);var v=this._interpolate(n,e,f,r,"raw"===a?"string":a,"raw"===a?void 0:i,o);if(this._isFallbackRoot(v)){if(!this._root)throw Error("unexpected error");var m=this._root.$i18n;v=m._translate(m._getMessages(),m.locale,m.fallbackLocale,f,r,a,i)}v=this._warnDefault(n,f,v,r,Ft(i)?i:[i],a),this._modifiers.hasOwnProperty(h)?v=this._modifiers[h](v):_r.hasOwnProperty(h)&&(v=_r[h](v)),o.pop(),s=v?s.replace(u,v):s}return s},Cr.prototype._createMessageContext=function(n,e,t,r){var a=this,i=Ft(n)?n:[],o=Mt(n)?n:{},s=this._getMessages(),l=this.locale;return{list:function(n){return i[n]},named:function(n){return o[n]},values:n,formatter:e,path:t,messages:s,locale:l,linked:function(n){return a._interpolate(l,s[l]||{},n,null,r,void 0,[n])}}},Cr.prototype._render=function(n,e,t,r){if(Jt(n))return n(this._createMessageContext(t,this._formatter||Sr,r,e));var a=this._formatter.interpolate(n,t,r);return a||(a=Sr.interpolate(n,t,r)),"string"!==e||zt(a)?a:a.join("")},Cr.prototype._appendItemToChain=function(n,e,t){var r=!1;return Vt(n,e)||(r=!0,e&&(r="!"!==e[e.length-1],e=e.replace(/!/g,""),n.push(e),t&&t[e]&&(r=t[e]))),r},Cr.prototype._appendLocaleToChain=function(n,e,t){var r,a=e.split("-");do{var i=a.join("-");r=this._appendItemToChain(n,i,t),a.splice(-1,1)}while(a.length&&!0===r);return r},Cr.prototype._appendBlockToChain=function(n,e,t){for(var r=!0,a=0;a<e.length&&"boolean"==typeof r;a++){var i=e[a];zt(i)&&(r=this._appendLocaleToChain(n,i,t))}return r},Cr.prototype._getLocaleChain=function(n,e){if(""===n)return[];this._localeChainCache||(this._localeChainCache={});var t=this._localeChainCache[n];if(!t){e||(e=this.fallbackLocale),t=[];for(var r,a=[n];Ft(a);)a=this._appendBlockToChain(t,a,e);(a=zt(r=Ft(e)?e:Mt(e)?e.default?e.default:null:e)?[r]:r)&&this._appendBlockToChain(t,a,null),this._localeChainCache[n]=t}return t},Cr.prototype._translate=function(n,e,t,r,a,i,o){for(var s,l=this._getLocaleChain(e,t),c=0;c<l.length;c++){var u=l[c];if(!$t(s=this._interpolate(u,n[u],r,a,i,o,[r])))return s}return null},Cr.prototype._t=function(n,e,t,r){for(var a,i=[],o=arguments.length-4;o-- >0;)i[o]=arguments[o+4];if(!n)return"";var s=Wt.apply(void 0,i);this._escapeParameterHtml&&(s.params=Xt(s.params));var l=s.locale||e,c=this._translate(t,l,this.fallbackLocale,n,r,"string",s.params);if(this._isFallbackRoot(c)){if(!this._root)throw Error("unexpected error");return(a=this._root).$t.apply(a,[n].concat(i))}return c=this._warnDefault(l,n,c,r,i,"string"),this._postTranslation&&null!=c&&(c=this._postTranslation(c,n)),c},Cr.prototype.t=function(n){for(var e,t=[],r=arguments.length-1;r-- >0;)t[r]=arguments[r+1];return(e=this)._t.apply(e,[n,this.locale,this._getMessages(),null].concat(t))},Cr.prototype._i=function(n,e,t,r,a){var i=this._translate(t,e,this.fallbackLocale,n,r,"raw",a);if(this._isFallbackRoot(i)){if(!this._root)throw Error("unexpected error");return this._root.$i18n.i(n,e,a)}return this._warnDefault(e,n,i,r,[a],"raw")},Cr.prototype.i=function(n,e,t){return n?(zt(e)||(e=this.locale),this._i(n,e,this._getMessages(),null,t)):""},Cr.prototype._tc=function(n,e,t,r,a){for(var i,o=[],s=arguments.length-5;s-- >0;)o[s]=arguments[s+5];if(!n)return"";void 0===a&&(a=1);var l={count:a,n:a},c=Wt.apply(void 0,o);return c.params=Object.assign(l,c.params),o=null===c.locale?[c.params]:[c.locale,c.params],this.fetchChoice((i=this)._t.apply(i,[n,e,t,r].concat(o)),a)},Cr.prototype.fetchChoice=function(n,e){if(!n||!zt(n))return null;var t=n.split("|");return t[e=this.getChoiceIndex(e,t.length)]?t[e].trim():n},Cr.prototype.tc=function(n,e){for(var t,r=[],a=arguments.length-2;a-- >0;)r[a]=arguments[a+2];return(t=this)._tc.apply(t,[n,this.locale,this._getMessages(),null,e].concat(r))},Cr.prototype._te=function(n,e,t){for(var r=[],a=arguments.length-3;a-- >0;)r[a]=arguments[a+3];var i=Wt.apply(void 0,r).locale||e;return this._exist(t[i],n)},Cr.prototype.te=function(n,e){return this._te(n,this.locale,this._getMessages(),e)},Cr.prototype.getLocaleMessage=function(n){return Qt(this._vm.messages[n]||{})},Cr.prototype.setLocaleMessage=function(n,e){"warn"!==this._warnHtmlInMessage&&"error"!==this._warnHtmlInMessage||this._checkLocaleMessage(n,this._warnHtmlInMessage,e),this._vm.$set(this._vm.messages,n,e)},Cr.prototype.mergeLocaleMessage=function(n,e){"warn"!==this._warnHtmlInMessage&&"error"!==this._warnHtmlInMessage||this._checkLocaleMessage(n,this._warnHtmlInMessage,e),this._vm.$set(this._vm.messages,n,Kt(void 0!==this._vm.messages[n]&&Object.keys(this._vm.messages[n]).length?Object.assign({},this._vm.messages[n]):{},e))},Cr.prototype.getDateTimeFormat=function(n){return Qt(this._vm.dateTimeFormats[n]||{})},Cr.prototype.setDateTimeFormat=function(n,e){this._vm.$set(this._vm.dateTimeFormats,n,e),this._clearDateTimeFormat(n,e)},Cr.prototype.mergeDateTimeFormat=function(n,e){this._vm.$set(this._vm.dateTimeFormats,n,Kt(this._vm.dateTimeFormats[n]||{},e)),this._clearDateTimeFormat(n,e)},Cr.prototype._clearDateTimeFormat=function(n,e){for(var t in e){var r=n+"__"+t;this._dateTimeFormatters.hasOwnProperty(r)&&delete this._dateTimeFormatters[r]}},Cr.prototype._localizeDateTime=function(n,e,t,r,a){for(var i=e,o=r[i],s=this._getLocaleChain(e,t),l=0;l<s.length;l++){var c=s[l];if(i=c,!$t(o=r[c])&&!$t(o[a]))break}if($t(o)||$t(o[a]))return null;var u=o[a],d=i+"__"+a,p=this._dateTimeFormatters[d];return p||(p=this._dateTimeFormatters[d]=new Intl.DateTimeFormat(i,u)),p.format(n)},Cr.prototype._d=function(n,e,t){if(!t)return new Intl.DateTimeFormat(e).format(n);var r=this._localizeDateTime(n,e,this.fallbackLocale,this._getDateTimeFormats(),t);if(this._isFallbackRoot(r)){if(!this._root)throw Error("unexpected error");return this._root.$i18n.d(n,t,e)}return r||""},Cr.prototype.d=function(n){for(var e=[],t=arguments.length-1;t-- >0;)e[t]=arguments[t+1];var r=this.locale,a=null;return 1===e.length?zt(e[0])?a=e[0]:Mt(e[0])&&(e[0].locale&&(r=e[0].locale),e[0].key&&(a=e[0].key)):2===e.length&&(zt(e[0])&&(a=e[0]),zt(e[1])&&(r=e[1])),this._d(n,r,a)},Cr.prototype.getNumberFormat=function(n){return Qt(this._vm.numberFormats[n]||{})},Cr.prototype.setNumberFormat=function(n,e){this._vm.$set(this._vm.numberFormats,n,e),this._clearNumberFormat(n,e)},Cr.prototype.mergeNumberFormat=function(n,e){this._vm.$set(this._vm.numberFormats,n,Kt(this._vm.numberFormats[n]||{},e)),this._clearNumberFormat(n,e)},Cr.prototype._clearNumberFormat=function(n,e){for(var t in e){var r=n+"__"+t;this._numberFormatters.hasOwnProperty(r)&&delete this._numberFormatters[r]}},Cr.prototype._getNumberFormatter=function(n,e,t,r,a,i){for(var o=e,s=r[o],l=this._getLocaleChain(e,t),c=0;c<l.length;c++){var u=l[c];if(o=u,!$t(s=r[u])&&!$t(s[a]))break}if($t(s)||$t(s[a]))return null;var d,p=s[a];if(i)d=new Intl.NumberFormat(o,Object.assign({},p,i));else{var h=o+"__"+a;(d=this._numberFormatters[h])||(d=this._numberFormatters[h]=new Intl.NumberFormat(o,p))}return d},Cr.prototype._n=function(n,e,t,r){if(!Cr.availabilities.numberFormat)return"";if(!t)return(r?new Intl.NumberFormat(e,r):new Intl.NumberFormat(e)).format(n);var a=this._getNumberFormatter(n,e,this.fallbackLocale,this._getNumberFormats(),t,r),i=a&&a.format(n);if(this._isFallbackRoot(i)){if(!this._root)throw Error("unexpected error");return this._root.$i18n.n(n,Object.assign({},{key:t,locale:e},r))}return i||""},Cr.prototype.n=function(n){for(var e=[],t=arguments.length-1;t-- >0;)e[t]=arguments[t+1];var r=this.locale,a=null,i=null;return 1===e.length?zt(e[0])?a=e[0]:Mt(e[0])&&(e[0].locale&&(r=e[0].locale),e[0].key&&(a=e[0].key),i=Object.keys(e[0]).reduce((function(n,t){var r;return Vt(qt,t)?Object.assign({},n,((r={})[t]=e[0][t],r)):n}),null)):2===e.length&&(zt(e[0])&&(a=e[0]),zt(e[1])&&(r=e[1])),this._n(n,r,a,i)},Cr.prototype._ntp=function(n,e,t,r){if(!Cr.availabilities.numberFormat)return[];if(!t)return(r?new Intl.NumberFormat(e,r):new Intl.NumberFormat(e)).formatToParts(n);var a=this._getNumberFormatter(n,e,this.fallbackLocale,this._getNumberFormats(),t,r),i=a&&a.formatToParts(n);if(this._isFallbackRoot(i)){if(!this._root)throw Error("unexpected error");return this._root.$i18n._ntp(n,e,t,r)}return i||[]},Object.defineProperties(Cr.prototype,Tr),Object.defineProperty(Cr,"availabilities",{get:function(){if(!wr){var n="undefined"!=typeof Intl;wr={dateTimeFormat:n&&void 0!==Intl.DateTimeFormat,numberFormat:n&&void 0!==Intl.NumberFormat}}return wr}}),Cr.install=dr,Cr.version="8.27.1";var Or=Cr;
/*!
 * vssue - A vue-powered issue-based comment plugin
 *
 * @version v1.4.8
 * @link https://vssue.js.org
 * @license MIT
 * @copyright 2018-2021 meteorlxy
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */function jr(n,e,t,r){var a,i=arguments.length,o=i<3?e:null===r?r=Object.getOwnPropertyDescriptor(e,t):r;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)o=Reflect.decorate(n,e,t,r);else for(var s=n.length-1;s>=0;s--)(a=n[s])&&(o=(i<3?a(o):i>3?a(e,t,o):a(e,t))||o);return i>3&&o&&Object.defineProperty(e,t,o),o}var Br=i.default.extend({name:"Iconfont"});function Ir(n,e,t,r,a,i,o,s,l,c){"boolean"!=typeof o&&(l=s,s=o,o=!1);const u="function"==typeof t?t.options:t;let d;if(n&&n.render&&(u.render=n.render,u.staticRenderFns=n.staticRenderFns,u._compiled=!0,a&&(u.functional=!0)),r&&(u._scopeId=r),i?(d=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),e&&e.call(this,l(n)),n&&n._registeredComponents&&n._registeredComponents.add(i)},u._ssrRegister=d):e&&(d=o?function(n){e.call(this,c(n,this.$root.$options.shadowRoot))}:function(n){e.call(this,s(n))}),d)if(u.functional){const n=u.render;u.render=function(e,t){return d.call(t),n(e,t)}}else{const n=u.beforeCreate;u.beforeCreate=n?[].concat(n,d):[d]}return t}"undefined"!=typeof navigator&&/msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());const Lr=Ir({render:function(n,e){var t=e._c;return t("svg",{directives:[{name:"show",rawName:"v-show",value:!1,expression:"false"}]},[t("symbol",{attrs:{id:"vssue-icon-bitbucket",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M579.5522464 489.45249493q4.8371808 38.38537173-30.81752427 61.55702827t-67.95459093 3.66689493q-23.79580907-10.37653333-32.6119616-35.34262826t-0.31207573-50.01020907 31.67573333-35.34262827q21.92335253-11.00068587 44.1587808-7.33379093t39.00952427 21.61127573 16.77409493 41.1160384zM647.19476053 476.65737173q-8.50407573-65.22392427-68.8908192-99.9424t-120.07131413-7.9579424q-38.38537173 17.08617173-61.24495253 53.9111616t-21.0651424 78.95527574q2.41859093 55.4715424 47.20152426 94.48106666t100.87862827 34.1723424q55.4715424-4.8371808 92.60860907-51.18049493t30.50544746-102.43900907zM792.93434133 146.32472427q-12.17097173-16.4620192-34.1723424-27.15062827t-35.34262826-13.41927573-43.30057174-7.64586667q-177.33729493-28.63299093-345.00022826 1.24830507-26.2144 4.29104747-40.25782827 7.33379093t-33.54819093 13.41927573-30.50544747 26.2144q18.2564576 17.08617173 46.34331413 27.6967616t44.78293334 13.41927574 53.36502826 7.02171413q138.95192427 17.71032427 273.06666667 0.62415253 38.38537173-4.8371808 54.53531413-7.33379093t44.1587808-13.1072 45.7191616-28.32091413zM827.65281813 777.10872427q-4.8371808 15.83786667-9.44030506 46.65539093t-8.50407574 51.18049493-17.39824746 42.6764192-35.34262827 34.4064q-52.4288 29.2571424-115.46819093 43.61264747t-123.1140576 13.41927573-122.8019808-11.3127616q-28.0088384-4.8371808-49.69813334-11.00068586t-46.65539093-16.4620192-44.4708576-26.52647574-31.67573333-37.4491424q-15.21371413-58.51428587-34.71847574-177.96144746l3.66689494-9.7523808 11.00068586-5.46133334q135.9091808 90.1900192 308.72137174 90.1900192t309.34552426-90.1900192q12.79512427 3.66689493 14.5895616 14.04342827t-3.0427424 27.46270507-4.8371808 22.54750506zM937.97175147 191.41973333q-15.83786667 101.8148576-67.64251414 399.22346667-3.0427424 18.2564576-16.4620192 34.1723424t-26.52647573 24.3419424-33.23611413 18.88060907q-153.61950507 76.7707424-371.8387808 53.67710506-151.12289493-16.4620192-240.14262827-84.72868586-9.12822827-7.33379093-15.52579093-16.1499424t-10.37653334-21.2992-5.46133333-20.75306667-3.66689493-24.10788587-3.3548192-21.2992q-5.46133333-30.50544747-16.1499424-91.43832426t-17.08617174-98.4600384-14.35550506-89.8779424-13.41927574-96.27550507q1.7944384-15.83786667 10.68860907-29.5692192t19.19268587-22.8595808 27.46270506-18.2564576 28.0088384-13.73135253 29.2571424-11.3127616q76.22460907-28.0088384 190.75657174-39.00952427 231.0144-22.54750507 412.01859093 30.50544747 94.48106667 28.0088384 131.072 74.35215253 9.7523808 12.17097173 10.0644576 31.0515808t-3.3548192 32.9240384z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-gitea",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M184.31868985 236.10860742C106.94832667 235.94086648 3.32655508 285.13080468 9.02973665 408.46209936c8.93218827 192.65010787 206.32096845 210.5144844 285.20099725 212.06608453 8.63864186 36.14810496 101.48307766 160.77938883 170.21479898 167.32127321h301.09442177c180.57278288-11.99345499 315.77172611-546.07960359 215.54670217-548.09249109-165.7696721 7.79993906-264.02374305 11.74184405-348.27147151 12.41280591v166.69224585l-26.25140843-11.61603761-0.16773997-154.99233728c-96.70246985-0.04193548-181.83083757-4.52899687-343.4069947-12.49667687-20.21274496-0.12580547-48.39316992-3.5644886-78.67035236-3.64835859z m10.94507577 68.14462849h9.22573371c10.98701124 98.75729283 28.85138778 156.50200291 64.99949274 244.73357185-92.25734394-10.90314029-170.75995634-37.69970509-185.18564974-137.75698809-7.46445813-51.78991757 17.69663558-105.84433456 110.96042329-107.01851827z m358.83913087 97.07988723c6.29027343 0.08386999 12.70635233 1.25805468 18.74501482 4.02577499l31.40943263 13.54505513-22.51917887 41.05451824a28.18042496 25.03528825 0 0 0-10.10637297 1.59353561 28.18042496 25.03528825 0 0 0-16.98373825 32.038459 28.18042496 25.03528825 0 0 0 4.69673781 7.29671718l-38.83195528 70.70267333a28.18042496 25.03528825 0 0 0-9.30960467 1.59353659 28.18042496 25.03528825 0 0 0-16.98373825 32.038459 28.18042496 25.03528825 0 0 0 36.06423497 15.09665623 28.18042496 25.03528825 0 0 0 16.94180276-32.08039449 28.18042496 25.03528825 0 0 0-6.62575434-9.22573468l37.82551056-68.85752581a28.18042496 25.03528825 0 0 0 12.28700044-1.25805469 28.18042496 25.03528825 0 0 0 8.93218826-4.69673783c14.59343435 6.12253248 26.54495386 11.11281671 35.14166122 15.34826717 12.91602778 6.37414341 17.48696012 10.60959485 18.87082027 15.30633169 1.38386015 4.61286685-0.12580547 13.50312062-7.42252263 29.10299872-5.45157063 11.61603859-14.46762889 28.09655497-25.11915823 47.51253164a28.18042496 25.03528825 0 0 0-10.52572486 1.59353659 28.18042496 25.03528825 0 0 0-16.98373826 32.038459 28.18042496 25.03528825 0 0 0 36.06423498 15.09665623 28.18042496 25.03528825 0 0 0 16.94180278-32.03845901 28.18042496 25.03528825 0 0 0-5.74511608-8.47090188c10.52572388-19.20630122 19.58371762-35.72875308 25.41270465-48.14155897 7.88380904-16.85793279 11.99345499-29.39654416 8.38703091-41.51580463-3.60642311-12.11926046-14.67730434-20.0030695-29.35460966-27.25785217-9.6450856-4.73867233-21.68047607-9.77089106-36.06423399-15.80955357a28.18042496 25.03528825 0 0 0-1.59353562-10.022502 28.18042496 25.03528825 0 0 0-6.08059796-8.7644483l22.14176246-40.38355541 122.61839638 52.96410227c22.14176247 9.6031511 31.2836262 33.12877372 20.54822685 52.8382968l-84.28966393 154.32137544c-10.77733482 19.66758857-37.23841869 27.80300855-59.38018118 18.24179293l-173.48574115-74.98005927c-22.14176247-9.5612156-31.32556167-33.12877372-20.54822687-52.83829679l84.28966395-154.27943995c7.38058716-13.54505513 22.22563246-21.59660511 37.951317-22.22563246h2.68384935z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-gitee",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M978.404275 409.561604H455.061338c-25.117645 0-45.499734 20.382089-45.499734 45.499734l-0.031997 113.781333c0 25.117645 20.350092 45.499734 45.499734 45.531731h318.594132c25.117645 0 45.499734 20.382089 45.499734 45.499735v22.749867a136.5312 136.5312 0 0 1-136.5312 136.5312H250.248539a45.499734 45.499734 0 0 1-45.499734-45.499734V341.343999a136.5312 136.5312 0 0 1 136.5312-136.5312L978.308284 204.780802c25.117645 0 45.499734-20.350092 45.499734-45.467738L1023.904009 45.531731h0.031997A45.499734 45.499734 0 0 0 978.468269 0h-0.031997L341.343999 0.031997C152.84967 0.031997 0.031997 152.84967 0.031997 341.343999v637.092273c0 25.117645 20.382089 45.499734 45.499734 45.499734h671.233072a307.171203 307.171203 0 0 0 307.171203-307.171203v-261.671468c0-25.117645-20.382089-45.499734-45.499734-45.499734z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-github",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M512 20.4425c-278.334 0-504 225.6345-504 504 0 222.6735 144.4275 411.6105 344.673 478.233 25.2 4.662 34.461-10.9305 34.461-24.255 0-12.0015-0.4725-51.723-0.693-93.8385-140.238 30.492-169.8165-59.472-169.8165-59.472-22.932-58.2435-55.944-73.7415-55.944-73.7415-45.738-31.2795 3.465-30.6495 3.465-30.6495 50.589 3.5595 77.238 51.9435 77.238 51.9435 44.9505 77.049 117.9045 54.7785 146.664 41.895 4.5045-32.571 17.577-54.81 32.004-67.41-111.951-12.726-229.635-55.9755-229.635-249.0705 0-55.0305 19.6875-99.981 51.9435-135.2925-5.229-12.6945-22.491-63.945 4.8825-133.371 0 0 42.336-13.545 138.6315 51.66 40.194-11.1825 83.3175-16.758 126.1575-16.9785 42.8085 0.189 85.9635 5.796 126.252 16.9785 96.201-65.205 138.4425-51.66 138.4425-51.66 27.4365 69.426 10.1745 120.6765 4.9455 133.371 32.319 35.28 51.8805 80.262 51.8805 135.2925 0 193.5675-117.9045 236.187-230.139 248.6925 18.081 15.6555 34.1775 46.305 34.1775 93.3345 0 67.4415-0.5985 121.716-0.5985 138.3165 0 13.419 9.072 29.1375 34.6185 24.192 200.151-66.717 344.3895-255.5595 344.3895-478.17 0-278.3655-225.666-504-504-504z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-gitlab",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M66.61375986 405.11600042L512.11376028 976.03999972 23.84576 621.65599958a39.312 39.312 0 0 1-14.07600042-43.30799944l56.8080007-173.26800028z m259.88400014 0h371.26800014L512.14975986 976.03999972zM215.11376 60.88400042l111.384 344.232H66.61375986l111.384-344.232a19.72800014 19.72800014 0 0 1 37.11600014 0z m742.49999972 344.232l56.8080007 173.2679993a39.23999986 39.23999986 0 0 1-14.07600042 43.30800042l-488.26800028 354.38400014 445.50000042-570.92400028z m0 0h-259.88400014l111.384-344.232a19.72800014 19.72800014 0 0 1 37.11600014 0z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-loading",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M843.307 742.24c0 3.217 2.607 5.824 5.824 5.824s5.824-2.607 5.824-5.824a5.823 5.823 0 0 0-5.824-5.824 5.823 5.823 0 0 0-5.824 5.824zM714.731 874.912c0 6.398 5.186 11.584 11.584 11.584s11.584-5.186 11.584-11.584-5.186-11.584-11.584-11.584-11.584 5.186-11.584 11.584zM541.419 943.2c0 9.614 7.794 17.408 17.408 17.408s17.408-7.794 17.408-17.408-7.794-17.408-17.408-17.408-17.408 7.794-17.408 17.408z m-186.56-9.152c0 12.795 10.373 23.168 23.168 23.168s23.168-10.373 23.168-23.168-10.373-23.168-23.168-23.168-23.168 10.373-23.168 23.168zM189.355 849.12c0 16.012 12.98 28.992 28.992 28.992s28.992-12.98 28.992-28.992-12.98-28.992-28.992-28.992-28.992 12.98-28.992 28.992zM74.731 704.736c0 19.228 15.588 34.816 34.816 34.816s34.816-15.588 34.816-34.816-15.588-34.816-34.816-34.816-34.816 15.588-34.816 34.816z m-43.008-177.28c0 22.41 18.166 40.576 40.576 40.576s40.576-18.166 40.576-40.576-18.166-40.576-40.576-40.576-40.576 18.166-40.576 40.576z m35.392-176.128c0 25.626 20.774 46.4 46.4 46.4s46.4-20.774 46.4-46.4c0-25.626-20.774-46.4-46.4-46.4-25.626 0-46.4 20.774-46.4 46.4z m106.176-142.016c0 28.843 23.381 52.224 52.224 52.224s52.224-23.381 52.224-52.224c0-28.843-23.381-52.224-52.224-52.224-28.843 0-52.224 23.381-52.224 52.224z m155.904-81.344c0 32.024 25.96 57.984 57.984 57.984s57.984-25.96 57.984-57.984-25.96-57.984-57.984-57.984-57.984 25.96-57.984 57.984z m175.104-5.056c0 35.24 28.568 63.808 63.808 63.808s63.808-28.568 63.808-63.808c0-35.24-28.568-63.808-63.808-63.808-35.24 0-63.808 28.568-63.808 63.808z m160.32 72.128c0 38.421 31.147 69.568 69.568 69.568s69.568-31.147 69.568-69.568-31.147-69.568-69.568-69.568-69.568 31.147-69.568 69.568z m113.92 135.488c0 41.638 33.754 75.392 75.392 75.392s75.392-33.754 75.392-75.392-33.754-75.392-75.392-75.392-75.392 33.754-75.392 75.392z m45.312 175.488c0 44.854 36.362 81.216 81.216 81.216s81.216-36.362 81.216-81.216c0-44.854-36.362-81.216-81.216-81.216-44.854 0-81.216 36.362-81.216 81.216z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-like",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M885.9 533.7c16.8-22.2 26.1-49.4 26.1-77.7 0-44.9-25.1-87.4-65.5-111.1a67.67 67.67 0 0 0-34.3-9.3H572.4l6-122.9c1.4-29.7-9.1-57.9-29.5-79.4-20.5-21.5-48.1-33.4-77.9-33.4-52 0-98 35-111.8 85.1l-85.9 311H144c-17.7 0-32 14.3-32 32v364c0 17.7 14.3 32 32 32h601.3c9.2 0 18.2-1.8 26.5-5.4 47.6-20.3 78.3-66.8 78.3-118.4 0-12.6-1.8-25-5.4-37 16.8-22.2 26.1-49.4 26.1-77.7 0-12.6-1.8-25-5.4-37 16.8-22.2 26.1-49.4 26.1-77.7-0.2-12.6-2-25.1-5.6-37.1zM184 852V568h81v284h-81z m636.4-353l-21.9 19 13.9 25.4c4.6 8.4 6.9 17.6 6.9 27.3 0 16.5-7.2 32.2-19.6 43l-21.9 19 13.9 25.4c4.6 8.4 6.9 17.6 6.9 27.3 0 16.5-7.2 32.2-19.6 43l-21.9 19 13.9 25.4c4.6 8.4 6.9 17.6 6.9 27.3 0 22.4-13.2 42.6-33.6 51.8H329V564.8l99.5-360.5c5.2-18.9 22.5-32.2 42.2-32.3 7.6 0 15.1 2.2 21.1 6.7 9.9 7.4 15.2 18.6 14.6 30.5l-9.6 198.4h314.4C829 418.5 840 436.9 840 456c0 16.5-7.2 32.1-19.6 43z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-unlike",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M885.9 490.3c3.6-12 5.4-24.4 5.4-37 0-28.3-9.3-55.5-26.1-77.7 3.6-12 5.4-24.4 5.4-37 0-28.3-9.3-55.5-26.1-77.7 3.6-12 5.4-24.4 5.4-37 0-51.6-30.7-98.1-78.3-118.4-8.3-3.6-17.2-5.4-26.5-5.4H144c-17.7 0-32 14.3-32 32v364c0 17.7 14.3 32 32 32h129.3l85.8 310.8C372.9 889 418.9 924 470.9 924c29.7 0 57.4-11.8 77.9-33.4 20.5-21.5 31-49.7 29.5-79.4l-6-122.9h239.9c12.1 0 23.9-3.2 34.3-9.3 40.4-23.5 65.5-66.1 65.5-111 0-28.3-9.3-55.5-26.1-77.7zM184 456V172h81v284h-81z m627.2 160.4H496.8l9.6 198.4c0.6 11.9-4.7 23.1-14.6 30.5-6.1 4.5-13.6 6.8-21.1 6.7-19.6-0.1-36.9-13.4-42.2-32.3L329 459.2V172h415.4c20.4 9.2 33.6 29.4 33.6 51.8 0 9.7-2.3 18.9-6.9 27.3l-13.9 25.4 21.9 19c12.5 10.8 19.6 26.5 19.6 43 0 9.7-2.3 18.9-6.9 27.3l-13.9 25.4 21.9 19c12.5 10.8 19.6 26.5 19.6 43 0 9.7-2.3 18.9-6.9 27.3l-14 25.5 21.9 19c12.5 10.8 19.6 26.5 19.6 43 0 19.1-11 37.5-28.8 48.4z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-heart",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M923 283.6c-13.4-31.1-32.6-58.9-56.9-82.8-24.3-23.8-52.5-42.4-84-55.5-32.5-13.5-66.9-20.3-102.4-20.3-49.3 0-97.4 13.5-139.2 39-10 6.1-19.5 12.8-28.5 20.1-9-7.3-18.5-14-28.5-20.1-41.8-25.5-89.9-39-139.2-39-35.5 0-69.9 6.8-102.4 20.3-31.4 13-59.7 31.7-84 55.5-24.4 23.9-43.5 51.7-56.9 82.8-13.9 32.3-21 66.6-21 101.9 0 33.3 6.8 68 20.3 103.3 11.3 29.5 27.5 60.1 48.2 91 32.8 48.9 77.9 99.9 133.9 151.6 92.8 85.7 184.7 144.9 188.6 147.3l23.7 15.2c10.5 6.7 24 6.7 34.5 0l23.7-15.2c3.9-2.5 95.7-61.6 188.6-147.3 56-51.7 101.1-102.7 133.9-151.6 20.7-30.9 37-61.5 48.2-91 13.5-35.3 20.3-70 20.3-103.3 0.1-35.3-7-69.6-20.9-101.9zM512 814.8S156 586.7 156 385.5C156 283.6 240.3 201 344.3 201c73.1 0 136.5 40.8 167.7 100.4C543.2 241.8 606.6 201 679.7 201c104 0 188.3 82.6 188.3 184.5 0 201.2-356 429.3-356 429.3z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-edit",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M723.2 917.76H286.72c-65.28 0-118.4-51.2-118.4-113.92V261.76C168.32 198.4 221.44 147.2 286.72 147.2h375.04c17.92 0 32 14.08 32 32s-14.08 32-32 32H286.72c-30.08 0-54.4 22.4-54.4 49.92v542.08c0 27.52 24.32 49.92 54.4 49.92H723.2c30.08 0 54.4-22.4 54.4-49.92V440.32c0-17.92 14.08-32 32-32s32 14.08 32 32v363.52c0 62.72-53.12 113.92-118.4 113.92z"}}),e._v(" "),t("path",{attrs:{d:"M499.84 602.24c-7.68 0-14.72-2.56-21.12-7.68-13.44-11.52-14.72-32-3.2-45.44L780.16 198.4c11.52-13.44 32-14.72 45.44-3.2s14.72 32 3.2 45.44L524.16 591.36c-6.4 7.04-15.36 10.88-24.32 10.88z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-delete",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M677.647059 256l0-90.352941c0-37.436235-23.461647-60.235294-61.771294-60.235294L408.094118 105.411765c-38.249412 0-61.741176 22.799059-61.741176 60.235294l0 90.352941-180.705882 0 0 60.235294 60.235294 0 0 512c0 54.272 33.972706 90.352941 90.352941 90.352941l391.529412 0c55.085176 0 90.352941-33.490824 90.352941-90.352941l0-512 60.235294 0 0-60.235294L677.647059 256zM406.588235 165.647059l210.823529 0-1.264941 90.352941L406.588235 256 406.588235 165.647059zM737.882353 858.352941l-451.764706 0 0-542.117647 451.764706 0L737.882353 858.352941zM466.823529 376.470588l-58.729412 0-1.505882 391.529412 60.235294 0L466.823529 376.470588zM617.411765 376.470588l-60.235294 0 0 391.529412 60.235294 0L617.411765 376.470588z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-reply",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M426.666667 384 426.666667 213.333333 128 512 426.666667 810.666667 426.666667 635.733333C640 635.733333 789.333333 704 896 853.333333 853.333333 640 725.333333 426.666667 426.666667 384Z"}})]),e._v(" "),t("symbol",{attrs:{id:"vssue-icon-error",viewBox:"0 0 1024 1024"}},[t("path",{attrs:{d:"M512 720m-48 0a48 48 0 1 0 96 0 48 48 0 1 0-96 0Z"}}),e._v(" "),t("path",{attrs:{d:"M480 416v184c0 4.4 3.6 8 8 8h48c4.4 0 8-3.6 8-8V416c0-4.4-3.6-8-8-8h-48c-4.4 0-8 3.6-8 8z"}}),e._v(" "),t("path",{attrs:{d:"M955.7 856l-416-720c-6.2-10.7-16.9-16-27.7-16s-21.6 5.3-27.7 16l-416 720C56 877.4 71.4 904 96 904h832c24.6 0 40-26.6 27.7-48z m-783.5-27.9L512 239.9l339.8 588.2H172.2z"}})])])},staticRenderFns:[]},void 0,Br,void 0,!0,void 0,!1,void 0,void 0,void 0);const Nr=Ir({},void 0,i.default.extend({name:"TransitionFade",functional:!0,props:{group:{type:Boolean,required:!1,default:!1},tag:{type:String,required:!1,default:"div"}},render:(n,{props:e,children:t})=>n(e.group?"TransitionGroup":"Transition",{props:{name:"fade",mode:"out-in",appear:!0,tag:e.tag}},t)}),void 0,void 0,void 0,!1,void 0,void 0,void 0);const Pr=Ir({},void 0,i.default.extend({name:"VssueIcon",functional:!0,props:{name:{type:String,required:!0},title:{type:String,required:!1,default:null}},render:(n,{props:e,data:t})=>n("svg",Object.assign(Object.assign({},t),{class:["vssue-icon","vssue-icon-"+e.name],attrs:{"aria-hidden":"true"}}),[n("title",e.title),n("use",{attrs:{"xlink:href":"#vssue-icon-"+e.name}})])}),void 0,void 0,void 0,!1,void 0,void 0,void 0);let qr=class extends i.default{constructor(){super(...arguments),this.editMode=!1,this.editContent=this.comment.contentRaw,this.creatingReactions=[],this.isPutingComment=!1,this.isDeletingComment=!1}get currentUser(){return this.vssue.user?this.vssue.user.username:null}get content(){return this.comment.content}get author(){return this.comment.author}get createdAt(){return Lt(this.comment.createdAt)}get updatedAt(){return Lt(this.comment.updatedAt)}get showReactions(){return Boolean(this.vssue.API&&this.vssue.API.platform.meta.reactable&&this.comment.reactions&&!this.editMode)}get reactionKeys(){return["heart","like","unlike"]}get editContentRows(){return this.editContent.split("\n").length-1}get editInputRows(){return this.editContentRows<3?5:this.editContentRows+2}async postReaction({reaction:n}){try{if(this.creatingReactions.includes(n))return;this.creatingReactions.push(n);await this.vssue.postCommentReaction({commentId:this.comment.id,reaction:n})||this.vssue.$emit("error",new Error(this.vssue.$t("reactionGiven",{reaction:this.vssue.$t(n)})));const e=await this.vssue.getCommentReactions({commentId:this.comment.id});e&&(this.comment.reactions=e)}finally{this.creatingReactions.splice(this.creatingReactions.findIndex(e=>e===n),1)}}enterEdit(){this.editMode=!0,this.$nextTick(()=>{this.$refs.input.focus()})}resetEdit(){this.editMode=!1,this.editContent=this.comment.contentRaw}async putComment(){try{if(this.vssue.isPending)return;if(this.editContent!==this.comment.contentRaw){this.isPutingComment=!0,this.vssue.isUpdatingComment=!0;const n=await this.vssue.putComment({commentId:this.comment.id,content:this.editContent});n&&this.vssue.comments.data.splice(this.vssue.comments.data.findIndex(n=>n.id===this.comment.id),1,n)}this.editMode=!1}finally{this.isPutingComment=!1,this.vssue.isUpdatingComment=!1}}async deleteComment(){try{if(this.vssue.isPending)return;if(!window.confirm(this.vssue.$t("deleteConfirm")))return;this.isDeletingComment=!0,this.vssue.isUpdatingComment=!0;await this.vssue.deleteComment({commentId:this.comment.id})?(this.vssue.comments.count-=1,this.vssue.comments.data.length>1&&this.vssue.comments.data.splice(this.vssue.comments.data.findIndex(n=>n.id===this.comment.id),1),this.vssue.query.page>1&&this.vssue.query.page>Math.ceil(this.vssue.comments.count/this.vssue.query.perPage)?this.vssue.query.page-=1:await this.vssue.getComments()):this.vssue.$emit("error",new Error(this.vssue.$t("deleteFailed")))}finally{this.isDeletingComment=!1,this.vssue.isUpdatingComment=!1}}};jr([_t({type:Object,required:!0})],qr.prototype,"comment",void 0),jr([wt()],qr.prototype,"vssue",void 0),qr=jr([bt({components:{VssueIcon:Pr}})],qr);const Rr=Ir({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-comment",class:{"vssue-comment-edit-mode":n.editMode,"vssue-comment-disabled":n.isDeletingComment||n.isPutingComment}},[t("div",{staticClass:"vssue-comment-avatar"},[t("a",{attrs:{href:n.author.homepage,title:n.author.username,target:"_blank",rel:"noopener noreferrer"}},[t("img",{attrs:{src:n.author.avatar,alt:n.author.username}})])]),n._v(" "),t("div",{staticClass:"vssue-comment-body"},[n._t("body",[t("div",{staticClass:"vssue-comment-header"},[t("span",{staticClass:"vssue-comment-author"},[t("a",{attrs:{href:n.author.homepage,title:n.author.username,target:"_blank",rel:"noopener noreferrer"}},[n._v("\n            "+n._s(n.author.username)+"\n          ")])]),n._v(" "),t("span",{staticClass:"vssue-comment-created-at"},[n._v("\n          "+n._s(n.createdAt)+"\n        ")])]),n._v(" "),t("div",{staticClass:"vssue-comment-main"},[n.editMode?t("textarea",{directives:[{name:"model",rawName:"v-model",value:n.editContent,expression:"editContent"}],ref:"input",staticClass:"vssue-edit-comment-input",attrs:{rows:n.editInputRows},domProps:{value:n.editContent},on:{keyup:function(e){return!e.type.indexOf("key")&&n._k(e.keyCode,"enter",13,e.key,"Enter")?null:e.ctrlKey?n.putComment():null},input:function(e){e.target.composing||(n.editContent=e.target.value)}}}):t("article",{staticClass:"markdown-body",domProps:{innerHTML:n._s(n.content)}})]),n._v(" "),t("div",{staticClass:"vssue-comment-footer"},[n.editMode?t("span",{staticClass:"vssue-comment-hint"},[n._v("\n          "+n._s(n.vssue.$t("editMode"))+"\n        ")]):n._e(),n._v(" "),n.showReactions?t("span",{staticClass:"vssue-comment-reactions"},n._l(n.reactionKeys,(function(e){return t("span",{key:e,staticClass:"vssue-comment-reaction",attrs:{title:n.vssue.$t(n.creatingReactions.includes(e)?"loading":e)},on:{click:function(t){return n.postReaction({reaction:e})}}},[t("VssueIcon",{attrs:{name:n.creatingReactions.includes(e)?"loading":e,title:n.vssue.$t(n.creatingReactions.includes(e)?"loading":e)}}),n._v(" "),t("span",{staticClass:"vssue-comment-reaction-number"},[n._v("\n              "+n._s(n.comment.reactions[e])+"\n            ")])],1)})),0):n._e(),n._v(" "),t("span",{staticClass:"vssue-comment-operations"},[n.comment.author.username===n.currentUser&&n.editMode?t("span",{staticClass:"vssue-comment-operation",class:{"vssue-comment-operation-muted":n.isPutingComment},attrs:{title:n.vssue.$t(n.isPutingComment?"loading":"submit")},on:{click:function(e){return n.putComment()}}},[t("VssueIcon",{directives:[{name:"show",rawName:"v-show",value:n.isPutingComment,expression:"isPutingComment"}],attrs:{name:"loading",title:n.vssue.$t("loading")}}),n._v("\n\n            "+n._s(n.vssue.$t("submit"))+"\n          ")],1):n._e(),n._v(" "),n.comment.author.username===n.currentUser&&n.editMode?t("span",{staticClass:"vssue-comment-operation vssue-comment-operation-muted",attrs:{title:n.vssue.$t("cancel")},on:{click:function(e){return n.resetEdit()}}},[n._v("\n            "+n._s(n.vssue.$t("cancel"))+"\n          ")]):n._e(),n._v(" "),n.comment.author.username===n.currentUser?t("span",{directives:[{name:"show",rawName:"v-show",value:!n.editMode,expression:"!editMode"}],staticClass:"vssue-comment-operation",on:{click:function(e){return n.enterEdit()}}},[t("VssueIcon",{attrs:{name:"edit",title:n.vssue.$t("edit")}})],1):n._e(),n._v(" "),n.comment.author.username===n.currentUser||n.vssue.isAdmin?t("span",{directives:[{name:"show",rawName:"v-show",value:!n.editMode,expression:"!editMode"}],staticClass:"vssue-comment-operation",on:{click:function(e){return n.deleteComment()}}},[t("VssueIcon",{attrs:{name:n.isDeletingComment?"loading":"delete",title:n.vssue.$t(n.isDeletingComment?"loading":"delete")}})],1):n._e(),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:!n.editMode,expression:"!editMode"}],staticClass:"vssue-comment-operation",on:{click:function(e){return n.vssue.$emit("reply-comment",n.comment)}}},[t("VssueIcon",{attrs:{name:"reply",title:n.vssue.$t("reply")}})],1)])])])],2)])},staticRenderFns:[]},void 0,qr,void 0,!1,void 0,!1,void 0,void 0,void 0);let Fr=class extends i.default{get disabled(){return this.vssue.isPending}get pageCount(){const n=Math.ceil(this.vssue.comments.count/this.vssue.comments.perPage);return n>1?n:1}get perPageOptions(){const n=[5,10,20,50];return!n.includes(this.vssue.options.perPage)&&this.vssue.options.perPage<100&&n.push(this.vssue.options.perPage),n.sort((n,e)=>n-e)}get page(){return this.vssue.query.page>this.pageCount?this.pageCount:this.vssue.query.page}set page(n){n>0&&n<=this.pageCount&&(this.vssue.query.page=n)}get perPage(){return this.vssue.query.perPage}set perPage(n){this.perPageOptions.includes(n)&&(this.vssue.query.perPage=n)}};jr([wt()],Fr.prototype,"vssue",void 0),Fr=jr([bt({components:{VssueIcon:Pr}})],Fr);const Mr=Ir({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-pagination"},[t("div",{staticClass:"vssue-pagination-per-page"},[t("label",[t("select",{directives:[{name:"model",rawName:"v-model",value:n.perPage,expression:"perPage"}],staticClass:"vssue-pagination-select",attrs:{disabled:n.disabled},on:{change:function(e){var t=Array.prototype.filter.call(e.target.options,(function(n){return n.selected})).map((function(n){return"_value"in n?n._value:n.value}));n.perPage=e.target.multiple?t:t[0]}}},n._l(n.perPageOptions,(function(e){return t("option",{key:e,domProps:{value:e}},[n._v("\n          "+n._s(e)+"\n        ")])})),0),n._v(" "),t("span",[n._v("\n        "+n._s(n.vssue.$t("perPage"))+"\n      ")])]),n._v(" "),n.vssue.API.platform.meta.sortable?t("span",{class:{"vssue-pagination-link":!0,disabled:n.disabled},attrs:{title:n.vssue.$t("sort")},on:{click:function(e){n.vssue.query.sort="asc"===n.vssue.query.sort?"desc":"asc"}}},[n._v("\n      "+n._s("asc"===n.vssue.query.sort?"↑":"↓")+"\n    ")]):n._e()]),n._v(" "),t("div",{staticClass:"vssue-pagination-page"},[t("span",{class:{"vssue-pagination-link":!0,disabled:1===n.page||n.disabled},attrs:{title:n.vssue.$t("prev")},domProps:{textContent:n._s("<")},on:{click:function(e){n.page-=1}}}),n._v(" "),t("label",[t("span",[n._v("\n        "+n._s(n.vssue.$t("page"))+"\n      ")]),n._v(" "),t("select",{directives:[{name:"show",rawName:"v-show",value:n.pageCount>1,expression:"pageCount > 1"},{name:"model",rawName:"v-model",value:n.page,expression:"page"}],staticClass:"vssue-pagination-select",attrs:{disabled:n.disabled},on:{change:function(e){var t=Array.prototype.filter.call(e.target.options,(function(n){return n.selected})).map((function(n){return"_value"in n?n._value:n.value}));n.page=e.target.multiple?t:t[0]}}},n._l(n.pageCount,(function(e){return t("option",{key:e,domProps:{value:e}},[n._v("\n          "+n._s(e)+"\n        ")])})),0),n._v(" "),t("span",{directives:[{name:"show",rawName:"v-show",value:n.pageCount<2,expression:"pageCount < 2"}],domProps:{textContent:n._s(n.page)}}),n._v(" "),t("span",{domProps:{textContent:n._s(" / "+n.pageCount+" ")}})]),n._v(" "),t("span",{class:{"vssue-pagination-link":!0,disabled:n.page===n.pageCount||n.disabled},attrs:{title:n.vssue.$t("next")},domProps:{textContent:n._s(">")},on:{click:function(e){n.page+=1}}})])])},staticRenderFns:[]},void 0,Fr,void 0,!1,void 0,!1,void 0,void 0,void 0);let zr=class extends i.default{};jr([wt()],zr.prototype,"vssue",void 0),zr=jr([bt({components:{TransitionFade:Nr,VssueComment:Rr,VssuePagination:Mr}})],zr);const Dr=Ir({render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"vssue-comments"},[e("VssuePagination"),this._v(" "),e("TransitionFade",{attrs:{group:""}},this._l(this.vssue.comments.data,(function(n){return e("VssueComment",{key:n.id,attrs:{comment:n}})})),1),this._v(" "),e("VssuePagination",{directives:[{name:"show",rawName:"v-show",value:this.vssue.comments.data.length>5,expression:"vssue.comments.data.length > 5"}]})],1)},staticRenderFns:[]},void 0,zr,void 0,!1,void 0,!1,void 0,void 0,void 0);const Ur=Ir({},void 0,i.default.extend({name:"VssueIcon",functional:!0,props:{type:{type:String,required:!1,default:"default"}},render:(n,{props:e,data:t,children:r})=>n("button",Object.assign(Object.assign({},t),{class:["vssue-button","vssue-button-"+e.type]}),r)}),void 0,void 0,void 0,!1,void 0,void 0,void 0);let $r=class extends i.default{constructor(){super(...arguments),this.content=""}get user(){return this.vssue.user}get platform(){return this.vssue.API&&this.vssue.API.platform.name}get isInputDisabled(){return this.loading||null===this.user||null===this.vssue.issue}get isSubmitDisabled(){return""===this.content||this.vssue.isPending||null===this.vssue.issue}get loading(){return this.vssue.isCreatingComment}get contentRows(){return this.content.split("\n").length-1}get inputRows(){return this.contentRows<3?5:this.contentRows+2}created(){this.vssue.$on("reply-comment",n=>{const e=n.contentRaw.replace(/\n/g,"\n> "),t=`@${n.author.username}\n\n> ${e}\n\n`;this.content=this.content.concat(t),this.focus()})}beforeDestroy(){this.vssue.$off("reply-comment")}focus(){this.$refs.input.focus()}async submit(){this.isSubmitDisabled||(await this.vssue.postComment({content:this.content}),this.content="",await this.vssue.getComments())}};jr([wt()],$r.prototype,"vssue",void 0),$r=jr([bt({components:{VssueButton:Ur,VssueIcon:Pr}})],$r);const Jr=Ir({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-new-comment"},[t("div",{staticClass:"vssue-comment-avatar"},[n.user?t("a",{attrs:{href:n.user.homepage,title:n.user.username,target:"_blank",rel:"noopener noreferrer"}},[t("img",{attrs:{src:n.user.avatar,alt:n.user.username}})]):t("VssueIcon",{attrs:{name:n.platform.toLowerCase(),title:n.vssue.$t("loginToComment",{platform:n.platform})},on:{click:function(e){return n.vssue.login()}}})],1),n._v(" "),t("div",{staticClass:"vssue-new-comment-body"},[t("textarea",{directives:[{name:"model",rawName:"v-model",value:n.content,expression:"content"}],ref:"input",staticClass:"vssue-new-comment-input",attrs:{rows:n.inputRows,disabled:n.isInputDisabled,placeholder:n.vssue.$t(n.user?"placeholder":"noLoginPlaceHolder"),spellcheck:!1,"aria-label":"leave a comment"},domProps:{value:n.content},on:{keyup:function(e){return!e.type.indexOf("key")&&n._k(e.keyCode,"enter",13,e.key,"Enter")?null:e.ctrlKey?n.submit():null},input:function(e){e.target.composing||(n.content=e.target.value)}}})]),n._v(" "),t("div",{staticClass:"vssue-new-comment-footer"},[n.user?t("span",{staticClass:"vssue-current-user"},[t("span",[n._v(n._s(n.vssue.$t("currentUser"))+" - "+n._s(n.user.username)+" - ")]),n._v(" "),t("a",{staticClass:"vssue-logout",on:{click:function(e){return n.vssue.logout()}}},[n._v("\n        "+n._s(n.vssue.$t("logout"))+"\n      ")])]):t("span",{staticClass:"vssue-current-user"},[n._v("\n      "+n._s(n.vssue.$t("loginToComment",{platform:n.platform}))+"\n    ")]),n._v(" "),t("div",{staticClass:"vssue-new-comment-operations"},[n.user?t("VssueButton",{staticClass:"vssue-button-submit-comment",attrs:{type:"primary",disabled:n.isSubmitDisabled},on:{click:function(e){return n.submit()}}},[t("VssueIcon",{directives:[{name:"show",rawName:"v-show",value:n.loading,expression:"loading"}],attrs:{name:"loading"}}),n._v("\n\n        "+n._s(n.vssue.$t(n.loading?"submitting":"submitComment"))+"\n      ")],1):t("VssueButton",{staticClass:"vssue-button-login",attrs:{type:"primary",title:n.vssue.$t("loginToComment",{platform:n.platform})},on:{click:function(e){return n.vssue.login()}}},[n._v("\n        "+n._s(n.vssue.$t("login",{platform:n.platform}))+"\n      ")])],1)])])},staticRenderFns:[]},void 0,$r,void 0,!1,void 0,!1,void 0,void 0,void 0);let Wr=class extends i.default{constructor(){super(...arguments),this.progress={show:!1,percent:0,timer:null,speed:200},this.alert={show:!1,message:null,timer:null}}onLoadingCommentsChange(n){this.vssue.comments&&(n?this.progressStart():this.progressDone())}created(){this.vssue.$on("error",n=>this.alertShow(n.message))}beforeDestroy(){this.vssue.$off("error"),null!==this.progress.timer&&window.clearTimeout(this.progress.timer),null!==this.alert.timer&&window.clearTimeout(this.alert.timer)}progressStart(){this.progress.show=!0,this.progress.percent=0,this.progress.timer=window.setInterval(()=>{this.progress.percent+=5,this.progress.percent>94&&null!==this.progress.timer&&window.clearInterval(this.progress.timer)},this.progress.speed)}progressDone(){this.progress.percent=100,null!==this.progress.timer&&window.clearTimeout(this.progress.timer),this.progress.timer=null,window.setTimeout(()=>{this.progress.show=!1},this.progress.speed)}alertShow(n){this.alert.show=!0,this.alert.message=n,null!==this.alert.timer&&window.clearTimeout(this.alert.timer),this.alert.timer=window.setTimeout(()=>{this.alertHide()},3e3)}alertHide(){this.alert.show=!1,null!==this.alert.timer&&window.clearTimeout(this.alert.timer),this.alert.timer=null}};jr([wt()],Wr.prototype,"vssue",void 0),jr([St("vssue.isLoadingComments")],Wr.prototype,"onLoadingCommentsChange",null),Wr=jr([bt({components:{TransitionFade:Nr}})],Wr);const Qr=Ir({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-notice"},[t("div",{directives:[{name:"show",rawName:"v-show",value:n.progress.show,expression:"progress.show"}],staticClass:"vssue-progress",style:{width:n.progress.percent+"%",transition:"all "+n.progress.speed+"ms linear"}}),n._v(" "),t("TransitionFade",[t("div",{directives:[{name:"show",rawName:"v-show",value:n.alert.show,expression:"alert.show"}],staticClass:"vssue-alert",domProps:{textContent:n._s(n.alert.message)},on:{click:function(e){return n.alertHide()}}})])],1)},staticRenderFns:[]},void 0,Wr,void 0,!1,void 0,!1,void 0,void 0,void 0);let Vr=class extends i.default{get status(){return this.vssue.isFailed?"failed":this.vssue.isInitializing?"initializing":this.vssue.isIssueNotCreated&&!this.vssue.isCreatingIssue?this.vssue.isAdmin||!this.vssue.isLogined?"issueNotCreated":"failed":this.vssue.isLoginRequired?"loginRequired":!this.vssue.comments||this.vssue.isCreatingIssue?"loadingComments":0===this.vssue.comments.data.length?"noComments":null}handleClick(){"issueNotCreated"===this.status?this.vssue.postIssue():"loginRequired"===this.status&&this.vssue.login()}};jr([wt()],Vr.prototype,"vssue",void 0),Vr=jr([bt({components:{TransitionFade:Nr,VssueIcon:Pr}})],Vr);const Hr=Ir({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("TransitionFade",[n.status?t("div",{key:n.status,staticClass:"vssue-status"},[["failed","loadingComments","initializing"].includes(n.status)?t("VssueIcon",{attrs:{name:"failed"===n.status?"error":"loading"}}):n._e(),n._v(" "),t("p",{staticClass:"vssue-status-info"},[t(["issueNotCreated","loginRequired"].includes(n.status)?"a":"span",{tag:"Component",on:{click:n.handleClick}},[n._v("\n        "+n._s(n.vssue.$t(n.status))+"\n      ")])],1)],1):n._e()])},staticRenderFns:[]},void 0,Vr,void 0,!1,void 0,!1,void 0,void 0,void 0);let Gr=class extends i.default{};jr([wt()],Gr.prototype,"vssue",void 0),Gr=jr([bt({components:{TransitionFade:Nr,VssueIcon:Pr,VssueComments:Dr,VssueNewComment:Jr,VssueNotice:Qr,VssueStatus:Hr}})],Gr);const Kr=Ir({render:function(){var n=this.$createElement,e=this._self._c||n;return e("TransitionFade",[this.vssue.isInitializing?e("VssueStatus"):e("div",{staticClass:"vssue-body"},[this.vssue.API?e("VssueNewComment"):this._e(),this._v(" "),e("VssueNotice"),this._v(" "),e("TransitionFade",[this.vssue.comments&&this.vssue.comments.data.length>0?e("VssueComments"):e("VssueStatus")],1)],1)],1)},staticRenderFns:[]},void 0,Gr,void 0,!1,void 0,!1,void 0,void 0,void 0);let Yr=class extends i.default{};jr([wt()],Yr.prototype,"vssue",void 0),Yr=jr([bt],Yr);const Xr=Ir({render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"vssue-header"},[t("a",{staticClass:"vssue-header-comments-count",attrs:{href:n.vssue.issue?n.vssue.issue.link:null,target:"_blank",rel:"noopener noreferrer"}},[t("span",[n._v("\n      "+n._s(n.vssue.comments?n.vssue.$tc("comments",n.vssue.comments.count,{count:n.vssue.comments.count}):n.vssue.$tc("comments",0))+"\n    ")])]),n._v(" "),t("span",{staticClass:"vssue-header-powered-by"},[t("span",[n._v("Powered by")]),n._v(" "),n.vssue.API?t("span",[t("a",{attrs:{href:n.vssue.API.platform.link,title:n.vssue.API.platform.name+" API "+n.vssue.API.platform.version,target:"_blank",rel:"noopener noreferrer"}},[n._v("\n        "+n._s(n.vssue.API.platform.name)+"\n      ")]),n._v(" "),t("span",[n._v("&")])]):n._e(),n._v(" "),t("a",{attrs:{href:"https://github.com/meteorlxy/vssue",title:"Vssue v"+n.vssue.version,target:"_blank",rel:"noopener noreferrer"}},[n._v("\n      Vssue\n    ")])])])},staticRenderFns:[]},void 0,Yr,void 0,!1,void 0,!1,void 0,void 0,void 0),Zr={login:"Login with {platform}",logout:"Logout",currentUser:"Current User",loading:"Loading",submit:"Submit",submitting:"Submitting",submitComment:"Submit Comment",cancel:"Cancel",edit:"Edit",editMode:"Edit Mode",delete:"Delete",reply:"Reply",heart:"Heart",like:"Like",unlike:"Unlike",perPage:"Comments per page",sort:"Click to change the sort direction",page:"Page",prev:"Previous Page",next:"Next Page",comments:"Comments | {count} Comment | {count} Comments",loginToComment:"Login with {platform} account to leave a comment",placeholder:"Leave a comment. Styling with Markdown is supported. Ctrl + Enter to submit.",noLoginPlaceHolder:"Login to leave a comment. Styling with Markdown is supported. ",failed:"Failed to load comments",initializing:"Initializing...",issueNotCreated:"Click to create issue",loadingComments:"Loading comments...",loginRequired:"Login to view comments",noComments:"No comments yet. Leave the first comment !",reactionGiven:"Already given '{reaction}' reaction",deleteConfirm:"Confirm to delete this comment ?",deleteFailed:"Failed to delete comment"},na={login:"使用 {platform} 登录",logout:"退出登录",currentUser:"当前用户",loading:"加载中",submit:"提交",submitting:"发表中",submitComment:"发表评论",cancel:"取消",edit:"编辑",editMode:"编辑模式",delete:"删除",reply:"回复",heart:"喜欢",like:"赞",unlike:"踩",perPage:"每页评论数",sort:"点击改变排序方式",page:"页数",prev:"上一页",next:"下一页",comments:"评论 | {count} 条评论 | {count} 条评论",loginToComment:"使用 {platform} 帐号登录后发表评论",placeholder:"留下你的评论丨支持 Markdown 语法丨Ctrl + Enter 发表评论",noLoginPlaceHolder:"登录后才能发表评论丨支持 Markdown 语法",failed:"评论加载失败",initializing:"正在初始化...",issueNotCreated:"点击创建 Issue",loadingComments:"正在加载评论...",loginRequired:"登录后查看评论",noComments:"还没有评论，来发表第一条评论吧！",reactionGiven:"已经添加过 '{reaction}' 了",deleteConfirm:"确认要删除该评论吗？",deleteFailed:"评论删除失败"},ea={login:"Entrar com {platform}",logout:"Sair",currentUser:"Usuário Atual",loading:"Carregando",submit:"Enviar",submitting:"Enviando",submitComment:"Enviar Comentário",cancel:"Cancelar",edit:"Editar",editMode:"Modo de Edição",delete:"Apagar",reply:"Responder",heart:"Heart",like:"Like",unlike:"Unlike",perPage:"Comentários por página",sort:"Clique para alterar a ordenação",page:"Página",prev:"Página Anterior",next:"Próxima Página",comments:"Comentários | {count} Comentário | {count} Comentários",loginToComment:"Entre com uma conta {platform} para deixar um comentário",placeholder:"Deixe um comentário. Estilos com Markdown suportados. Ctrl + Enter para enviar.",noLoginPlaceHolder:"Entre para deixar um comentário. Estilos com Markdown suportados. ",failed:"Falha ao carregar comentários",initializing:"Inicializando...",issueNotCreated:"Click to create issue",loadingComments:"Carregando comentários...",loginRequired:"Entrar para visualizar comentários",noComments:"Nenhum comentário. Deixe o primeiro comentário!",reactionGiven:"Já reagiu com '{reaction}'",deleteConfirm:"Apagar este comentário?",deleteFailed:"Falha ao apagar comentário"},ta={login:"{platform} でログイン",logout:"ログアウト",currentUser:"現在のユーザー",loading:"読み込み中",submit:"送信",submitting:"送信中",submitComment:"コメントを送信",cancel:"キャンセル",edit:"編集",editMode:"編集モード",delete:"削除",reply:"返信",heart:"ハート",like:"高評価",unlike:"低評価",perPage:"コメント/ページ",sort:"並び順を変更するにはクリックしてください",page:"ページ",prev:"前のページ",next:"次のページ",comments:"コメント | {count} コメント | {count} コメント",loginToComment:"コメントを残すには {platform} アカウントでログインしてください。",placeholder:"コメントを残してください。Markdown 記法をサポートしています。 Ctrl + Enter で送信できます。",noLoginPlaceHolder:"コメントを残すにはログインしてください。マークダウン記法をサポートしています。",failed:"コメントの読み込みに失敗しました",initializing:"初期化中...",issueNotCreated:"Click to create issue",loadingComments:"コメントの読み込み中...",loginRequired:"コメントを見るにはログインしてください",noComments:"まだコメントがありません。最初のコメントを残しましょう！",reactionGiven:"既に '{reaction}' のリアクションをしています",deleteConfirm:"本当にコメントを削除してもいいですか？",deleteFailed:"コメントの削除に失敗しました"},ra={login:"התחברו עם {platform}",logout:"התנתקו",currentUser:"משתמש/ת נוכחי/ת",loading:"טוען",submit:"שליחה",submitting:"שולח",submitComment:"שליחת תגובה",cancel:"ביטל",edit:"עריכה",editMode:"מצב עריכה",delete:"מחיקה",reply:"תשובה",heart:"לב",like:"לייק",unlike:"אנלייק",perPage:"תגובות לדף",sort:"לחצו כדי לשנות את כיוון המיון",page:"דף",prev:"הדף הקודם",next:"הדף הבא",comments:"תגובות | {count} תגובה | {count} תגובות",loginToComment:"התחברו עם חשבון {platform} כדי להשאיר תגובה",placeholder:"השאירו תגובה. יש תמיכה בעיצוב בעזרת Markdown. Ctrl + Enter כדי לשלוח.",noLoginPlaceHolder:"התחברו כדי להשאיר תגובה. יש תמיכה בעיצוב בעזרת Markdown. ",failed:"כשלון בטעינת התגובות",initializing:"מאתחל...",issueNotCreated:"לחצו ליצירת issue",loadingComments:"טוען תגובות...",loginRequired:"התחברו כדי לצפות בתגובות",noComments:"עדיין אין תגובות. השאירו תגובה ראשונה !",reactionGiven:"כבר ניתן חיווי '{reaction}'",deleteConfirm:"בטוחים במחיקת התגובה ?",deleteFailed:"כשלון במחיקת התגובה"};Object.prototype.hasOwnProperty.call(i.default,"$i18n")||i.default.use(Or);const aa=new Or({locale:"en",fallbackLocale:"en",messages:{en:Zr,"en-US":Zr,zh:na,"zh-CN":na,pt:ea,"pt-BR":ea,ja:ta,"ja-JP":ta,he:ra,"he-IL":ra}});let ia=class extends i.default{constructor(){super(...arguments),this.title=n=>`${n.prefix}${document.title}`,this.issueId=null,this.options=null,this.API=null,this.accessToken=null,this.user=null,this.issue=null,this.comments=null,this.query={page:1,perPage:10,sort:"desc"},this.isInitializing=!0,this.isIssueNotCreated=!1,this.isLoginRequired=!1,this.isFailed=!1,this.isCreatingIssue=!1,this.isLoadingComments=!1,this.isCreatingComment=!1,this.isUpdatingComment=!1}get version(){return"1.4.8"}get issueTitle(){return null===this.options?"":"function"==typeof this.title?this.title(this.options):`${this.options.prefix}${this.title}`}get isPending(){return this.isLoadingComments||this.isCreatingComment||this.isUpdatingComment}get isLogined(){return null!==this.accessToken&&null!==this.user}get isAdmin(){return null!==this.options&&null!==this.accessToken&&null!==this.user&&(this.user.username===this.options.owner||this.options.admins.includes(this.user.username))}get accessTokenKey(){return this.API?`Vssue.${this.API.platform.name.toLowerCase()}.access_token`:""}onQueryPerPageChange(){this.query.page=1,this.getComments()}onQueryChange(){this.getComments()}setOptions(n){this.options=Object.assign({labels:["Vssue"],state:"Vssue",prefix:"[Vssue]",admins:[],perPage:10,proxy:n=>"https://cors-anywhere.azm.workers.dev/"+n,issueContent:({url:n})=>n,autoCreateIssue:!1},n);const e=["api","owner","repo","clientId"];for(const n of e)this.options[n]||console.warn(`[Vssue] the option '${n}' is required`);if(this.options.locale)this.$i18n.locale=this.options.locale;else{const n=Object.keys(this.$i18n.messages),e=window.navigator.languages;this.$i18n.locale=e.filter(e=>n.includes(e)).shift()||"en"}}async init(){try{await this.initStore(),await this.initComments()}catch(n){n.response&&[401,403].includes(n.response.status)?this.isLoginRequired=!0:this.isFailed=!0,console.error(n)}}async initStore(){try{if(!this.options)throw new Error("Options are required to initialize Vssue");this.API=null,this.accessToken=null,this.user=null,this.issue=null,this.comments=null,this.query={page:1,perPage:this.options.perPage,sort:"desc"},this.isInitializing=!0,this.isIssueNotCreated=!1,this.isLoginRequired=!1,this.isFailed=!1,this.isCreatingIssue=!1,this.isLoadingComments=!1,this.isCreatingComment=!1,this.isUpdatingComment=!1;const n=this.options.api;this.API=new n({baseURL:this.options.baseURL,labels:this.options.labels,state:this.options.state,owner:this.options.owner,repo:this.options.repo,clientId:this.options.clientId,clientSecret:this.options.clientSecret,proxy:this.options.proxy}),await this.handleAuth()}finally{this.isInitializing=!1}}async initComments(){if(this.API&&this.options)if(this.issueId){const[n,e]=await Promise.all([this.API.getIssue({accessToken:this.accessToken,issueId:this.issueId}),this.API.getComments({accessToken:this.accessToken,issueId:this.issueId,query:this.query})]);this.issue=n,this.comments=e}else this.issue=await this.API.getIssue({accessToken:this.accessToken,issueTitle:this.issueTitle}),null===this.issue?(this.isIssueNotCreated=!0,this.options.autoCreateIssue&&await this.postIssue()):await this.getComments()}async postIssue(){if(this.API&&this.options&&!this.issue&&!this.issueId&&(this.isLogined||this.login(),this.isAdmin))try{this.isCreatingIssue=!0;const n=await this.API.postIssue({title:this.issueTitle,content:await this.options.issueContent({options:this.options,url:Nt(window.location.href)}),accessToken:this.accessToken});this.issue=n,this.isIssueNotCreated=!1,await this.getComments()}catch(n){this.isFailed=!0}finally{this.isCreatingIssue=!1}}async getComments(){try{if(!this.API||!this.issue||this.isLoadingComments)return;this.isLoadingComments=!0;const n=await this.API.getComments({accessToken:this.accessToken,issueId:this.issue.id,query:this.query});return this.comments=n,this.query.page!==n.page&&(this.query.page=n.page),this.query.perPage!==n.perPage&&(this.query.perPage=n.perPage),n}catch(n){if(!n.response||![401,403].includes(n.response.status)||this.isLogined)throw this.$emit("error",n),n;this.isLoginRequired=!0}finally{this.isLoadingComments=!1}}async postComment({content:n}){try{if(!this.API||!this.issue||this.isCreatingComment)return;this.isCreatingComment=!0;return await this.API.postComment({accessToken:this.accessToken,content:n,issueId:this.issue.id})}catch(n){throw this.$emit("error",n),n}finally{this.isCreatingComment=!1}}async putComment({commentId:n,content:e}){try{if(!this.API||!this.issue)return;return await this.API.putComment({accessToken:this.accessToken,issueId:this.issue.id,commentId:n,content:e})}catch(n){throw this.$emit("error",n),n}}async deleteComment({commentId:n}){try{if(!this.API||!this.issue)return;return await this.API.deleteComment({accessToken:this.accessToken,issueId:this.issue.id,commentId:n})}catch(n){throw this.$emit("error",n),n}}async getCommentReactions({commentId:n}){try{if(!this.API||!this.issue)return;return await this.API.getCommentReactions({accessToken:this.accessToken,issueId:this.issue.id,commentId:n})}catch(n){throw this.$emit("error",n),n}}async postCommentReaction({commentId:n,reaction:e}){try{if(!this.API||!this.issue)return!1;return await this.API.postCommentReaction({accessToken:this.accessToken,issueId:this.issue.id,commentId:n,reaction:e})}catch(n){throw this.$emit("error",n),n}}login(){this.API&&this.API.redirectAuth()}logout(){this.setAccessToken(null),this.user=null}async handleAuth(){if(!this.API)return;const n=await this.API.handleAuth();n?(this.setAccessToken(n),this.user=await this.API.getUser({accessToken:n})):this.getAccessToken()?this.user=await this.API.getUser({accessToken:this.accessToken}):(this.setAccessToken(null),this.user=null)}getAccessToken(){return this.accessToken=window.localStorage.getItem(this.accessTokenKey),this.accessToken}setAccessToken(n){null===n?window.localStorage.removeItem(this.accessTokenKey):window.localStorage.setItem(this.accessTokenKey,n),this.accessToken=n}};jr([St("query.perPage")],ia.prototype,"onQueryPerPageChange",null),jr([St("query.page"),St("query.sort")],ia.prototype,"onQueryChange",null),ia=jr([bt({i18n:aa})],ia);var oa=ia;let sa=class extends i.default{constructor(){super(...arguments),this.vssue=new oa}onOptionsChange(n){this.vssue.setOptions(n)}mounted(){null!==this.title&&(this.vssue.title=this.title),null!==this.issueId&&(this.vssue.issueId=this.issueId),this.vssue.setOptions(this.options),this.vssue.init()}};var la;jr([_t({type:[String,Function],required:!1,default:null})],sa.prototype,"title",void 0),jr([_t({type:[String,Number],required:!1,default:null})],sa.prototype,"issueId",void 0),jr([_t({type:Object,required:!1,default:()=>({})})],sa.prototype,"options",void 0),jr([(la="vssue",pt((function(n,e){var t=n.provide;xt(t)&&(t=n.provide=kt(t)),t.managed[e]=la||e})))],sa.prototype,"vssue",void 0),jr([St("options",{deep:!0})],sa.prototype,"onOptionsChange",null),sa=jr([bt({components:{Iconfont:Lr,VssueBody:Kr,VssueHeader:Xr}})],sa);const ca=Ir({render:function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"vssue"},[e("Iconfont"),this._v(" "),e("VssueHeader"),this._v(" "),e("VssueBody")],1)},staticRenderFns:[]},void 0,sa,void 0,!1,void 0,!1,void 0,void 0,void 0);var ua=t(31),da=t.n(ua);function pa(n){return{username:n.login,avatar:n.avatar_url,homepage:n.html_url}}function ha(n){return{id:n.number,title:n.title,content:n.body,link:n.html_url}}function fa(n){return{like:n["+1"],unlike:n[-1],heart:n.heart}}function va(n){return{id:n.id,content:n.body_html,contentRaw:n.body,author:pa(n.user),createdAt:n.created_at,updatedAt:n.updated_at,reactions:fa(n.reactions)}}function ma(n){return"like"===n?"+1":"unlike"===n?"-1":n}class ya{constructor({baseURL:n="https://github.com",owner:e,repo:t,labels:r,clientId:a,clientSecret:i,state:o,proxy:s}){if(void 0===i||void 0===s)throw new Error("clientSecret and proxy is required for GitHub V3");this.baseURL=n,this.owner=e,this.repo=t,this.labels=r,this.clientId=a,this.clientSecret=i,this.state=o,this.proxy=s,this.$http=da.a.create({baseURL:"https://github.com"===n?"https://api.github.com":jt(n,"api/v3"),headers:{Accept:"application/vnd.github.v3+json"}}),this.$http.interceptors.response.use(n=>n.data&&n.data.error?Promise.reject(new Error(n.data.error_description)):n,n=>(void 0===n.response&&"Network Error"===n.message&&(n.response={status:403}),Promise.reject(n)))}get platform(){return{name:"GitHub",link:this.baseURL,version:"v3",meta:{reactable:!0,sortable:!1}}}redirectAuth(){window.location.href=Ot(jt(this.baseURL,"login/oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,scope:"public_repo",state:this.state})}async handleAuth(){const n=Pt(window.location.search);if(n.code){if(n.state!==this.state)return null;const e=n.code;delete n.code,delete n.state;const t=Ot(Nt(window.location.href),n)+window.location.hash;window.history.replaceState(null,"",t);return await this.getAccessToken({code:e})}return null}async getAccessToken({code:n}){const e=jt(this.baseURL,"login/oauth/access_token"),t="function"==typeof this.proxy?this.proxy(e):this.proxy,{data:r}=await this.$http.post(t,{client_id:this.clientId,client_secret:this.clientSecret,code:n},{headers:{Accept:"application/json"}});return r.access_token}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{headers:{Authorization:"token "+n}});return pa(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const r={};if(n&&(r.headers={Authorization:"token "+n}),!e){r.params={q:[`"${t}"`,"is:issue","in:title",`repo:${this.owner}/${this.repo}`,"is:public",...this.labels.map(n=>"label:"+n)].join(" "),timestamp:Date.now()};const{data:n}=await this.$http.get("search/issues",r);return n.items.map(ha).find(n=>n.title===t)||null}try{r.params={timestamp:Date.now()};const{data:n}=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}`,r);return ha(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:r}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues`,{title:e,body:t,labels:this.labels},{headers:{Authorization:"token "+n}});return ha(r)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:r=10}={}}){const a={params:{timestamp:Date.now()}},i={params:{page:t,per_page:r,timestamp:Date.now()},headers:{Accept:["application/vnd.github.v3.raw+json","application/vnd.github.v3.html+json","application/vnd.github.squirrel-girl-preview"]}};n&&(a.headers={Authorization:"token "+n},i.headers.Authorization="token "+n);const[o,s]=await Promise.all([this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}`,a),this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,i)]),l=s.headers.link||null,c=/rel="next"/.test(l)?Number(l.replace(/^.*[^_]page=(\d*).*rel="next".*$/,"$1"))-1:/rel="prev"/.test(l)?Number(l.replace(/^.*[^_]page=(\d*).*rel="prev".*$/,"$1"))+1:1,u=l?Number(l.replace(/^.*per_page=(\d*).*$/,"$1")):r;return{count:Number(o.data.comments),page:c,perPage:u,data:s.data.map(va)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:r}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,{body:t},{headers:{Authorization:"token "+n,Accept:["application/vnd.github.v3.raw+json","application/vnd.github.v3.html+json","application/vnd.github.squirrel-girl-preview"]}});return va(r)}async putComment({accessToken:n,commentId:e,content:t}){const{data:r}=await this.$http.patch(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{body:t},{headers:{Authorization:"token "+n,Accept:["application/vnd.github.v3.raw+json","application/vnd.github.v3.html+json","application/vnd.github.squirrel-girl-preview"]}});return va(r)}async deleteComment({accessToken:n,commentId:e}){const{status:t}=await this.$http.delete(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{headers:{Authorization:"token "+n}});return 204===t}async getCommentReactions({accessToken:n,commentId:e}){const{data:t}=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{params:{timestamp:Date.now()},headers:{Authorization:"token "+n,Accept:"application/vnd.github.squirrel-girl-preview"}});return fa(t.reactions)}async postCommentReaction({accessToken:n,commentId:e,reaction:t}){const r=await this.$http.post(`repos/${this.owner}/${this.repo}/issues/comments/${e}/reactions`,{content:ma(t)},{headers:{Authorization:"token "+n,Accept:"application/vnd.github.squirrel-girl-preview"}});return 200===r.status?this.deleteCommentReaction({accessToken:n,commentId:e,reactionId:r.data.id}):201===r.status}async deleteCommentReaction({accessToken:n,commentId:e,reactionId:t}){return 204===(await this.$http.delete(`repos/${this.owner}/${this.repo}/issues/comments/${e}/reactions/${t}`,{headers:{Authorization:"token "+n,Accept:"application/vnd.github.squirrel-girl-preview"}})).status}}function ba(n){return null===n?{username:"ghost",avatar:"https://avatars3.githubusercontent.com/u/10137?v=4",homepage:"https://github.com/ghost"}:{username:n.login,avatar:n.avatarUrl,homepage:n.url}}function wa(n){return{id:n.number,title:n.title,content:n.body,link:n.url}}function ka(n){return{like:n.find(n=>"THUMBS_UP"===n.content).users.totalCount,unlike:n.find(n=>"THUMBS_DOWN"===n.content).users.totalCount,heart:n.find(n=>"HEART"===n.content).users.totalCount}}function xa(n){return{id:n.id,content:n.bodyHTML,contentRaw:n.body,author:ba(n.author),createdAt:n.createdAt,updatedAt:n.updatedAt,reactions:ka(n.reactionGroups)}}function Ea(n){return"like"===n?"THUMBS_UP":"unlike"===n?"THUMBS_DOWN":"heart"===n?"HEART":n}class Aa{constructor({baseURL:n="https://github.com",owner:e,repo:t,labels:r,clientId:a,clientSecret:i,state:o,proxy:s}){if(void 0===i||void 0===s)throw new Error("clientSecret and proxy is required for GitHub V4");this.baseURL=n,this.owner=e,this.repo=t,this.labels=r,this.clientId=a,this.clientSecret=i,this.state=o,this.proxy=s,this._pageInfo={page:1,startCursor:null,endCursor:null,sort:null,perPage:null},this._issueNodeId=null,this.$http=da.a.create({baseURL:"https://github.com"===n?"https://api.github.com":jt(n,"api"),headers:{Accept:"application/vnd.github.v3+json"}}),this.$http.interceptors.response.use(n=>n.data.error?Promise.reject(n.data.error_description):n.data.errors?Promise.reject(n.data.errors[0].message):n)}get platform(){return{name:"GitHub",link:this.baseURL,version:"v4",meta:{reactable:!0,sortable:!0}}}redirectAuth(){window.location.href=Ot(jt(this.baseURL,"login/oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,scope:"public_repo",state:this.state})}async handleAuth(){const n=Pt(window.location.search);if(n.code){if(n.state!==this.state)return null;const e=n.code;delete n.code,delete n.state;const t=Ot(Nt(window.location.href),n)+window.location.hash;window.history.replaceState(null,"",t);return await this.getAccessToken({code:e})}return null}async getAccessToken({code:n}){const e=jt(this.baseURL,"login/oauth/access_token"),t="function"==typeof this.proxy?this.proxy(e):this.proxy,{data:r}=await this.$http.post(t,{client_id:this.clientId,client_secret:this.clientSecret,code:n},{headers:{Accept:"application/json"}});return r.access_token}async getUser({accessToken:n}){const{data:e}=await this.$http.post("graphql",{query:"query getUser {\n  viewer {\n    login\n    avatarUrl\n    url\n  }\n}"},{headers:{Authorization:"token "+n}});return ba(e.data.viewer)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const r={};if(n&&(r.headers={Authorization:"token "+n}),!e){const n=[`"${t}"`,"in:title",`repo:${this.owner}/${this.repo}`,"is:public",...this.labels.map(n=>"label:"+n)].join(" "),{data:e}=await this.$http.post("graphql",{variables:{query:n},query:"query getIssueByTitle(\n  $query: String!\n) {\n  search(\n    query: $query\n    type: ISSUE\n    first: 20\n    ) {\n      nodes {\n      ... on Issue {\n        id\n        number\n        title\n        body\n        url\n      }\n    }\n  }\n}"},r),a=e.data.search.nodes.find(n=>n.title===t);return a?(this._issueNodeId=a.id,wa(a)):null}try{const{data:n}=await this.$http.post("graphql",{query:`query getIssueById {\n  repository(owner: "${this.owner}", name: "${this.repo}") {\n    issue (number: ${e}) {\n      id\n      number\n      title\n      body\n      url\n    }\n  }\n}`},r);return this._issueNodeId=n.data.repository.issue.id,wa(n.data.repository.issue)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:r}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues`,{title:e,body:t,labels:this.labels},{headers:{Authorization:"token "+n}});return r.url=r.html_url,this._issueNodeId=r.node_id,wa(r)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:r=10,sort:a="desc"}={}}){const i={};n&&(i.headers={Authorization:"token "+n}),null!==this._pageInfo.sort&&a!==this._pageInfo.sort&&(t=1);const{firstOrLast:o,afterOrBefore:s,cursor:l}=this._getQueryParams({page:t,sort:a}),{data:c}=await this.$http.post("graphql",{variables:{owner:this.owner,repo:this.repo,issueId:e,perPage:r},query:`query getComments(\n  $owner: String!\n  $repo: String!\n  $issueId: Int!\n  $perPage: Int!\n) {\n  repository(owner: $owner, name: $repo) {\n    issue(number: $issueId) {\n      comments(\n        ${o}: $perPage\n        ${null===s?"":`${s}: "${l}"`}\n      ) {\n        totalCount\n        pageInfo {\n          endCursor\n          startCursor\n        }\n        nodes {\n          id\n          body\n          bodyHTML\n          createdAt\n          updatedAt\n          author {\n            avatarUrl\n            login\n            url\n          }\n          reactionGroups {\n            users (first: 0) {\n              totalCount\n            }\n            content\n          }\n        }\n      }\n    }\n  }\n}`},i),u=c.data.repository.issue.comments;return"desc"===a&&u.nodes.reverse(),this._pageInfo={page:t,startCursor:u.pageInfo.startCursor,endCursor:u.pageInfo.endCursor,sort:a,perPage:r},{count:u.totalCount,page:t,perPage:r,data:u.nodes.map(xa)}}async postComment({accessToken:n,content:e}){const{data:t}=await this.$http.post("graphql",{variables:{issueNodeId:this._issueNodeId,content:e},query:"mutation postComment(\n  $issueNodeId: ID!\n  $content: String!\n) {\n  addComment(\n    input: {\n      subjectId: $issueNodeId\n      body: $content\n    }\n  ) {\n    commentEdge {\n      node {\n        id\n        body\n        bodyHTML\n        createdAt\n        updatedAt\n        author {\n          avatarUrl\n          login\n          url\n        }\n        reactionGroups {\n          users (first: 0) {\n            totalCount\n          }\n          content\n        }\n      }\n    }\n  }\n}"},{headers:{Authorization:"token "+n}});return xa(t.data.addComment.commentEdge.node)}async putComment({accessToken:n,commentId:e,content:t}){const{data:r}=await this.$http.post("graphql",{variables:{commentId:e,content:t},query:"mutation putComment(\n  $commentId: ID!,\n  $content: String!,\n) {\n  updateIssueComment(input: {\n    id: $commentId\n    body: $content\n  }) {\n    issueComment {\n      id\n      body\n      bodyHTML\n      createdAt\n      updatedAt\n      author {\n        avatarUrl\n        login\n        url\n      }\n      reactionGroups {\n        users (first: 0) {\n          totalCount\n        }\n        content\n      }\n    }\n  }\n}"},{headers:{Authorization:"token "+n}});return xa(r.data.updateIssueComment.issueComment)}async deleteComment({accessToken:n,commentId:e}){return await this.$http.post("graphql",{variables:{commentId:e},query:"mutation deleteComment(\n  $commentId: ID!,\n) {\n  deleteIssueComment(input: {\n    id: $commentId\n  }) {\n    clientMutationId\n  }\n}"},{headers:{Authorization:"token "+n}}),!0}async getCommentReactions({accessToken:n,issueId:e,commentId:t}){const{firstOrLast:r,afterOrBefore:a,cursor:i}=this._getQueryParams(),{data:o}=await this.$http.post("graphql",{variables:{owner:this.owner,repo:this.repo,issueId:e,perPage:this._pageInfo.perPage},query:`query getComments(\n  $owner: String!\n  $repo: String!\n  $issueId: Int!\n  $perPage: Int!\n) {\n  repository(owner: $owner, name: $repo) {\n    issue(number: $issueId) {\n      comments(\n        ${r}: $perPage\n        ${null===a?"":`${a}: "${i}"`}\n      ) {\n        nodes {\n          id\n          reactionGroups {\n            users (first: 0) {\n              totalCount\n            }\n            content\n          }\n        }\n      }\n    }\n  }\n}`},{headers:{Authorization:"token "+n}});return ka(o.data.repository.issue.comments.nodes.find(n=>n.id===t).reactionGroups)}async postCommentReaction({accessToken:n,commentId:e,reaction:t}){return await this.$http.post("graphql",{variables:{commentId:e,content:Ea(t)},query:"mutation postCommentReaction(\n  $commentId: ID!,\n  $content: ReactionContent!,\n) {\n  addReaction(input: {\n    subjectId: $commentId\n    content: $content\n  }) {\n    reaction {\n      databaseId\n    }\n  }\n}"},{headers:{Authorization:"token "+n}}),!0}_getQueryParams({page:n=this._pageInfo.page,sort:e=this._pageInfo.sort}={}){let t,r,a;return 1===n?(t="asc"===e?"first":"last",r=null,a=null):"asc"===e?n>this._pageInfo.page?(t="first",r="after",a=this._pageInfo.endCursor):(t="last",r="before",a=this._pageInfo.startCursor):n>this._pageInfo.page?(t="last",r="before",a=this._pageInfo.startCursor):(t="first",r="after",a=this._pageInfo.endCursor),{firstOrLast:t,afterOrBefore:r,cursor:a}}}function _a(n){return{username:n.username,avatar:n.avatar_url,homepage:n.web_url}}function Sa(n){return{id:n.iid,title:n.title,content:n.description,link:n.web_url}}function Ca(n){return{id:n.id,content:n.body_html||"",contentRaw:n.body,author:_a(n.author),createdAt:n.created_at,updatedAt:n.updated_at,reactions:n.reactions}}function Ta(n){return{like:n.filter(n=>"thumbsup"===n.name).length,unlike:n.filter(n=>"thumbsdown"===n.name).length,heart:n.filter(n=>"heart"===n.name).length}}function Oa(n){return"like"===n?"thumbsup":"unlike"===n?"thumbsdown":n}class ja{constructor({baseURL:n="https://gitlab.com",owner:e,repo:t,labels:r,clientId:a,state:i}){this.baseURL=n,this.owner=e,this.repo=t,this.labels=r,this.clientId=a,this.state=i,this._encodedRepo=encodeURIComponent(`${this.owner}/${this.repo}`),this.$http=da.a.create({baseURL:jt(n,"api/v4"),headers:{Accept:"application/json"}})}get platform(){return{name:"GitLab",link:this.baseURL,version:"v4",meta:{reactable:!0,sortable:!0}}}redirectAuth(){window.location.href=Ot(jt(this.baseURL,"oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,response_type:"token",state:this.state})}async handleAuth(){const n=Pt(window.location.hash.slice(1));if(!n.access_token||n.state!==this.state)return null;const e=n.access_token;delete n.access_token,delete n.token_type,delete n.expires_in,delete n.state;const t=Tt(n),r=t?"#"+t:"",a=`${Nt(window.location.href)}${window.location.search}${r}`;return window.history.replaceState(null,"",a),e}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{headers:{Authorization:"Bearer "+n}});return _a(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const r={};if(n&&(r.headers={Authorization:"Bearer "+n}),!e){r.params={labels:this.labels.join(","),order_by:"created_at",sort:"asc",search:t};const{data:n}=await this.$http.get(`projects/${this._encodedRepo}/issues`,r);return n.map(Sa).find(n=>n.title===t)||null}try{const{data:n}=await this.$http.get(`projects/${this._encodedRepo}/issues/${e}`,r);return Sa(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:r}=await this.$http.post(`projects/${this._encodedRepo}/issues`,{title:e,description:t,labels:this.labels.join(",")},{headers:{Authorization:"Bearer "+n}});return Sa(r)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:r=10,sort:a="desc"}={}}){const i={params:{page:t,per_page:r,order_by:"created_at",sort:a}};n&&(i.headers={Authorization:"Bearer "+n});const o=await this.$http.get(`projects/${this._encodedRepo}/issues/${e}/notes`,i),s=o.data,l=[];for(const t of s)l.push((async()=>{t.body_html=await this.getMarkdownContent({accessToken:n,contentRaw:t.body})})()),l.push((async()=>{t.reactions=await this.getCommentReactions({accessToken:n,issueId:e,commentId:t.id})})());return await Promise.all(l),{count:Number(o.headers["x-total"]),page:Number(o.headers["x-page"]),perPage:Number(o.headers["x-per-page"]),data:s.map(Ca)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:r}=await this.$http.post(`projects/${this._encodedRepo}/issues/${e}/notes`,{body:t},{headers:{Authorization:"Bearer "+n}});return Ca(r)}async putComment({accessToken:n,issueId:e,commentId:t,content:r}){const{data:a}=await this.$http.put(`projects/${this._encodedRepo}/issues/${e}/notes/${t}`,{body:r},{headers:{Authorization:"Bearer "+n}}),[i,o]=await Promise.all([this.getMarkdownContent({accessToken:n,contentRaw:a.body}),this.getCommentReactions({accessToken:n,issueId:e,commentId:a.id})]);return a.body_html=i,a.reactions=o,Ca(a)}async deleteComment({accessToken:n,issueId:e,commentId:t}){const{status:r}=await this.$http.delete(`projects/${this._encodedRepo}/issues/${e}/notes/${t}`,{headers:{Authorization:"Bearer "+n}});return 204===r}async getCommentReactions({accessToken:n,issueId:e,commentId:t}){const{data:r}=await this.$http.get(`projects/${this._encodedRepo}/issues/${e}/notes/${t}/award_emoji`,{headers:{Authorization:"Bearer "+n}});return Ta(r)}async postCommentReaction({issueId:n,commentId:e,reaction:t,accessToken:r}){try{return 201===(await this.$http.post(`projects/${this._encodedRepo}/issues/${n}/notes/${e}/award_emoji`,{name:Oa(t)},{headers:{Authorization:"Bearer "+r}})).status}catch(n){if(n.response&&404===n.response.status)return!1;throw n}}async getMarkdownContent({accessToken:n,contentRaw:e}){const t={};n&&(t.headers={Authorization:"Bearer "+n});const{data:r}=await this.$http.post("markdown",{text:e,gfm:!0},t);return r.html}}function Ba(n){return{username:n.nickname,avatar:n.links.avatar.href,homepage:n.links.html.href}}function Ia(n){return{id:n.id,title:n.title,content:n.content.raw,link:n.links.html.href}}function La(n){return{id:n.id,content:n.content.html,contentRaw:n.content.raw,author:Ba(n.user),createdAt:n.created_on,updatedAt:n.updated_on,reactions:null}}class Na{constructor({baseURL:n="https://bitbucket.org",owner:e,repo:t,clientId:r,state:a}){this.baseURL=n,this.owner=e,this.repo=t,this.clientId=r,this.state=a,this.$http=da.a.create({baseURL:"https://api.bitbucket.org/2.0",headers:{Accept:"application/json"}})}get platform(){return{name:"Bitbucket",link:this.baseURL,version:"v2",meta:{reactable:!1,sortable:!0}}}redirectAuth(){window.location.href=Ot(jt(this.baseURL,"site/oauth2/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,response_type:"token",state:this.state})}async handleAuth(){const n=Pt(window.location.hash.slice(1));if(!n.access_token||n.state!==this.state)return null;const e=n.access_token;delete n.access_token,delete n.token_type,delete n.expires_in,delete n.state,delete n.scopes;const t=Tt(n),r=t?"#"+t:"",a=`${Nt(window.location.href)}${window.location.search}${r}`;return window.history.replaceState(null,"",a),e}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{headers:{Authorization:"Bearer "+n}});return Ba(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const r={};if(n&&(r.headers={Authorization:"Bearer "+n}),!e){r.params={sort:"created_on",q:`title="${t}"`,timestamp:Date.now()};const{data:n}=await this.$http.get(`repositories/${this.owner}/${this.repo}/issues`,r);return n.size>0?Ia(n.values[0]):null}try{r.params={timestamp:Date.now()};const{data:n}=await this.$http.get(`repositories/${this.owner}/${this.repo}/issues/${e}`,r);return Ia(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:r}=await this.$http.post(`repositories/${this.owner}/${this.repo}/issues`,{title:e,content:{raw:t},priority:"trivial",kind:"task"},{headers:{Authorization:"Bearer "+n}});return r.links.html={href:jt(this.baseURL,`${this.owner}/${this.repo}/issues/${r.id}`)},Ia(r)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:r=10,sort:a="desc"}={}}){const i={params:{page:t,pagelen:r,sort:"desc"===a?"-created_on":"created_on",timestamp:Date.now()}};n&&(i.headers={Authorization:"Bearer "+n});const{data:o}=await this.$http.get(`repositories/${this.owner}/${this.repo}/issues/${e}/comments`,i);return{count:o.size,page:o.page,perPage:o.pagelen,data:o.values.filter(n=>null!==n.content.raw).map(La)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:r}=await this.$http.post(`repositories/${this.owner}/${this.repo}/issues/${e}/comments`,{content:{raw:t}},{headers:{Authorization:"Bearer "+n}});return La(r)}async putComment({accessToken:n,issueId:e,commentId:t,content:r}){const{data:a}=await this.$http.put(`repositories/${this.owner}/${this.repo}/issues/${e}/comments/${t}`,{content:{raw:r}},{headers:{Authorization:"Bearer "+n}});return La(a)}async deleteComment({accessToken:n,issueId:e,commentId:t}){const{status:r}=await this.$http.delete(`repositories/${this.owner}/${this.repo}/issues/${e}/comments/${t}`,{headers:{Authorization:"Bearer "+n}});return 204===r}async getCommentReactions(n){throw new Error("501 Not Implemented")}async postCommentReaction(n){throw new Error("501 Not Implemented")}}function Pa(n){return{username:n.login,avatar:n.avatar_url,homepage:n.html_url}}function qa(n){return{id:n.number,title:n.title,content:n.body,link:n.html_url}}function Ra(n){return{id:n.id,content:n.body_html||"",contentRaw:n.body,author:Pa(n.user),createdAt:n.created_at,updatedAt:n.updated_at||"",reactions:null}}class Fa{constructor({baseURL:n="https://gitee.com",owner:e,repo:t,labels:r,clientId:a,clientSecret:i,state:o,proxy:s}){if(void 0===i||void 0===s)throw new Error("clientSecret and proxy is required for Gitee V5");this.baseURL=n,this.owner=e,this.repo=t,this.labels=r,this.clientId=a,this.clientSecret=i,this.state=o,this.proxy=s,this.$http=da.a.create({baseURL:jt(n,"api/v5")}),this.$http.interceptors.response.use(n=>n,n=>(n.response.data&&n.response.data.message&&(n.message=n.response.data.message),Promise.reject(n)))}get platform(){return{name:"Gitee",link:this.baseURL,version:"v5",meta:{reactable:!1,sortable:!1}}}redirectAuth(){window.location.href=Ot(jt(this.baseURL,"oauth/authorize"),{client_id:this.clientId,redirect_uri:window.location.href,scope:"user_info issues notes",response_type:"code",state:this.state})}async handleAuth(){const n=Pt(window.location.search);if(n.code){if(n.state!==this.state)return null;const e=n.code;delete n.code,delete n.state;const t=Ot(Nt(window.location.href),n)+window.location.hash;window.history.replaceState(null,"",t);return await this.getAccessToken({code:e})}return null}async getAccessToken({code:n}){const e=jt(this.baseURL,"oauth/token"),t="function"==typeof this.proxy?this.proxy(e):this.proxy,{data:r}=await this.$http.post(t,{client_id:this.clientId,client_secret:this.clientSecret,code:n,grant_type:"authorization_code",redirect_uri:window.location.href});return r.access_token}async getUser({accessToken:n}){const{data:e}=await this.$http.get("user",{params:{access_token:n}});return Pa(e)}async getIssue({accessToken:n,issueId:e,issueTitle:t}){const r={params:{timestamp:Date.now()}};if(n&&(r.params.access_token=n),!e){Object.assign(r.params,{q:t,repo:`${this.owner}/${this.repo}`,per_page:1});const{data:n}=await this.$http.get("search/issues",r);return n.map(qa).find(n=>n.title===t)||null}try{const{data:n}=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}`,r);return qa(n)}catch(n){if(n.response&&404===n.response.status)return null;throw n}}async postIssue({accessToken:n,title:e,content:t}){const{data:r}=await this.$http.post(`repos/${this.owner}/issues`,{access_token:n,repo:this.repo,title:e,body:t,labels:this.labels.join(",")});return qa(r)}async getComments({accessToken:n,issueId:e,query:{page:t=1,perPage:r=10}={}}){const a={params:{page:t,per_page:r,timestamp:Date.now()},headers:{Accept:["application/vnd.gitee.html+json"]}};n&&(a.params.access_token=n);const i=await this.$http.get(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,a);return{count:Number(i.headers.total_count),page:t,perPage:r,data:i.data.map(Ra)}}async postComment({accessToken:n,issueId:e,content:t}){const{data:r}=await this.$http.post(`repos/${this.owner}/${this.repo}/issues/${e}/comments`,{body:t,access_token:n},{headers:{Accept:["application/vnd.gitee.html+json"]}});return Ra(r)}async putComment({accessToken:n,commentId:e,content:t}){const{data:r}=await this.$http.patch(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{body:t,access_token:n},{headers:{Accept:["application/vnd.gitee.html+json"]}});return Ra(r)}async deleteComment({accessToken:n,commentId:e}){const{status:t}=await this.$http.delete(`repos/${this.owner}/${this.repo}/issues/comments/${e}`,{params:{access_token:n}});return 204===t}async getCommentReactions(n){throw new Error("501 Not Implemented")}async postCommentReaction(n){throw new Error("501 Not Implemented")}}t(489);var Ma={name:"Vssue",components:{VssueComponent:ca},props:{options:{type:Object,default:function(){return{}}}},data:function(){return{key:"key",platformOptions:{github:ya,"github-v4":Aa,gitlab:ja,bitbucket:Na,gitee:Fa}}},computed:{vssueOptions:function(){var n=this.platformOptions,e=this.options,t=n[e.platform];return Object(Me.a)(Object(Me.a)({},e),{},{api:t})}},watch:{$route:function(n,e){var t=this;n.path!==e.path&&setTimeout((function(){t.key="reco-".concat((new Date).getTime())}),300)}}},za=(t(490),{components:{Valine:at,Vssue:Object(we.a)(Ma,(function(){var n=this.$createElement;return(this._self._c||n)("VssueComponent",{key:this.key,staticClass:"vssue-wrapper",attrs:{options:this.vssueOptions}})}),[],!1,null,null,null).exports},props:{isShowComments:{type:Boolean,default:!0}},data:function(){return{commentsOptions:{}}},computed:{solution:function(){var n=this.commentsOptions.solution,e=this.$themeConfig,t=e.valineConfig,r=e.vssueConfig,a="";return void 0!==n?a=n:void 0!==t?a="valine":void 0!==r&&(a="vssue"),this.$themeConfig.commentsSolution=a,a},options:function(){var n=this.commentsOptions.options,e=this.$themeConfig,t=e.valineConfig,r=e.vssueConfig;return void 0!==n?n:void 0!==t?t:void 0!==r?r:null},componentName:function(){var n=this.solution;return"valine"===n?"Valine":"vssue"===n?"Vssue":""}}}),Da=Object(we.a)(za,(function(){var n=this.$createElement,e=this._self._c||n;return e("div",{directives:[{name:"show",rawName:"v-show",value:this.isShowComments,expression:"isShowComments"}],staticClass:"comments-wrapper"},[e(this.componentName,{tag:"component",attrs:{options:this.options}})],1)}),[],!1,null,null,null).exports,Ua={props:{idVal:String,numStyle:Object,flagTitle:{type:String,default:"Your Article Title"}},methods:{getIdVal:function(n){var e=this.$site.base;return e.slice(0,e.length-1)+n}}},$a=Object(we.a)(Ua,(function(){var n=this.$createElement,e=this._self._c||n;return this.$themeConfig.valineConfig&&0!=this.$themeConfig.valineConfig.visitor?e("span",{staticClass:"leancloud-visitors",attrs:{id:this.getIdVal(this.idVal),"data-flag-title":this.flagTitle}},[e("a",{staticClass:"leancloud-visitors-count",style:this.numStyle})]):this._e()}),[],!1,null,null,null).exports,Ja=t(94);t(47),t(44);function Wa(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}t(70);function Qa(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function Va(n,e,t){return e&&Qa(n.prototype,e),t&&Qa(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}var Ha,Ga={tags:{Idea:{key:"Idea",scope:"tags",path:"/tags/Idea/",pageKeys:["v-073380e6","v-1be91c9a","v-f7f26542","v-a67c1470","v-3dc3c778","v-e8410f2c"]},"爱情":{key:"爱情",scope:"tags",path:"/tags/爱情/",pageKeys:["v-073380e6"]},"青年节":{key:"青年节",scope:"tags",path:"/tags/青年节/",pageKeys:["v-1be91c9a"]},"人生境界":{key:"人生境界",scope:"tags",path:"/tags/人生境界/",pageKeys:["v-f7f26542"]},"王小波":{key:"王小波",scope:"tags",path:"/tags/王小波/",pageKeys:["v-3dc3c778","v-e8410f2c"]},Java:{key:"Java",scope:"tags",path:"/tags/Java/",pageKeys:["v-bdcf9946","v-d0b6117a","v-0f4f0be8","v-312a14d9","v-383aa104","v-05a7ba0f","v-5f3f8622","v-22a22e56","v-5ae78972","v-6266d266","v-f65945d6","v-e1ec06b4","v-58e095d5","v-66485df2","v-7771c16d","v-5c491b59","v-64a9c608","v-5af16972","v-a9c98eb6","v-54d6b646","v-0de9a35d","v-464f68c4","v-6edd8a2c","v-36962f7c","v-008512f6","v-1252c4e0"]},"Java并发编程":{key:"Java并发编程",scope:"tags",path:"/tags/Java并发编程/",pageKeys:["v-bdcf9946","v-d0b6117a","v-0f4f0be8","v-312a14d9","v-383aa104","v-05a7ba0f","v-5f3f8622","v-22a22e56","v-5ae78972","v-6266d266","v-f65945d6","v-e1ec06b4","v-58e095d5","v-66485df2","v-7771c16d","v-5c491b59","v-64a9c608","v-5af16972","v-a9c98eb6","v-54d6b646","v-0de9a35d","v-464f68c4","v-6edd8a2c","v-36962f7c","v-008512f6","v-1252c4e0"]},JUC:{key:"JUC",scope:"tags",path:"/tags/JUC/",pageKeys:["v-bdcf9946","v-d0b6117a","v-0f4f0be8","v-312a14d9","v-383aa104","v-05a7ba0f","v-5f3f8622","v-22a22e56","v-5ae78972","v-6266d266","v-f65945d6","v-e1ec06b4","v-58e095d5","v-66485df2","v-7771c16d","v-5c491b59","v-64a9c608","v-5af16972","v-a9c98eb6","v-54d6b646","v-0de9a35d","v-464f68c4","v-6edd8a2c","v-36962f7c","v-008512f6","v-1252c4e0"]},"黄金时代":{key:"黄金时代",scope:"tags",path:"/tags/黄金时代/",pageKeys:["v-e8410f2c"]}},categories:{Idea:{key:"Idea",scope:"categories",path:"/categories/Idea/",pageKeys:["v-073380e6","v-1be91c9a","v-f7f26542","v-a67c1470","v-3dc3c778","v-e8410f2c"]},"技术":{key:"技术",scope:"categories",path:"/categories/技术/",pageKeys:["v-bdcf9946","v-d0b6117a","v-0f4f0be8","v-312a14d9","v-383aa104","v-05a7ba0f","v-5f3f8622","v-22a22e56","v-5ae78972","v-6266d266","v-f65945d6","v-e1ec06b4","v-58e095d5","v-66485df2","v-7771c16d","v-5c491b59","v-64a9c608","v-5af16972","v-a9c98eb6","v-54d6b646","v-0de9a35d","v-464f68c4","v-6edd8a2c","v-36962f7c","v-008512f6","v-1252c4e0"]}},timeline:{}},Ka=function(){function n(e,t){var r=this;Wa(this,n),this._metaMap=Object.assign({},e),Object.keys(this._metaMap).forEach((function(n){var e=r._metaMap[n].pageKeys;r._metaMap[n].pages=e.map((function(n){return Object(Xn.b)(t,n)}))}))}return Va(n,[{key:"length",get:function(){return Object.keys(this._metaMap).length}},{key:"map",get:function(){return this._metaMap}},{key:"pages",get:function(){return this.list}},{key:"list",get:function(){return this.toArray()}},{key:"toArray",value:function(){var n=this,e=[];return Object.keys(this._metaMap).forEach((function(t){var r=n._metaMap[t],a=r.pages,i=r.path;e.push({name:t,pages:a,path:i})})),e}},{key:"getItemByName",value:function(n){return this._metaMap[n]}}]),n}(),Ya=(t(239),{tags:function(n,e){return new Date(n.frontmatter.date).getTime()-new Date(e.frontmatter.date).getTime()>0?-1:1},categories:function(n,e){return new Date(n.frontmatter.date).getTime()-new Date(e.frontmatter.date).getTime()>0?-1:1}}),Xa=(t(102),{tags:function(n,e,t){var r=e;return["tags"].some((function(e){var t=n.frontmatter[e];return Array.isArray(t)?t.some((function(n){return n===r})):t===r}))},categories:function(n,e,t){var r=e;return["categories"].some((function(e){var t=n.frontmatter[e];return Array.isArray(t)?t.some((function(n){return n===r})):t===r}))}}),Za=[{pid:"tags",id:"Idea",filter:Xa.tags,sorter:Ya.tags,pages:[{path:"/tags/Idea/",interval:[0,6]}]},{pid:"tags",id:"爱情",filter:Xa.tags,sorter:Ya.tags,pages:[{path:"/tags/爱情/",interval:[0,1]}]},{pid:"tags",id:"青年节",filter:Xa.tags,sorter:Ya.tags,pages:[{path:"/tags/青年节/",interval:[0,1]}]},{pid:"tags",id:"人生境界",filter:Xa.tags,sorter:Ya.tags,pages:[{path:"/tags/人生境界/",interval:[0,1]}]},{pid:"tags",id:"王小波",filter:Xa.tags,sorter:Ya.tags,pages:[{path:"/tags/王小波/",interval:[0,2]}]},{pid:"tags",id:"Java",filter:Xa.tags,sorter:Ya.tags,pages:[{path:"/tags/Java/",interval:[0,9]},{path:"/tags/Java/page/2/",interval:[10,19]},{path:"/tags/Java/page/3/",interval:[20,26]}]},{pid:"tags",id:"Java并发编程",filter:Xa.tags,sorter:Ya.tags,pages:[{path:"/tags/Java并发编程/",interval:[0,9]},{path:"/tags/Java并发编程/page/2/",interval:[10,19]},{path:"/tags/Java并发编程/page/3/",interval:[20,26]}]},{pid:"tags",id:"JUC",filter:Xa.tags,sorter:Ya.tags,pages:[{path:"/tags/JUC/",interval:[0,9]},{path:"/tags/JUC/page/2/",interval:[10,19]},{path:"/tags/JUC/page/3/",interval:[20,26]}]},{pid:"tags",id:"黄金时代",filter:Xa.tags,sorter:Ya.tags,pages:[{path:"/tags/黄金时代/",interval:[0,1]}]},{pid:"categories",id:"Idea",filter:Xa.categories,sorter:Ya.categories,pages:[{path:"/categories/Idea/",interval:[0,6]}]},{pid:"categories",id:"技术",filter:Xa.categories,sorter:Ya.categories,pages:[{path:"/categories/技术/",interval:[0,9]},{path:"/categories/技术/page/2/",interval:[10,19]},{path:"/categories/技术/page/3/",interval:[20,26]}]}],ni=t(271),ei=t.n(ni)()("plugin-blog:pagination"),ti=function(){function n(e,t,r){Wa(this,n),ei(e);for(var a=e.pages,i=r.path,o=0,s=a.length;o<s;o++){if(a[o].path===i){this.paginationIndex=o;break}}this.paginationIndex||(this.paginationIndex=0),this._paginationPages=a,this._currentPage=a[this.paginationIndex],this._matchedPages=t.filter((function(n){return e.filter(n,e.id,e.pid)})).sort(e.sorter)}return Va(n,[{key:"setIndexPage",value:function(n){this._indexPage=n}},{key:"length",get:function(){return this._paginationPages.length}},{key:"pages",get:function(){var n=Object(ne.a)(this._currentPage.interval,2),e=n[0],t=n[1];return this._matchedPages.slice(e,t+1)}},{key:"hasPrev",get:function(){return 0!==this.paginationIndex}},{key:"prevLink",get:function(){return this.hasPrev?this.paginationIndex-1==0&&this._indexPage?this._indexPage:this._paginationPages[this.paginationIndex-1].path:null}},{key:"hasNext",get:function(){return this.paginationIndex!==this.length-1}},{key:"nextLink",get:function(){return this.hasNext?this._paginationPages[this.paginationIndex+1].path:null}},{key:"getSpecificPageLink",value:function(n){return this._paginationPages[n].path}}]),n}(),ri=new(function(){function n(e){Wa(this,n),this.paginations=e}return Va(n,[{key:"pages",get:function(){return i.default.$vuepress.$get("siteData").pages}},{key:"getPagination",value:function(n,e,t){ei("id",e),ei("this.paginations",this.paginations);var r=this.paginations.filter((function(t){return t.id===e&&t.pid===n}))[0];return new ti(r,this.pages,t)}}]),n}())(Za),ai=Object(we.a)({},(function(){var n=this.$createElement,e=this._self._c||n;return e("svg",{staticStyle:{"enable-background":"new 0 0 50 50"},attrs:{xmlns:"http://www.w3.org/2000/svg",x:"0px",y:"0px",viewBox:"0 0 30 30"}},[e("rect",{attrs:{x:"0",y:"13",width:"4",height:"5"}},[e("animate",{attrs:{attributeName:"height",attributeType:"XML",values:"5;21;5",begin:"0s",dur:"0.6s",repeatCount:"indefinite"}}),this._v(" "),e("animate",{attrs:{attributeName:"y",attributeType:"XML",values:"13; 5; 13",begin:"0s",dur:"0.6s",repeatCount:"indefinite"}})]),this._v(" "),e("rect",{attrs:{x:"10",y:"13",width:"4",height:"5"}},[e("animate",{attrs:{attributeName:"height",attributeType:"XML",values:"5;21;5",begin:"0.15s",dur:"0.6s",repeatCount:"indefinite"}}),this._v(" "),e("animate",{attrs:{attributeName:"y",attributeType:"XML",values:"13; 5; 13",begin:"0.15s",dur:"0.6s",repeatCount:"indefinite"}})]),this._v(" "),e("rect",{attrs:{x:"20",y:"13",width:"4",height:"5"}},[e("animate",{attrs:{attributeName:"height",attributeType:"XML",values:"5;21;5",begin:"0.3s",dur:"0.6s",repeatCount:"indefinite"}}),this._v(" "),e("animate",{attrs:{attributeName:"y",attributeType:"XML",values:"13; 5; 13",begin:"0.3s",dur:"0.6s",repeatCount:"indefinite"}})])])}),[],!1,null,null,null).exports,ii={x:0,y:0,"line-width":2,"line-length":50,"text-margin":10,"font-size":14,"font-color":"#8DA1AC","line-color":"#8DA1AC","element-color":"black",fill:"white","yes-text":"yes","no-text":"no","arrow-end":"block",scale:1},oi={ant:Object.assign({},ii,{symbols:{start:{class:"start-element","font-color":"white",fill:"#595959","line-width":"0px"},end:{class:"end-element","font-color":"white",fill:"#595959","line-width":"0px"},operation:{class:"operation-element","font-color":"white",fill:"#1890ff","line-width":"0px"},inputoutput:{class:"inputoutput-element","font-color":"white",fill:"#1890ff","line-width":"0px"},subroutine:{class:"subroutine-element","font-color":"white",fill:"#FF485E","element-color":"#fff","line-color":"red"},condition:{class:"condition-element","font-color":"white",fill:"#FF485E","line-width":"0px"},parallel:{class:"parallel-element","font-color":"white",fill:"#1890ff","line-width":"0px"}}}),vue:Object.assign({},ii,{symbols:{start:{class:"start-element","font-color":"white",fill:"#2F495F","line-width":"0px"},end:{class:"end-element","font-color":"white",fill:"#2F495F","line-width":"0px"},operation:{class:"operation-element","font-color":"white",fill:"#00BC7D","line-width":"0px"},inputoutput:{class:"inputoutput-element","font-color":"white",fill:"#EB4D5D","line-width":"0px"},subroutine:{class:"subroutine-element","font-color":"white",fill:"#937AC4","element-color":"#fff","line-color":"red"},condition:{class:"condition-element","font-color":"white",fill:"#FFB500","line-width":"0px"},parallel:{class:"parallel-element","font-color":"white",fill:"#2F495F","line-width":"0px"}}})},si={name:"flowchart",components:{Loading:ai},props:{id:{type:String,required:!0},code:{type:String,required:!0},preset:{type:String,default:"vue"}},data:function(){return{loading:!0}},mounted:function(){var n=this,e=oi[this.preset];if(e){var r=this.code;this.$el.setAttribute("id",this.id);Promise.all([t.e(3).then(t.t.bind(null,733,7)),new Promise((function(n){return setTimeout(n,500)}))]).then((function(t){(0,Object(ne.a)(t,1)[0].default.parse)(r).drawSVG(n.id,e),n.loading=!1}))}else console.warn("[vuepress-plugin-flowchart] Unknown preset: ".concat(this.preset))}},li=(t(493),Object(we.a)(si,(function(){var n=this.$createElement,e=this._self._c||n;return e("div",{staticClass:"vuepress-flowchart",class:{loading:this.loading}},[this.loading?e("Loading",{staticClass:"vuepress-flowchart-loading-icon"}):this._e()],1)}),[],!1,null,null,null).exports);function ci(n,e){void 0===e&&(e={});var t=e.registrationOptions;void 0===t&&(t={}),delete e.registrationOptions;var r=function(n){for(var t=[],r=arguments.length-1;r-- >0;)t[r]=arguments[r+1];e&&e[n]&&e[n].apply(e,t)};"serviceWorker"in navigator&&Ha.then((function(){Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/))?(!function(n,e,t){fetch(n).then((function(r){404===r.status?(e("error",new Error("Service worker not found at "+n)),pi()):-1===r.headers.get("content-type").indexOf("javascript")?(e("error",new Error("Expected "+n+" to have javascript content-type, but received "+r.headers.get("content-type"))),pi()):di(n,e,t)})).catch((function(n){return ui(e,n)}))}(n,r,t),navigator.serviceWorker.ready.then((function(n){r("ready",n)})).catch((function(n){return ui(r,n)}))):(di(n,r,t),navigator.serviceWorker.ready.then((function(n){r("ready",n)})).catch((function(n){return ui(r,n)})))}))}function ui(n,e){navigator.onLine||n("offline"),n("error",e)}function di(n,e,t){navigator.serviceWorker.register(n,t).then((function(n){e("registered",n),n.waiting?e("updated",n):n.onupdatefound=function(){e("updatefound",n);var t=n.installing;t.onstatechange=function(){"installed"===t.state&&(navigator.serviceWorker.controller?e("updated",n):e("cached",n))}}})).catch((function(n){return ui(e,n)}))}function pi(){"serviceWorker"in navigator&&navigator.serviceWorker.ready.then((function(n){n.unregister()})).catch((function(n){return ui(emit,n)}))}"undefined"!=typeof window&&(Ha="undefined"!=typeof Promise?new Promise((function(n){return window.addEventListener("load",n)})):{then:function(n){return window.addEventListener("load",n)}});var hi=function(){function n(e){Wa(this,n),Object.defineProperty(this,"registration",{value:e,configurable:!0,writable:!0})}return Va(n,[{key:"update",value:function(){return this.registration.update()}},{key:"skipWaiting",value:function(){var n=this.registration.waiting;return n?(console.log("[vuepress:sw] Doing worker.skipWaiting()."),new Promise((function(e,t){var r=new MessageChannel;r.port1.onmessage=function(n){console.log("[vuepress:sw] Done worker.skipWaiting()."),n.data.error?t(n.data.error):e(n.data)},n.postMessage({type:"skip-waiting"},[r.port2])}))):Promise.resolve()}}]),n}(),fi=t(74);i.default.component("SWUpdatePopup",(function(){return Promise.all([t.e(0),t.e(23)]).then(t.bind(null,735))}));t(171);var vi={name:"DynamicTitle",data:function(){return{originTitle:"",recoverTimeout:null,config:{showIcon:"/img/favicon.ico",showText:"(/≧▽≦/)欢迎回来！",hideIcon:"/img/favicon.ico",hideText:"别跑呀",recoverTime:2e3}}},mounted:function(){var n=this;this.originTitle=document.title,""!==this.config.showIcon&&this.getIconElm().setAttribute("href",this.config.showIcon),document.addEventListener("visibilitychange",(function(){document.hidden?n.hidden():n.visible()}))},methods:{hidden:function(){""!==this.config.hideIcon&&this.getIconElm().setAttribute("href",this.config.hideIcon),document.title=this.config.hideText,clearTimeout(this.recoverTimeout)},visible:function(){var n=this;""!==this.config.showIcon&&this.getIconElm().setAttribute("href",this.config.showIcon),document.title=this.config.showText+this.originTitle,this.recoverTimeout=setTimeout((function(){document.title=n.originTitle}),this.config.recoverTime)},getIconElm:function(){var n=document.querySelector("link[rel=icon]");return null===n&&((n=document.createElement("link")).setAttribute("rel","icon"),document.head.appendChild(n)),n}},watch:{$route:function(n,e){n.path!==e.path&&(this.originTitle=document.title,clearTimeout(this.recoverTimeout))}}},mi=Object(we.a)(vi,(function(){var n=this.$createElement;return(this._self._c||n)("div")}),[],!1,null,null,null).exports;t(494);var gi=function(n){var e=n.Vue;n.router.options.scrollBehavior=function(n,t,r){if(r)return window.scrollTo({top:r.y,behavior:"smooth"});if(!n.hash)return window.scrollTo({top:0,behavior:"smooth"});if(!e.$vuepress.$get("disableScrollBehavior")){var a,i,o,s=document.querySelector(n.hash);return s?window.scrollTo({top:(a=s,i=document.documentElement.getBoundingClientRect(),o=a.getBoundingClientRect(),{x:o.left-i.left,y:o.top-i.top}).y,behavior:"smooth"}):void 0}}},yi=(t(282),{name:"ReadingProgress",data:function(){return{readingTop:0,readingHeight:1,progressStyle:null,transform:void 0,running:!1}},watch:{$readingShow:function(){this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)}},mounted:function(){this.transform=this.getTransform(),this.progressStyle=this.getProgressStyle(),this.$readingShow&&window.addEventListener("scroll",this.base)},beforeDestroy:function(){this.$readingShow&&window.removeEventListener("scroll",this.base)},methods:{base:function(){this.running||(this.running=!0,requestAnimationFrame(this.getReadingBase))},getReadingBase:function(){this.readingHeight=this.getReadingHeight()-this.getScreenHeight(),this.readingTop=this.getReadingTop(),this.progressStyle=this.getProgressStyle(),this.running=!1},getReadingHeight:function(){return Math.max(document.body.scrollHeight,document.body.offsetHeight,0)},getScreenHeight:function(){return Math.max(window.innerHeight,document.documentElement.clientHeight,0)},getReadingTop:function(){return Math.max(window.pageYOffset,document.documentElement.scrollTop,0)},getTransform:function(){var n=document.createElement("div");return["transform","-webkit-transform","-moz-transform","-o-transform","-ms-transform"].find((function(e){return e in n.style}))||void 0},getProgressStyle:function(){var n=this.readingTop/this.readingHeight;switch(this.$readingShow){case"top":case"bottom":return this.transform?"".concat(this.transform,": scaleX(").concat(n,")"):"width: ".concat(100*n,"%");case"left":case"right":return this.transform?"".concat(this.transform,": scaleY(").concat(n,")"):"height: ".concat(100*n,"%");default:return null}}}}),bi=(t(495),Object(we.a)(yi,(function(){var n=this.$createElement,e=this._self._c||n;return e("ClientOnly",[this.$readingShow?e("div",{staticClass:"reading-progress",class:this.$readingShow},[e("div",{staticClass:"progress",style:this.progressStyle})]):this._e()])}),[],!1,null,"3640397f",null).exports),wi=(t(179),t(180),t(132),t(172),{name:"Meting",props:{auto:{required:!1,type:String,default:""},server:{required:!1,type:String,default:""},type:{required:!1,type:String,default:""},mid:{required:!1,type:String,default:""},additionalAudios:{required:!1,type:Array,default:function(){return[]}},fixed:{required:!1,type:Boolean,default:!1},mini:{required:!1,type:Boolean,default:null},autoplay:{required:!1,type:Boolean,default:!1},theme:{required:!1,type:String,default:"#b7daff"},loop:{required:!1,type:String,default:"all"},order:{required:!1,type:String,default:"list"},preload:{required:!1,type:String,default:"auto"},volume:{required:!1,type:Number,default:.7},customAudioType:{required:!1,type:Object,default:void 0},mutex:{required:!1,type:Boolean,default:!0},lrcType:{required:!1,type:Number,default:0},listFolded:{required:!1,type:Boolean,default:!1},listMaxHeight:{required:!1,type:Number,default:250},storageName:{required:!1,type:String,default:"vuepress-plugin-meting"}},data:function(){return{metingApi:"https://api.i-meto.com/meting/api",audio:[]}},mounted:function(){var n,e=this;if(this.auto){var t=this.parse_link(this.auto);n=Object(Me.a)(Object(Me.a)({},t),{},{r:Math.random()})}else n={server:this.server,type:this.type,id:this.mid,r:Math.random()};var r=this.metingApi,a=[];Object.keys(n).forEach((function(e){return a.push(e+"="+n[e])})),r+="?"+a.join("&"),fetch(r,{headers:{referer:null}}).then((function(n){return n.json()})).then((function(n){var t=n.map((function(n){return{name:n.name||n.title||"Audio name",artist:n.artist||n.author||"Audio artist",url:n.url,cover:n.cover||n.pic,lrc:n.lrc||n.lyric||"",type:n.type||"auto"}}));e.audio=t.concat(e.additionalAudios)}))},methods:{parse_link:function(n){for(var e=0,t=[["music.163.com.*song.*id=(\\d+)","netease","song"],["music.163.com.*album.*id=(\\d+)","netease","album"],["music.163.com.*artist.*id=(\\d+)","netease","artist"],["music.163.com.*playlist.*id=(\\d+)","netease","playlist"],["music.163.com.*discover/toplist.*id=(\\d+)","netease","playlist"],["y.qq.com.*song/(\\w+).html","tencent","song"],["y.qq.com.*album/(\\w+).html","tencent","album"],["y.qq.com.*singer/(\\w+).html","tencent","artist"],["y.qq.com.*playsquare/(\\w+).html","tencent","playlist"],["y.qq.com.*playlist/(\\w+).html","tencent","playlist"],["xiami.com.*song/(\\w+)","xiami","song"],["xiami.com.*album/(\\w+)","xiami","album"],["xiami.com.*artist/(\\w+)","xiami","artist"],["xiami.com.*collect/(\\w+)","xiami","playlist"]];e<t.length;e++){var r=t[e],a=new RegExp(r[0]).exec(n);if(null!==a)return{server:r[1],type:r[2],id:a[1]}}return console.error("无法解析的链接: ".concat(n,"，请检查链接是否书写正确")),{server:"",type:"",id:""}}}}),ki=Object(we.a)(wi,(function(){var n=this,e=n.$createElement;return(n._self._c||e)("APlayer",{attrs:{audio:n.audio,fixed:n.fixed,mini:n.mini,autoplay:n.autoplay,theme:n.theme,loop:n.loop,order:n.order,preload:n.preload,volume:n.volume,"custom-audio-type":n.customAudioType,mutex:n.mutex,"lrc-type":n.lrcType,"list-folded":n.listFolded,"list-max-height":n.listMaxHeight,"storage-name":n.storageName}})}),[],!1,null,null,null).exports,xi=(t(97),{name:"MetingGlobal",data:function(){return Object(Me.a)(Object(Me.a)({},{auto:"https://music.163.com/#/playlist?id=7437230073",server:"",type:"",mid:""}),{additionalAudios:[],mini:!0,autoplay:!1,theme:"#282c34",loop:"all",order:"list",preload:"auto",volume:.7,mutex:!0,lrcType:0,listFolded:!1,listMaxHeight:250,storageName:"vuepress-plugin-meting"})},mounted:function(){/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)&&this.aplayer_fixed_mobile_switch()},methods:{aplayer_fixed_mobile_switch:function(){var n=document.getElementById("aplayer-fixed");if(null!==n){var e=n.querySelector(".aplayer-body"),t=n.querySelector(".aplayer-miniswitcher"),r=n.querySelector(".aplayer-lrc"),a=!1;i(),t.onclick=function(){a?i():(e.childNodes.forEach((function(n){n.style.display="block"})),e.style.background="white",t.style.right="0",r.style.display="block",a=!0)}}function i(){__MOBILE_OPTIONS.cover||(e.childNodes.forEach((function(n){n.style.display="none"})),e.style.background="transparent",t.style.display="block",t.style.right="auto"),r.style.display="none",a=!1}}}}),Ei=Object(we.a)(xi,(function(){var n=this,e=n.$createElement;return(n._self._c||e)("Meting",{attrs:{id:"aplayer-fixed",auto:n.auto,server:n.server,type:n.type,mid:n.mid,"additional-audios":n.additionalAudios,fixed:!0,mini:n.mini,autoplay:n.autoplay,theme:n.theme,loop:n.loop,order:n.order,preload:n.preload,volume:n.volume,mutex:n.mutex,"lrc-type":n.lrcType,"list-folded":n.listFolded,"list-max-height":n.listMaxHeight,"storage-name":n.storageName}})}),[],!1,null,null,null).exports,Ai=[function(n){n.router.beforeEach((function(n,e,t){"undefined"!=typeof _hmt&&n.path&&_hmt.push(["_trackPageview",n.fullPath]),t()}))},function(n){n.Vue.mixin(He)},{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},function(n){n.Vue.component("BackToTop",Ye)},function(n){n.Vue.component("RecoDemo",Ze)},function(n){n.Vue.component("LoadingPage",nt)},function(n){n.Vue.component("Pagation",tt)},function(n){var e=n.Vue;e.component("Comments",Da),e.component("AccessNumber",$a)},function(n){var e=n.Vue,t=Object.keys(Ga).map((function(n){var e,t=Ga[n],r="$".concat(n);return e={},Object(Ja.a)(e,r,(function(){var n=this.$site.pages;return new Ka(t,n)})),Object(Ja.a)(e,"$current".concat(n.charAt(0).toUpperCase()+n.slice(1)),(function(){var n=this.$route.meta.id;return this[r].getItemByName(n)})),e})).reduce((function(n,e){return Object.assign(n,e),n}),{});t.$frontmatterKey=function(){var n=this["$".concat(this.$route.meta.id)];return n||null},e.mixin({computed:t})},function(n){n.Vue.mixin({methods:{$getPagination:function(n,e){return e=e||n,ri.getPagination(n,e,this.$route)}},computed:{$pagination:function(){return this.$route.meta.pid&&this.$route.meta.id?this.$getPagination(this.$route.meta.pid,this.$route.meta.id):null}}})},function(n){n.Vue.component("FlowChart",li)},function(n){var e=n.router,t=n.isServer;e.onReady((function(){t||ci("".concat("/vuepress/","service-worker.js"),{registrationOptions:{},ready:function(){console.log("[vuepress:sw] Service worker is active."),fi.a.$emit("sw-ready")},cached:function(n){console.log("[vuepress:sw] Content has been cached for offline use."),fi.a.$emit("sw-cached",new hi(n))},updated:function(n){console.log("[vuepress:sw] Content updated."),fi.a.$emit("sw-updated",new hi(n))},offline:function(){console.log("[vuepress:sw] No internet connection found. App is running in offline mode."),fi.a.$emit("sw-offline")},error:function(n){console.error("[vuepress:sw] Error during service worker registration:",n),fi.a.$emit("sw-error",n),GA_ID&&ga("send","exception",{exDescription:n.message,exFatal:!1})}})}))},function(n){var e=n.siteData;n.options;e.themeConfig.sidebar={"/Java/Java并发编程的艺术/":[{title:"Java并发编程的艺术",collapsable:!1,sidebarDepth:1,children:["","01、并发编程面临的挑战","02、线程的状态转换以及基本操作","03、Java内存模型以及happens-before","04、彻底理解synchronized","05、彻底理解volatile","06、你真的了解final吗？","07、三大性质总结：原子性、可见性以及有序性","08、初识Lock与AbstractQueuedSynchronizer-AQS","09、深入理解AbstractQueuedSynchronizer-AQS","10、ReentrantLock的重入性与公平性","11、深入理解读写锁ReentrantReadWriteLock","12、详解Condition的线程通信机制","13、LockSupport工具","14、并发容器之ConcurrentHashMap-JDK1.8","15、并发容器之ConcurrentLinkedQueue","16、并发容器之CopyOnWriteArrayList","17、并发容器之ThreadLocal","18、并发容器之BlockingQueue","19、线程池ThreadPoolExecutor实现原理","20、线程池之ScheduledThreadPoolExecutor","21、FutureTask源码解析","22、Java中atomic包中的原子操作类总结","23、CountDownLatch与CyclicBarrier计数器","24、java并发工具类-Semaphore，Exchanger","25、彻底弄懂生产者--消费者问题"]}],"/Idea/王小波/":[{title:"王小波",collapsable:!1,sidebarDepth:1,children:["","黄金时代"]}],"/guide/":[{title:"Guide",collapsable:!1,sidebarDepth:1,children:[""]}],"/Idea/":[{title:"Idea",collapsable:!1,sidebarDepth:1,children:["","01、爱情","02、人生境界究竟指什么","03、青年节前夕..."]}]}},function(n){n.router;"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},function(n){n.Vue.component("DynamicTitle",mi)},{},gi,function(n){var e=n.Vue;e.component(bi.name,bi),e.mixin({computed:{$readingShow:function(){return this.$page.frontmatter.readingShow}}})},function(n){n.Vue.component("CodeCopy",De)},function(n){var e=n.Vue;"undefined"!=typeof window&&(localStorage.setItem("aplayer-setting","[]"),e.use(t(496).default,{defaultCover:"https://github.com/SigureMo.png"})),e.component("Meting",ki),e.component("MetingGlobal",Ei)}],_i=["BackToTop","SWUpdatePopup","DynamicTitle","ReadingProgress","MetingGlobal"];t(69),t(89);t(146),t(149);function Si(n,e){return(Si=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}t(261),t(262);function Ci(n){return(Ci=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function Ti(n,e){if(e&&("object"===Object(pe.a)(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n)}function Oi(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,r=Ci(n);if(e){var a=Ci(this).constructor;t=Reflect.construct(r,arguments,a)}else t=r.apply(this,arguments);return Ti(this,t)}}var ji=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),e&&Si(n,e)}(t,n);var e=Oi(t);function t(){return Wa(this,t),e.apply(this,arguments)}return Va(t)}(function(){function n(){Wa(this,n),this.store=new i.default({data:{state:{}}})}return Va(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,e){i.default.set(this.store.state,n,e)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(ji.prototype,{getPageAsyncComponent:Xn.e,getLayoutAsyncComponent:Xn.d,getAsyncComponent:Xn.c,getVueComponent:Xn.f});var Bi={install:function(n){var e=new ji;n.$vuepress=e,n.prototype.$vuepress=e}};function Ii(n){n.beforeEach((function(e,t,r){if(Li(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){var a=e.path.replace(/\/$/,"")+".html";Li(n,a)?r(a):r()}else r();else{var i=e.path+"/",o=e.path+".html";Li(n,o)?r(o):Li(n,i)?r(i):r()}}))}function Li(n,e){var t=e.toLowerCase();return n.options.routes.some((function(n){return n.path.toLowerCase()===t}))}var Ni={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var e=this.pageKey||this.$parent.$page.key;return Object(Xn.i)("pageKey",e),i.default.component(e)||i.default.component(e,Object(Xn.e)(e)),i.default.component(e)?n(e):n("")}},Pi={functional:!0,props:{slotKey:String,required:!0},render:function(n,e){var t=e.props,r=e.slots;return n("div",{class:["content__".concat(t.slotKey)]},r()[t.slotKey])}},qi={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Ri=(t(498),t(499),Object(we.a)(qi,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function Fi(){return(Fi=Object(a.a)(Object(r.a)().mark((function n(e){var t,a,o,s;return Object(r.a)().wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Qe.routerBase||Qe.base,Ii(a=new Kn({base:t,mode:"history",fallback:!1,routes:We,scrollBehavior:function(n,e,t){return t||(n.hash?!i.default.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),o={},n.prev=4,n.next=7,Promise.all(Ai.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:i.default,options:o,router:a,siteData:Qe,isServer:e})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return s=new i.default(Object.assign(o,{router:a,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},_i.map((function(e){return n(e)})))])}})),n.abrupt("return",{app:s,router:a});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}i.default.config.productionTip=!1,i.default.use(Kn),i.default.use(Bi),i.default.mixin(function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:i.default;Yn(e),t.$vuepress.$set("siteData",e);var r=n(t.$vuepress.$get("siteData")),a=new r,o=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),s={};return Object.keys(o).reduce((function(n,e){return e.startsWith("$")&&(n[e]=o[e].get),n}),s),{computed:s}}((function(n){return function(){function e(){Wa(this,e)}return Va(e,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,e,t=this.$site.locales,r=void 0===t?{}:t;for(var a in r)"/"===a?e=r[a]:0===this.$page.path.indexOf(a)&&(n=r[a]);return n||e||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,e=this.$page.frontmatter.metaTitle;if("string"==typeof e)return e;var t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var e=n.filter((function(n){return"description"===n.name}))[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,e){for(var t=0;t<n.length;t++){var r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),e}()}),Qe)),i.default.component("Content",Ni),i.default.component("ContentSlotsDistributor",Pi),i.default.component("OutboundLink",Ri),i.default.component("ClientOnly",{functional:!0,render:function(n,e){var t=e.parent,r=e.children;if(t._isMounted)return r;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),i.default.component("Layout",Object(Xn.d)("Layout")),i.default.component("NotFound",Object(Xn.d)("NotFound")),i.default.prototype.$withBase=function(n){var e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.7",hash:"31e10f8"},function(n){return Fi.apply(this,arguments)}(!1).then((function(n){var e=n.app;n.router.onReady((function(){e.$mount("#app")}))}))}]);